// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.IoT.DeviceUpdate
{
    /// <summary> The DeviceManagement service client. </summary>
    public partial class DeviceManagementClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://api.adu.microsoft.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _instanceId;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of DeviceManagementClient for mocking. </summary>
        protected DeviceManagementClient()
        {
        }

        /// <summary> Initializes a new instance of DeviceManagementClient. </summary>
        /// <param name="endpoint"> Account endpoint. </param>
        /// <param name="instanceId"> Account instance identifier. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/>, <paramref name="instanceId"/> or <paramref name="credential"/> is null. </exception>
        public DeviceManagementClient(Uri endpoint, string instanceId, TokenCredential credential) : this(endpoint, instanceId, credential, new DeviceUpdateClientOptions())
        {
        }

        /// <summary> Initializes a new instance of DeviceManagementClient. </summary>
        /// <param name="endpoint"> Account endpoint. </param>
        /// <param name="instanceId"> Account instance identifier. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/>, <paramref name="instanceId"/> or <paramref name="credential"/> is null. </exception>
        public DeviceManagementClient(Uri endpoint, string instanceId, TokenCredential credential, DeviceUpdateClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(instanceId, nameof(instanceId));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new DeviceUpdateClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _instanceId = instanceId;
            _apiVersion = options.Version;
        }

        /// <summary> Gets the properties of a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deviceClassId: string,
        ///   friendlyName: string,
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string,
        ///       name: string
        ///     },
        ///     compatProperties: Dictionary&lt;string, string&gt;
        ///   },
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassAsync(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassRequest(deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the properties of a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deviceClassId: string,
        ///   friendlyName: string,
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string,
        ///       name: string
        ///     },
        ///     compatProperties: Dictionary&lt;string, string&gt;
        ///   },
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClass(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassRequest(deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update device class details. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   friendlyName: string (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deviceClassId: string,
        ///   friendlyName: string,
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string,
        ///       name: string
        ///     },
        ///     compatProperties: Dictionary&lt;string, string&gt;
        ///   },
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UpdateDeviceClassAsync(string deviceClassId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.UpdateDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDeviceClassRequest(deviceClassId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update device class details. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   friendlyName: string (required)
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deviceClassId: string,
        ///   friendlyName: string,
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string,
        ///       name: string
        ///     },
        ///     compatProperties: Dictionary&lt;string, string&gt;
        ///   },
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UpdateDeviceClass(string deviceClassId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.UpdateDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDeviceClassRequest(deviceClassId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class. Device classes are created automatically when Device Update-enabled devices are connected to the hub but are not automatically cleaned up since they are referenced by DeviceClassSubgroups. If the user has deleted all DeviceClassSubgroups for a device class they can also delete the device class to remove the records from the system and to stop checking the compatibility of this device class with new updates. If a device is ever reconnected for this device class it will be re-created. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteDeviceClassAsync(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassRequest(deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class. Device classes are created automatically when Device Update-enabled devices are connected to the hub but are not automatically cleaned up since they are referenced by DeviceClassSubgroups. If the user has deleted all DeviceClassSubgroups for a device class they can also delete the device class to remove the records from the system and to stop checking the compatibility of this device class with new updates. If a device is ever reconnected for this device class it will be re-created. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DeleteDeviceClass(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassRequest(deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device properties and latest deployment status for a device connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deviceId: string,
        ///   moduleId: string,
        ///   deviceClassId: string,
        ///   groupId: string,
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;,
        ///   installedUpdate: UpdateInfo,
        ///   onLatestUpdate: boolean,
        ///   lastDeploymentId: string,
        ///   lastInstallResult: {
        ///     resultCode: number,
        ///     extendedResultCode: number,
        ///     resultDetails: string,
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo,
        ///         description: string,
        ///         resultCode: number,
        ///         extendedResultCode: number,
        ///         resultDetails: string
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceAsync(string deviceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDevice");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceRequest(deviceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device properties and latest deployment status for a device connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deviceId: string,
        ///   moduleId: string,
        ///   deviceClassId: string,
        ///   groupId: string,
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;,
        ///   installedUpdate: UpdateInfo,
        ///   onLatestUpdate: boolean,
        ///   lastDeploymentId: string,
        ///   lastInstallResult: {
        ///     resultCode: number,
        ///     extendedResultCode: number,
        ///     resultDetails: string,
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo,
        ///         description: string,
        ///         resultCode: number,
        ///         extendedResultCode: number,
        ///         resultDetails: string
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDevice(string deviceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDevice");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceRequest(deviceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device module properties and latest deployment status for a device module connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="moduleId"> Device module identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deviceId: string,
        ///   moduleId: string,
        ///   deviceClassId: string,
        ///   groupId: string,
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;,
        ///   installedUpdate: UpdateInfo,
        ///   onLatestUpdate: boolean,
        ///   lastDeploymentId: string,
        ///   lastInstallResult: {
        ///     resultCode: number,
        ///     extendedResultCode: number,
        ///     resultDetails: string,
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo,
        ///         description: string,
        ///         resultCode: number,
        ///         extendedResultCode: number,
        ///         resultDetails: string
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceModuleAsync(string deviceId, string moduleId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));
            Argument.AssertNotNullOrEmpty(moduleId, nameof(moduleId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceModule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceModuleRequest(deviceId, moduleId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device module properties and latest deployment status for a device module connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="moduleId"> Device module identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deviceId: string,
        ///   moduleId: string,
        ///   deviceClassId: string,
        ///   groupId: string,
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;,
        ///   installedUpdate: UpdateInfo,
        ///   onLatestUpdate: boolean,
        ///   lastDeploymentId: string,
        ///   lastInstallResult: {
        ///     resultCode: number,
        ///     extendedResultCode: number,
        ///     resultDetails: string,
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo,
        ///         description: string,
        ///         resultCode: number,
        ///         extendedResultCode: number,
        ///         resultDetails: string
        ///       }
        ///     ]
        ///   }
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceModule(string deviceId, string moduleId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));
            Argument.AssertNotNullOrEmpty(moduleId, nameof(moduleId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceModule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceModuleRequest(deviceId, moduleId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the breakdown of how many devices are on their latest update, have new updates available, or are in progress receiving new updates. </summary>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   totalDeviceCount: number,
        ///   onLatestUpdateDeviceCount: number,
        ///   newUpdatesAvailableDeviceCount: number,
        ///   updatesInProgressDeviceCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetUpdateComplianceAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the breakdown of how many devices are on their latest update, have new updates available, or are in progress receiving new updates. </summary>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   totalDeviceCount: number,
        ///   onLatestUpdateDeviceCount: number,
        ///   newUpdatesAvailableDeviceCount: number,
        ///   updatesInProgressDeviceCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetUpdateCompliance(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device group properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   groupId: string,
        ///   groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;,
        ///   createdDateTime: string,
        ///   deviceCount: number,
        ///   subgroupsWithNewUpdatesAvailableCount: number,
        ///   subgroupsWithUpdatesInProgressCount: number,
        ///   subgroupsWithOnLatestUpdateCount: number,
        ///   deployments: [string]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetGroupAsync(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device group properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   groupId: string,
        ///   groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;,
        ///   createdDateTime: string,
        ///   deviceCount: number,
        ///   subgroupsWithNewUpdatesAvailableCount: number,
        ///   subgroupsWithUpdatesInProgressCount: number,
        ///   subgroupsWithOnLatestUpdateCount: number,
        ///   deployments: [string]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetGroup(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device group. This group is automatically created when a Device Update-enabled device is connected to the hub and reports its properties. Groups, subgroups, and deployments are not automatically cleaned up but are retained for history purposes. Users can call this method to delete a group if they do not need to retain any of the history of the group and no longer need it. If a device is ever connected again for this group after the group was deleted it will be automatically re-created but there will be no history. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteGroupAsync(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device group. This group is automatically created when a Device Update-enabled device is connected to the hub and reports its properties. Groups, subgroups, and deployments are not automatically cleaned up but are retained for history purposes. Users can call this method to delete a group if they do not need to retain any of the history of the group and no longer need it. If a device is ever connected again for this group after the group was deleted it will be automatically re-created but there will be no history. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DeleteGroup(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device group update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   totalDeviceCount: number,
        ///   onLatestUpdateDeviceCount: number,
        ///   newUpdatesAvailableDeviceCount: number,
        ///   updatesInProgressDeviceCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetUpdateComplianceForGroupAsync(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateComplianceForGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceForGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device group update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   totalDeviceCount: number,
        ///   onLatestUpdateDeviceCount: number,
        ///   newUpdatesAvailableDeviceCount: number,
        ///   updatesInProgressDeviceCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetUpdateComplianceForGroup(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateComplianceForGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceForGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deploymentId: string,
        ///   startDateTime: string (ISO 8601 Format),
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   groupId: string,
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo,
        ///     failure: {
        ///       devicesFailedPercentage: number,
        ///       devicesFailedCount: number
        ///     }
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentAsync(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deploymentId: string,
        ///   startDateTime: string (ISO 8601 Format),
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   groupId: string,
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo,
        ///     failure: {
        ///       devicesFailedPercentage: number,
        ///       devicesFailedCount: number
        ///     }
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeployment(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates or updates a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deploymentId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   deploymentId: string (required),
        ///   startDateTime: string (ISO 8601 Format) (required),
        ///   update: {
        ///     updateId: {
        ///       provider: string (required),
        ///       name: string (required),
        ///       version: string (required)
        ///     } (required),
        ///     description: string,
        ///     friendlyName: string
        ///   } (required),
        ///   groupId: string (required),
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo (required),
        ///     failure: {
        ///       devicesFailedPercentage: number (required),
        ///       devicesFailedCount: number (required)
        ///     } (required)
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deploymentId: string,
        ///   startDateTime: string (ISO 8601 Format),
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   groupId: string,
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo,
        ///     failure: {
        ///       devicesFailedPercentage: number,
        ///       devicesFailedCount: number
        ///     }
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateOrUpdateDeploymentAsync(string groupId, string deploymentId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.CreateOrUpdateDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateDeploymentRequest(groupId, deploymentId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates or updates a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deploymentId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   deploymentId: string (required),
        ///   startDateTime: string (ISO 8601 Format) (required),
        ///   update: {
        ///     updateId: {
        ///       provider: string (required),
        ///       name: string (required),
        ///       version: string (required)
        ///     } (required),
        ///     description: string,
        ///     friendlyName: string
        ///   } (required),
        ///   groupId: string (required),
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo (required),
        ///     failure: {
        ///       devicesFailedPercentage: number (required),
        ///       devicesFailedCount: number (required)
        ///     } (required)
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deploymentId: string,
        ///   startDateTime: string (ISO 8601 Format),
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   groupId: string,
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo,
        ///     failure: {
        ///       devicesFailedPercentage: number,
        ///       devicesFailedCount: number
        ///     }
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateOrUpdateDeployment(string groupId, string deploymentId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.CreateOrUpdateDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateDeploymentRequest(groupId, deploymentId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteDeploymentAsync(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DeleteDeployment(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   groupId: string,
        ///   deploymentState: &quot;Active&quot; | &quot;ActiveWithSubgroupFailures&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;,
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   },
        ///   subgroupStatus: [
        ///     {
        ///       groupId: string,
        ///       deviceClassId: string,
        ///       deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;,
        ///       error: Error,
        ///       totalDevices: number,
        ///       devicesInProgressCount: number,
        ///       devicesCompletedFailedCount: number,
        ///       devicesCompletedSucceededCount: number,
        ///       devicesCanceledCount: number
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentStatusAsync(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentStatusRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   groupId: string,
        ///   deploymentState: &quot;Active&quot; | &quot;ActiveWithSubgroupFailures&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;,
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   },
        ///   subgroupStatus: [
        ///     {
        ///       groupId: string,
        ///       deviceClassId: string,
        ///       deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;,
        ///       error: Error,
        ///       totalDevices: number,
        ///       devicesInProgressCount: number,
        ///       devicesCompletedFailedCount: number,
        ///       devicesCompletedSucceededCount: number,
        ///       devicesCanceledCount: number
        ///     }
        ///   ]
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeploymentStatus(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentStatusRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets device class subgroup details. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deviceClassId: string,
        ///   groupId: string,
        ///   createdDateTime: string,
        ///   deviceCount: number,
        ///   deploymentId: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets device class subgroup details. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deviceClassId: string,
        ///   groupId: string,
        ///   createdDateTime: string,
        ///   deviceCount: number,
        ///   deploymentId: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DeleteDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device class subgroup update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   totalDeviceCount: number,
        ///   onLatestUpdateDeviceCount: number,
        ///   newUpdatesAvailableDeviceCount: number,
        ///   updatesInProgressDeviceCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassSubgroupUpdateComplianceAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupUpdateComplianceRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device class subgroup update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   totalDeviceCount: number,
        ///   onLatestUpdateDeviceCount: number,
        ///   newUpdatesAvailableDeviceCount: number,
        ///   updatesInProgressDeviceCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClassSubgroupUpdateCompliance(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupUpdateComplianceRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the best available update for a device class subgroup and a count of how many devices need this update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   groupId: string,
        ///   deviceClassId: string,
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   deviceCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetBestUpdatesForDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetBestUpdatesForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBestUpdatesForDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the best available update for a device class subgroup and a count of how many devices need this update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   groupId: string,
        ///   deviceClassId: string,
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   deviceCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetBestUpdatesForDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetBestUpdatesForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBestUpdatesForDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deploymentId: string,
        ///   startDateTime: string (ISO 8601 Format),
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   groupId: string,
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo,
        ///     failure: {
        ///       devicesFailedPercentage: number,
        ///       devicesFailedCount: number
        ///     }
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentForDeviceClassSubgroupAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deploymentId: string,
        ///   startDateTime: string (ISO 8601 Format),
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   groupId: string,
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo,
        ///     failure: {
        ///       devicesFailedPercentage: number,
        ///       devicesFailedCount: number
        ///     }
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeploymentForDeviceClassSubgroup(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> DeleteDeploymentForDeviceClassSubgroupAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response DeleteDeploymentForDeviceClassSubgroup(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stops a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deploymentId: string,
        ///   startDateTime: string (ISO 8601 Format),
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   groupId: string,
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo,
        ///     failure: {
        ///       devicesFailedPercentage: number,
        ///       devicesFailedCount: number
        ///     }
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> StopDeploymentAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StopDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stops a deployment. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deploymentId: string,
        ///   startDateTime: string (ISO 8601 Format),
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   groupId: string,
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo,
        ///     failure: {
        ///       devicesFailedPercentage: number,
        ///       devicesFailedCount: number
        ///     }
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response StopDeployment(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StopDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retries a deployment with failed devices. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deploymentId: string,
        ///   startDateTime: string (ISO 8601 Format),
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   groupId: string,
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo,
        ///     failure: {
        ///       devicesFailedPercentage: number,
        ///       devicesFailedCount: number
        ///     }
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> RetryDeploymentAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.RetryDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRetryDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retries a deployment with failed devices. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   deploymentId: string,
        ///   startDateTime: string (ISO 8601 Format),
        ///   update: {
        ///     updateId: {
        ///       provider: string,
        ///       name: string,
        ///       version: string
        ///     },
        ///     description: string,
        ///     friendlyName: string
        ///   },
        ///   groupId: string,
        ///   deviceClassSubgroups: [string],
        ///   isCanceled: boolean,
        ///   isRetried: boolean,
        ///   rollbackPolicy: {
        ///     update: UpdateInfo,
        ///     failure: {
        ///       devicesFailedPercentage: number,
        ///       devicesFailedCount: number
        ///     }
        ///   },
        ///   isCloudInitiatedRollback: boolean
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response RetryDeployment(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.RetryDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRetryDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   groupId: string,
        ///   deviceClassId: string,
        ///   deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;,
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   },
        ///   totalDevices: number,
        ///   devicesInProgressCount: number,
        ///   devicesCompletedFailedCount: number,
        ///   devicesCompletedSucceededCount: number,
        ///   devicesCanceledCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassSubgroupDeploymentStatusAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupDeploymentStatusRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   groupId: string,
        ///   deviceClassId: string,
        ///   deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;,
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   },
        ///   totalDevices: number,
        ///   devicesInProgressCount: number,
        ///   devicesCompletedFailedCount: number,
        ///   devicesCompletedSucceededCount: number,
        ///   devicesCanceledCount: number
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClassSubgroupDeploymentStatus(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupDeploymentStatusRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve operation status. </summary>
        /// <param name="operationId"> Operation identifier. </param>
        /// <param name="ifNoneMatch"> Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   operationId: string,
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;,
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   },
        ///   traceId: string,
        ///   lastActionDateTime: string (ISO 8601 Format),
        ///   createdDateTime: string (ISO 8601 Format),
        ///   etag: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetOperationAsync(string operationId, ETag? ifNoneMatch = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetOperation");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetOperationRequest(operationId, ifNoneMatch, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve operation status. </summary>
        /// <param name="operationId"> Operation identifier. </param>
        /// <param name="ifNoneMatch"> Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   operationId: string,
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;,
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   },
        ///   traceId: string,
        ///   lastActionDateTime: string (ISO 8601 Format),
        ///   createdDateTime: string (ISO 8601 Format),
        ///   etag: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetOperation(string operationId, ETag? ifNoneMatch = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetOperation");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetOperationRequest(operationId, ifNoneMatch, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Start the device diagnostics log collection on specified devices. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   operationId: string,
        ///   deviceList: [
        ///     {
        ///       deviceId: string (required),
        ///       moduleId: string
        ///     }
        ///   ] (required),
        ///   description: string,
        ///   createdDateTime: string,
        ///   lastActionDateTime: string,
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   operationId: string,
        ///   deviceList: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string
        ///     }
        ///   ],
        ///   description: string,
        ///   createdDateTime: string,
        ///   lastActionDateTime: string,
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> StartLogCollectionAsync(string logCollectionId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StartLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStartLogCollectionRequest(logCollectionId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Start the device diagnostics log collection on specified devices. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Request Body</c>:
        /// <code>{
        ///   operationId: string,
        ///   deviceList: [
        ///     {
        ///       deviceId: string (required),
        ///       moduleId: string
        ///     }
        ///   ] (required),
        ///   description: string,
        ///   createdDateTime: string,
        ///   lastActionDateTime: string,
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;
        /// }
        /// </code>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   operationId: string,
        ///   deviceList: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string
        ///     }
        ///   ],
        ///   description: string,
        ///   createdDateTime: string,
        ///   lastActionDateTime: string,
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response StartLogCollection(string logCollectionId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StartLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStartLogCollectionRequest(logCollectionId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the device diagnostics log collection. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   operationId: string,
        ///   deviceList: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string
        ///     }
        ///   ],
        ///   description: string,
        ///   createdDateTime: string,
        ///   lastActionDateTime: string,
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetLogCollectionAsync(string logCollectionId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionRequest(logCollectionId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the device diagnostics log collection. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   operationId: string,
        ///   deviceList: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string
        ///     }
        ///   ],
        ///   description: string,
        ///   createdDateTime: string,
        ///   lastActionDateTime: string,
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetLogCollection(string logCollectionId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionRequest(logCollectionId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get log collection with detailed status. </summary>
        /// <param name="operationId"> Operation identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   operationId: string,
        ///   createdDateTime: string,
        ///   lastActionDateTime: string,
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;,
        ///   deviceStatus: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string,
        ///       status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;,
        ///       resultCode: string,
        ///       extendedResultCode: string,
        ///       logLocation: string
        ///     }
        ///   ],
        ///   description: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetLogCollectionDetailedStatusAsync(string operationId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollectionDetailedStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionDetailedStatusRequest(operationId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get log collection with detailed status. </summary>
        /// <param name="operationId"> Operation identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   operationId: string,
        ///   createdDateTime: string,
        ///   lastActionDateTime: string,
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;,
        ///   deviceStatus: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string,
        ///       status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;,
        ///       resultCode: string,
        ///       extendedResultCode: string,
        ///       logLocation: string
        ///     }
        ///   ],
        ///   description: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetLogCollectionDetailedStatus(string operationId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollectionDetailedStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionDetailedStatusRequest(operationId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of all device classes (unique combinations of device manufacturer and model) for all devices connected to Device Update for IoT Hub. </summary>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deviceClassId: string,
        ///       friendlyName: string,
        ///       deviceClassProperties: {
        ///         contractModel: {
        ///           id: string,
        ///           name: string
        ///         },
        ///         compatProperties: Dictionary&lt;string, string&gt;
        ///       },
        ///       bestCompatibleUpdate: {
        ///         updateId: {
        ///           provider: string,
        ///           name: string,
        ///           version: string
        ///         },
        ///         description: string,
        ///         friendlyName: string
        ///       }
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeviceClassesAsync(RequestContext context = null)
        {
            return GetDeviceClassesImplementationAsync("DeviceManagementClient.GetDeviceClasses", context);
        }

        private AsyncPageable<BinaryData> GetDeviceClassesImplementationAsync(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassesRequest(context)
                        : CreateGetDeviceClassesNextPageRequest(nextLink, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of all device classes (unique combinations of device manufacturer and model) for all devices connected to Device Update for IoT Hub. </summary>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deviceClassId: string,
        ///       friendlyName: string,
        ///       deviceClassProperties: {
        ///         contractModel: {
        ///           id: string,
        ///           name: string
        ///         },
        ///         compatProperties: Dictionary&lt;string, string&gt;
        ///       },
        ///       bestCompatibleUpdate: {
        ///         updateId: {
        ///           provider: string,
        ///           name: string,
        ///           version: string
        ///         },
        ///         description: string,
        ///         friendlyName: string
        ///       }
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeviceClasses(RequestContext context = null)
        {
            return GetDeviceClassesImplementation("DeviceManagementClient.GetDeviceClasses", context);
        }

        private Pageable<BinaryData> GetDeviceClassesImplementation(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassesRequest(context)
                        : CreateGetDeviceClassesNextPageRequest(nextLink, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of installable updates for a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       updateId: {
        ///         provider: string,
        ///         name: string,
        ///         version: string
        ///       },
        ///       description: string,
        ///       friendlyName: string
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetInstallableUpdatesForDeviceClassesAsync(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetInstallableUpdatesForDeviceClassesImplementationAsync("DeviceManagementClient.GetInstallableUpdatesForDeviceClasses", deviceClassId, context);
        }

        private AsyncPageable<BinaryData> GetInstallableUpdatesForDeviceClassesImplementationAsync(string diagnosticsScopeName, string deviceClassId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetInstallableUpdatesForDeviceClassesRequest(deviceClassId, context)
                        : CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(nextLink, deviceClassId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of installable updates for a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       updateId: {
        ///         provider: string,
        ///         name: string,
        ///         version: string
        ///       },
        ///       description: string,
        ///       friendlyName: string
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetInstallableUpdatesForDeviceClasses(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetInstallableUpdatesForDeviceClassesImplementation("DeviceManagementClient.GetInstallableUpdatesForDeviceClasses", deviceClassId, context);
        }

        private Pageable<BinaryData> GetInstallableUpdatesForDeviceClassesImplementation(string diagnosticsScopeName, string deviceClassId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetInstallableUpdatesForDeviceClassesRequest(deviceClassId, context)
                        : CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(nextLink, deviceClassId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices connected to Device Update for IoT Hub. </summary>
        /// <param name="filter"> Restricts the set of devices returned. You can filter on GroupId, DeviceClassId, or GroupId and DeploymentStatus. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string,
        ///       deviceClassId: string,
        ///       groupId: string,
        ///       lastAttemptedUpdate: {
        ///         updateId: {
        ///           provider: string,
        ///           name: string,
        ///           version: string
        ///         },
        ///         description: string,
        ///         friendlyName: string
        ///       },
        ///       deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;,
        ///       installedUpdate: UpdateInfo,
        ///       onLatestUpdate: boolean,
        ///       lastDeploymentId: string,
        ///       lastInstallResult: {
        ///         resultCode: number,
        ///         extendedResultCode: number,
        ///         resultDetails: string,
        ///         stepResults: [
        ///           {
        ///             update: UpdateInfo,
        ///             description: string,
        ///             resultCode: number,
        ///             extendedResultCode: number,
        ///             resultDetails: string
        ///           }
        ///         ]
        ///       }
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDevicesAsync(string filter = null, RequestContext context = null)
        {
            return GetDevicesImplementationAsync("DeviceManagementClient.GetDevices", filter, context);
        }

        private AsyncPageable<BinaryData> GetDevicesImplementationAsync(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDevicesRequest(filter, context)
                        : CreateGetDevicesNextPageRequest(nextLink, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices connected to Device Update for IoT Hub. </summary>
        /// <param name="filter"> Restricts the set of devices returned. You can filter on GroupId, DeviceClassId, or GroupId and DeploymentStatus. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string,
        ///       deviceClassId: string,
        ///       groupId: string,
        ///       lastAttemptedUpdate: {
        ///         updateId: {
        ///           provider: string,
        ///           name: string,
        ///           version: string
        ///         },
        ///         description: string,
        ///         friendlyName: string
        ///       },
        ///       deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;,
        ///       installedUpdate: UpdateInfo,
        ///       onLatestUpdate: boolean,
        ///       lastDeploymentId: string,
        ///       lastInstallResult: {
        ///         resultCode: number,
        ///         extendedResultCode: number,
        ///         resultDetails: string,
        ///         stepResults: [
        ///           {
        ///             update: UpdateInfo,
        ///             description: string,
        ///             resultCode: number,
        ///             extendedResultCode: number,
        ///             resultDetails: string
        ///           }
        ///         ]
        ///       }
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDevices(string filter = null, RequestContext context = null)
        {
            return GetDevicesImplementation("DeviceManagementClient.GetDevices", filter, context);
        }

        private Pageable<BinaryData> GetDevicesImplementation(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDevicesRequest(filter, context)
                        : CreateGetDevicesNextPageRequest(nextLink, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of all device groups.  The $default group will always be returned first. </summary>
        /// <param name="orderBy"> Orders the set of groups returned. You can order by any combination of groupId, device count, created date, subgroupsWithNewUpdatesAvailableCount, subgroupsWithUpdatesInProgressCount, or subgroupsOnLatestUpdateCount. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       groupId: string,
        ///       groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;,
        ///       createdDateTime: string,
        ///       deviceCount: number,
        ///       subgroupsWithNewUpdatesAvailableCount: number,
        ///       subgroupsWithUpdatesInProgressCount: number,
        ///       subgroupsWithOnLatestUpdateCount: number,
        ///       deployments: [string]
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetGroupsAsync(string orderBy = null, RequestContext context = null)
        {
            return GetGroupsImplementationAsync("DeviceManagementClient.GetGroups", orderBy, context);
        }

        private AsyncPageable<BinaryData> GetGroupsImplementationAsync(string diagnosticsScopeName, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetGroupsRequest(orderBy, context)
                        : CreateGetGroupsNextPageRequest(nextLink, orderBy, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of all device groups.  The $default group will always be returned first. </summary>
        /// <param name="orderBy"> Orders the set of groups returned. You can order by any combination of groupId, device count, created date, subgroupsWithNewUpdatesAvailableCount, subgroupsWithUpdatesInProgressCount, or subgroupsOnLatestUpdateCount. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       groupId: string,
        ///       groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;,
        ///       createdDateTime: string,
        ///       deviceCount: number,
        ///       subgroupsWithNewUpdatesAvailableCount: number,
        ///       subgroupsWithUpdatesInProgressCount: number,
        ///       subgroupsWithOnLatestUpdateCount: number,
        ///       deployments: [string]
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetGroups(string orderBy = null, RequestContext context = null)
        {
            return GetGroupsImplementation("DeviceManagementClient.GetGroups", orderBy, context);
        }

        private Pageable<BinaryData> GetGroupsImplementation(string diagnosticsScopeName, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetGroupsRequest(orderBy, context)
                        : CreateGetGroupsNextPageRequest(nextLink, orderBy, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the best available updates for a device group and a count of how many devices need each update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="filter"> Restricts the set of bestUpdates returned. You can filter on update Provider, Name and Version property. This filter is deprecated and should not be used. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       groupId: string,
        ///       deviceClassId: string,
        ///       update: {
        ///         updateId: {
        ///           provider: string,
        ///           name: string,
        ///           version: string
        ///         },
        ///         description: string,
        ///         friendlyName: string
        ///       },
        ///       deviceCount: number
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetBestUpdatesForGroupsAsync(string groupId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetBestUpdatesForGroupsImplementationAsync("DeviceManagementClient.GetBestUpdatesForGroups", groupId, filter, context);
        }

        private AsyncPageable<BinaryData> GetBestUpdatesForGroupsImplementationAsync(string diagnosticsScopeName, string groupId, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetBestUpdatesForGroupsRequest(groupId, filter, context)
                        : CreateGetBestUpdatesForGroupsNextPageRequest(nextLink, groupId, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the best available updates for a device group and a count of how many devices need each update. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="filter"> Restricts the set of bestUpdates returned. You can filter on update Provider, Name and Version property. This filter is deprecated and should not be used. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       groupId: string,
        ///       deviceClassId: string,
        ///       update: {
        ///         updateId: {
        ///           provider: string,
        ///           name: string,
        ///           version: string
        ///         },
        ///         description: string,
        ///         friendlyName: string
        ///       },
        ///       deviceCount: number
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetBestUpdatesForGroups(string groupId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetBestUpdatesForGroupsImplementation("DeviceManagementClient.GetBestUpdatesForGroups", groupId, filter, context);
        }

        private Pageable<BinaryData> GetBestUpdatesForGroupsImplementation(string diagnosticsScopeName, string groupId, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetBestUpdatesForGroupsRequest(groupId, filter, context)
                        : CreateGetBestUpdatesForGroupsNextPageRequest(nextLink, groupId, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device group. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deploymentId: string,
        ///       startDateTime: string (ISO 8601 Format),
        ///       update: {
        ///         updateId: {
        ///           provider: string,
        ///           name: string,
        ///           version: string
        ///         },
        ///         description: string,
        ///         friendlyName: string
        ///       },
        ///       groupId: string,
        ///       deviceClassSubgroups: [string],
        ///       isCanceled: boolean,
        ///       isRetried: boolean,
        ///       rollbackPolicy: {
        ///         update: UpdateInfo,
        ///         failure: {
        ///           devicesFailedPercentage: number,
        ///           devicesFailedCount: number
        ///         }
        ///       },
        ///       isCloudInitiatedRollback: boolean
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeploymentsForGroupsAsync(string groupId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeploymentsForGroupsImplementationAsync("DeviceManagementClient.GetDeploymentsForGroups", groupId, orderBy, context);
        }

        private AsyncPageable<BinaryData> GetDeploymentsForGroupsImplementationAsync(string diagnosticsScopeName, string groupId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForGroupsRequest(groupId, orderBy, context)
                        : CreateGetDeploymentsForGroupsNextPageRequest(nextLink, groupId, orderBy, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device group. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deploymentId: string,
        ///       startDateTime: string (ISO 8601 Format),
        ///       update: {
        ///         updateId: {
        ///           provider: string,
        ///           name: string,
        ///           version: string
        ///         },
        ///         description: string,
        ///         friendlyName: string
        ///       },
        ///       groupId: string,
        ///       deviceClassSubgroups: [string],
        ///       isCanceled: boolean,
        ///       isRetried: boolean,
        ///       rollbackPolicy: {
        ///         update: UpdateInfo,
        ///         failure: {
        ///           devicesFailedPercentage: number,
        ///           devicesFailedCount: number
        ///         }
        ///       },
        ///       isCloudInitiatedRollback: boolean
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeploymentsForGroups(string groupId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeploymentsForGroupsImplementation("DeviceManagementClient.GetDeploymentsForGroups", groupId, orderBy, context);
        }

        private Pageable<BinaryData> GetDeploymentsForGroupsImplementation(string diagnosticsScopeName, string groupId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForGroupsRequest(groupId, orderBy, context)
                        : CreateGetDeploymentsForGroupsNextPageRequest(nextLink, groupId, orderBy, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the device class subgroups for the group. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="filter"> Restricts the set of device class subgroups returned. You can filter on compat properties by name and value. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deviceClassId: string,
        ///       groupId: string,
        ///       createdDateTime: string,
        ///       deviceCount: number,
        ///       deploymentId: string
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeviceClassSubgroupsForGroupsAsync(string groupId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeviceClassSubgroupsForGroupsImplementationAsync("DeviceManagementClient.GetDeviceClassSubgroupsForGroups", groupId, filter, context);
        }

        private AsyncPageable<BinaryData> GetDeviceClassSubgroupsForGroupsImplementationAsync(string diagnosticsScopeName, string groupId, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassSubgroupsForGroupsRequest(groupId, filter, context)
                        : CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(nextLink, groupId, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the device class subgroups for the group. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="filter"> Restricts the set of device class subgroups returned. You can filter on compat properties by name and value. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deviceClassId: string,
        ///       groupId: string,
        ///       createdDateTime: string,
        ///       deviceCount: number,
        ///       deploymentId: string
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeviceClassSubgroupsForGroups(string groupId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeviceClassSubgroupsForGroupsImplementation("DeviceManagementClient.GetDeviceClassSubgroupsForGroups", groupId, filter, context);
        }

        private Pageable<BinaryData> GetDeviceClassSubgroupsForGroupsImplementation(string diagnosticsScopeName, string groupId, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassSubgroupsForGroupsRequest(groupId, filter, context)
                        : CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(nextLink, groupId, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device class subgroup. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deploymentId: string,
        ///       startDateTime: string (ISO 8601 Format),
        ///       update: {
        ///         updateId: {
        ///           provider: string,
        ///           name: string,
        ///           version: string
        ///         },
        ///         description: string,
        ///         friendlyName: string
        ///       },
        ///       groupId: string,
        ///       deviceClassSubgroups: [string],
        ///       isCanceled: boolean,
        ///       isRetried: boolean,
        ///       rollbackPolicy: {
        ///         update: UpdateInfo,
        ///         failure: {
        ///           devicesFailedPercentage: number,
        ///           devicesFailedCount: number
        ///         }
        ///       },
        ///       isCloudInitiatedRollback: boolean
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeploymentsForDeviceClassSubgroupsAsync(string groupId, string deviceClassId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetDeploymentsForDeviceClassSubgroupsImplementationAsync("DeviceManagementClient.GetDeploymentsForDeviceClassSubgroups", groupId, deviceClassId, orderBy, context);
        }

        private AsyncPageable<BinaryData> GetDeploymentsForDeviceClassSubgroupsImplementationAsync(string diagnosticsScopeName, string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForDeviceClassSubgroupsRequest(groupId, deviceClassId, orderBy, context)
                        : CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(nextLink, groupId, deviceClassId, orderBy, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device class subgroup. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deploymentId: string,
        ///       startDateTime: string (ISO 8601 Format),
        ///       update: {
        ///         updateId: {
        ///           provider: string,
        ///           name: string,
        ///           version: string
        ///         },
        ///         description: string,
        ///         friendlyName: string
        ///       },
        ///       groupId: string,
        ///       deviceClassSubgroups: [string],
        ///       isCanceled: boolean,
        ///       isRetried: boolean,
        ///       rollbackPolicy: {
        ///         update: UpdateInfo,
        ///         failure: {
        ///           devicesFailedPercentage: number,
        ///           devicesFailedCount: number
        ///         }
        ///       },
        ///       isCloudInitiatedRollback: boolean
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeploymentsForDeviceClassSubgroups(string groupId, string deviceClassId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetDeploymentsForDeviceClassSubgroupsImplementation("DeviceManagementClient.GetDeploymentsForDeviceClassSubgroups", groupId, deviceClassId, orderBy, context);
        }

        private Pageable<BinaryData> GetDeploymentsForDeviceClassSubgroupsImplementation(string diagnosticsScopeName, string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForDeviceClassSubgroupsRequest(groupId, deviceClassId, orderBy, context)
                        : CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(nextLink, groupId, deviceClassId, orderBy, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices in a deployment along with their state. Useful for getting a list of failed devices. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="filter"> Restricts the set of deployment device states returned. You can filter on deviceId and moduleId and/or deviceState. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string,
        ///       retryCount: number,
        ///       movedOnToNewDeployment: boolean,
        ///       deviceState: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync(string groupId, string deviceClassId, string deploymentId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            return GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementationAsync("DeviceManagementClient.GetDeviceStatesForDeviceClassSubgroupDeployments", groupId, deviceClassId, deploymentId, filter, context);
        }

        private AsyncPageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementationAsync(string diagnosticsScopeName, string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(groupId, deviceClassId, deploymentId, filter, context)
                        : CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(nextLink, groupId, deviceClassId, deploymentId, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices in a deployment along with their state. Useful for getting a list of failed devices. </summary>
        /// <param name="groupId"> Group identity. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="filter"> Restricts the set of deployment device states returned. You can filter on deviceId and moduleId and/or deviceState. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string,
        ///       retryCount: number,
        ///       movedOnToNewDeployment: boolean,
        ///       deviceState: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeployments(string groupId, string deviceClassId, string deploymentId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            return GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementation("DeviceManagementClient.GetDeviceStatesForDeviceClassSubgroupDeployments", groupId, deviceClassId, deploymentId, filter, context);
        }

        private Pageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementation(string diagnosticsScopeName, string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(groupId, deviceClassId, deploymentId, filter, context)
                        : CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(nextLink, groupId, deviceClassId, deploymentId, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get a list of all device import operations. Completed operations are kept for 7 days before auto-deleted. </summary>
        /// <param name="filter"> Restricts the set of operations returned. Only one specific filter is supported: &quot;status eq &apos;NotStarted&apos; or status eq &apos;Running&apos;&quot;. </param>
        /// <param name="top"> Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the number of available items up to but not greater than the specified value n. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       operationId: string,
        ///       status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;,
        ///       error: {
        ///         code: string,
        ///         message: string,
        ///         target: string,
        ///         details: [Error],
        ///         innererror: {
        ///           code: string,
        ///           message: string,
        ///           errorDetail: string,
        ///           innerError: InnerError
        ///         },
        ///         occurredDateTime: string (ISO 8601 Format)
        ///       },
        ///       traceId: string,
        ///       lastActionDateTime: string (ISO 8601 Format),
        ///       createdDateTime: string (ISO 8601 Format),
        ///       etag: string
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetOperationsAsync(string filter = null, int? top = null, RequestContext context = null)
        {
            return GetOperationsImplementationAsync("DeviceManagementClient.GetOperations", filter, top, context);
        }

        private AsyncPageable<BinaryData> GetOperationsImplementationAsync(string diagnosticsScopeName, string filter, int? top, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetOperationsRequest(filter, top, context)
                        : CreateGetOperationsNextPageRequest(nextLink, filter, top, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get a list of all device import operations. Completed operations are kept for 7 days before auto-deleted. </summary>
        /// <param name="filter"> Restricts the set of operations returned. Only one specific filter is supported: &quot;status eq &apos;NotStarted&apos; or status eq &apos;Running&apos;&quot;. </param>
        /// <param name="top"> Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the number of available items up to but not greater than the specified value n. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       operationId: string,
        ///       status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;,
        ///       error: {
        ///         code: string,
        ///         message: string,
        ///         target: string,
        ///         details: [Error],
        ///         innererror: {
        ///           code: string,
        ///           message: string,
        ///           errorDetail: string,
        ///           innerError: InnerError
        ///         },
        ///         occurredDateTime: string (ISO 8601 Format)
        ///       },
        ///       traceId: string,
        ///       lastActionDateTime: string (ISO 8601 Format),
        ///       createdDateTime: string (ISO 8601 Format),
        ///       etag: string
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetOperations(string filter = null, int? top = null, RequestContext context = null)
        {
            return GetOperationsImplementation("DeviceManagementClient.GetOperations", filter, top, context);
        }

        private Pageable<BinaryData> GetOperationsImplementation(string diagnosticsScopeName, string filter, int? top, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetOperationsRequest(filter, top, context)
                        : CreateGetOperationsNextPageRequest(nextLink, filter, top, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get all device diagnostics log collections. </summary>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       operationId: string,
        ///       deviceList: [
        ///         {
        ///           deviceId: string,
        ///           moduleId: string
        ///         }
        ///       ],
        ///       description: string,
        ///       createdDateTime: string,
        ///       lastActionDateTime: string,
        ///       status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetLogCollectionsAsync(RequestContext context = null)
        {
            return GetLogCollectionsImplementationAsync("DeviceManagementClient.GetLogCollections", context);
        }

        private AsyncPageable<BinaryData> GetLogCollectionsImplementationAsync(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetLogCollectionsRequest(context)
                        : CreateGetLogCollectionsNextPageRequest(nextLink, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get all device diagnostics log collections. </summary>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       operationId: string,
        ///       deviceList: [
        ///         {
        ///           deviceId: string,
        ///           moduleId: string
        ///         }
        ///       ],
        ///       description: string,
        ///       createdDateTime: string,
        ///       lastActionDateTime: string,
        ///       status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetLogCollections(RequestContext context = null)
        {
            return GetLogCollectionsImplementation("DeviceManagementClient.GetLogCollections", context);
        }

        private Pageable<BinaryData> GetLogCollectionsImplementation(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetLogCollectionsRequest(context)
                        : CreateGetLogCollectionsNextPageRequest(nextLink, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get list of device health. </summary>
        /// <param name="filter"> Filter list by specified properties. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filter"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string,
        ///       state: &quot;healthy&quot; | &quot;unhealthy&quot;,
        ///       digitalTwinModelId: string,
        ///       healthChecks: [
        ///         {
        ///           name: string,
        ///           result: &quot;success&quot; | &quot;userError&quot;
        ///         }
        ///       ]
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeviceHealthsAsync(string filter, RequestContext context = null)
        {
            Argument.AssertNotNull(filter, nameof(filter));

            return GetDeviceHealthsImplementationAsync("DeviceManagementClient.GetDeviceHealths", filter, context);
        }

        private AsyncPageable<BinaryData> GetDeviceHealthsImplementationAsync(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceHealthsRequest(filter, context)
                        : CreateGetDeviceHealthsNextPageRequest(nextLink, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get list of device health. </summary>
        /// <param name="filter"> Filter list by specified properties. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filter"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Response Body</c>:
        /// <code>{
        ///   value: [
        ///     {
        ///       deviceId: string,
        ///       moduleId: string,
        ///       state: &quot;healthy&quot; | &quot;unhealthy&quot;,
        ///       digitalTwinModelId: string,
        ///       healthChecks: [
        ///         {
        ///           name: string,
        ///           result: &quot;success&quot; | &quot;userError&quot;
        ///         }
        ///       ]
        ///     }
        ///   ],
        ///   nextLink: string
        /// }
        /// </code>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeviceHealths(string filter, RequestContext context = null)
        {
            Argument.AssertNotNull(filter, nameof(filter));

            return GetDeviceHealthsImplementation("DeviceManagementClient.GetDeviceHealths", filter, context);
        }

        private Pageable<BinaryData> GetDeviceHealthsImplementation(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceHealthsRequest(filter, context)
                        : CreateGetDeviceHealthsNextPageRequest(nextLink, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Import existing devices from IoT Hub. This is a long-running-operation; use Operation-Location response header value to check for operation status. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Operation<BinaryData>> ImportDevicesAsync(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.ImportDevices");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportDevicesRequest(content, context);
                return await LowLevelOperationHelpers.ProcessMessageAsync(_pipeline, message, ClientDiagnostics, "DeviceManagementClient.ImportDevices", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Import existing devices from IoT Hub. This is a long-running-operation; use Operation-Location response header value to check for operation status. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. </param>
        /// <param name="context"> The request context, which can override default behaviors on the request on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <remarks>
        /// Schema for <c>Response Error</c>:
        /// <code>{
        ///   error: {
        ///     code: string,
        ///     message: string,
        ///     target: string,
        ///     details: [Error],
        ///     innererror: {
        ///       code: string,
        ///       message: string,
        ///       errorDetail: string,
        ///       innerError: InnerError
        ///     },
        ///     occurredDateTime: string (ISO 8601 Format)
        ///   }
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Operation<BinaryData> ImportDevices(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.ImportDevices");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportDevicesRequest(content, context);
                return LowLevelOperationHelpers.ProcessMessage(_pipeline, message, ClientDiagnostics, "DeviceManagementClient.ImportDevices", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetDeviceClassesRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateDeviceClassRequest(string deviceClassId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDeviceClassRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetInstallableUpdatesForDeviceClassesRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/installableUpdates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDevicesRequest(string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateImportDevicesRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices:import", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDeviceRequest(string deviceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices/", false);
            uri.AppendPath(deviceId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceModuleRequest(string deviceId, string moduleId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices/", false);
            uri.AppendPath(deviceId, true);
            uri.AppendPath("/modules/", false);
            uri.AppendPath(moduleId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUpdateComplianceRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupsRequest(string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups", false);
            if (orderBy != null)
            {
                uri.AppendQuery("orderby", orderBy, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUpdateComplianceForGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForGroupsRequest(string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/bestUpdates", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForGroupsRequest(string groupId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (orderBy != null)
            {
                uri.AppendQuery("orderby", orderBy, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrUpdateDeploymentRequest(string groupId, string deploymentId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDeploymentRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentStatusRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/status", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupsForGroupsRequest(string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupUpdateComplianceRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/bestUpdates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForDeviceClassSubgroupsRequest(string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (orderBy != null)
            {
                uri.AppendQuery("orderby", orderBy, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentForDeviceClassSubgroupRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteDeploymentForDeviceClassSubgroupRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateStopDeploymentRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath(":cancel", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateRetryDeploymentRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath(":retry", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupDeploymentStatusRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/status", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/devicestates", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetOperationRequest(string operationId, ETag? ifNoneMatch, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200304);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/operations/", false);
            uri.AppendPath(operationId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ifNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", ifNoneMatch.Value);
            }
            return message;
        }

        internal HttpMessage CreateGetOperationsRequest(string filter, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/operations", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateStartLogCollectionRequest(string logCollectionId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(logCollectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLogCollectionRequest(string logCollectionId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(logCollectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionsRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionDetailedStatusRequest(string operationId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(operationId, true);
            uri.AppendPath("/detailedStatus", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceHealthsRequest(string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/deviceHealth", false);
            uri.AppendQuery("filter", filter, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassesNextPageRequest(string nextLink, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(string nextLink, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDevicesNextPageRequest(string nextLink, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupsNextPageRequest(string nextLink, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForGroupsNextPageRequest(string nextLink, string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForGroupsNextPageRequest(string nextLink, string groupId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(string nextLink, string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(string nextLink, string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(string nextLink, string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetOperationsNextPageRequest(string nextLink, string filter, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionsNextPageRequest(string nextLink, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceHealthsNextPageRequest(string nextLink, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
        private static ResponseClassifier _responseClassifier200304;
        private static ResponseClassifier ResponseClassifier200304 => _responseClassifier200304 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 304 });
        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
    }
}
