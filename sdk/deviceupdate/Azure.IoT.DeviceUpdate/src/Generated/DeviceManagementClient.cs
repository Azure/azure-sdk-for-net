// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License.

// <auto-generated/>

#nullable disable

using System;
using System.Collections.Generic;
using System.Runtime.CompilerServices;
using System.Threading;
using System.Threading.Tasks;
using Azure;
using Azure.Core;
using Azure.Core.Pipeline;

namespace Azure.IoT.DeviceUpdate
{
    // Data plane generated client. The DeviceManagement service client.
    /// <summary> The DeviceManagement service client. </summary>
    public partial class DeviceManagementClient
    {
        private static readonly string[] AuthorizationScopes = new string[] { "https://api.adu.microsoft.com/.default" };
        private readonly TokenCredential _tokenCredential;
        private readonly HttpPipeline _pipeline;
        private readonly Uri _endpoint;
        private readonly string _instanceId;
        private readonly string _apiVersion;

        /// <summary> The ClientDiagnostics is used to provide tracing support for the client library. </summary>
        internal ClientDiagnostics ClientDiagnostics { get; }

        /// <summary> The HTTP pipeline for sending and receiving REST requests and responses. </summary>
        public virtual HttpPipeline Pipeline => _pipeline;

        /// <summary> Initializes a new instance of DeviceManagementClient for mocking. </summary>
        protected DeviceManagementClient()
        {
        }

        /// <summary> Initializes a new instance of DeviceManagementClient. </summary>
        /// <param name="endpoint"> The Device Update for IoT Hub account endpoint (hostname only, no protocol). </param>
        /// <param name="instanceId"> The Device Update for IoT Hub account instance identifier. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/>, <paramref name="instanceId"/> or <paramref name="credential"/> is null. </exception>
        public DeviceManagementClient(Uri endpoint, string instanceId, TokenCredential credential) : this(endpoint, instanceId, credential, new DeviceUpdateClientOptions())
        {
        }

        /// <summary> Initializes a new instance of DeviceManagementClient. </summary>
        /// <param name="endpoint"> The Device Update for IoT Hub account endpoint (hostname only, no protocol). </param>
        /// <param name="instanceId"> The Device Update for IoT Hub account instance identifier. </param>
        /// <param name="credential"> A credential used to authenticate to an Azure Service. </param>
        /// <param name="options"> The options for configuring the client. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="endpoint"/>, <paramref name="instanceId"/> or <paramref name="credential"/> is null. </exception>
        public DeviceManagementClient(Uri endpoint, string instanceId, TokenCredential credential, DeviceUpdateClientOptions options)
        {
            Argument.AssertNotNull(endpoint, nameof(endpoint));
            Argument.AssertNotNull(instanceId, nameof(instanceId));
            Argument.AssertNotNull(credential, nameof(credential));
            options ??= new DeviceUpdateClientOptions();

            ClientDiagnostics = new ClientDiagnostics(options, true);
            _tokenCredential = credential;
            _pipeline = HttpPipelineBuilder.Build(options, Array.Empty<HttpPipelinePolicy>(), new HttpPipelinePolicy[] { new BearerTokenAuthenticationPolicy(_tokenCredential, AuthorizationScopes) }, new ResponseClassifier());
            _endpoint = endpoint;
            _instanceId = instanceId;
            _apiVersion = options.Version;
        }

        /// <summary> Gets the properties of a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClassAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetDeviceClassAsync("<deviceClassId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("compatProperties").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("friendlyName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClass</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier. This is generated from the model Id and the compat properties reported by the device update agent in the Device Update PnP interface in IoT Hub. It is a hex-encoded SHA1 hash.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is the highest version compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassAsync(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassRequest(deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the properties of a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClass with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetDeviceClass("<deviceClassId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("compatProperties").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("friendlyName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClass</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier. This is generated from the model Id and the compat properties reported by the device update agent in the Device Update PnP interface in IoT Hub. It is a hex-encoded SHA1 hash.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is the highest version compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClass(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassRequest(deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update device class details. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UpdateDeviceClassAsync with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = new {
        ///     friendlyName = "<friendlyName>",
        /// };
        /// 
        /// Response response = await client.UpdateDeviceClassAsync("<deviceClassId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("compatProperties").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("friendlyName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>PatchBody</c>:
        /// <code>{
        ///   friendlyName: string, # Required. The device class friendly name. Friendly name can be 1-100 characters, alphanumeric, dot, and dash.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClass</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier. This is generated from the model Id and the compat properties reported by the device update agent in the Device Update PnP interface in IoT Hub. It is a hex-encoded SHA1 hash.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is the highest version compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> UpdateDeviceClassAsync(string deviceClassId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.UpdateDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDeviceClassRequest(deviceClassId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Update device class details. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call UpdateDeviceClass with required parameters and request content and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = new {
        ///     friendlyName = "<friendlyName>",
        /// };
        /// 
        /// Response response = client.UpdateDeviceClass("<deviceClassId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("id").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("compatProperties").GetProperty("<test>").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("friendlyName").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>PatchBody</c>:
        /// <code>{
        ///   friendlyName: string, # Required. The device class friendly name. Friendly name can be 1-100 characters, alphanumeric, dot, and dash.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClass</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier. This is generated from the model Id and the compat properties reported by the device update agent in the Device Update PnP interface in IoT Hub. It is a hex-encoded SHA1 hash.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is the highest version compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response UpdateDeviceClass(string deviceClassId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.UpdateDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateUpdateDeviceClassRequest(deviceClassId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class. Device classes are created automatically when Device Update-enabled devices are connected to the hub but are not automatically cleaned up since they are referenced by DeviceClassSubgroups. If the user has deleted all DeviceClassSubgroups for a device class they can also delete the device class to remove the records from the system and to stop checking the compatibility of this device class with new updates. If a device is ever reconnected for this device class it will be re-created. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeviceClassAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.DeleteDeviceClassAsync("<deviceClassId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteDeviceClassAsync(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassRequest(deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class. Device classes are created automatically when Device Update-enabled devices are connected to the hub but are not automatically cleaned up since they are referenced by DeviceClassSubgroups. If the user has deleted all DeviceClassSubgroups for a device class they can also delete the device class to remove the records from the system and to stop checking the compatibility of this device class with new updates. If a device is ever reconnected for this device class it will be re-created. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeviceClass with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.DeleteDeviceClass("<deviceClassId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteDeviceClass(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClass");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassRequest(deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device properties and latest deployment status for a device connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetDeviceAsync("<deviceId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceId").ToString());
        /// Console.WriteLine(result.GetProperty("moduleId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentStatus").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("onLatestUpdate").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("extendedResultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultDetails").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("extendedResultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultDetails").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Device</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update (the best compatible update for the device&apos;s device class and group) is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceAsync(string deviceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDevice");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceRequest(deviceId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device properties and latest deployment status for a device connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDevice with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetDevice("<deviceId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceId").ToString());
        /// Console.WriteLine(result.GetProperty("moduleId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentStatus").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("onLatestUpdate").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("extendedResultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultDetails").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("extendedResultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultDetails").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Device</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update (the best compatible update for the device&apos;s device class and group) is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDevice(string deviceId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDevice");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceRequest(deviceId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device module properties and latest deployment status for a device module connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="moduleId"> Device module identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceModuleAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetDeviceModuleAsync("<deviceId>", "<moduleId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceId").ToString());
        /// Console.WriteLine(result.GetProperty("moduleId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentStatus").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("onLatestUpdate").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("extendedResultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultDetails").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("extendedResultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultDetails").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Device</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update (the best compatible update for the device&apos;s device class and group) is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceModuleAsync(string deviceId, string moduleId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));
            Argument.AssertNotNullOrEmpty(moduleId, nameof(moduleId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceModule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceModuleRequest(deviceId, moduleId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device module properties and latest deployment status for a device module connected to Device Update for IoT Hub. </summary>
        /// <param name="deviceId"> Device identifier in Azure IoT Hub. </param>
        /// <param name="moduleId"> Device module identifier in Azure IoT Hub. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceId"/> or <paramref name="moduleId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceModule with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetDeviceModule("<deviceId>", "<moduleId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceId").ToString());
        /// Console.WriteLine(result.GetProperty("moduleId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentStatus").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("onLatestUpdate").ToString());
        /// Console.WriteLine(result.GetProperty("lastDeploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("extendedResultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultDetails").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("extendedResultCode").ToString());
        /// Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultDetails").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Device</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update (the best compatible update for the device&apos;s device class and group) is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceModule(string deviceId, string moduleId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceId, nameof(deviceId));
            Argument.AssertNotNullOrEmpty(moduleId, nameof(moduleId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceModule");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceModuleRequest(deviceId, moduleId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the breakdown of how many devices are on their latest update, have new updates available, or are in progress receiving new updates. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetUpdateComplianceAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetUpdateComplianceAsync();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("totalDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("onLatestUpdateDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("newUpdatesAvailableDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("updatesInProgressDeviceCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetUpdateComplianceAsync(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceRequest(context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the breakdown of how many devices are on their latest update, have new updates available, or are in progress receiving new updates. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetUpdateCompliance and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetUpdateCompliance();
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("totalDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("onLatestUpdateDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("newUpdatesAvailableDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("updatesInProgressDeviceCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetUpdateCompliance(RequestContext context = null)
        {
            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceRequest(context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device group properties. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetGroupAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetGroupAsync("<groupId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("groupType").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupsWithNewUpdatesAvailableCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupsWithUpdatesInProgressCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupsWithOnLatestUpdateCount").ToString());
        /// Console.WriteLine(result.GetProperty("deployments")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Group</c>:
        /// <code>{
        ///   groupId: string, # Required. Group identity. This is created from the value of the ADUGroup tag in the Iot Hub&apos;s device/module twin or $default for devices with no tag.
        ///   groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;, # Required. Group type.
        ///   createdDateTime: string, # Required. Date and time when the update was created.
        ///   deviceCount: number, # Optional. The number of devices in the group.
        ///   subgroupsWithNewUpdatesAvailableCount: number, # Optional. The count of subgroups with new updates available.
        ///   subgroupsWithUpdatesInProgressCount: number, # Optional. The count of subgroups with updates in progress.
        ///   subgroupsWithOnLatestUpdateCount: number, # Optional. The count of subgroups with devices on the latest update.
        ///   deployments: [string], # Optional. The active deployment Ids for the group
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetGroupAsync(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the device group properties. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetGroup with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetGroup("<groupId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("groupType").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupsWithNewUpdatesAvailableCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupsWithUpdatesInProgressCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupsWithOnLatestUpdateCount").ToString());
        /// Console.WriteLine(result.GetProperty("deployments")[0].ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Group</c>:
        /// <code>{
        ///   groupId: string, # Required. Group identity. This is created from the value of the ADUGroup tag in the Iot Hub&apos;s device/module twin or $default for devices with no tag.
        ///   groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;, # Required. Group type.
        ///   createdDateTime: string, # Required. Date and time when the update was created.
        ///   deviceCount: number, # Optional. The number of devices in the group.
        ///   subgroupsWithNewUpdatesAvailableCount: number, # Optional. The count of subgroups with new updates available.
        ///   subgroupsWithUpdatesInProgressCount: number, # Optional. The count of subgroups with updates in progress.
        ///   subgroupsWithOnLatestUpdateCount: number, # Optional. The count of subgroups with devices on the latest update.
        ///   deployments: [string], # Optional. The active deployment Ids for the group
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetGroup(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device group. This group is automatically created when a Device Update-enabled device is connected to the hub and reports its properties. Groups, subgroups, and deployments are not automatically cleaned up but are retained for history purposes. Users can call this method to delete a group if they do not need to retain any of the history of the group and no longer need it. If a device is ever connected again for this group after the group was deleted it will be automatically re-created but there will be no history. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteGroupAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.DeleteGroupAsync("<groupId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteGroupAsync(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device group. This group is automatically created when a Device Update-enabled device is connected to the hub and reports its properties. Groups, subgroups, and deployments are not automatically cleaned up but are retained for history purposes. Users can call this method to delete a group if they do not need to retain any of the history of the group and no longer need it. If a device is ever connected again for this group after the group was deleted it will be automatically re-created but there will be no history. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteGroup with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.DeleteGroup("<groupId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteGroup(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device group update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetUpdateComplianceForGroupAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetUpdateComplianceForGroupAsync("<groupId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("totalDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("onLatestUpdateDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("newUpdatesAvailableDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("updatesInProgressDeviceCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetUpdateComplianceForGroupAsync(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateComplianceForGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceForGroupRequest(groupId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device group update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetUpdateComplianceForGroup with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetUpdateComplianceForGroup("<groupId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("totalDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("onLatestUpdateDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("newUpdatesAvailableDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("updatesInProgressDeviceCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetUpdateComplianceForGroup(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetUpdateComplianceForGroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetUpdateComplianceForGroupRequest(groupId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetDeploymentAsync("<groupId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        /// Console.WriteLine(result.GetProperty("isCanceled").ToString());
        /// Console.WriteLine(result.GetProperty("isRetried").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentAsync(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeployment with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetDeployment("<groupId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        /// Console.WriteLine(result.GetProperty("isCanceled").ToString());
        /// Console.WriteLine(result.GetProperty("isRetried").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeployment(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates or updates a deployment. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deploymentId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdateDeploymentAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = new {
        ///     deploymentId = "<deploymentId>",
        ///     startDateTime = "2022-05-10T18:57:31.2311892Z",
        ///     update = new {
        ///         updateId = new {
        ///             provider = "<provider>",
        ///             name = "<name>",
        ///             version = "<version>",
        ///         },
        ///     },
        ///     groupId = "<groupId>",
        /// };
        /// 
        /// Response response = await client.CreateOrUpdateDeploymentAsync("<groupId>", "<deploymentId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdateDeploymentAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = new {
        ///     deploymentId = "<deploymentId>",
        ///     startDateTime = "2022-05-10T18:57:31.2311892Z",
        ///     update = new {
        ///         updateId = new {
        ///             provider = "<provider>",
        ///             name = "<name>",
        ///             version = "<version>",
        ///         },
        ///     },
        ///     groupId = "<groupId>",
        ///     deviceClassSubgroups = new[] {
        ///         "<String>"
        ///     },
        ///     isCanceled = true,
        ///     isRetried = true,
        ///     rollbackPolicy = new {
        ///         update = new {
        ///             updateId = new {
        ///                 provider = "<provider>",
        ///                 name = "<name>",
        ///                 version = "<version>",
        ///             },
        ///         },
        ///         failure = new {
        ///             devicesFailedPercentage = 1234,
        ///             devicesFailedCount = 1234,
        ///         },
        ///     },
        ///     isCloudInitiatedRollback = true,
        /// };
        /// 
        /// Response response = await client.CreateOrUpdateDeploymentAsync("<groupId>", "<deploymentId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        /// Console.WriteLine(result.GetProperty("isCanceled").ToString());
        /// Console.WriteLine(result.GetProperty("isRetried").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> CreateOrUpdateDeploymentAsync(string groupId, string deploymentId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.CreateOrUpdateDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateDeploymentRequest(groupId, deploymentId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Creates or updates a deployment. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deploymentId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call CreateOrUpdateDeployment with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = new {
        ///     deploymentId = "<deploymentId>",
        ///     startDateTime = "2022-05-10T18:57:31.2311892Z",
        ///     update = new {
        ///         updateId = new {
        ///             provider = "<provider>",
        ///             name = "<name>",
        ///             version = "<version>",
        ///         },
        ///     },
        ///     groupId = "<groupId>",
        /// };
        /// 
        /// Response response = client.CreateOrUpdateDeployment("<groupId>", "<deploymentId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// ]]></code>
        /// This sample shows how to call CreateOrUpdateDeployment with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = new {
        ///     deploymentId = "<deploymentId>",
        ///     startDateTime = "2022-05-10T18:57:31.2311892Z",
        ///     update = new {
        ///         updateId = new {
        ///             provider = "<provider>",
        ///             name = "<name>",
        ///             version = "<version>",
        ///         },
        ///     },
        ///     groupId = "<groupId>",
        ///     deviceClassSubgroups = new[] {
        ///         "<String>"
        ///     },
        ///     isCanceled = true,
        ///     isRetried = true,
        ///     rollbackPolicy = new {
        ///         update = new {
        ///             updateId = new {
        ///                 provider = "<provider>",
        ///                 name = "<name>",
        ///                 version = "<version>",
        ///             },
        ///         },
        ///         failure = new {
        ///             devicesFailedPercentage = 1234,
        ///             devicesFailedCount = 1234,
        ///         },
        ///     },
        ///     isCloudInitiatedRollback = true,
        /// };
        /// 
        /// Response response = client.CreateOrUpdateDeployment("<groupId>", "<deploymentId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        /// Console.WriteLine(result.GetProperty("isCanceled").ToString());
        /// Console.WriteLine(result.GetProperty("isRetried").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response CreateOrUpdateDeployment(string groupId, string deploymentId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.CreateOrUpdateDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateCreateOrUpdateDeploymentRequest(groupId, deploymentId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a deployment. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeploymentAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.DeleteDeploymentAsync("<groupId>", "<deploymentId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteDeploymentAsync(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a deployment. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeployment with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.DeleteDeployment("<groupId>", "<deploymentId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteDeployment(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetDeploymentStatusAsync("<groupId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentState").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("errorDetail").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("occurredDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("deploymentState").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("innererror").GetProperty("errorDetail").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("occurredDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("totalDevices").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("devicesInProgressCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("devicesCompletedFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("devicesCompletedSucceededCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("devicesCanceledCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentStatus</c>:
        /// <code>{
        ///   groupId: string, # Required. The group identity
        ///   deploymentState: &quot;Active&quot; | &quot;ActiveWithSubgroupFailures&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the deployment.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///   subgroupStatus: [
        ///     {
        ///       groupId: string, # Required. The group identity
        ///       deviceClassId: string, # Required. The device class subgroup identity
        ///       deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the subgroup deployment.
        ///       error: Error, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///       totalDevices: number, # Optional. The total number of devices in the deployment.
        ///       devicesInProgressCount: number, # Optional. The number of devices that are currently in deployment.
        ///       devicesCompletedFailedCount: number, # Optional. The number of devices that have completed deployment with a failure.
        ///       devicesCompletedSucceededCount: number, # Optional. The number of devices which have successfully completed deployment.
        ///       devicesCanceledCount: number, # Optional. The number of devices which have had their deployment canceled.
        ///     }
        ///   ], # Required. The collection of device class subgroup status objects
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentStatusAsync(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentStatusRequest(groupId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetDeploymentStatus("<groupId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentState").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("errorDetail").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("occurredDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("deploymentState").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("innererror").GetProperty("errorDetail").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("error").GetProperty("occurredDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("totalDevices").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("devicesInProgressCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("devicesCompletedFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("devicesCompletedSucceededCount").ToString());
        /// Console.WriteLine(result.GetProperty("subgroupStatus")[0].GetProperty("devicesCanceledCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentStatus</c>:
        /// <code>{
        ///   groupId: string, # Required. The group identity
        ///   deploymentState: &quot;Active&quot; | &quot;ActiveWithSubgroupFailures&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the deployment.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///   subgroupStatus: [
        ///     {
        ///       groupId: string, # Required. The group identity
        ///       deviceClassId: string, # Required. The device class subgroup identity
        ///       deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the subgroup deployment.
        ///       error: Error, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///       totalDevices: number, # Optional. The total number of devices in the deployment.
        ///       devicesInProgressCount: number, # Optional. The number of devices that are currently in deployment.
        ///       devicesCompletedFailedCount: number, # Optional. The number of devices that have completed deployment with a failure.
        ///       devicesCompletedSucceededCount: number, # Optional. The number of devices which have successfully completed deployment.
        ///       devicesCanceledCount: number, # Optional. The number of devices which have had their deployment canceled.
        ///     }
        ///   ], # Required. The collection of device class subgroup status objects
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeploymentStatus(string groupId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentStatusRequest(groupId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets device class subgroup details. A device class subgroup is the set of devices within the group that share the same device class. All devices within the same device class are compatible with the same updates. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClassSubgroupAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetDeviceClassSubgroupAsync("<groupId>", "<deviceClassId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroup</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. Device class subgroup identity. This is generated from the model Id and the compat properties reported by the device update agent in the Device Update PnP interface in IoT Hub. It is a hex-encoded SHA1 hash.
        ///   groupId: string, # Required. Group identity.
        ///   createdDateTime: string, # Required. Date and time when the device class subgroup was created.
        ///   deviceCount: number, # Optional. The number of devices in the device class subgroup.
        ///   deploymentId: string, # Optional. The active deployment Id for the device class subgroup.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets device class subgroup details. A device class subgroup is the set of devices within the group that share the same device class. All devices within the same device class are compatible with the same updates. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClassSubgroup with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetDeviceClassSubgroup("<groupId>", "<deviceClassId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("deviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroup</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. Device class subgroup identity. This is generated from the model Id and the compat properties reported by the device update agent in the Device Update PnP interface in IoT Hub. It is a hex-encoded SHA1 hash.
        ///   groupId: string, # Required. Group identity.
        ///   createdDateTime: string, # Required. Date and time when the device class subgroup was created.
        ///   deviceCount: number, # Optional. The number of devices in the device class subgroup.
        ///   deploymentId: string, # Optional. The active deployment Id for the device class subgroup.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup. This subgroup is automatically created when a Device Update-enabled device is connected to the hub and reports its properties. Groups, subgroups, and deployments are not automatically cleaned up but are retained for history purposes. Users can call this method to delete a subgroup if they do not need to retain any of the history of the subgroup and no longer need it. If a device is ever connected again for this subgroup after the subgroup was deleted it will be automatically re-created but there will be no history. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeviceClassSubgroupAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.DeleteDeviceClassSubgroupAsync("<groupId>", "<deviceClassId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup. This subgroup is automatically created when a Device Update-enabled device is connected to the hub and reports its properties. Groups, subgroups, and deployments are not automatically cleaned up but are retained for history purposes. Users can call this method to delete a subgroup if they do not need to retain any of the history of the subgroup and no longer need it. If a device is ever connected again for this subgroup after the subgroup was deleted it will be automatically re-created but there will be no history. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeviceClassSubgroup with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.DeleteDeviceClassSubgroup("<groupId>", "<deviceClassId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device class subgroup update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClassSubgroupUpdateComplianceAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetDeviceClassSubgroupUpdateComplianceAsync("<groupId>", "<deviceClassId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("totalDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("onLatestUpdateDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("newUpdatesAvailableDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("updatesInProgressDeviceCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassSubgroupUpdateComplianceAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupUpdateComplianceRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get device class subgroup update compliance information such as how many devices are on their latest update, how many need new updates, and how many are in progress on receiving a new update. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClassSubgroupUpdateCompliance with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetDeviceClassSubgroupUpdateCompliance("<groupId>", "<deviceClassId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("totalDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("onLatestUpdateDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("newUpdatesAvailableDeviceCount").ToString());
        /// Console.WriteLine(result.GetProperty("updatesInProgressDeviceCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateCompliance</c>:
        /// <code>{
        ///   totalDeviceCount: number, # Required. Total number of devices.
        ///   onLatestUpdateDeviceCount: number, # Required. Number of devices on the latest update.
        ///   newUpdatesAvailableDeviceCount: number, # Required. Number of devices with a newer update available.
        ///   updatesInProgressDeviceCount: number, # Required. Number of devices with update in-progress.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClassSubgroupUpdateCompliance(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupUpdateCompliance");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupUpdateComplianceRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the best available update for a device class subgroup and a count of how many devices need this update. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetBestUpdatesForDeviceClassSubgroupAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetBestUpdatesForDeviceClassSubgroupAsync("<groupId>", "<deviceClassId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("deviceCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupUpdatableDevices</c>:
        /// <code>{
        ///   groupId: string, # Required. The group Id
        ///   deviceClassId: string, # Required. The device class subgroup&apos;s device class Id
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information.
        ///   deviceCount: number, # Required. Total number of devices for which the update is applicable.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetBestUpdatesForDeviceClassSubgroupAsync(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetBestUpdatesForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBestUpdatesForDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the best available update for a device class subgroup and a count of how many devices need this update. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetBestUpdatesForDeviceClassSubgroup with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetBestUpdatesForDeviceClassSubgroup("<groupId>", "<deviceClassId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("deviceCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupUpdatableDevices</c>:
        /// <code>{
        ///   groupId: string, # Required. The group Id
        ///   deviceClassId: string, # Required. The device class subgroup&apos;s device class Id
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information.
        ///   deviceCount: number, # Required. Total number of devices for which the update is applicable.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetBestUpdatesForDeviceClassSubgroup(string groupId, string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetBestUpdatesForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetBestUpdatesForDeviceClassSubgroupRequest(groupId, deviceClassId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentForDeviceClassSubgroupAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetDeploymentForDeviceClassSubgroupAsync("<groupId>", "<deviceClassId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        /// Console.WriteLine(result.GetProperty("isCanceled").ToString());
        /// Console.WriteLine(result.GetProperty("isRetried").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeploymentForDeviceClassSubgroupAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the deployment properties. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentForDeviceClassSubgroup with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetDeploymentForDeviceClassSubgroup("<groupId>", "<deviceClassId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        /// Console.WriteLine(result.GetProperty("isCanceled").ToString());
        /// Console.WriteLine(result.GetProperty("isRetried").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeploymentForDeviceClassSubgroup(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup deployment. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeploymentForDeviceClassSubgroupAsync with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.DeleteDeploymentForDeviceClassSubgroupAsync("<groupId>", "<deviceClassId>", "<deploymentId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual async Task<Response> DeleteDeploymentForDeviceClassSubgroupAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Deletes a device class subgroup deployment. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. </returns>
        /// <example>
        /// This sample shows how to call DeleteDeploymentForDeviceClassSubgroup with required parameters.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.DeleteDeploymentForDeviceClassSubgroup("<groupId>", "<deviceClassId>", "<deploymentId>");
        /// Console.WriteLine(response.Status);
        /// ]]></code>
        /// </example>
        public virtual Response DeleteDeploymentForDeviceClassSubgroup(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.DeleteDeploymentForDeviceClassSubgroup");
            scope.Start();
            try
            {
                using HttpMessage message = CreateDeleteDeploymentForDeviceClassSubgroupRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stops a deployment. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call StopDeploymentAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.StopDeploymentAsync("<groupId>", "<deviceClassId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        /// Console.WriteLine(result.GetProperty("isCanceled").ToString());
        /// Console.WriteLine(result.GetProperty("isRetried").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> StopDeploymentAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StopDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Stops a deployment. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call StopDeployment with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.StopDeployment("<groupId>", "<deviceClassId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        /// Console.WriteLine(result.GetProperty("isCanceled").ToString());
        /// Console.WriteLine(result.GetProperty("isRetried").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response StopDeployment(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StopDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStopDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retries a deployment with failed devices. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call RetryDeploymentAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.RetryDeploymentAsync("<groupId>", "<deviceClassId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        /// Console.WriteLine(result.GetProperty("isCanceled").ToString());
        /// Console.WriteLine(result.GetProperty("isRetried").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> RetryDeploymentAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.RetryDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRetryDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retries a deployment with failed devices. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call RetryDeployment with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.RetryDeployment("<groupId>", "<deviceClassId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// Console.WriteLine(result.GetProperty("startDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        /// Console.WriteLine(result.GetProperty("isCanceled").ToString());
        /// Console.WriteLine(result.GetProperty("isRetried").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        /// Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>Deployment</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response RetryDeployment(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.RetryDeployment");
            scope.Start();
            try
            {
                using HttpMessage message = CreateRetryDeploymentRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClassSubgroupDeploymentStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetDeviceClassSubgroupDeploymentStatusAsync("<groupId>", "<deviceClassId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentState").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("errorDetail").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("occurredDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("totalDevices").ToString());
        /// Console.WriteLine(result.GetProperty("devicesInProgressCount").ToString());
        /// Console.WriteLine(result.GetProperty("devicesCompletedFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("devicesCompletedSucceededCount").ToString());
        /// Console.WriteLine(result.GetProperty("devicesCanceledCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupDeploymentStatus</c>:
        /// <code>{
        ///   groupId: string, # Required. The group identity
        ///   deviceClassId: string, # Required. The device class subgroup identity
        ///   deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the subgroup deployment.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///   totalDevices: number, # Optional. The total number of devices in the deployment.
        ///   devicesInProgressCount: number, # Optional. The number of devices that are currently in deployment.
        ///   devicesCompletedFailedCount: number, # Optional. The number of devices that have completed deployment with a failure.
        ///   devicesCompletedSucceededCount: number, # Optional. The number of devices which have successfully completed deployment.
        ///   devicesCanceledCount: number, # Optional. The number of devices which have had their deployment canceled.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetDeviceClassSubgroupDeploymentStatusAsync(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupDeploymentStatusRequest(groupId, deviceClassId, deploymentId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets the status of a deployment including a breakdown of how many devices in the deployment are in progress, completed, or failed. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClassSubgroupDeploymentStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetDeviceClassSubgroupDeploymentStatus("<groupId>", "<deviceClassId>", "<deploymentId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("groupId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        /// Console.WriteLine(result.GetProperty("deploymentState").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("errorDetail").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("occurredDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("totalDevices").ToString());
        /// Console.WriteLine(result.GetProperty("devicesInProgressCount").ToString());
        /// Console.WriteLine(result.GetProperty("devicesCompletedFailedCount").ToString());
        /// Console.WriteLine(result.GetProperty("devicesCompletedSucceededCount").ToString());
        /// Console.WriteLine(result.GetProperty("devicesCanceledCount").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupDeploymentStatus</c>:
        /// <code>{
        ///   groupId: string, # Required. The group identity
        ///   deviceClassId: string, # Required. The device class subgroup identity
        ///   deploymentState: &quot;Active&quot; | &quot;Failed&quot; | &quot;Inactive&quot; | &quot;Canceled&quot;, # Required. The state of the subgroup deployment.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. The error details of the Failed state.  This is not present if the deployment state is not Failed.
        ///   totalDevices: number, # Optional. The total number of devices in the deployment.
        ///   devicesInProgressCount: number, # Optional. The number of devices that are currently in deployment.
        ///   devicesCompletedFailedCount: number, # Optional. The number of devices that have completed deployment with a failure.
        ///   devicesCompletedSucceededCount: number, # Optional. The number of devices which have successfully completed deployment.
        ///   devicesCanceledCount: number, # Optional. The number of devices which have had their deployment canceled.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetDeviceClassSubgroupDeploymentStatus(string groupId, string deviceClassId, string deploymentId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetDeviceClassSubgroupDeploymentStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetDeviceClassSubgroupDeploymentStatusRequest(groupId, deviceClassId, deploymentId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve operation status. </summary>
        /// <param name="operationId"> Operation identifier. </param>
        /// <param name="ifNoneMatch"> Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetOperationStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetOperationStatusAsync("<operationId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("operationId").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// ]]></code>
        /// This sample shows how to call GetOperationStatusAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetOperationStatusAsync("<operationId>", null);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("operationId").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("errorDetail").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("occurredDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("traceId").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceOperation</c>:
        /// <code>{
        ///   operationId: string, # Required. Operation Id.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Operation status.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. Operation error encountered, if any.
        ///   traceId: string, # Optional. Operation correlation identity that can used by Microsoft Support for troubleshooting.
        ///   lastActionDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation status was last updated.
        ///   createdDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation was created.
        ///   etag: string, # Optional. Operation ETag.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetOperationStatusAsync(string operationId, ETag? ifNoneMatch = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetOperationStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetOperationStatusRequest(operationId, ifNoneMatch, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Retrieve operation status. </summary>
        /// <param name="operationId"> Operation identifier. </param>
        /// <param name="ifNoneMatch"> Defines the If-None-Match condition. The operation will be performed only if the ETag on the server does not match this value. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="operationId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="operationId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetOperationStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetOperationStatus("<operationId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("operationId").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// ]]></code>
        /// This sample shows how to call GetOperationStatus with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetOperationStatus("<operationId>", null);
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("operationId").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("code").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("message").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("errorDetail").ToString());
        /// Console.WriteLine(result.GetProperty("error").GetProperty("occurredDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("traceId").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("etag").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceOperation</c>:
        /// <code>{
        ///   operationId: string, # Required. Operation Id.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Operation status.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. Operation error encountered, if any.
        ///   traceId: string, # Optional. Operation correlation identity that can used by Microsoft Support for troubleshooting.
        ///   lastActionDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation status was last updated.
        ///   createdDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation was created.
        ///   etag: string, # Optional. Operation ETag.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetOperationStatus(string operationId, ETag? ifNoneMatch = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(operationId, nameof(operationId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetOperationStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetOperationStatusRequest(operationId, ifNoneMatch, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Start the device diagnostics log collection on specified devices. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call StartLogCollectionAsync with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = new {
        ///     deviceList = new[] {
        ///         new {
        ///             deviceId = "<deviceId>",
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = await client.StartLogCollectionAsync("<logCollectionId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("deviceId").ToString());
        /// ]]></code>
        /// This sample shows how to call StartLogCollectionAsync with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = new {
        ///     operationId = "<operationId>",
        ///     deviceList = new[] {
        ///         new {
        ///             deviceId = "<deviceId>",
        ///             moduleId = "<moduleId>",
        ///         }
        ///     },
        ///     description = "<description>",
        /// };
        /// 
        /// Response response = await client.StartLogCollectionAsync("<logCollectionId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("operationId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("deviceId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("moduleId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> StartLogCollectionAsync(string logCollectionId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StartLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStartLogCollectionRequest(logCollectionId, content, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Start the device diagnostics log collection on specified devices. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> or <paramref name="content"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call StartLogCollection with required parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = new {
        ///     deviceList = new[] {
        ///         new {
        ///             deviceId = "<deviceId>",
        ///         }
        ///     },
        /// };
        /// 
        /// Response response = client.StartLogCollection("<logCollectionId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("deviceId").ToString());
        /// ]]></code>
        /// This sample shows how to call StartLogCollection with all parameters and request content, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = new {
        ///     operationId = "<operationId>",
        ///     deviceList = new[] {
        ///         new {
        ///             deviceId = "<deviceId>",
        ///             moduleId = "<moduleId>",
        ///         }
        ///     },
        ///     description = "<description>",
        /// };
        /// 
        /// Response response = client.StartLogCollection("<logCollectionId>", RequestContent.Create(data));
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("operationId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("deviceId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("moduleId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the request and response payloads.
        /// 
        /// Request Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response StartLogCollection(string logCollectionId, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.StartLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateStartLogCollectionRequest(logCollectionId, content, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the device diagnostics log collection. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLogCollectionAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetLogCollectionAsync("<logCollectionId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("operationId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("deviceId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("moduleId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetLogCollectionAsync(string logCollectionId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionRequest(logCollectionId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get the device diagnostics log collection. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLogCollection with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetLogCollection("<logCollectionId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("operationId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("deviceId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("moduleId").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollection</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetLogCollection(string logCollectionId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollection");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionRequest(logCollectionId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get log collection with detailed status. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLogCollectionDetailedStatusAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = await client.GetLogCollectionDetailedStatusAsync("<logCollectionId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("operationId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("deviceId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("moduleId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("resultCode").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("extendedResultCode").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("logLocation").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollectionOperationDetailedStatus</c>:
        /// <code>{
        ///   operationId: string, # Optional. The device diagnostics operation id.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        ///   deviceStatus: [
        ///     {
        ///       deviceId: string, # Required. Device id
        ///       moduleId: string, # Optional. Module id.
        ///       status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Log upload status
        ///       resultCode: string, # Optional. Log upload result code
        ///       extendedResultCode: string, # Optional. Log upload extended result code
        ///       logLocation: string, # Optional. Log upload location
        ///     }
        ///   ], # Optional. Status of the devices in the operation
        ///   description: string, # Optional. Device diagnostics operation description.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual async Task<Response> GetLogCollectionDetailedStatusAsync(string logCollectionId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollectionDetailedStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionDetailedStatusRequest(logCollectionId, context);
                return await _pipeline.ProcessMessageAsync(message, context).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Get log collection with detailed status. </summary>
        /// <param name="logCollectionId"> Log collection identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="logCollectionId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="logCollectionId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The response returned from the service. Details of the response body schema are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLogCollectionDetailedStatus with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// Response response = client.GetLogCollectionDetailedStatus("<logCollectionId>");
        /// 
        /// JsonElement result = JsonDocument.Parse(response.ContentStream).RootElement;
        /// Console.WriteLine(result.GetProperty("operationId").ToString());
        /// Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        /// Console.WriteLine(result.GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("deviceId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("moduleId").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("status").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("resultCode").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("extendedResultCode").ToString());
        /// Console.WriteLine(result.GetProperty("deviceStatus")[0].GetProperty("logLocation").ToString());
        /// Console.WriteLine(result.GetProperty("description").ToString());
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for the response payload.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollectionOperationDetailedStatus</c>:
        /// <code>{
        ///   operationId: string, # Optional. The device diagnostics operation id.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        ///   deviceStatus: [
        ///     {
        ///       deviceId: string, # Required. Device id
        ///       moduleId: string, # Optional. Module id.
        ///       status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Log upload status
        ///       resultCode: string, # Optional. Log upload result code
        ///       extendedResultCode: string, # Optional. Log upload extended result code
        ///       logLocation: string, # Optional. Log upload location
        ///     }
        ///   ], # Optional. Status of the devices in the operation
        ///   description: string, # Optional. Device diagnostics operation description.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Response GetLogCollectionDetailedStatus(string logCollectionId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(logCollectionId, nameof(logCollectionId));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.GetLogCollectionDetailedStatus");
            scope.Start();
            try
            {
                using HttpMessage message = CreateGetLogCollectionDetailedStatusRequest(logCollectionId, context);
                return _pipeline.ProcessMessage(message, context);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Gets a list of all device classes (sets of devices compatible with the same updates based on the model Id and compat properties reported in the Device Update PnP interface in IoT Hub) for all devices connected to Device Update for IoT Hub. </summary>
        /// <param name="filter"> Restricts the set of device classes returned. You can filter on friendly name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClassesAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDeviceClassesAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("compatProperties").GetProperty("<test>").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeviceClassesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDeviceClassesAsync("<filter>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("compatProperties").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("friendlyName").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassesListValue</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier. This is generated from the model Id and the compat properties reported by the device update agent in the Device Update PnP interface in IoT Hub. It is a hex-encoded SHA1 hash.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is the highest version compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeviceClassesAsync(string filter = null, RequestContext context = null)
        {
            return GetDeviceClassesImplementationAsync("DeviceManagementClient.GetDeviceClasses", filter, context);
        }

        private AsyncPageable<BinaryData> GetDeviceClassesImplementationAsync(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassesRequest(filter, context)
                        : CreateGetDeviceClassesNextPageRequest(nextLink, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of all device classes (sets of devices compatible with the same updates based on the model Id and compat properties reported in the Device Update PnP interface in IoT Hub) for all devices connected to Device Update for IoT Hub. </summary>
        /// <param name="filter"> Restricts the set of device classes returned. You can filter on friendly name. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClasses and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDeviceClasses())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("compatProperties").GetProperty("<test>").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeviceClasses with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDeviceClasses("<filter>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("id").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("contractModel").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassProperties").GetProperty("compatProperties").GetProperty("<test>").ToString());
        ///     Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("bestCompatibleUpdate").GetProperty("friendlyName").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassesListValue</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. The device class identifier. This is generated from the model Id and the compat properties reported by the device update agent in the Device Update PnP interface in IoT Hub. It is a hex-encoded SHA1 hash.
        ///   friendlyName: string, # Optional. The device class friendly name. This can be updated by callers after the device class has been automatically created.
        ///   deviceClassProperties: {
        ///     contractModel: {
        ///       id: string, # Required. The Device Update agent contract model Id of the device class. This is also used to calculate the device class Id.
        ///       name: string, # Required. The Device Update agent contract model name of the device class. Intended to be a more readable form of the contract model Id.
        ///     }, # Optional. The Device Update agent contract model.
        ///     compatProperties: Dictionary&lt;string, string&gt;, # Required. The compat properties of the device class. This object can be thought of as a set of key-value pairs where the key is the name of the compatibility property and the value is the value of the compatibility property. There will always be at least 1 compat property
        ///   }, # Required. The device class properties that are used to calculate the device class Id
        ///   bestCompatibleUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. Update that is the highest version compatible with this device class.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeviceClasses(string filter = null, RequestContext context = null)
        {
            return GetDeviceClassesImplementation("DeviceManagementClient.GetDeviceClasses", filter, context);
        }

        private Pageable<BinaryData> GetDeviceClassesImplementation(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassesRequest(filter, context)
                        : CreateGetDeviceClassesNextPageRequest(nextLink, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of installable updates for a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetInstallableUpdatesForDeviceClassesAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetInstallableUpdatesForDeviceClassesAsync("<deviceClassId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("friendlyName").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateInfoListValue</c>:
        /// <code>{
        ///   updateId: {
        ///     provider: string, # Required. Update provider.
        ///     name: string, # Required. Update name.
        ///     version: string, # Required. Update version.
        ///   }, # Required. Update identifier.
        ///   description: string, # Optional. Update description.
        ///   friendlyName: string, # Optional. Friendly update name.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetInstallableUpdatesForDeviceClassesAsync(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetInstallableUpdatesForDeviceClassesImplementationAsync("DeviceManagementClient.GetInstallableUpdatesForDeviceClasses", deviceClassId, context);
        }

        private AsyncPageable<BinaryData> GetInstallableUpdatesForDeviceClassesImplementationAsync(string diagnosticsScopeName, string deviceClassId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetInstallableUpdatesForDeviceClassesRequest(deviceClassId, context)
                        : CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(nextLink, deviceClassId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of installable updates for a device class. </summary>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetInstallableUpdatesForDeviceClasses with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetInstallableUpdatesForDeviceClasses("<deviceClassId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("friendlyName").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>UpdateInfoListValue</c>:
        /// <code>{
        ///   updateId: {
        ///     provider: string, # Required. Update provider.
        ///     name: string, # Required. Update name.
        ///     version: string, # Required. Update version.
        ///   }, # Required. Update identifier.
        ///   description: string, # Optional. Update description.
        ///   friendlyName: string, # Optional. Friendly update name.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetInstallableUpdatesForDeviceClasses(string deviceClassId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetInstallableUpdatesForDeviceClassesImplementation("DeviceManagementClient.GetInstallableUpdatesForDeviceClasses", deviceClassId, context);
        }

        private Pageable<BinaryData> GetInstallableUpdatesForDeviceClassesImplementation(string diagnosticsScopeName, string deviceClassId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetInstallableUpdatesForDeviceClassesRequest(deviceClassId, context)
                        : CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(nextLink, deviceClassId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices connected to Device Update for IoT Hub. </summary>
        /// <param name="filter"> Restricts the set of devices returned. You can filter on GroupId, DeviceClassId, or GroupId and DeploymentStatus. Use DeploymentStatus eq null to query for devices with no deployment status (that have never been deployed to). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDevicesAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDevicesAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("onLatestUpdate").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDevicesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDevicesAsync("<filter>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("moduleId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("onLatestUpdate").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeploymentId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultCode").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("extendedResultCode").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultDetails").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultCode").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("extendedResultCode").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultDetails").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DevicesListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update (the best compatible update for the device&apos;s device class and group) is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDevicesAsync(string filter = null, RequestContext context = null)
        {
            return GetDevicesImplementationAsync("DeviceManagementClient.GetDevices", filter, context);
        }

        private AsyncPageable<BinaryData> GetDevicesImplementationAsync(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDevicesRequest(filter, context)
                        : CreateGetDevicesNextPageRequest(nextLink, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices connected to Device Update for IoT Hub. </summary>
        /// <param name="filter"> Restricts the set of devices returned. You can filter on GroupId, DeviceClassId, or GroupId and DeploymentStatus. Use DeploymentStatus eq null to query for devices with no deployment status (that have never been deployed to). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDevices and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDevices())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("onLatestUpdate").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDevices with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDevices("<filter>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("moduleId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("lastAttemptedUpdate").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentStatus").ToString());
        ///     Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("installedUpdate").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("onLatestUpdate").ToString());
        ///     Console.WriteLine(result.GetProperty("lastDeploymentId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultCode").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("extendedResultCode").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("resultDetails").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultCode").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("extendedResultCode").ToString());
        ///     Console.WriteLine(result.GetProperty("lastInstallResult").GetProperty("stepResults")[0].GetProperty("resultDetails").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DevicesListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   deviceClassId: string, # Required. Device class identity.
        ///   groupId: string, # Optional. Device group identity.
        ///   lastAttemptedUpdate: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Optional. The update that device last attempted to install.
        ///   deploymentStatus: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Optional. State of the device in its last deployment.
        ///   installedUpdate: UpdateInfo, # Optional. Currently installed update on device.
        ///   onLatestUpdate: boolean, # Required. Boolean flag indicating whether the latest update (the best compatible update for the device&apos;s device class and group) is installed on the device
        ///   lastDeploymentId: string, # Optional. The deployment identifier for the last deployment to the device
        ///   lastInstallResult: {
        ///     resultCode: number, # Required. Install result code.
        ///     extendedResultCode: number, # Required. Install extended result code
        ///     resultDetails: string, # Optional. A string containing further details about the install result
        ///     stepResults: [
        ///       {
        ///         update: UpdateInfo, # Optional. The update that this step installs if it is of reference type.
        ///         description: string, # Optional. Step description.
        ///         resultCode: number, # Required. Install result code.
        ///         extendedResultCode: number, # Required. Install extended result code
        ///         resultDetails: string, # Optional. A string containing further details about the install result
        ///       }
        ///     ], # Optional. Array of step results
        ///   }, # Optional. Last install result.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDevices(string filter = null, RequestContext context = null)
        {
            return GetDevicesImplementation("DeviceManagementClient.GetDevices", filter, context);
        }

        private Pageable<BinaryData> GetDevicesImplementation(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDevicesRequest(filter, context)
                        : CreateGetDevicesNextPageRequest(nextLink, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of all device groups.  The $default group will always be returned first. </summary>
        /// <param name="orderBy"> Orders the set of groups returned. You can order by groupId, deviceCount, createdDate, subgroupsWithNewUpdatesAvailableCount, subgroupsWithUpdatesInProgressCount, or subgroupsOnLatestUpdateCount. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetGroupsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetGroupsAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("groupType").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetGroupsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetGroupsAsync("<orderBy>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("groupType").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceCount").ToString());
        ///     Console.WriteLine(result.GetProperty("subgroupsWithNewUpdatesAvailableCount").ToString());
        ///     Console.WriteLine(result.GetProperty("subgroupsWithUpdatesInProgressCount").ToString());
        ///     Console.WriteLine(result.GetProperty("subgroupsWithOnLatestUpdateCount").ToString());
        ///     Console.WriteLine(result.GetProperty("deployments")[0].ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>GroupsListValue</c>:
        /// <code>{
        ///   groupId: string, # Required. Group identity. This is created from the value of the ADUGroup tag in the Iot Hub&apos;s device/module twin or $default for devices with no tag.
        ///   groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;, # Required. Group type.
        ///   createdDateTime: string, # Required. Date and time when the update was created.
        ///   deviceCount: number, # Optional. The number of devices in the group.
        ///   subgroupsWithNewUpdatesAvailableCount: number, # Optional. The count of subgroups with new updates available.
        ///   subgroupsWithUpdatesInProgressCount: number, # Optional. The count of subgroups with updates in progress.
        ///   subgroupsWithOnLatestUpdateCount: number, # Optional. The count of subgroups with devices on the latest update.
        ///   deployments: [string], # Optional. The active deployment Ids for the group
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetGroupsAsync(string orderBy = null, RequestContext context = null)
        {
            return GetGroupsImplementationAsync("DeviceManagementClient.GetGroups", orderBy, context);
        }

        private AsyncPageable<BinaryData> GetGroupsImplementationAsync(string diagnosticsScopeName, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetGroupsRequest(orderBy, context)
                        : CreateGetGroupsNextPageRequest(nextLink, orderBy, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of all device groups.  The $default group will always be returned first. </summary>
        /// <param name="orderBy"> Orders the set of groups returned. You can order by groupId, deviceCount, createdDate, subgroupsWithNewUpdatesAvailableCount, subgroupsWithUpdatesInProgressCount, or subgroupsOnLatestUpdateCount. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetGroups and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetGroups())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("groupType").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetGroups with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetGroups("<orderBy>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("groupType").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceCount").ToString());
        ///     Console.WriteLine(result.GetProperty("subgroupsWithNewUpdatesAvailableCount").ToString());
        ///     Console.WriteLine(result.GetProperty("subgroupsWithUpdatesInProgressCount").ToString());
        ///     Console.WriteLine(result.GetProperty("subgroupsWithOnLatestUpdateCount").ToString());
        ///     Console.WriteLine(result.GetProperty("deployments")[0].ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>GroupsListValue</c>:
        /// <code>{
        ///   groupId: string, # Required. Group identity. This is created from the value of the ADUGroup tag in the Iot Hub&apos;s device/module twin or $default for devices with no tag.
        ///   groupType: &quot;IoTHubTag&quot; | &quot;DefaultNoTag&quot;, # Required. Group type.
        ///   createdDateTime: string, # Required. Date and time when the update was created.
        ///   deviceCount: number, # Optional. The number of devices in the group.
        ///   subgroupsWithNewUpdatesAvailableCount: number, # Optional. The count of subgroups with new updates available.
        ///   subgroupsWithUpdatesInProgressCount: number, # Optional. The count of subgroups with updates in progress.
        ///   subgroupsWithOnLatestUpdateCount: number, # Optional. The count of subgroups with devices on the latest update.
        ///   deployments: [string], # Optional. The active deployment Ids for the group
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetGroups(string orderBy = null, RequestContext context = null)
        {
            return GetGroupsImplementation("DeviceManagementClient.GetGroups", orderBy, context);
        }

        private Pageable<BinaryData> GetGroupsImplementation(string diagnosticsScopeName, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetGroupsRequest(orderBy, context)
                        : CreateGetGroupsNextPageRequest(nextLink, orderBy, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the best available updates for a device group and a count of how many devices need each update. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetBestUpdatesForGroupsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetBestUpdatesForGroupsAsync("<groupId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceCount").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupUpdatableDevicesListValue</c>:
        /// <code>{
        ///   groupId: string, # Required. The group Id
        ///   deviceClassId: string, # Required. The device class subgroup&apos;s device class Id
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information.
        ///   deviceCount: number, # Required. Total number of devices for which the update is applicable.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetBestUpdatesForGroupsAsync(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetBestUpdatesForGroupsImplementationAsync("DeviceManagementClient.GetBestUpdatesForGroups", groupId, context);
        }

        private AsyncPageable<BinaryData> GetBestUpdatesForGroupsImplementationAsync(string diagnosticsScopeName, string groupId, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetBestUpdatesForGroupsRequest(groupId, context)
                        : CreateGetBestUpdatesForGroupsNextPageRequest(nextLink, groupId, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the best available updates for a device group and a count of how many devices need each update. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetBestUpdatesForGroups with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetBestUpdatesForGroups("<groupId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceCount").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupUpdatableDevicesListValue</c>:
        /// <code>{
        ///   groupId: string, # Required. The group Id
        ///   deviceClassId: string, # Required. The device class subgroup&apos;s device class Id
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information.
        ///   deviceCount: number, # Required. Total number of devices for which the update is applicable.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetBestUpdatesForGroups(string groupId, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetBestUpdatesForGroupsImplementation("DeviceManagementClient.GetBestUpdatesForGroups", groupId, context);
        }

        private Pageable<BinaryData> GetBestUpdatesForGroupsImplementation(string diagnosticsScopeName, string groupId, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetBestUpdatesForGroupsRequest(groupId, context)
                        : CreateGetBestUpdatesForGroupsNextPageRequest(nextLink, groupId, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device group. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentsForGroupsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDeploymentsForGroupsAsync("<groupId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentId").ToString());
        ///     Console.WriteLine(result.GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeploymentsForGroupsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDeploymentsForGroupsAsync("<groupId>", "<orderBy>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentId").ToString());
        ///     Console.WriteLine(result.GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("isCanceled").ToString());
        ///     Console.WriteLine(result.GetProperty("isRetried").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        ///     Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentsListValue</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeploymentsForGroupsAsync(string groupId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeploymentsForGroupsImplementationAsync("DeviceManagementClient.GetDeploymentsForGroups", groupId, orderBy, context);
        }

        private AsyncPageable<BinaryData> GetDeploymentsForGroupsImplementationAsync(string diagnosticsScopeName, string groupId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForGroupsRequest(groupId, orderBy, context)
                        : CreateGetDeploymentsForGroupsNextPageRequest(nextLink, groupId, orderBy, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device group. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentsForGroups with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDeploymentsForGroups("<groupId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentId").ToString());
        ///     Console.WriteLine(result.GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeploymentsForGroups with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDeploymentsForGroups("<groupId>", "<orderBy>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentId").ToString());
        ///     Console.WriteLine(result.GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("isCanceled").ToString());
        ///     Console.WriteLine(result.GetProperty("isRetried").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        ///     Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentsListValue</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeploymentsForGroups(string groupId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeploymentsForGroupsImplementation("DeviceManagementClient.GetDeploymentsForGroups", groupId, orderBy, context);
        }

        private Pageable<BinaryData> GetDeploymentsForGroupsImplementation(string diagnosticsScopeName, string groupId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForGroupsRequest(groupId, orderBy, context)
                        : CreateGetDeploymentsForGroupsNextPageRequest(nextLink, groupId, orderBy, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the device class subgroups for the group. A device class subgroup is the set of devices within the group that share the same device class. All devices within the same device class are compatible with the same updates. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="filter"> Restricts the set of device class subgroups returned. You can filter on compat properties by name and value. (i.e. filter=compatProperties/propertyName1 eq &apos;value1&apos; and compatProperties/propertyName2 eq &apos;value2&apos;). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClassSubgroupsForGroupsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDeviceClassSubgroupsForGroupsAsync("<groupId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeviceClassSubgroupsForGroupsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDeviceClassSubgroupsForGroupsAsync("<groupId>", "<filter>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceCount").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupsListValue</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. Device class subgroup identity. This is generated from the model Id and the compat properties reported by the device update agent in the Device Update PnP interface in IoT Hub. It is a hex-encoded SHA1 hash.
        ///   groupId: string, # Required. Group identity.
        ///   createdDateTime: string, # Required. Date and time when the device class subgroup was created.
        ///   deviceCount: number, # Optional. The number of devices in the device class subgroup.
        ///   deploymentId: string, # Optional. The active deployment Id for the device class subgroup.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeviceClassSubgroupsForGroupsAsync(string groupId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeviceClassSubgroupsForGroupsImplementationAsync("DeviceManagementClient.GetDeviceClassSubgroupsForGroups", groupId, filter, context);
        }

        private AsyncPageable<BinaryData> GetDeviceClassSubgroupsForGroupsImplementationAsync(string diagnosticsScopeName, string groupId, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassSubgroupsForGroupsRequest(groupId, filter, context)
                        : CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(nextLink, groupId, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get the device class subgroups for the group. A device class subgroup is the set of devices within the group that share the same device class. All devices within the same device class are compatible with the same updates. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="filter"> Restricts the set of device class subgroups returned. You can filter on compat properties by name and value. (i.e. filter=compatProperties/propertyName1 eq &apos;value1&apos; and compatProperties/propertyName2 eq &apos;value2&apos;). </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceClassSubgroupsForGroups with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDeviceClassSubgroupsForGroups("<groupId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeviceClassSubgroupsForGroups with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDeviceClassSubgroupsForGroups("<groupId>", "<filter>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceClassId").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceCount").ToString());
        ///     Console.WriteLine(result.GetProperty("deploymentId").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceClassSubgroupsListValue</c>:
        /// <code>{
        ///   deviceClassId: string, # Required. Device class subgroup identity. This is generated from the model Id and the compat properties reported by the device update agent in the Device Update PnP interface in IoT Hub. It is a hex-encoded SHA1 hash.
        ///   groupId: string, # Required. Group identity.
        ///   createdDateTime: string, # Required. Date and time when the device class subgroup was created.
        ///   deviceCount: number, # Optional. The number of devices in the device class subgroup.
        ///   deploymentId: string, # Optional. The active deployment Id for the device class subgroup.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeviceClassSubgroupsForGroups(string groupId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));

            return GetDeviceClassSubgroupsForGroupsImplementation("DeviceManagementClient.GetDeviceClassSubgroupsForGroups", groupId, filter, context);
        }

        private Pageable<BinaryData> GetDeviceClassSubgroupsForGroupsImplementation(string diagnosticsScopeName, string groupId, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceClassSubgroupsForGroupsRequest(groupId, filter, context)
                        : CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(nextLink, groupId, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device class subgroup. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentsForDeviceClassSubgroupsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDeploymentsForDeviceClassSubgroupsAsync("<groupId>", "<deviceClassId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentId").ToString());
        ///     Console.WriteLine(result.GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeploymentsForDeviceClassSubgroupsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDeploymentsForDeviceClassSubgroupsAsync("<groupId>", "<deviceClassId>", "<orderBy>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentId").ToString());
        ///     Console.WriteLine(result.GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("isCanceled").ToString());
        ///     Console.WriteLine(result.GetProperty("isRetried").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        ///     Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentsListValue</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeploymentsForDeviceClassSubgroupsAsync(string groupId, string deviceClassId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetDeploymentsForDeviceClassSubgroupsImplementationAsync("DeviceManagementClient.GetDeploymentsForDeviceClassSubgroups", groupId, deviceClassId, orderBy, context);
        }

        private AsyncPageable<BinaryData> GetDeploymentsForDeviceClassSubgroupsImplementationAsync(string diagnosticsScopeName, string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForDeviceClassSubgroupsRequest(groupId, deviceClassId, orderBy, context)
                        : CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(nextLink, groupId, deviceClassId, orderBy, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of deployments for a device class subgroup. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="orderBy"> Orders the set of deployments returned. You can order by start date. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/> or <paramref name="deviceClassId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeploymentsForDeviceClassSubgroups with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDeploymentsForDeviceClassSubgroups("<groupId>", "<deviceClassId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentId").ToString());
        ///     Console.WriteLine(result.GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeploymentsForDeviceClassSubgroups with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDeploymentsForDeviceClassSubgroups("<groupId>", "<deviceClassId>", "<orderBy>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deploymentId").ToString());
        ///     Console.WriteLine(result.GetProperty("startDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("groupId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceClassSubgroups")[0].ToString());
        ///     Console.WriteLine(result.GetProperty("isCanceled").ToString());
        ///     Console.WriteLine(result.GetProperty("isRetried").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("provider").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("updateId").GetProperty("version").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("update").GetProperty("friendlyName").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedPercentage").ToString());
        ///     Console.WriteLine(result.GetProperty("rollbackPolicy").GetProperty("failure").GetProperty("devicesFailedCount").ToString());
        ///     Console.WriteLine(result.GetProperty("isCloudInitiatedRollback").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentsListValue</c>:
        /// <code>{
        ///   deploymentId: string, # Required. The caller-provided deployment identifier. This cannot be longer than 73 characters, must be all lower-case, and cannot contain &apos;&amp;&apos;, &apos;^&apos;, &apos;[&apos;, &apos;]&apos;, &apos;{&apos;, &apos;}&apos;, &apos;|&apos;, &apos;&lt;&apos;, &apos;&gt;&apos;, forward slash, backslash, or double quote. The Updates view in the Azure Portal IoT Hub resource generates a GUID for deploymentId when you create a deployment.
        ///   startDateTime: string (ISO 8601 Format), # Required. The deployment start datetime.
        ///   update: {
        ///     updateId: {
        ///       provider: string, # Required. Update provider.
        ///       name: string, # Required. Update name.
        ///       version: string, # Required. Update version.
        ///     }, # Required. Update identifier.
        ///     description: string, # Optional. Update description.
        ///     friendlyName: string, # Optional. Friendly update name.
        ///   }, # Required. Update information for the update in the deployment.
        ///   groupId: string, # Required. The group identity for the devices the deployment is intended to update.
        ///   deviceClassSubgroups: [string], # Optional. The device class subgroups the deployment is compatible with and subgroup deployments have been created for. This is not provided by the caller during CreateOrUpdateDeployment but is automatically determined by Device Update
        ///   isCanceled: boolean, # Optional. Boolean flag indicating whether the deployment was canceled.
        ///   isRetried: boolean, # Optional. Boolean flag indicating whether the deployment has been retried.
        ///   rollbackPolicy: {
        ///     update: UpdateInfo, # Required. Update to rollback to.
        ///     failure: {
        ///       devicesFailedPercentage: number, # Required. Percentage of devices that failed.
        ///       devicesFailedCount: number, # Required. Number of devices that failed.
        ///     }, # Required. Failure conditions to initiate rollback policy.
        ///   }, # Optional. The rollback policy for the deployment.
        ///   isCloudInitiatedRollback: boolean, # Optional. Boolean flag indicating whether the deployment is a rollback deployment.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeploymentsForDeviceClassSubgroups(string groupId, string deviceClassId, string orderBy = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));

            return GetDeploymentsForDeviceClassSubgroupsImplementation("DeviceManagementClient.GetDeploymentsForDeviceClassSubgroups", groupId, deviceClassId, orderBy, context);
        }

        private Pageable<BinaryData> GetDeploymentsForDeviceClassSubgroupsImplementation(string diagnosticsScopeName, string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeploymentsForDeviceClassSubgroupsRequest(groupId, deviceClassId, orderBy, context)
                        : CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(nextLink, groupId, deviceClassId, orderBy, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices in a deployment along with their state. Useful for getting a list of failed devices. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="filter"> Restricts the set of deployment device states returned. You can filter on deviceId and moduleId and/or deviceState. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync("<groupId>", "<deviceClassId>", "<deploymentId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("retryCount").ToString());
        ///     Console.WriteLine(result.GetProperty("movedOnToNewDeployment").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceState").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync("<groupId>", "<deviceClassId>", "<deploymentId>", "<filter>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("moduleId").ToString());
        ///     Console.WriteLine(result.GetProperty("retryCount").ToString());
        ///     Console.WriteLine(result.GetProperty("movedOnToNewDeployment").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceState").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentDeviceStatesListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   retryCount: number, # Required. The number of times this deployment has been retried on this device.
        ///   movedOnToNewDeployment: boolean, # Required. Boolean flag indicating whether this device is in a newer deployment and can no longer retry this deployment.
        ///   deviceState: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Required. Deployment device state.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeploymentsAsync(string groupId, string deviceClassId, string deploymentId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            return GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementationAsync("DeviceManagementClient.GetDeviceStatesForDeviceClassSubgroupDeployments", groupId, deviceClassId, deploymentId, filter, context);
        }

        private AsyncPageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementationAsync(string diagnosticsScopeName, string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(groupId, deviceClassId, deploymentId, filter, context)
                        : CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(nextLink, groupId, deviceClassId, deploymentId, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Gets a list of devices in a deployment along with their state. Useful for getting a list of failed devices. </summary>
        /// <param name="groupId"> Group identifier. </param>
        /// <param name="deviceClassId"> Device class identifier. </param>
        /// <param name="deploymentId"> Deployment identifier. </param>
        /// <param name="filter"> Restricts the set of deployment device states returned. You can filter on deviceId and moduleId and/or deviceState. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is null. </exception>
        /// <exception cref="ArgumentException"> <paramref name="groupId"/>, <paramref name="deviceClassId"/> or <paramref name="deploymentId"/> is an empty string, and was expected to be non-empty. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetDeviceStatesForDeviceClassSubgroupDeployments with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDeviceStatesForDeviceClassSubgroupDeployments("<groupId>", "<deviceClassId>", "<deploymentId>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("retryCount").ToString());
        ///     Console.WriteLine(result.GetProperty("movedOnToNewDeployment").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceState").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetDeviceStatesForDeviceClassSubgroupDeployments with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetDeviceStatesForDeviceClassSubgroupDeployments("<groupId>", "<deviceClassId>", "<deploymentId>", "<filter>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("moduleId").ToString());
        ///     Console.WriteLine(result.GetProperty("retryCount").ToString());
        ///     Console.WriteLine(result.GetProperty("movedOnToNewDeployment").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceState").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeploymentDeviceStatesListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device identity.
        ///   moduleId: string, # Optional. Device module identity.
        ///   retryCount: number, # Required. The number of times this deployment has been retried on this device.
        ///   movedOnToNewDeployment: boolean, # Required. Boolean flag indicating whether this device is in a newer deployment and can no longer retry this deployment.
        ///   deviceState: &quot;Succeeded&quot; | &quot;InProgress&quot; | &quot;Canceled&quot; | &quot;Failed&quot;, # Required. Deployment device state.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeployments(string groupId, string deviceClassId, string deploymentId, string filter = null, RequestContext context = null)
        {
            Argument.AssertNotNullOrEmpty(groupId, nameof(groupId));
            Argument.AssertNotNullOrEmpty(deviceClassId, nameof(deviceClassId));
            Argument.AssertNotNullOrEmpty(deploymentId, nameof(deploymentId));

            return GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementation("DeviceManagementClient.GetDeviceStatesForDeviceClassSubgroupDeployments", groupId, deviceClassId, deploymentId, filter, context);
        }

        private Pageable<BinaryData> GetDeviceStatesForDeviceClassSubgroupDeploymentsImplementation(string diagnosticsScopeName, string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(groupId, deviceClassId, deploymentId, filter, context)
                        : CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(nextLink, groupId, deviceClassId, deploymentId, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get a list of all device import operations. Completed operations are kept for 7 days before auto-deleted. </summary>
        /// <param name="filter"> Restricts the set of operations returned. Only one specific filter is supported: &quot;status eq &apos;NotStarted&apos; or status eq &apos;Running&apos;&quot;. </param>
        /// <param name="top"> Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the number of available items up to but not greater than the specified value n. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetOperationStatusesAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetOperationStatusesAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("operationId").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetOperationStatusesAsync with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetOperationStatusesAsync("<filter>", 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("operationId").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("errorDetail").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("occurredDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("traceId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("etag").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceOperationsListValue</c>:
        /// <code>{
        ///   operationId: string, # Required. Operation Id.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Operation status.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. Operation error encountered, if any.
        ///   traceId: string, # Optional. Operation correlation identity that can used by Microsoft Support for troubleshooting.
        ///   lastActionDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation status was last updated.
        ///   createdDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation was created.
        ///   etag: string, # Optional. Operation ETag.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetOperationStatusesAsync(string filter = null, int? top = null, RequestContext context = null)
        {
            return GetOperationStatusesImplementationAsync("DeviceManagementClient.GetOperationStatuses", filter, top, context);
        }

        private AsyncPageable<BinaryData> GetOperationStatusesImplementationAsync(string diagnosticsScopeName, string filter, int? top, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetOperationStatusesRequest(filter, top, context)
                        : CreateGetOperationStatusesNextPageRequest(nextLink, filter, top, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get a list of all device import operations. Completed operations are kept for 7 days before auto-deleted. </summary>
        /// <param name="filter"> Restricts the set of operations returned. Only one specific filter is supported: &quot;status eq &apos;NotStarted&apos; or status eq &apos;Running&apos;&quot;. </param>
        /// <param name="top"> Specifies a non-negative integer n that limits the number of items returned from a collection. The service returns the number of available items up to but not greater than the specified value n. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetOperationStatuses and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetOperationStatuses())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("operationId").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        /// }
        /// ]]></code>
        /// This sample shows how to call GetOperationStatuses with all parameters, and how to parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetOperationStatuses("<filter>", 1234))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("operationId").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("target").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("code").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("message").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("innererror").GetProperty("errorDetail").ToString());
        ///     Console.WriteLine(result.GetProperty("error").GetProperty("occurredDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("traceId").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("etag").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceOperationsListValue</c>:
        /// <code>{
        ///   operationId: string, # Required. Operation Id.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Required. Operation status.
        ///   error: {
        ///     code: string, # Required. Server defined error code.
        ///     message: string, # Required. A human-readable representation of the error.
        ///     target: string, # Optional. The target of the error.
        ///     details: [Error], # Optional. An array of errors that led to the reported error.
        ///     innererror: {
        ///       code: string, # Required. A more specific error code than what was provided by the containing error.
        ///       message: string, # Optional. A human-readable representation of the error.
        ///       errorDetail: string, # Optional. The internal error or exception message.
        ///       innerError: InnerError, # Optional. An object containing more specific information than the current object about the error.
        ///     }, # Optional. An object containing more specific information than the current object about the error.
        ///     occurredDateTime: string (ISO 8601 Format), # Optional. Date and time in UTC when the error occurred.
        ///   }, # Optional. Operation error encountered, if any.
        ///   traceId: string, # Optional. Operation correlation identity that can used by Microsoft Support for troubleshooting.
        ///   lastActionDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation status was last updated.
        ///   createdDateTime: string (ISO 8601 Format), # Required. Date and time in UTC when the operation was created.
        ///   etag: string, # Optional. Operation ETag.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetOperationStatuses(string filter = null, int? top = null, RequestContext context = null)
        {
            return GetOperationStatusesImplementation("DeviceManagementClient.GetOperationStatuses", filter, top, context);
        }

        private Pageable<BinaryData> GetOperationStatusesImplementation(string diagnosticsScopeName, string filter, int? top, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetOperationStatusesRequest(filter, top, context)
                        : CreateGetOperationStatusesNextPageRequest(nextLink, filter, top, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get all device diagnostics log collections. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLogCollectionsAsync and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetLogCollectionsAsync())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("operationId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("moduleId").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollectionListValue</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetLogCollectionsAsync(RequestContext context = null)
        {
            return GetLogCollectionsImplementationAsync("DeviceManagementClient.GetLogCollections", context);
        }

        private AsyncPageable<BinaryData> GetLogCollectionsImplementationAsync(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetLogCollectionsRequest(context)
                        : CreateGetLogCollectionsNextPageRequest(nextLink, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get all device diagnostics log collections. </summary>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetLogCollections and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetLogCollections())
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("operationId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("deviceList")[0].GetProperty("moduleId").ToString());
        ///     Console.WriteLine(result.GetProperty("description").ToString());
        ///     Console.WriteLine(result.GetProperty("createdDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("lastActionDateTime").ToString());
        ///     Console.WriteLine(result.GetProperty("status").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>LogCollectionListValue</c>:
        /// <code>{
        ///   operationId: string, # Optional. The log collection id.
        ///   deviceList: [
        ///     {
        ///       deviceId: string, # Required. Device Id
        ///       moduleId: string, # Optional. Module Id
        ///     }
        ///   ], # Required. Array of Device Update agent ids
        ///   description: string, # Optional. Description of the diagnostics operation.
        ///   createdDateTime: string, # Optional. The timestamp when the operation was created.
        ///   lastActionDateTime: string, # Optional. A timestamp for when the current state was entered.
        ///   status: &quot;NotStarted&quot; | &quot;Running&quot; | &quot;Succeeded&quot; | &quot;Failed&quot;, # Optional. Operation status.
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetLogCollections(RequestContext context = null)
        {
            return GetLogCollectionsImplementation("DeviceManagementClient.GetLogCollections", context);
        }

        private Pageable<BinaryData> GetLogCollectionsImplementation(string diagnosticsScopeName, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetLogCollectionsRequest(context)
                        : CreateGetLogCollectionsNextPageRequest(nextLink, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get list of device health. </summary>
        /// <param name="filter"> Restricts the set of devices for which device health is returned. You can filter on status, device id and module id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filter"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="AsyncPageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetHealthOfDevicesAsync with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// await foreach (var data in client.GetHealthOfDevicesAsync("<filter>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("moduleId").ToString());
        ///     Console.WriteLine(result.GetProperty("state").ToString());
        ///     Console.WriteLine(result.GetProperty("digitalTwinModelId").ToString());
        ///     Console.WriteLine(result.GetProperty("healthChecks")[0].GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("healthChecks")[0].GetProperty("result").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceHealthListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device id
        ///   moduleId: string, # Optional. Module id
        ///   state: &quot;healthy&quot; | &quot;unhealthy&quot;, # Required. Aggregate device health state
        ///   digitalTwinModelId: string, # Optional. Digital twin model Id
        ///   healthChecks: [
        ///     {
        ///       name: string, # Optional. Health check name
        ///       result: &quot;success&quot; | &quot;userError&quot;, # Optional. Health check result
        ///     }
        ///   ], # Required. Array of health checks and their results
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual AsyncPageable<BinaryData> GetHealthOfDevicesAsync(string filter, RequestContext context = null)
        {
            Argument.AssertNotNull(filter, nameof(filter));

            return GetHealthOfDevicesImplementationAsync("DeviceManagementClient.GetHealthOfDevices", filter, context);
        }

        private AsyncPageable<BinaryData> GetHealthOfDevicesImplementationAsync(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreateAsyncPageable(CreateEnumerableAsync, ClientDiagnostics, diagnosticsScopeName);
            async IAsyncEnumerable<Page<BinaryData>> CreateEnumerableAsync(string nextLink, int? pageSizeHint, [EnumeratorCancellation] CancellationToken cancellationToken = default)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetHealthOfDevicesRequest(filter, context)
                        : CreateGetHealthOfDevicesNextPageRequest(nextLink, filter, context);
                    var page = await LowLevelPageableHelpers.ProcessMessageAsync(_pipeline, message, context, "value", "nextLink", cancellationToken).ConfigureAwait(false);
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Get list of device health. </summary>
        /// <param name="filter"> Restricts the set of devices for which device health is returned. You can filter on status, device id and module id. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="filter"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Pageable{T}"/> from the service containing a list of <see cref="BinaryData"/> objects. Details of the body schema for each item in the collection are in the Remarks section below. </returns>
        /// <example>
        /// This sample shows how to call GetHealthOfDevices with required parameters and parse the result.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// foreach (var data in client.GetHealthOfDevices("<filter>"))
        /// {
        ///     JsonElement result = JsonDocument.Parse(data.ToStream()).RootElement;
        ///     Console.WriteLine(result.GetProperty("deviceId").ToString());
        ///     Console.WriteLine(result.GetProperty("moduleId").ToString());
        ///     Console.WriteLine(result.GetProperty("state").ToString());
        ///     Console.WriteLine(result.GetProperty("digitalTwinModelId").ToString());
        ///     Console.WriteLine(result.GetProperty("healthChecks")[0].GetProperty("name").ToString());
        ///     Console.WriteLine(result.GetProperty("healthChecks")[0].GetProperty("result").ToString());
        /// }
        /// ]]></code>
        /// </example>
        /// <remarks>
        /// Below is the JSON schema for one item in the pageable response.
        /// 
        /// Response Body:
        /// 
        /// Schema for <c>DeviceHealthListValue</c>:
        /// <code>{
        ///   deviceId: string, # Required. Device id
        ///   moduleId: string, # Optional. Module id
        ///   state: &quot;healthy&quot; | &quot;unhealthy&quot;, # Required. Aggregate device health state
        ///   digitalTwinModelId: string, # Optional. Digital twin model Id
        ///   healthChecks: [
        ///     {
        ///       name: string, # Optional. Health check name
        ///       result: &quot;success&quot; | &quot;userError&quot;, # Optional. Health check result
        ///     }
        ///   ], # Required. Array of health checks and their results
        /// }
        /// </code>
        /// 
        /// </remarks>
        public virtual Pageable<BinaryData> GetHealthOfDevices(string filter, RequestContext context = null)
        {
            Argument.AssertNotNull(filter, nameof(filter));

            return GetHealthOfDevicesImplementation("DeviceManagementClient.GetHealthOfDevices", filter, context);
        }

        private Pageable<BinaryData> GetHealthOfDevicesImplementation(string diagnosticsScopeName, string filter, RequestContext context)
        {
            return PageableHelpers.CreatePageable(CreateEnumerable, ClientDiagnostics, diagnosticsScopeName);
            IEnumerable<Page<BinaryData>> CreateEnumerable(string nextLink, int? pageSizeHint)
            {
                do
                {
                    var message = string.IsNullOrEmpty(nextLink)
                        ? CreateGetHealthOfDevicesRequest(filter, context)
                        : CreateGetHealthOfDevicesNextPageRequest(nextLink, filter, context);
                    var page = LowLevelPageableHelpers.ProcessMessage(_pipeline, message, context, "value", "nextLink");
                    nextLink = page.ContinuationToken;
                    yield return page;
                } while (!string.IsNullOrEmpty(nextLink));
            }
        }

        /// <summary> Import existing devices from IoT Hub. This is a long-running-operation; use Operation-Location response header value to check for operation status. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call ImportDevicesAsync with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = "Devices";
        /// 
        /// var operation = await client.ImportDevicesAsync(WaitUntil.Completed, RequestContent.Create(data));
        /// 
        /// var response = await operation.WaitForCompletionResponseAsync();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        public virtual async Task<Operation> ImportDevicesAsync(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.ImportDevices");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportDevicesRequest(content, context);
                return await ProtocolOperationHelpers.ProcessMessageWithoutResponseValueAsync(_pipeline, message, ClientDiagnostics, "DeviceManagementClient.ImportDevices", OperationFinalStateVia.Location, context, waitUntil).ConfigureAwait(false);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        /// <summary> Import existing devices from IoT Hub. This is a long-running-operation; use Operation-Location response header value to check for operation status. </summary>
        /// <param name="waitUntil"> <see cref="WaitUntil.Completed"/> if the method should wait to return until the long-running operation has completed on the service; <see cref="WaitUntil.Started"/> if it should return after starting the operation. For more information on long-running operations, please see <see href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/LongRunningOperations.md"> Azure.Core Long-Running Operation samples</see>. </param>
        /// <param name="content"> The content to send as the body of the request. Details of the request body schema are in the Remarks section below. </param>
        /// <param name="context"> The request context, which can override default behaviors of the client pipeline on a per-call basis. </param>
        /// <exception cref="ArgumentNullException"> <paramref name="content"/> is null. </exception>
        /// <exception cref="RequestFailedException"> Service returned a non-success status code. </exception>
        /// <returns> The <see cref="Operation"/> representing an asynchronous operation on the service. </returns>
        /// <example>
        /// This sample shows how to call ImportDevices with required parameters and request content.
        /// <code><![CDATA[
        /// var credential = new DefaultAzureCredential();
        /// var endpoint = new Uri("<https://my-service.azure.com>");
        /// var client = new DeviceManagementClient(endpoint, "<instanceId>", credential);
        /// 
        /// var data = "Devices";
        /// 
        /// var operation = client.ImportDevices(WaitUntil.Completed, RequestContent.Create(data));
        /// 
        /// var response = operation.WaitForCompletionResponse();
        /// Console.WriteLine(response.Status)
        /// ]]></code>
        /// </example>
        public virtual Operation ImportDevices(WaitUntil waitUntil, RequestContent content, RequestContext context = null)
        {
            Argument.AssertNotNull(content, nameof(content));

            using var scope = ClientDiagnostics.CreateScope("DeviceManagementClient.ImportDevices");
            scope.Start();
            try
            {
                using HttpMessage message = CreateImportDevicesRequest(content, context);
                return ProtocolOperationHelpers.ProcessMessageWithoutResponseValue(_pipeline, message, ClientDiagnostics, "DeviceManagementClient.ImportDevices", OperationFinalStateVia.Location, context, waitUntil);
            }
            catch (Exception e)
            {
                scope.Failed(e);
                throw;
            }
        }

        internal HttpMessage CreateGetDeviceClassesRequest(string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateUpdateDeviceClassRequest(string deviceClassId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Patch;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/merge-patch+json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDeviceClassRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetInstallableUpdatesForDeviceClassesRequest(string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceClasses/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/installableUpdates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDevicesRequest(string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateImportDevicesRequest(RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier202);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices:import", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetDeviceRequest(string deviceId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices/", false);
            uri.AppendPath(deviceId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceModuleRequest(string deviceId, string moduleId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/devices/", false);
            uri.AppendPath(deviceId, true);
            uri.AppendPath("/modules/", false);
            uri.AppendPath(moduleId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUpdateComplianceRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupsRequest(string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups", false);
            if (orderBy != null)
            {
                uri.AppendQuery("orderby", orderBy, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetUpdateComplianceForGroupRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForGroupsRequest(string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/bestUpdates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForGroupsRequest(string groupId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (orderBy != null)
            {
                uri.AppendQuery("orderby", orderBy, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateCreateOrUpdateDeploymentRequest(string groupId, string deploymentId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateDeleteDeploymentRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentStatusRequest(string groupId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/status", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupsForGroupsRequest(string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupUpdateComplianceRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/updateCompliance", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForDeviceClassSubgroupRequest(string groupId, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/bestUpdates", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForDeviceClassSubgroupsRequest(string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            if (orderBy != null)
            {
                uri.AppendQuery("orderby", orderBy, true);
            }
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentForDeviceClassSubgroupRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateDeleteDeploymentForDeviceClassSubgroupRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier204);
            var request = message.Request;
            request.Method = RequestMethod.Delete;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateStopDeploymentRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath(":cancel", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateRetryDeploymentRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Post;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath(":retry", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupDeploymentStatusRequest(string groupId, string deviceClassId, string deploymentId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/status", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsRequest(string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/groups/", false);
            uri.AppendPath(groupId, true);
            uri.AppendPath("/deviceClassSubgroups/", false);
            uri.AppendPath(deviceClassId, true);
            uri.AppendPath("/deployments/", false);
            uri.AppendPath(deploymentId, true);
            uri.AppendPath("/devicestates", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetOperationStatusRequest(string operationId, ETag? ifNoneMatch, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200304);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/operations/", false);
            uri.AppendPath(operationId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            if (ifNoneMatch != null)
            {
                request.Headers.Add("If-None-Match", ifNoneMatch.Value);
            }
            return message;
        }

        internal HttpMessage CreateGetOperationStatusesRequest(string filter, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/operations", false);
            if (filter != null)
            {
                uri.AppendQuery("filter", filter, true);
            }
            if (top != null)
            {
                uri.AppendQuery("top", top.Value, true);
            }
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateStartLogCollectionRequest(string logCollectionId, RequestContent content, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier201);
            var request = message.Request;
            request.Method = RequestMethod.Put;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(logCollectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            request.Headers.Add("Content-Type", "application/json");
            request.Content = content;
            return message;
        }

        internal HttpMessage CreateGetLogCollectionRequest(string logCollectionId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(logCollectionId, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionsRequest(RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionDetailedStatusRequest(string logCollectionId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/logCollections/", false);
            uri.AppendPath(logCollectionId, true);
            uri.AppendPath("/detailedStatus", false);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetHealthOfDevicesRequest(string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendPath("/deviceUpdate/", false);
            uri.AppendPath(_instanceId, false);
            uri.AppendPath("/management/deviceDiagnostics/deviceHealth", false);
            uri.AppendQuery("filter", filter, true);
            uri.AppendQuery("api-version", _apiVersion, true);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassesNextPageRequest(string nextLink, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetInstallableUpdatesForDeviceClassesNextPageRequest(string nextLink, string deviceClassId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDevicesNextPageRequest(string nextLink, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetGroupsNextPageRequest(string nextLink, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetBestUpdatesForGroupsNextPageRequest(string nextLink, string groupId, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForGroupsNextPageRequest(string nextLink, string groupId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceClassSubgroupsForGroupsNextPageRequest(string nextLink, string groupId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeploymentsForDeviceClassSubgroupsNextPageRequest(string nextLink, string groupId, string deviceClassId, string orderBy, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetDeviceStatesForDeviceClassSubgroupDeploymentsNextPageRequest(string nextLink, string groupId, string deviceClassId, string deploymentId, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetOperationStatusesNextPageRequest(string nextLink, string filter, int? top, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetLogCollectionsNextPageRequest(string nextLink, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        internal HttpMessage CreateGetHealthOfDevicesNextPageRequest(string nextLink, string filter, RequestContext context)
        {
            var message = _pipeline.CreateMessage(context, ResponseClassifier200);
            var request = message.Request;
            request.Method = RequestMethod.Get;
            var uri = new RawRequestUriBuilder();
            uri.AppendRaw("https://", false);
            uri.Reset(_endpoint);
            uri.AppendRawNextLink(nextLink, false);
            request.Uri = uri;
            request.Headers.Add("Accept", "application/json");
            return message;
        }

        private static ResponseClassifier _responseClassifier200;
        private static ResponseClassifier ResponseClassifier200 => _responseClassifier200 ??= new StatusCodeClassifier(stackalloc ushort[] { 200 });
        private static ResponseClassifier _responseClassifier204;
        private static ResponseClassifier ResponseClassifier204 => _responseClassifier204 ??= new StatusCodeClassifier(stackalloc ushort[] { 204 });
        private static ResponseClassifier _responseClassifier202;
        private static ResponseClassifier ResponseClassifier202 => _responseClassifier202 ??= new StatusCodeClassifier(stackalloc ushort[] { 202 });
        private static ResponseClassifier _responseClassifier200304;
        private static ResponseClassifier ResponseClassifier200304 => _responseClassifier200304 ??= new StatusCodeClassifier(stackalloc ushort[] { 200, 304 });
        private static ResponseClassifier _responseClassifier201;
        private static ResponseClassifier ResponseClassifier201 => _responseClassifier201 ??= new StatusCodeClassifier(stackalloc ushort[] { 201 });
    }
}
