steps:
  - pwsh: |
      Invoke-WebRequest -MaximumRetryCount 10 -Uri "https://github.com/mono/api-doc-tools/releases/download/mdoc-5.7.4.9/mdoc-5.7.4.9.zip" `
      -OutFile "mdoc.zip" | Wait-Process; Expand-Archive -Path "mdoc.zip" -DestinationPath "./mdoc/"
    workingDirectory: $(Build.BinariesDirectory)
    displayName: Download and Extract mdoc Zip
  - pwsh: |
      Invoke-WebRequest -MaximumRetryCount 10 -Uri "https://github.com/dotnet/docfx/releases/download/v2.43.2/docfx.zip" `
      -OutFile "docfx.zip" | Wait-Process; Expand-Archive -Path "docfx.zip" -DestinationPath "./docfx/"
    workingDirectory: $(Build.BinariesDirectory)
    displayName: Download and Extract DocFX
  - pwsh: |
      dotnet restore "$(Build.SourcesDirectory)/eng/docgeneration/assets/docgen.csproj" /p:BuildBinariesDirectory=$(Build.BinariesDirectory)
    displayName: Restore Nuget Packages Needed
  - task: DotNetCoreInstaller@2
    displayName: "Use .NET Core sdk $(DotNetCoreSDKVersion)"
    inputs:
      version: $(DotNetCoreSDKVersion)
  - pwsh: GCI . -Recurse
    displayName: Dump Source Directory
    workingDirectory: $(Pipeline.Workspace)
  - ${{ if ne(variables['Build.DefinitionName'], 'net - client - ci')}}:
    - ${{ each artifact in parameters.Artifacts }}:
      - pwsh: |
          echo "##vso[task.setvariable variable=packageLocation]${{parameters.ServiceDirectory}}/${{artifact.name}}"
          echo "##vso[task.setvariable variable=artifactSafeName]${{artifact.safeName}}"
          if ('${{parameters.ServiceDirectory}}' -eq '*') {
            echo "##vso[task.setvariable variable=packageLocation]core/${{artifact.name}}"
          }
          if ('${{parameters.ServiceDirectory}}' -eq 'cognitiveservices') {
            echo "##vso[task.setvariable variable=packageLocation]cognitiveservices/${{artifact.directoryName}}"
            echo "##vso[task.setvariable variable=artifactSafeName]${{artifact.directoryName}}"
          }
          if ('${{parameters.LibType}}' -eq 'Management') {
            echo "##vso[task.setvariable variable=packageLocation]${{artifact.serviceDir}}/${{artifact.name}}"
            $safeName = "${{artifact.name}}"
            $safeName = $safeName.Substring($safeName.LastIndexOf('.Management') + 1)
            echo "##vso[task.setvariable variable=artifactSafeName]$($safeName)"
          }
          echo "##vso[task.setvariable variable=sourcedir]$(Build.SourcesDirectory)
        displayName: Set Variables for current Loop
      - pwsh: |
          mkdir $(artifactSafeName)/dll-docs/my-api
          mkdir $(artifactSafeName)/dll-docs/dependencies/my-api
          mkdir $(artifactSafeName)/dll-xml-output
          mkdir $(artifactSafeName)/dll-yaml-output
          mkdir $(artifactSafeName)/docfx-output
        displayName: Create Directories for Doc Generation
        workingDirectory: $(Build.BinariesDirectory)
      - pwsh: dotnet build eng/service.proj /p:ServiceDirectory=$(packageLocation) /p:IncludeTests=false /p:IncludeSamples=false /p:OutputPath=$(Build.BinariesDirectory)/$(artifactSafeName)/dll-docs/my-api /p:TargetFramework=netstandard2.0
        displayName: Build Client Packages
        condition: and(succeeded(), eq(False, '${{ parameters.LibType }}'))
      - pwsh: dotnet build eng/service.proj /p:ServiceDirectory=$(packageLocation) /p:IncludeTests=false /p:IncludeSamples=false /p:OutputPath=$(Build.BinariesDirectory)/$(artifactSafeName)/dll-docs/dependencies/my-api /p:TargetFramework=netstandard2.0 /p:CopyLocalLockFileAssemblies=true
        displayName: Build Client Packages, Include Dependencies
        condition: and(succeeded(), eq(False, '${{ parameters.LibType }}'))
      - script: dotnet msbuild eng/mgmt.proj /p:scope=$(packageLocation) /p:OutputPath=$(Build.BinariesDirectory)/$(artifactSafeName)/dll-docs/my-api -maxcpucount:1 -nodeReuse:false
        displayName: Build Mgmt Packages
        condition: and(succeeded(), eq(True, '${{ parameters.LibType }}'))
      - script: dotnet msbuild eng/mgmt.proj /p:scope=$(packageLocation) /p:OutputPath=$(Build.BinariesDirectory)/$(artifactSafeName)/dll-docs/dependencies/my-api /p:CopyLocalLockFileAssemblies=true -maxcpucount:1 -nodeReuse:false
        displayName: Build Mgmt Packages, Include Dependencies
        condition: and(succeeded(), eq(True, '${{ parameters.LibType }}'))
      - task: DeleteFiles@1
        displayName: "Delete files from $(Build.BinariesDirectory)/$(artifactSafeName)/dll-docs/my-api"
        inputs:
          SourceFolder: "$(Build.BinariesDirectory)/$(artifactSafeName)/dll-docs/my-api"
          Contents: |
            *.json
            *.pdb
            *.config
      - task: CmdLine@2
        displayName: Initialize Frameworks File
        inputs:
          script: mdoc.exe fx-bootstrap ../$(artifactSafeName)/dll-docs
          workingDirectory: $(Build.BinariesDirectory)/mdoc
          failOnStderr: true
      - pwsh: ./popimport.exe -f ../$(artifactSafeName)/dll-docs/
        workingDirectory: $(Build.BinariesDirectory)/PopImport
        displayName: Include XML Files
      - task: CmdLine@2
        displayName: Produce ECMAXML
        inputs:
          script: |
            mdoc.exe update -fx ../$(artifactSafeName)/dll-docs -o ../$(artifactSafeName)/dll-xml-output --debug -lang docid -lang vb.net -lang fsharp --delete
          workingDirectory: $(Build.BinariesDirectory)/mdoc
          failOnStderr: true
      - task: CmdLine@2
        displayName: Generate YAML
        inputs:
          script: |
            "$(Build.BinariesDirectory)/ECMA2Yml/ECMA2Yaml.exe" -s "./$(artifactSafeName)/dll-xml-output" -o "./$(artifactSafeName)/dll-yaml-output"
          workingDirectory: $(Build.BinariesDirectory)
          failOnStderr: true
      - task: CmdLine@2
        displayName: Provision DocFX Directory
        inputs:
          script: $(Build.BinariesDirectory)/docfx/docfx.exe init -q
          workingDirectory: $(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output
          failOnStderr: true
      - task: UsePythonVersion@0
        displayName: 'Use Python 3.6'
        inputs:
          versionSpec: '3.6'
      - template: eng/pipelines/templates/scripts/replace-relative-links.yml@azure-sdk-tools
        parameters:
          TargetFolder: '$(sourcedir)'
          RootFolder: '$(sourcedir)'
          BuildSHA: $(Build.SourceVersion)
          RepoId: 'Azure/azure-sdk-for-net'
      - task: PublishPipelineArtifact@0
        condition: succeeded()
        inputs:
          artifactName: ReadMe.${{artifact.name}}
          targetPath: $(Build.SourcesDirectory)/sdk/$(packageLocation)/README.md
      - pwsh: |
          # Copy Package ReadMe
          $PkgReadMePath = "$(Build.SourcesDirectory)/sdk/$(packageLocation)/README.md"
          if ([System.IO.File]::Exists($PkgReadMePath))
          {
            Copy-Item $PkgReadMePath -Destination "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/api/index.md" -Force
            Copy-Item $PkgReadMePath -Destination "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/index.md" -Force
          }
          else
          {
            New-Item "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/api/index.md" -Force
            Add-Content -Path "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/api/index.md" -Value "This Package Contains no Readme."
            Copy-Item $(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/api/index.md -Destination "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/index.md" -Force
            Write-Host "Package ReadMe was not found"
          }

          # Copy over generated yml and other assets
          Copy-Item "$(Build.BinariesDirectory)/$(artifactSafeName)/dll-yaml-output/*" -Destination "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/api/" -Recurse
          Copy-Item "$(Build.SourcesDirectory)/eng/docgeneration/assets/perpackagedocs/docfx.json" -Destination "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project" -Recurse -Force
          New-Item -Path "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project" -Name "templates" -ItemType "directory"
          Copy-Item "$(Build.SourcesDirectory)/eng/docgeneration/templates/**" -Destination "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/templates" -Recurse -Force

          # Create Toc for Site Navigation
          New-Item "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/toc.yml" -Force
          Add-Content -Path "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/toc.yml" -Value "- name: ${{artifact.name}}`r`n  href: api/`r`n  homepage: api/index.md"
        displayName: Copy over Yaml and Md files
      - task: CmdLine@2
        displayName: Build Doc Content
        inputs:
          script: $(Build.BinariesDirectory)/docfx/docfx.exe build
          workingDirectory: $(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/
          failOnStderr: true
      - pwsh: |
          Copy-Item "$(Build.SourcesDirectory)/eng/docgeneration/assets/logo.svg" -Destination `
          "$(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/_site" -Recurse -Force
        displayName: "Copy over site logo"
      - task: PublishPipelineArtifact@0
        condition: succeeded()
        inputs:
          artifactName: Docs.${{artifact.name}}
          targetPath: $(Build.BinariesDirectory)/$(artifactSafeName)/docfx-output/docfx_project/_site