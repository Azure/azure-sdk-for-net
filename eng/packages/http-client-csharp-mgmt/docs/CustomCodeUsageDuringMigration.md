# Custom Code Usage During Management Plane Generator (MPG) Migration

## Overview

This document provides guidance on using custom code during the migration to the new Management Plane Generator (MPG). It is based on analysis of 17 migrated services that utilize custom code to address gaps between the generated code and service requirements.

**Analysis Date:** December 2024

**Services Analyzed:** nginx, quota, storagesync, hardwaresecuritymodules, healthdataaiservices, paloaltonetworks.ngfw, storagemover, agricultureplatform, databasewatcher, deviceregistry, workloadorchestration, carbon, dellstorage, impactreporting, neonpostgres, portalservices, virtualenclaves

## Table of Contents

1. [What is Custom Code?](#what-is-custom-code)
2. [When to Use Custom Code](#when-to-use-custom-code)
3. [Common Customization Patterns](#common-customization-patterns)
4. [Best Practices](#best-practices)
5. [Examples by Pattern](#examples-by-pattern)

## What is Custom Code?

Custom code is hand-written C# code that extends or overrides the code generated by the MPG emitter. It is placed in a `Custom` or `Customization` folder within the library's `src` directory and is used to address scenarios where:

- The generated code doesn't match the service behavior
- API improvements are needed for better usability
- Backwards compatibility must be preserved
- Generator limitations need workarounds

## When to Use Custom Code

Custom code should be used **sparingly** and only when necessary. Common scenarios include:

1. **Service specification gaps** - When the TypeSpec/OpenAPI spec is incomplete or incorrect
2. **Generator limitations** - When the generator doesn't support a required feature yet
3. **Breaking change mitigation** - When preserving backwards compatibility during migration
4. **Usability improvements** - When the generated API needs enhancement for better developer experience

## Common Customization Patterns

### 1. Model Factory Customizations

**Purpose:** Provide factory methods for creating model instances, especially for testing/mocking scenarios.

**Use Cases:**
- Adding overloads with different parameter orders for backwards compatibility
- Providing deprecated factory methods marked with `[EditorBrowsable(EditorBrowsableState.Never)]`
- Creating factory methods with additional/different parameters than generated

**Example Files:**
- `ArmNginxModelFactory.cs` (68 lines)
- `ArmQuotaModelFactory.cs` (108 lines)
- `ArmStorageSyncModelFactory.cs` (175 lines)
- `ArmPaloAltoNetworksNgfwModelFactory.cs` (160 lines)

**Key Indicators:**
- File name pattern: `Arm{Service}ModelFactory.cs`
- Contains `partial class` extending generated factory
- Methods often marked with `[EditorBrowsable(EditorBrowsableState.Never)]`
- Methods typically return model types for mocking

### 2. Missing Property Additions

**Purpose:** Add properties that are returned by the service but missing from the specification.

**Use Cases:**
- Service returns fields not documented in the spec
- Properties needed for proper service interaction
- Hash values, computed fields, or service-generated metadata

**Example:**
```csharp
// nginx/Custom/Models/NginxConfigurationFile.cs
[Microsoft.TypeSpec.Generator.Customizations.CodeGenSerialization(nameof(ContentHash), "contentHash")]
public partial class NginxConfigurationFile
{
    /// <summary> Gets or sets the Content. </summary>
    public string ContentHash { get; set; }  // Service returns "contentHash" field missing from spec
}
```

**Key Indicators:**
- Uses `[CodeGenSerialization]` attribute
- Adds properties to existing generated models
- Comments indicate "missing from spec" or "not in spec"

### 3. Constructor Parameter Reordering

**Purpose:** Maintain backwards compatibility when constructor parameter order changes.

**Use Cases:**
- Preserving API compatibility during migration
- Matching old AutoRest-generated constructor signatures

**Example:**
```csharp
// hardwaresecuritymodules/Custom/DedicatedHsmData.cs
public partial class DedicatedHsmData
{
    public DedicatedHsmData(AzureLocation location, DedicatedHsmSku sku, DedicatedHsmProperties properties) 
        : this(location, properties, sku)  // Reorder to match generated constructor
    {
    }
}
```

**Key Indicators:**
- Additional constructors in Data/Model classes
- Constructor delegates to another constructor with reordered parameters
- Preserves existing public API

### 4. Custom Collection Operations

**Purpose:** Provide custom implementations of collection operations when generated code is insufficient.

**Use Cases:**
- Converting between request/response models
- Handling complex creation scenarios
- Working around spec limitations

**Example:**
```csharp
// nginx/Custom/NginxConfigurationCollection.cs
public virtual async Task<ArmOperation<NginxConfigurationResource>> CreateOrUpdateAsync(
    WaitUntil waitUntil, 
    string configurationName, 
    NginxConfigurationData data, 
    CancellationToken cancellationToken = default)
    => await CreateOrUpdateAsync(waitUntil, configurationName,
        new NginxConfigurationCreateOrUpdateContent(
            data.Id, data.Name, data.ResourceType,
            new NginxConfigurationCreateOrUpdateProperties(
                data.Properties.ProvisioningState, 
                data.Properties.Files,
                data.Properties.ProtectedFiles?.Select(file => 
                    new NginxConfigurationContentProtectedFile(null, file.VirtualPath, file.ContentHash, null)
                ).ToList(),
                data.Properties.Package, 
                data.Properties.RootFile, 
                null
            ),
            data.SystemData, 
            null
        ),
        cancellationToken).ConfigureAwait(false);
```

**Key Indicators:**
- Overrides in Collection classes
- Transforms data models between client and service representations
- Adds convenience overloads

### 5. Extension Method Customizations

**Purpose:** Add, modify, or suppress extension methods on ARM resources.

**Use Cases:**
- Adding tenant or management group scoped operations
- Suppressing generated operations that shouldn't be exposed
- Providing backwards-compatible method signatures

**Example:**
```csharp
// quota/Custom/Extensions/QuotaExtensions.cs
public static partial class QuotaExtensions
{
    [EditorBrowsable(EditorBrowsableState.Never)]
    public static async Task<Response<SubscriptionQuotaAllocationsListResource>> GetSubscriptionQuotaAllocationsListAsync(
        this ManagementGroupResource managementGroupResource, 
        string subscriptionId, 
        string groupQuotaName, 
        string resourceProviderName, 
        AzureLocation location, 
        CancellationToken cancellationToken = default)
    {
        return await GetMockableQuotaManagementGroupResource(managementGroupResource)
            .GetSubscriptionQuotaAllocationsListAsync(subscriptionId, groupQuotaName, resourceProviderName, location, cancellationToken)
            .ConfigureAwait(false);
    }
}
```

**Key Indicators:**
- `partial class` for `{Service}Extensions`
- Extension methods on `ArmResource`, `SubscriptionResource`, `ManagementGroupResource`, etc.
- Often marked `[EditorBrowsable(EditorBrowsableState.Never)]` for deprecated methods

### 6. Mockable Resource Extensions

**Purpose:** Provide mockable extension methods for testing scenarios.

**Use Cases:**
- Supporting dependency injection and mocking
- Adding resource-scoped operations to mockable resources

**Example Files:**
- `quota/Custom/Extensions/MockableQuotaManagementGroupResource.cs`
- `quota/Custom/Extensions/MockableQuotaTenantResource.cs`
- `deviceregistry/Custom/Extensions/MockableDeviceRegistrySubscriptionResource.cs`

**Key Indicators:**
- File name pattern: `Mockable{Service}{Scope}Resource.cs`
- Extends ARM resource types for specific scopes
- Contains resource-specific operations

### 7. Custom Pageable Operations

**Purpose:** Implement pagination for operations that should be pageable but aren't in the spec.

**Use Cases:**
- Adding pagination support where spec lacks proper decorators
- Custom pagination logic

**Example:**
```csharp
// paloaltonetworks.ngfw/Custom/GlobalRulestackResource.cs
public virtual AsyncPageable<string> GetAppIdsAsync(
    string appIdVersion = null, 
    string appPrefix = null, 
    string skip = null, 
    int? top = null, 
    CancellationToken cancellationToken = default)
{
    HttpMessage FirstPageRequest(int? pageSizeHint) => 
        _globalRulestackRestOperations.CreateListAppIdsRequest(Id.Name, appIdVersion, appPrefix, skip, top);
    return GeneratorPageableHelpers.CreateAsyncPageable(
        FirstPageRequest, null, e => e.GetString(), 
        _globalRulestackClientDiagnostics, Pipeline, 
        "GlobalRulestackResource.GetAppIds", "value", null, cancellationToken);
}
```

**Key Indicators:**
- Returns `AsyncPageable<T>` or `Pageable<T>`
- Uses `GeneratorPageableHelpers`
- Custom REST operation clients
- Comments referencing TypeSpec pageable decorator issues

### 8. Custom REST Operations

**Purpose:** Provide REST client operations when generated ones are insufficient.

**Use Cases:**
- Working around spec issues
- Temporary fix until TypeSpec/generator support improves

**Example:**
```csharp
// storagesync/Custom/RestOperations/StorageSyncServicesRestOperations.cs
internal partial class StorageSyncServices
{
    // This function will be removed once we have support for new pageable decorator
    // https://github.com/Azure/typespec-azure/issues/3650
    internal HttpMessage CreateGetByStorageSyncServiceRequest(
        Guid subscriptionId, 
        string resourceGroupName, 
        string storageSyncServiceName, 
        RequestContext context)
    {
        // Custom REST operation implementation
    }
}
```

**Key Indicators:**
- Located in `RestOperations` folder
- `internal partial class` extending generated REST client
- Comments with GitHub issue references
- Temporary workarounds for generator limitations

### 9. Serialization Customizations

**Purpose:** Customize JSON serialization/deserialization behavior.

**Use Cases:**
- Handling type mismatches between spec and service
- Custom serialization for complex types
- Working with shared types from other namespaces

**Example:**
```csharp
// healthdataaiservices/Custom/DeidServicePatch.cs
[CodeGenSerialization(nameof(Identity), 
    SerializationValueHook = nameof(SerializeIdentity), 
    DeserializationValueHook = nameof(DeserializeIdentity))]
public partial class DeidServicePatch
{
    [CodeGenMember("Identity")]
    public Azure.ResourceManager.Models.ManagedServiceIdentity Identity { get; set; }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal void SerializeIdentity(Utf8JsonWriter writer, ModelReaderWriterOptions options)
    {
        ((IJsonModel<ManagedServiceIdentity>)Identity).Write(writer, options);
    }

    [MethodImpl(MethodImplOptions.AggressiveInlining)]
    internal static void DeserializeIdentity(JsonProperty property, ref ManagedServiceIdentity identity)
    {
        // Custom deserialization logic
    }
}
```

**Key Indicators:**
- Uses `[CodeGenSerialization]` attribute
- Custom serialization/deserialization hooks
- Handles types from different namespaces (e.g., `Azure.ResourceManager.Models`)

### 10. Abstract Base Class Modifications

**Purpose:** Modify constructors and accessibility of abstract base classes.

**Use Cases:**
- Preserving backwards compatibility
- Ensuring proper inheritance patterns
- Fixing generated constructor accessibility

**Example:**
```csharp
// storagemover/Customization/Models/StorageMoverCredentials.cs
public abstract partial class StorageMoverCredentials
{
    protected StorageMoverCredentials()  // MPG made this private; restore to protected for compatibility
    {
    }
}
```

**Key Indicators:**
- Abstract base classes with modified constructors
- Comments about preserving backwards compatibility
- Constructor accessibility changes (private → protected)

### 11. Unknown Type Renaming

**Purpose:** Rename generated "Unknown" discriminated union types.

**Use Cases:**
- Improving consistency in naming
- Matching existing patterns

**Example:**
```csharp
// storagemover/Customization/Models/UnknownCredentials.cs
[Microsoft.TypeSpec.Generator.Customizations.CodeGenType("UnknownStorageMoverCredentials")]
internal partial class UnknownCredentials { }
```

**Key Indicators:**
- Uses `[CodeGenType]` attribute to rename
- Renames `Unknown{Type}` classes
- Typically internal classes

### 12. Operation Suppression

**Purpose:** Suppress generated operations that shouldn't be exposed.

**Use Cases:**
- Removing operations not ready for public use
- Hiding deprecated or incorrect operations
- Working around spec issues

**Example:**
```csharp
// deviceregistry/Custom/Extensions/DeviceRegistryExtensions.cs
[CodeGenSuppress("GetOperationStatuAsync", typeof(SubscriptionResource), typeof(string), typeof(string), typeof(CancellationToken))]
[CodeGenSuppress("GetOperationStatu", typeof(SubscriptionResource), typeof(string), typeof(string), typeof(CancellationToken))]
public static partial class DeviceRegistryExtensions
{
}
```

**Key Indicators:**
- Uses `[CodeGenSuppress]` attribute
- Empty partial class bodies
- Comments referencing generator issues

### 13. Internal Model Visibility

**Purpose:** Change visibility of models that should not be public.

**Use Cases:**
- Hiding internal implementation details
- Response-only models that shouldn't be instantiated by users

**Example:**
```csharp
// deviceregistry/Custom/Data/OperationStatusResult.cs
internal partial class OperationStatusResult
{
}
```

**Key Indicators:**
- Changes `public` to `internal`
- Empty class body (just changes accessibility)
- Typically for response-only or internal models

### 14. Patch Properties Customization

**Purpose:** Add missing properties to patch/update models.

**Use Cases:**
- Service supports updating properties not in spec
- Spec incomplete for update operations

**Example Files:**
- `nginx/Custom/NginxDeploymentUpdateProperties.cs`
- `storagemover/Customization/Models/EndpointBaseUpdateProperties.cs`
- `databasewatcher/Custom/DatabaseWatcherUpdateProperties.cs`
- `workloadorchestration/Custom/EdgeSolutionTemplatePatchProperties.cs`

**Key Indicators:**
- File names ending with `UpdateProperties`, `Patch`, or `PatchProperties`
- Partial classes adding properties to update models

### 15. Enum Customizations

**Purpose:** Add, modify, or extend enum types.

**Use Cases:**
- Adding missing enum values
- Renaming for consistency

**Example:**
```csharp
// agricultureplatform/Custom/AuthCredentialsKind.cs
public enum AuthCredentialsKind
{
    // Custom enum definition or extension
}
```

**Key Indicators:**
- Enum type definitions
- Partial enum classes
- Often small files (10-15 lines)

### 16. Custom Collection Results

**Purpose:** Implement custom collection result types for pageable operations.

**Use Cases:**
- Custom pagination logic
- Async collection implementations

**Example Files:**
- `storagesync/Custom/CollectionResults/StorageSyncServicesGetByStorageSyncServiceCollectionResultOfT.cs`
- `paloaltonetworks.ngfw/Custom/LocalRulestacksGetFirewallsCollectionResultOfT.cs`

**Key Indicators:**
- File names ending with `CollectionResultOfT`
- Both sync and async variants
- Implements collection iteration patterns

## Best Practices

### 1. Minimize Custom Code

- Use custom code only when necessary
- Document why each customization is needed
- Include GitHub issue references when fixing generator limitations
- Plan to remove temporary workarounds when generator improves

### 2. Document Intent

```csharp
// Good: Explains why customization exists
public partial class NginxConfigurationFile
{
    /// <summary> Gets or sets the Content Hash. </summary>
    public string ContentHash { get; set; }  // Service returns "contentHash" field missing from spec
}

// Good: References tracking issue
// This function will be removed once we have support for new pageable decorator
// https://github.com/Azure/typespec-azure/issues/3650
internal HttpMessage CreateGetByStorageSyncServiceRequest(...)
```

### 3. Use Appropriate Attributes

- `[CodeGenSerialization]` - For custom serialization behavior
- `[CodeGenSuppress]` - To suppress generated members
- `[CodeGenType]` - To rename generated types
- `[CodeGenMember]` - To customize member generation
- `[EditorBrowsable(EditorBrowsableState.Never)]` - To hide deprecated members from IntelliSense

### 4. Follow Naming Conventions

- Model factories: `Arm{Service}ModelFactory.cs`
- Extensions: `{Service}Extensions.cs`
- Mockable resources: `Mockable{Service}{Scope}Resource.cs`
- Place files in appropriate subfolders:
  - `Models/` - For model customizations
  - `Extensions/` - For extension method customizations
  - `RestOperations/` - For REST client customizations
  - `CollectionResults/` - For custom collection implementations

### 5. Preserve Backwards Compatibility

When migrating from old generator:
- Add overload constructors with old parameter order
- Mark old methods with `[EditorBrowsable(EditorBrowsableState.Never)]`
- Preserve abstract class constructor accessibility
- Keep public API surface stable

### 6. Maintain Partial Class Pattern

```csharp
// Always use partial classes to extend generated code
public partial class MyCustomType
{
    // Custom members
}
```

### 7. Plan for Future Removal

- Add TODO comments for temporary workarounds
- Reference GitHub issues for generator improvements
- Mark temporary code clearly:

```csharp
// TODO: Remove once CodeGen supports [issue description]
// Tracking: https://github.com/Azure/autorest.csharp/issues/XXXX
```

## File Organization

### Recommended Structure

```
src/
├── Custom/                          # Main custom code folder
│   ├── Arm{Service}ModelFactory.cs  # Model factory customizations
│   ├── {Service}Extensions.cs       # Extension method customizations
│   ├── Extensions/                  # Extension-related files
│   │   ├── Mockable{Service}{Scope}Resource.cs
│   │   └── ...
│   ├── Models/                      # Model customizations
│   │   ├── {ModelName}.cs
│   │   └── ...
│   ├── RestOperations/              # REST client customizations
│   │   └── ...
│   ├── CollectionResults/           # Collection implementation customizations
│   │   └── ...
│   └── Data/                        # Data model customizations
│       └── ...
```

**Note:** Some services use `Customization` instead of `Custom`. Both are supported.

## Common Scenarios and Solutions

### Scenario 1: Service Returns Undocumented Property

**Problem:** Service API returns a field not in the TypeSpec specification.

**Solution:** Add property with `[CodeGenSerialization]` attribute.

```csharp
[Microsoft.TypeSpec.Generator.Customizations.CodeGenSerialization(nameof(ContentHash), "contentHash")]
public partial class NginxConfigurationFile
{
    public string ContentHash { get; set; }
}
```

### Scenario 2: Constructor Parameter Order Changed

**Problem:** Migration changes constructor parameter order, breaking compatibility.

**Solution:** Add overload constructor with old parameter order.

```csharp
public partial class DedicatedHsmData
{
    // New constructor for backwards compatibility
    public DedicatedHsmData(AzureLocation location, DedicatedHsmSku sku, DedicatedHsmProperties properties) 
        : this(location, properties, sku)  // Delegates to generated constructor
    {
    }
}
```

### Scenario 3: Need Pagination for Non-Pageable Operation

**Problem:** TypeSpec spec doesn't mark operation as pageable, but service supports pagination.

**Solution:** Implement custom pageable operation using REST client.

```csharp
public virtual AsyncPageable<T> GetItemsAsync(CancellationToken cancellationToken = default)
{
    HttpMessage FirstPageRequest(int? pageSizeHint) => 
        _restOperations.CreateListRequest(...);
    return GeneratorPageableHelpers.CreateAsyncPageable(
        FirstPageRequest, null, DeserializeItem, 
        _clientDiagnostics, Pipeline, "Resource.GetItems", "value", null, cancellationToken);
}
```

### Scenario 4: Hide Generated Operation

**Problem:** Generated operation shouldn't be exposed publicly.

**Solution:** Use `[CodeGenSuppress]` to suppress generation.

```csharp
[CodeGenSuppress("MethodName", typeof(Param1), typeof(Param2))]
public static partial class MyExtensions
{
}
```

### Scenario 5: Custom Serialization Needed

**Problem:** Type from different namespace needs custom serialization.

**Solution:** Use serialization hooks with `[CodeGenSerialization]`.

```csharp
[CodeGenSerialization(nameof(Identity), 
    SerializationValueHook = nameof(SerializeIdentity), 
    DeserializationValueHook = nameof(DeserializeIdentity))]
public partial class MyPatch
{
    [CodeGenMember("Identity")]
    public Azure.ResourceManager.Models.ManagedServiceIdentity Identity { get; set; }

    internal void SerializeIdentity(Utf8JsonWriter writer, ModelReaderWriterOptions options)
    {
        ((IJsonModel<ManagedServiceIdentity>)Identity).Write(writer, options);
    }

    internal static void DeserializeIdentity(JsonProperty property, ref ManagedServiceIdentity identity)
    {
        // Custom deserialization
    }
}
```

### Scenario 6: Abstract Constructor Accessibility

**Problem:** Generated abstract class has private constructor, preventing inheritance.

**Solution:** Override with protected constructor.

```csharp
public abstract partial class BaseCredentials
{
    protected BaseCredentials()  // Change from private to protected
    {
    }
}
```

### Scenario 7: Rename Generated Type

**Problem:** Generated type name doesn't match conventions.

**Solution:** Use `[CodeGenType]` attribute.

```csharp
[Microsoft.TypeSpec.Generator.Customizations.CodeGenType("UnknownStorageMoverCredentials")]
internal partial class UnknownCredentials { }
```

### Scenario 8: Add Extension Method for Different Scope

**Problem:** Need to add operation scoped to Management Group or Tenant.

**Solution:** Create mockable resource extension.

```csharp
// In Extensions/MockableQuotaManagementGroupResource.cs
public partial class MockableQuotaManagementGroupResource : ArmResource
{
    public virtual Response<T> GetResourceAtMgScope(CancellationToken cancellationToken = default)
    {
        // Implementation
    }
}
```

## Testing Custom Code

### Build and Generation

1. **Generate code:**
   ```bash
   dotnet build /t:GenerateCode
   ```

2. **Build the project:**
   ```bash
   dotnet build
   ```

3. **Run tests:**
   ```bash
   dotnet test
   ```

### Validation Steps

1. Ensure custom code compiles with generated code
2. Verify no build warnings introduced
3. Run existing tests to ensure backwards compatibility
4. Add tests for custom functionality
5. Validate API review compliance

## Migration Checklist

When migrating a service to new MPG:

- [ ] Identify existing customizations in old library
- [ ] Determine which customizations are still needed
- [ ] Check if generator now supports previously custom features
- [ ] Create `Custom` or `Customization` folder structure
- [ ] Implement required customizations using patterns from this guide
- [ ] Add documentation comments explaining each customization
- [ ] Test build and generation
- [ ] Verify backwards compatibility
- [ ] Run full test suite
- [ ] Document any temporary workarounds with issue references

## Summary

Custom code during MPG migration serves several critical purposes:

1. **Filling Specification Gaps** - Adding missing properties, operations, or behaviors
2. **Generator Limitations** - Working around current generator constraints
3. **Backwards Compatibility** - Preserving existing public API during migration
4. **Usability Improvements** - Enhancing generated API for better developer experience

The 16 patterns identified in this analysis cover the vast majority of customization scenarios. By following these patterns and best practices, you can successfully migrate services while maintaining quality and compatibility.

## Additional Resources

- [TypeSpec Documentation](https://typespec.io/)
- [Azure SDK Design Guidelines](https://azure.github.io/azure-sdk/general_introduction.html)
- [Generator Issue Tracker](https://github.com/Azure/autorest.csharp/issues)
- [Library Inventory](../../../../../../doc/GeneratorMigration/Library_Inventory.md)

## Appendix: Service Customization Summary

| Service | Custom Files | Primary Patterns |
|---------|--------------|------------------|
| nginx | 8 | Model Factory, Collection Operations, Missing Properties |
| quota | 11 | Model Factory, Extensions, Mockable Resources |
| storagesync | 10 | Model Factory, Custom REST Operations, Collection Results |
| hardwaresecuritymodules | 2 | Constructor Reordering, Model Factory |
| healthdataaiservices | 1 | Serialization Customization |
| paloaltonetworks.ngfw | 8 | Pageable Operations, Model Factory, REST Operations |
| storagemover | 7 | Abstract Class Modification, Unknown Type Renaming, Model Factory |
| agricultureplatform | 2 | Patch Properties, Enum Customization |
| databasewatcher | 1 | Patch Properties |
| deviceregistry | 3 | Operation Suppression, Internal Visibility |
| workloadorchestration | 6 | Model Factory, Patch Properties |
| carbon | 8 | Abstract Class Modifications, Unknown Type Renaming |
| dellstorage | 1 | Patch Properties |
| impactreporting | 3 | Patch Properties |
| neonpostgres | 2 | Deprecated Update Methods, Patch Properties |
| portalservices | 1 | Serialization Context |
| virtualenclaves | 11 | Enum/Type Renaming |

**Total Services Analyzed:** 17  
**Total Custom Files:** 85

---

*This document is based on analysis of custom code in migrated Management Plane libraries as of December 2024. Patterns and practices may evolve as the generator improves.*
