// Copyright (c) Microsoft and contributors.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
// http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// 
// See the License for the specific language governing permissions and
// limitations under the License.
// 
// Code generated by Microsoft (R) AutoRest Code Generator.
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

namespace Microsoft.Azure.Batch.Protocol
{
    using System.Threading.Tasks;
   using Microsoft.Rest.Azure;
   using Models;

    /// <summary>
    /// Extension methods for FileOperations.
    /// </summary>
    public static partial class FileOperationsExtensions
    {
            /// <summary>
            /// Deletes the specified task file from the compute node where the task ran.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='jobId'>
            /// The id of the job that contains the task.
            /// </param>
            /// <param name='taskId'>
            /// The id of the task whose file you want to delete.
            /// </param>
            /// <param name='fileName'>
            /// The path to the task file that you want to delete.
            /// </param>
            /// <param name='recursive'>
            /// Whether to delete children of a directory. If the fileName parameter
            /// represents a directory instead of a file, you can set Recursive to true
            /// to delete the directory and all of the files and subdirectories in it. If
            /// Recursive is false then the directory must be empty or deletion will fail.
            /// </param>
            /// <param name='fileDeleteFromTaskOptions'>
            /// Additional parameters for the operation
            /// </param>
            public static FileDeleteFromTaskHeaders DeleteFromTask(this IFileOperations operations, string jobId, string taskId, string fileName, bool? recursive = default(bool?), FileDeleteFromTaskOptions fileDeleteFromTaskOptions = default(FileDeleteFromTaskOptions))
            {
                return System.Threading.Tasks.Task.Factory.StartNew(s => ((IFileOperations)s).DeleteFromTaskAsync(jobId, taskId, fileName, recursive, fileDeleteFromTaskOptions), operations, System.Threading.CancellationToken.None, System.Threading.Tasks.TaskCreationOptions.None, System.Threading.Tasks.TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Deletes the specified task file from the compute node where the task ran.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='jobId'>
            /// The id of the job that contains the task.
            /// </param>
            /// <param name='taskId'>
            /// The id of the task whose file you want to delete.
            /// </param>
            /// <param name='fileName'>
            /// The path to the task file that you want to delete.
            /// </param>
            /// <param name='recursive'>
            /// Whether to delete children of a directory. If the fileName parameter
            /// represents a directory instead of a file, you can set Recursive to true
            /// to delete the directory and all of the files and subdirectories in it. If
            /// Recursive is false then the directory must be empty or deletion will fail.
            /// </param>
            /// <param name='fileDeleteFromTaskOptions'>
            /// Additional parameters for the operation
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async System.Threading.Tasks.Task<FileDeleteFromTaskHeaders> DeleteFromTaskAsync(this IFileOperations operations, string jobId, string taskId, string fileName, bool? recursive = default(bool?), FileDeleteFromTaskOptions fileDeleteFromTaskOptions = default(FileDeleteFromTaskOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.DeleteFromTaskWithHttpMessagesAsync(jobId, taskId, fileName, recursive, fileDeleteFromTaskOptions, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Headers;
                }
            }

            /// <summary>
            /// Returns the content of the specified task file.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='jobId'>
            /// The id of the job that contains the task.
            /// </param>
            /// <param name='taskId'>
            /// The id of the task whose file you want to retrieve.
            /// </param>
            /// <param name='fileName'>
            /// The path to the task file that you want to get the content of.
            /// </param>
            /// <param name='fileGetFromTaskOptions'>
            /// Additional parameters for the operation
            /// </param>
            public static System.IO.Stream GetFromTask(this IFileOperations operations, string jobId, string taskId, string fileName, FileGetFromTaskOptions fileGetFromTaskOptions = default(FileGetFromTaskOptions))
            {
                return System.Threading.Tasks.Task.Factory.StartNew(s => ((IFileOperations)s).GetFromTaskAsync(jobId, taskId, fileName, fileGetFromTaskOptions), operations, System.Threading.CancellationToken.None, System.Threading.Tasks.TaskCreationOptions.None, System.Threading.Tasks.TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Returns the content of the specified task file.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='jobId'>
            /// The id of the job that contains the task.
            /// </param>
            /// <param name='taskId'>
            /// The id of the task whose file you want to retrieve.
            /// </param>
            /// <param name='fileName'>
            /// The path to the task file that you want to get the content of.
            /// </param>
            /// <param name='fileGetFromTaskOptions'>
            /// Additional parameters for the operation
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async System.Threading.Tasks.Task<System.IO.Stream> GetFromTaskAsync(this IFileOperations operations, string jobId, string taskId, string fileName, FileGetFromTaskOptions fileGetFromTaskOptions = default(FileGetFromTaskOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                var _result = await operations.GetFromTaskWithHttpMessagesAsync(jobId, taskId, fileName, fileGetFromTaskOptions, null, cancellationToken).ConfigureAwait(false);
                _result.Request.Dispose();
                return _result.Body;
            }

            /// <summary>
            /// Gets the properties of the specified task file.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='jobId'>
            /// The id of the job that contains the task.
            /// </param>
            /// <param name='taskId'>
            /// The id of the task whose file you want to get the properties of.
            /// </param>
            /// <param name='fileName'>
            /// The path to the task file that you want to get the properties of.
            /// </param>
            /// <param name='fileGetNodeFilePropertiesFromTaskOptions'>
            /// Additional parameters for the operation
            /// </param>
            public static FileGetNodeFilePropertiesFromTaskHeaders GetNodeFilePropertiesFromTask(this IFileOperations operations, string jobId, string taskId, string fileName, FileGetNodeFilePropertiesFromTaskOptions fileGetNodeFilePropertiesFromTaskOptions = default(FileGetNodeFilePropertiesFromTaskOptions))
            {
                return System.Threading.Tasks.Task.Factory.StartNew(s => ((IFileOperations)s).GetNodeFilePropertiesFromTaskAsync(jobId, taskId, fileName, fileGetNodeFilePropertiesFromTaskOptions), operations, System.Threading.CancellationToken.None, System.Threading.Tasks.TaskCreationOptions.None, System.Threading.Tasks.TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Gets the properties of the specified task file.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='jobId'>
            /// The id of the job that contains the task.
            /// </param>
            /// <param name='taskId'>
            /// The id of the task whose file you want to get the properties of.
            /// </param>
            /// <param name='fileName'>
            /// The path to the task file that you want to get the properties of.
            /// </param>
            /// <param name='fileGetNodeFilePropertiesFromTaskOptions'>
            /// Additional parameters for the operation
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async System.Threading.Tasks.Task<FileGetNodeFilePropertiesFromTaskHeaders> GetNodeFilePropertiesFromTaskAsync(this IFileOperations operations, string jobId, string taskId, string fileName, FileGetNodeFilePropertiesFromTaskOptions fileGetNodeFilePropertiesFromTaskOptions = default(FileGetNodeFilePropertiesFromTaskOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.GetNodeFilePropertiesFromTaskWithHttpMessagesAsync(jobId, taskId, fileName, fileGetNodeFilePropertiesFromTaskOptions, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Headers;
                }
            }

            /// <summary>
            /// Deletes the specified task file from the compute node.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='poolId'>
            /// The id of the pool that contains the compute node.
            /// </param>
            /// <param name='nodeId'>
            /// The id of the compute node from which you want to delete the file.
            /// </param>
            /// <param name='fileName'>
            /// The path to the file that you want to delete.
            /// </param>
            /// <param name='recursive'>
            /// Whether to delete children of a directory. If the fileName parameter
            /// represents a directory instead of a file, you can set Recursive to true
            /// to delete the directory and all of the files and subdirectories in it. If
            /// Recursive is false then the directory must be empty or deletion will fail.
            /// </param>
            /// <param name='fileDeleteFromComputeNodeOptions'>
            /// Additional parameters for the operation
            /// </param>
            public static FileDeleteFromComputeNodeHeaders DeleteFromComputeNode(this IFileOperations operations, string poolId, string nodeId, string fileName, bool? recursive = default(bool?), FileDeleteFromComputeNodeOptions fileDeleteFromComputeNodeOptions = default(FileDeleteFromComputeNodeOptions))
            {
                return System.Threading.Tasks.Task.Factory.StartNew(s => ((IFileOperations)s).DeleteFromComputeNodeAsync(poolId, nodeId, fileName, recursive, fileDeleteFromComputeNodeOptions), operations, System.Threading.CancellationToken.None, System.Threading.Tasks.TaskCreationOptions.None, System.Threading.Tasks.TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Deletes the specified task file from the compute node.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='poolId'>
            /// The id of the pool that contains the compute node.
            /// </param>
            /// <param name='nodeId'>
            /// The id of the compute node from which you want to delete the file.
            /// </param>
            /// <param name='fileName'>
            /// The path to the file that you want to delete.
            /// </param>
            /// <param name='recursive'>
            /// Whether to delete children of a directory. If the fileName parameter
            /// represents a directory instead of a file, you can set Recursive to true
            /// to delete the directory and all of the files and subdirectories in it. If
            /// Recursive is false then the directory must be empty or deletion will fail.
            /// </param>
            /// <param name='fileDeleteFromComputeNodeOptions'>
            /// Additional parameters for the operation
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async System.Threading.Tasks.Task<FileDeleteFromComputeNodeHeaders> DeleteFromComputeNodeAsync(this IFileOperations operations, string poolId, string nodeId, string fileName, bool? recursive = default(bool?), FileDeleteFromComputeNodeOptions fileDeleteFromComputeNodeOptions = default(FileDeleteFromComputeNodeOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.DeleteFromComputeNodeWithHttpMessagesAsync(poolId, nodeId, fileName, recursive, fileDeleteFromComputeNodeOptions, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Headers;
                }
            }

            /// <summary>
            /// Returns the content of the specified task file.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='poolId'>
            /// The id of the pool that contains the compute node.
            /// </param>
            /// <param name='nodeId'>
            /// The id of the compute node that contains the file.
            /// </param>
            /// <param name='fileName'>
            /// The path to the task file that you want to get the content of.
            /// </param>
            /// <param name='fileGetFromComputeNodeOptions'>
            /// Additional parameters for the operation
            /// </param>
            public static System.IO.Stream GetFromComputeNode(this IFileOperations operations, string poolId, string nodeId, string fileName, FileGetFromComputeNodeOptions fileGetFromComputeNodeOptions = default(FileGetFromComputeNodeOptions))
            {
                return System.Threading.Tasks.Task.Factory.StartNew(s => ((IFileOperations)s).GetFromComputeNodeAsync(poolId, nodeId, fileName, fileGetFromComputeNodeOptions), operations, System.Threading.CancellationToken.None, System.Threading.Tasks.TaskCreationOptions.None, System.Threading.Tasks.TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Returns the content of the specified task file.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='poolId'>
            /// The id of the pool that contains the compute node.
            /// </param>
            /// <param name='nodeId'>
            /// The id of the compute node that contains the file.
            /// </param>
            /// <param name='fileName'>
            /// The path to the task file that you want to get the content of.
            /// </param>
            /// <param name='fileGetFromComputeNodeOptions'>
            /// Additional parameters for the operation
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async System.Threading.Tasks.Task<System.IO.Stream> GetFromComputeNodeAsync(this IFileOperations operations, string poolId, string nodeId, string fileName, FileGetFromComputeNodeOptions fileGetFromComputeNodeOptions = default(FileGetFromComputeNodeOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                var _result = await operations.GetFromComputeNodeWithHttpMessagesAsync(poolId, nodeId, fileName, fileGetFromComputeNodeOptions, null, cancellationToken).ConfigureAwait(false);
                _result.Request.Dispose();
                return _result.Body;
            }

            /// <summary>
            /// Gets the properties of the specified compute node file.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='poolId'>
            /// The id of the pool that contains the compute node.
            /// </param>
            /// <param name='nodeId'>
            /// The id of the compute node that contains the file.
            /// </param>
            /// <param name='fileName'>
            /// The path to the compute node file that you want to get the properties of.
            /// </param>
            /// <param name='fileGetNodeFilePropertiesFromComputeNodeOptions'>
            /// Additional parameters for the operation
            /// </param>
            public static FileGetNodeFilePropertiesFromComputeNodeHeaders GetNodeFilePropertiesFromComputeNode(this IFileOperations operations, string poolId, string nodeId, string fileName, FileGetNodeFilePropertiesFromComputeNodeOptions fileGetNodeFilePropertiesFromComputeNodeOptions = default(FileGetNodeFilePropertiesFromComputeNodeOptions))
            {
                return System.Threading.Tasks.Task.Factory.StartNew(s => ((IFileOperations)s).GetNodeFilePropertiesFromComputeNodeAsync(poolId, nodeId, fileName, fileGetNodeFilePropertiesFromComputeNodeOptions), operations, System.Threading.CancellationToken.None, System.Threading.Tasks.TaskCreationOptions.None, System.Threading.Tasks.TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Gets the properties of the specified compute node file.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='poolId'>
            /// The id of the pool that contains the compute node.
            /// </param>
            /// <param name='nodeId'>
            /// The id of the compute node that contains the file.
            /// </param>
            /// <param name='fileName'>
            /// The path to the compute node file that you want to get the properties of.
            /// </param>
            /// <param name='fileGetNodeFilePropertiesFromComputeNodeOptions'>
            /// Additional parameters for the operation
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async System.Threading.Tasks.Task<FileGetNodeFilePropertiesFromComputeNodeHeaders> GetNodeFilePropertiesFromComputeNodeAsync(this IFileOperations operations, string poolId, string nodeId, string fileName, FileGetNodeFilePropertiesFromComputeNodeOptions fileGetNodeFilePropertiesFromComputeNodeOptions = default(FileGetNodeFilePropertiesFromComputeNodeOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.GetNodeFilePropertiesFromComputeNodeWithHttpMessagesAsync(poolId, nodeId, fileName, fileGetNodeFilePropertiesFromComputeNodeOptions, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Headers;
                }
            }

            /// <summary>
            /// Lists the files in a task's directory on its compute node.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='jobId'>
            /// The id of the job that contains the task.
            /// </param>
            /// <param name='taskId'>
            /// The id of the task whose files you want to list.
            /// </param>
            /// <param name='recursive'>
            /// Whether to list children of a directory.
            /// </param>
            /// <param name='fileListFromTaskOptions'>
            /// Additional parameters for the operation
            /// </param>
            public static Microsoft.Rest.Azure.IPage<NodeFile> ListFromTask(this IFileOperations operations, string jobId, string taskId, bool? recursive = default(bool?), FileListFromTaskOptions fileListFromTaskOptions = default(FileListFromTaskOptions))
            {
                return System.Threading.Tasks.Task.Factory.StartNew(s => ((IFileOperations)s).ListFromTaskAsync(jobId, taskId, recursive, fileListFromTaskOptions), operations, System.Threading.CancellationToken.None, System.Threading.Tasks.TaskCreationOptions.None, System.Threading.Tasks.TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Lists the files in a task's directory on its compute node.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='jobId'>
            /// The id of the job that contains the task.
            /// </param>
            /// <param name='taskId'>
            /// The id of the task whose files you want to list.
            /// </param>
            /// <param name='recursive'>
            /// Whether to list children of a directory.
            /// </param>
            /// <param name='fileListFromTaskOptions'>
            /// Additional parameters for the operation
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Microsoft.Rest.Azure.IPage<NodeFile>> ListFromTaskAsync(this IFileOperations operations, string jobId, string taskId, bool? recursive = default(bool?), FileListFromTaskOptions fileListFromTaskOptions = default(FileListFromTaskOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.ListFromTaskWithHttpMessagesAsync(jobId, taskId, recursive, fileListFromTaskOptions, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Lists all of the files in task directories on the specified compute node.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='poolId'>
            /// The id of the pool that contains the compute node.
            /// </param>
            /// <param name='nodeId'>
            /// The id of the compute node whose files you want to list.
            /// </param>
            /// <param name='recursive'>
            /// Whether to list children of a directory.
            /// </param>
            /// <param name='fileListFromComputeNodeOptions'>
            /// Additional parameters for the operation
            /// </param>
            public static Microsoft.Rest.Azure.IPage<NodeFile> ListFromComputeNode(this IFileOperations operations, string poolId, string nodeId, bool? recursive = default(bool?), FileListFromComputeNodeOptions fileListFromComputeNodeOptions = default(FileListFromComputeNodeOptions))
            {
                return System.Threading.Tasks.Task.Factory.StartNew(s => ((IFileOperations)s).ListFromComputeNodeAsync(poolId, nodeId, recursive, fileListFromComputeNodeOptions), operations, System.Threading.CancellationToken.None, System.Threading.Tasks.TaskCreationOptions.None, System.Threading.Tasks.TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Lists all of the files in task directories on the specified compute node.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='poolId'>
            /// The id of the pool that contains the compute node.
            /// </param>
            /// <param name='nodeId'>
            /// The id of the compute node whose files you want to list.
            /// </param>
            /// <param name='recursive'>
            /// Whether to list children of a directory.
            /// </param>
            /// <param name='fileListFromComputeNodeOptions'>
            /// Additional parameters for the operation
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Microsoft.Rest.Azure.IPage<NodeFile>> ListFromComputeNodeAsync(this IFileOperations operations, string poolId, string nodeId, bool? recursive = default(bool?), FileListFromComputeNodeOptions fileListFromComputeNodeOptions = default(FileListFromComputeNodeOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.ListFromComputeNodeWithHttpMessagesAsync(poolId, nodeId, recursive, fileListFromComputeNodeOptions, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Lists the files in a task's directory on its compute node.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='nextPageLink'>
            /// The NextLink from the previous successful call to List operation.
            /// </param>
            /// <param name='fileListFromTaskNextOptions'>
            /// Additional parameters for the operation
            /// </param>
            public static Microsoft.Rest.Azure.IPage<NodeFile> ListFromTaskNext(this IFileOperations operations, string nextPageLink, FileListFromTaskNextOptions fileListFromTaskNextOptions = default(FileListFromTaskNextOptions))
            {
                return System.Threading.Tasks.Task.Factory.StartNew(s => ((IFileOperations)s).ListFromTaskNextAsync(nextPageLink, fileListFromTaskNextOptions), operations, System.Threading.CancellationToken.None, System.Threading.Tasks.TaskCreationOptions.None, System.Threading.Tasks.TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Lists the files in a task's directory on its compute node.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='nextPageLink'>
            /// The NextLink from the previous successful call to List operation.
            /// </param>
            /// <param name='fileListFromTaskNextOptions'>
            /// Additional parameters for the operation
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Microsoft.Rest.Azure.IPage<NodeFile>> ListFromTaskNextAsync(this IFileOperations operations, string nextPageLink, FileListFromTaskNextOptions fileListFromTaskNextOptions = default(FileListFromTaskNextOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.ListFromTaskNextWithHttpMessagesAsync(nextPageLink, fileListFromTaskNextOptions, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

            /// <summary>
            /// Lists all of the files in task directories on the specified compute node.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='nextPageLink'>
            /// The NextLink from the previous successful call to List operation.
            /// </param>
            /// <param name='fileListFromComputeNodeNextOptions'>
            /// Additional parameters for the operation
            /// </param>
            public static Microsoft.Rest.Azure.IPage<NodeFile> ListFromComputeNodeNext(this IFileOperations operations, string nextPageLink, FileListFromComputeNodeNextOptions fileListFromComputeNodeNextOptions = default(FileListFromComputeNodeNextOptions))
            {
                return System.Threading.Tasks.Task.Factory.StartNew(s => ((IFileOperations)s).ListFromComputeNodeNextAsync(nextPageLink, fileListFromComputeNodeNextOptions), operations, System.Threading.CancellationToken.None, System.Threading.Tasks.TaskCreationOptions.None, System.Threading.Tasks.TaskScheduler.Default).Unwrap().GetAwaiter().GetResult();
            }

            /// <summary>
            /// Lists all of the files in task directories on the specified compute node.
            /// </summary>
            /// <param name='operations'>
            /// The operations group for this extension method.
            /// </param>
            /// <param name='nextPageLink'>
            /// The NextLink from the previous successful call to List operation.
            /// </param>
            /// <param name='fileListFromComputeNodeNextOptions'>
            /// Additional parameters for the operation
            /// </param>
            /// <param name='cancellationToken'>
            /// The cancellation token.
            /// </param>
            public static async Task<Microsoft.Rest.Azure.IPage<NodeFile>> ListFromComputeNodeNextAsync(this IFileOperations operations, string nextPageLink, FileListFromComputeNodeNextOptions fileListFromComputeNodeNextOptions = default(FileListFromComputeNodeNextOptions), System.Threading.CancellationToken cancellationToken = default(System.Threading.CancellationToken))
            {
                using (var _result = await operations.ListFromComputeNodeNextWithHttpMessagesAsync(nextPageLink, fileListFromComputeNodeNextOptions, null, cancellationToken).ConfigureAwait(false))
                {
                    return _result.Body;
                }
            }

    }
}
