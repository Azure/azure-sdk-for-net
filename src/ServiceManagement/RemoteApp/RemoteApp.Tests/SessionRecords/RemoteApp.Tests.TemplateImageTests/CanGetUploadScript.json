{
  "Entries": [
    {
      "RequestUri": "/30da001a-1a9e-48a1-8b77-e5abcfe38bdc/services/rdst15/templateImages/uploadScript?api-version=2014-09-01",
      "EncodedRequestUri": "LzMwZGEwMDFhLTFhOWUtNDhhMS04Yjc3LWU1YWJjZmUzOGJkYy9zZXJ2aWNlcy9yZHN0MTUvdGVtcGxhdGVJbWFnZXMvdXBsb2FkU2NyaXB0P2FwaS12ZXJzaW9uPTIwMTQtMDktMDE=",
      "RequestMethod": "GET",
      "RequestBody": "",
      "RequestHeaders": {
        "Accept": [
          "application/json; charset=utf-8"
        ],
        "x-ms-version": [
          "2014-08-01"
        ],
        "User-Agent": [
          "Microsoft.Azure.Management.RemoteApp.RemoteAppManagementClient/1.0.0.0"
        ]
      },
      "ResponseBody": "\"param(\\u000d\\u000a    [Parameter(Mandatory=$true, ParameterSetName=\\\"UploadVhd\\\")]\\u000d\\u000a    [string] $uri,\\u000d\\u000a\\u000d\\u000a    [Parameter(Mandatory=$true, ParameterSetName=\\\"UploadVhd\\\")] \\u000d\\u000a    [string] $sas,\\u000d\\u000a\\u000d\\u000a    [Parameter(Mandatory=$false, ParameterSetName=\\\"UploadVhd\\\")]\\u000d\\u000a    [string] $vhdPath = $null,\\u000d\\u000a\\u000d\\u000a    [Parameter(Mandatory=$true, ParameterSetName=\\\"ValidateCurrentOS\\\")] \\u000d\\u000a    [switch] $validateCurrentOS\\u000d\\u000a)\\u000d\\u000a\\u000d\\u000a\\u000d\\u000a#############################\\u000d\\u000a# Localization string names #\\u000d\\u000a#############################\\u000d\\u000a\\u000d\\u000a$SuccessfullyMountedVhdScriptText            =    \\\"SuccessfullyMountedVhdScriptText\\\"\\u000d\\u000a$FailedToMountVhdScriptError                 =    \\\"FailedToMountVhdScriptError\\\"\\u000d\\u000a$SuccessfullyUnmountedVhdScriptText          =    \\\"SuccessfullyUnmountedVhdScriptText\\\"\\u000d\\u000a$UnsupportedOsScriptError                    =    \\\"UnsupportedOsScriptError\\\"\\u000d\\u000a$UnsupportedOsSkuScriptError                 =    \\\"UnsupportedOsSkuScriptError\\\"\\u000d\\u000a$UnsupportedOsEditionScriptError             =    \\\"UnsupportedOsEditionScriptError\\\"\\u000d\\u000a$ImageIsntGeneralizedScriptError             =    \\\"ImageIsntGeneralizedScriptError\\\"\\u000d\\u000a$FailedToReadAppServerRegistryKeyScriptError =    \\\"FailedToReadAppServerRegistryKeyScriptError\\\"\\u000d\\u000a$RdshRoleNotInstalledScriptError             =    \\\"RdshRoleNotInstalledScriptError\\\"\\u000d\\u000a$NotRemoteAppReadyImageScriptError           =    \\\"NotRemoteAppReadyImageScriptError\\\"\\u000d\\u000a$NotInAzurePowershellEnvironmentScriptError  =    \\\"NotInAzurePowershellEnvironmentScriptError\\\"\\u000d\\u000a$StartingImageUploadScriptText               =    \\\"StartingImageUploadScriptText\\\"\\u000d\\u000a$ImageUploadCompleteScriptText               =    \\\"ImageUploadCompleteScriptText\\\"\\u000d\\u000a$MountingVhdScriptText                       =    \\\"MountingVhdScriptText\\\"\\u000d\\u000a$NotRunningAsAdminScriptError                =    \\\"NotRunningAsAdminScriptError\\\"\\u000d\\u000a$NoOsFoundOnTemplateImage                    =    \\\"NoOsFoundOnTemplateImage\\\"\\u000d\\u000a$MultipleOsFoundOnTemplateImage              =    \\\"MultipleOsFoundOnTemplateImage\\\"\\u000d\\u000a$SysprepVmModeNotSupported                   =    \\\"SysprepVmModeNotSupported\\\"\\u000d\\u000a$UnattendFileError                           =    \\\"UnattendFileError\\\"\\u000d\\u000a$NumberOfWindowsVolumes                      =    \\\"NumberOfWindowsVolumes\\\"\\u000d\\u000a$HiveUnloadSuccess                           =    \\\"HiveUnloadSuccess\\\"\\u000d\\u000a$HiveUnloadFailure                           =    \\\"HiveUnloadFailure\\\"\\u000d\\u000a$CurrentVmModeValue                          =    \\\"CurrentVmModeValue\\\"\\u000d\\u000a$NtfsDisableEncryptionError                  =    \\\"NtfsDisableEncryptionError\\\"\\u000d\\u000a$ImportingAzureModuleScriptText              =    \\\"ImportingAzureModuleScriptText\\\"\\u000d\\u000a$ImportingStorageModuleScriptText            =    \\\"ImportingStorageModuleScriptText\\\"\\u000d\\u000a$FailedToLoadAzureModuleError                =    \\\"FailedToLoadAzureModuleError\\\"\\u000d\\u000a$FailedToLoadStorageModuleError              =    \\\"FailedToLoadStorageModuleError\\\"\\u000d\\u000a$IncompatibleAzurePowerShellModuleError      =    \\\"IncompatibleAzurePowerShellModuleError\\\"\\u000d\\u000a$AzureDotNetSdkNotInstalledError             =    \\\"AzureDotNetSdkNotInstalledError\\\"\\u000d\\u000a$RdpInitVersionInfo                          =    \\\"RdpInitVersionInfo\\\"\\u000d\\u000a$FailedRdpInitVersion                        =    \\\"FailedRdpInitVersion\\\"   \\u000d\\u000a$RdpInitVersionCheckSuccess                  =    \\\"RdpInitVersionCheckSuccess\\\"\\u000d\\u000a$ImageSizeNotMultipleOfMBs\\u0009\\u0009             =    \\\"ImageSizeNotMultipleOfMBs\\\"\\u000d\\u000a$ImageSizeGreaterThanMaxSizeLimit\\u0009         =    \\\"ImageSizeGreaterThanMaxSizeLimit\\\"\\u000d\\u000a$StorageModuleImportFailed                   =    \\\"StorageModuleImportFailed\\\"\\u000d\\u000a$ImagePartitionStyleNotSupported\\u0009         =    \\\"ImagePartitionStyleNotSupported\\\"\\u000d\\u000a$DiskPartitionStyle\\u0009\\u0009\\u0009                 =    \\\"DiskPartitionStyle\\\"\\u000d\\u000a$RdcbRoleInstalledScriptError\\u0009\\u0009         =\\u0009  \\\"RdcbRoleInstalledScriptError\\\"\\u000d\\u000a$FailedToReadTssdisRegistryKeyScriptError    =\\u0009  \\\"FailedToReadTssdisRegistryKeyScriptError\\\"\\u000d\\u000a$FailedToFindMountedDriveVhd                 =    \\\"FailedToFindMountedDriveVhd\\\"\\u000d\\u000a$ClientMachineRunningOnDownlevelOs           =    \\\"ClientMachineRunningOnDownlevelOs\\\"\\u000d\\u000a$FailedToGetVolumeListError                  =    \\\"FailedToGetVolumeListError\\\"\\u000d\\u000a$CurrentOsCheckSuccess                       =    \\\"CurrentOsCheckSuccess\\\"\\u000d\\u000a\\u000d\\u000a#######################\\u000d\\u000a# Localization tables #\\u000d\\u000a#######################\\u000d\\u000a\\u000d\\u000a$LocalizationTable_en = @{\\u000d\\u000a$SuccessfullyMountedVhdScriptText            =    \\\"Successfully mounted the VHD.\\\";\\u000d\\u000a$FailedToMountVhdScriptError                 =    \\\"Could not mount the specified VHD.\\\";\\u000d\\u000a$SuccessfullyUnmountedVhdScriptText          =    \\\"Successfully detached the VHD.\\\";\\u000d\\u000a$UnsupportedOsScriptError                    =    \\\"The template image must be created using Windows Server 2012 R2 as the operating system.\\\";\\u000d\\u000a$UnsupportedOsSkuScriptError                 =    \\\"The template image must be created using Windows Server as the operating system.\\\";\\u000d\\u000a$UnsupportedOsEditionScriptError             =    \\\"The template image must be created using Windows Server 2012 R2 DataCenter or Standard editions. Your template image edition is {0}\\\";\\u000d\\u000a$ImageIsntGeneralizedScriptError             =    \\\"The template image is not in a generalized state. You can use Sysprep on the image to change the template image to a generalized state.\\\";\\u000d\\u000a$FailedToReadAppServerRegistryKeyScriptError =    \\\"Failed to read the App Server reg key:\\\";\\u000d\\u000a$RdshRoleNotInstalledScriptError             =    \\\"The RD Session Host server role is not installed on the template image.\\\";\\u000d\\u000a$NotRemoteAppReadyImageScriptError           =    \\\"The image does not satisfy Windows Azure RemoteApp requirements.\\\";\\u000d\\u000a$NotInAzurePowershellEnvironmentScriptError  =    \\\"Run this script using Windows Azure PowerShell.\\\";\\u000d\\u000a$StartingImageUploadScriptText               =    \\\"Starting image upload.\\\";\\u000d\\u000a$ImageUploadCompleteScriptText               =    \\\"Successfully uploaded template image.\\\";\\u000d\\u000a$MountingVhdScriptText                       =    \\\"Mounting the VHD.\\\";\\u000d\\u000a$NotRunningAsAdminScriptError                =    \\\"This script requires elevation. Run Windows Azure PowerShell as Administrator and try again.\\\";\\u000d\\u000a$NoOsFoundOnTemplateImage                    =    \\\"Windows Operating System could not be located on the Image Template. Please verifiy that the image has a valid Windows Operating System.\\\";\\u000d\\u000a$MultipleOsFoundOnTemplateImage              =    \\\"The specified Template Image has multiple Windows Operating Systems installed. Please use an image which has only one Windows Operating System.\\\";\\u000d\\u000a$SysprepVmModeNotSupported                   =    \\\"Images prepared with sysprep \\/mode:VM flag are not supported. Please rerun sysprep.exe without \\/mode:vm flag and try to upload again.\\\"\\u000d\\u000a$UnattendFileError                           =    \\\"Please make sure there are no custom unattend files on the disk. Found: \\\"\\u000d\\u000a$NumberOfWindowsVolumes                      =    \\\"Number of volumes with Windows OS on it: \\\"\\u000d\\u000a$HiveUnloadSuccess                           =    \\\"Successfully unloaded hive: HKLM:\\\\{0} from the VHD.\\\"\\u000d\\u000a$HiveUnloadFailure                           =    \\\"Failed to unload registry hive HKLM:\\\\{0} from the VHD. Please unmount the registry hive manually.\\\"\\u000d\\u000a$CurrentVmModeValue                          =    \\\"Current sysprep VM Mode value of the image is: \\\"\\u000d\\u000a$NtfsDisableEncryptionError                  =    \\\"Please make sure Encrypting File System (EFS) is disabled on the template image you are trying to upload. In order to disable EFS, boot into a VM running with this template image, run 'Fsutil behavior set disableencryption 1' on an elevated command window and then sysprep and try uploading again\\\"\\u000d\\u000a$ImportingAzureModuleScriptText              =    \\\"Importing Azure module...\\\"\\u000d\\u000a$ImportingStorageModuleScriptText            =    \\\"Importing Storage module...\\\"\\u000d\\u000a$FailedToLoadAzureModuleError                =    \\\"Failed to load Azure module. Make sure you have the latest Azure PowerShell module installed.\\\"\\u000d\\u000a$FailedToLoadStorageModuleError              =    \\\"Failed to load Storage powershell module.\\\"\\u000d\\u000a$IncompatibleAzurePowerShellModuleError      =    \\\"This version of the Azure PowerShell module is not compatible with Azure RemoteApp services. Please install Azure PowerShell module version 0.8.3 or lower and then try uploading again.\\\"\\u000d\\u000a$AzureDotNetSdkNotInstalledError             =    \\\"This script requires Azure .Net SDK installed on the system. Please install Azure SDK and then run the script from a Windows Azure PowerShell\\\"\\u000d\\u000a$RdpInitVersionInfo                          =    \\\"RdpInit.exe version in the VHD:\\\"\\u000d\\u000a$FailedRdpInitVersion                        =    \\\"!!!!!!!!!RdpInit.exe in the '\\\\{0}' is not up to date. Please install KB2977219 from 'http:\\/\\/support.microsoft.com\\/kb\\/2977219'.\\\"\\u000d\\u000a$RdpInitVersionCheckSuccess                  =    \\\"RdpInit.exe in the '\\\\{0}' is up to date.\\\"\\u000d\\u000a$ImageSizeNotMultipleOfMBs\\u0009\\u0009             =    \\\"Size of the specified template image is not a multiple of MBs. Please upload an image whose size is a multiple of 1MB.\\\"\\u000d\\u000a$ImageSizeGreaterThanMaxSizeLimit            =    \\\"Size of the specified template image is greater than 128 GB. Please upload an image whose size is 128 GB or less.\\\"\\u000d\\u000a$StorageModuleImportFailed                   =    \\\"Please close all powershell windows and try executing the script again on a new powershell window. If you are running the script from Azure powershell window, please switch to a Windows powershell window and retry.\\\"\\u000d\\u000a$ImagePartitionStyleNotSupported\\u0009         =\\u0009  \\\"The template image you are trying to upload does not have 'MBR' partition style. Please re-create the image with 'MBR' partition style and upload again.\\\"\\u000d\\u000a$DiskPartitionStyle                          =    \\\"Template image disk partitioning style is: \\\"\\u000d\\u000a$RdcbRoleInstalledScriptError\\u0009\\u0009\\u0009\\u0009 =\\u0009  \\\"Remote Desktop Connection Manager role seems to be installed on the template image. Please uninstall the role, sysprep the image and try uploading again.\\\"\\u000d\\u000a$FailedToReadTssdisRegistryKeyScriptError\\u0009 =\\u0009  \\\"Failed to read the Tssdis reg key on the template image\\\"\\u000d\\u000a$FailedToFindMountedDriveVhd                 =    \\\"Failed to find mounted '\\\\{0}' VHD drive\\\"\\u000d\\u000a$ClientMachineRunningOnDownlevelOs           =    \\\"Client machine is running on OS lower than Windows 8.1 or Windows Server 2012 R2\\\"\\u000d\\u000a$FailedToGetVolumeListError                  =    \\\"Failed to retrieve the list of volumes on current operating system\\\"\\u000d\\u000a$CurrentOsCheckSuccess                       =    \\\"The current image satisfies all the requirements for Azure RemoteApp Template image.\\\"\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000a###################\\u000d\\u000a# Table of tables #\\u000d\\u000a###################\\u000d\\u000a\\u000d\\u000a$LocalizationTables = @{\\u000d\\u000a\\\"en\\\" = $LocalizationTable_en;\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000a###########################\\u000d\\u000a# Pick localization table #\\u000d\\u000a###########################\\u000d\\u000a\\u000d\\u000a$CurrentCulture = [System.Threading.Thread]::CurrentThread.CurrentUICulture\\u000d\\u000a$CurrentCultureTable = $null\\u000d\\u000a\\u000d\\u000awhile($CurrentCultureTable -eq $null)\\u000d\\u000a{\\u000d\\u000a    if([string]::IsNullOrEmpty($CurrentCulture.Name))\\u000d\\u000a    {\\u000d\\u000a        $CurrentCultureTable = $LocalizationTable_en;\\u000d\\u000a    }\\u000d\\u000a    else\\u000d\\u000a    {\\u000d\\u000a        if($LocalizationTables.ContainsKey($CurrentCulture.Name))\\u000d\\u000a        {\\u000d\\u000a            $CurrentCultureTable = $LocalizationTables[$CurrentCulture.Name]\\u000d\\u000a        }\\u000d\\u000a        else\\u000d\\u000a        {\\u000d\\u000a            $CurrentCulture = $CurrentCulture.Parent\\u000d\\u000a        }\\u000d\\u000a    }\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000afunction Get-FileVersion\\u000d\\u000a{\\u000d\\u000a  param(\\u000d\\u000a    [Parameter(Mandatory=$true)]\\u000d\\u000a     [string]$FileName)\\u000d\\u000a  \\u000d\\u000a  $ver = [System.Diagnostics.FileVersionInfo]::GetVersionInfo($FileName)\\u000d\\u000a  if ([string]::IsNullOrEmpty($ver.FileVersion)) {\\u000d\\u000a    return $null\\u000d\\u000a  }\\u000d\\u000a  \\u000d\\u000a  return New-Object Version($ver.FileMajorPart, $ver.FileMinorPart, $ver.FileBuildPart, $ver.FilePrivatePart)\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000a\\u000d\\u000afunction Get-File\\u000d\\u000a{   \\u000d\\u000a    [System.Reflection.Assembly]::LoadWithPartialName(\\\"System.windows.forms\\\") | Out-Null\\u000d\\u000a\\u000d\\u000a    $OpenFileDialog = New-Object System.Windows.Forms.OpenFileDialog\\u000d\\u000a    $OpenFileDialog.initialDirectory = \\\"C:\\\\\\\"\\u000d\\u000a    $OpenFileDialog.filter = \\\"VHD files (*.vhd;*.vhdx)| *vhd; *.vhdx\\\"\\u000d\\u000a    $dialogResult = $OpenFileDialog.ShowDialog()\\u000d\\u000a    if ($dialogResult -eq [System.Windows.Forms.DialogResult]::Cancel)\\u000d\\u000a    {\\u000d\\u000a        exit\\u000d\\u000a    }\\u000d\\u000a    $OpenFileDialog.filename \\u000d\\u000a    Split-Path $OpenFileDialog.filename -Leaf\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000afunction Is-RunningAsAdmin\\u000d\\u000a{\\u000d\\u000a    $windowsIdentity = [System.Security.Principal.WindowsIdentity]::GetCurrent()\\u000d\\u000a    $windowsPrincipal = new-object System.Security.Principal.WindowsPrincipal($windowsIdentity)\\u000d\\u000a    $administratorRole = [System.Security.Principal.WindowsBuiltInRole]::Administrator\\u000d\\u000a    $isRunningAsAdmin = $windowsPrincipal.IsInRole($administratorRole)\\u000d\\u000a    return $isRunningAsAdmin\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000afunction Get-AzureVersion\\u000d\\u000a{\\u000d\\u000a    $path = \\\"HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Microsoft SDKs\\\\ServiceHosting\\\"\\u000d\\u000a    $versions = Get-ChildItem -Path \\\"$path\\\" | Sort-Object -Descending\\u000d\\u000a    $version = Split-Path $versions[0].Name -Leaf  \\u000d\\u000a    return $version\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000afunction Get-VolumeList()\\u000d\\u000a{\\u000d\\u000a    try\\u000d\\u000a    {\\u000d\\u000a        $volumeInstances = Get-WmiObject -Class Win32_Volume\\u000d\\u000a        foreach($volume in $volumeInstances)\\u000d\\u000a        {\\u000d\\u000a            if(!($global:volumeList.Contains($volume.DeviceID)))\\u000d\\u000a            {\\u000d\\u000a                $global:volumeList.Add($volume.DeviceID)\\u000d\\u000a            }\\u000d\\u000a        }\\u000d\\u000a    }\\u000d\\u000a    catch\\u000d\\u000a    {\\u000d\\u000a    }\\u000d\\u000a    if ($global:volumeList.Count -gt 0) \\u000d\\u000a    {\\u000d\\u000a        return $true\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    Write-Error($CurrentCultureTable[$FailedToGetVolumeListError])\\u000d\\u000a    return $false\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000afunction Attach-VHD([string] $vhdfile) \\u000d\\u000a{\\u000d\\u000a\\u000d\\u000a    $success = $true\\u000d\\u000a    $diskpartOutput = [string]::Empty\\u000d\\u000a    $errorOutput = [string]::Empty\\u000d\\u000a\\u000d\\u000a    Write-Verbose \\\"`r`n\\\"\\u000d\\u000a    Write-Verbose ($CurrentCultureTable[$MountingVhdScriptText])\\u000d\\u000a    Write-Verbose \\\"`r`n\\\"\\u000d\\u000a\\u000d\\u000a    # register for new drive event\\u000d\\u000a    $guid = ([guid]::NewGuid()).ToString()\\u000d\\u000a    Register-WmiEvent -SourceIdentifier $guid `\\u000d\\u000a                    -Query \\\"Select * From __InstanceCreationEvent WITHIN 2 WHERE TargetInstance ISA 'Win32_Volume'\\\" `\\u000d\\u000a                    -Action { if(!($global:volumeList.Contains($event.SourceEventArgs.NewEvent.TargetInstance.DeviceId))) {$global:volumeList.Add( $event.SourceEventArgs.NewEvent.TargetInstance.DeviceId )} } | Out-Null\\u000d\\u000a\\u000d\\u000a    try \\u000d\\u000a    {\\u000d\\u000a        $diskpartOutput = \\u000d\\u000a$(@\\\"\\u000d\\u000a            SELECT VDISK FILE=\\\"$vhdfile\\\"\\u000d\\u000a            ATTACH VDISK READONLY\\u000d\\u000a            EXIT\\u000d\\u000a\\\"@ | diskpart)\\u000d\\u000a    }\\u000d\\u000a    catch\\u000d\\u000a    {\\u000d\\u000a        $success = $false\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    if ($success -eq $true)\\u000d\\u000a    {\\u000d\\u000a        $retry = 0\\u000d\\u000a\\u000d\\u000a        # Sleep for a bit to make sure the event is fired!\\u000d\\u000a        do\\u000d\\u000a        {\\u000d\\u000a            $retry++\\u000d\\u000a            if($global:volumeList.Count -le 0)\\u000d\\u000a            {\\u000d\\u000a                Start-Sleep -Seconds 2\\u000d\\u000a            }\\u000d\\u000a            else\\u000d\\u000a            {\\u000d\\u000a                break\\u000d\\u000a            }\\u000d\\u000a        } while($retry -lt 15)\\u000d\\u000a    }\\u000d\\u000a \\u000d\\u000a    # Sleep another 5 seconds to make sure that all the drive letters are received\\u000d\\u000a    Start-Sleep -Seconds 5\\u000d\\u000a\\u000d\\u000a    Unregister-Event -SourceIdentifier $guid -Force\\u000d\\u000a\\u000d\\u000a    # if drive letter detected, return the value\\u000d\\u000a    if ($global:volumeList.Count -gt 0) \\u000d\\u000a    {\\u000d\\u000a        Write-Verbose ($CurrentCultureTable[$SuccessfullyMountedVhdScriptText]);\\u000d\\u000a        $result = $true\\u000d\\u000a    }\\u000d\\u000a    else\\u000d\\u000a    {\\u000d\\u000a        $result = $false\\u000d\\u000a        $errorOutput = $diskpartOutput -join \\\"`r`n\\\"\\u000d\\u000a        Write-Error([string]::Concat($CurrentCultureTable[$FailedToMountVhdScriptError], \\\"`r`n\\\", $errorOutput))\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    return $result\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000a\\u000d\\u000afunction Detach-VHD([string] $vhdfile) \\u000d\\u000a{\\u000d\\u000a    try \\u000d\\u000a    {\\u000d\\u000a        $result = \\u000d\\u000a$(@\\\"\\u000d\\u000a            SELECT VDISK FILE=\\\"$vhdfile\\\"\\u000d\\u000a            DETACH VDISK\\u000d\\u000a            EXIT\\u000d\\u000a\\\"@ | diskpart)\\u000d\\u000a    }\\u000d\\u000a    catch\\u000d\\u000a    {\\u000d\\u000a        Write-Verbose $_\\u000d\\u000a        Write-Verbose ($result -join \\\"`r`n\\\")\\u000d\\u000a        return $false\\u000d\\u000a    }\\u000d\\u000a    Write-Verbose ($CurrentCultureTable[$SuccessfullyUnmountedVhdScriptText]);\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000afunction Test-RdpInitInVhd([string] $winVolume)\\u000d\\u000a{\\u000d\\u000a    $isRdpInitUpToDate = $true\\u000d\\u000a    $rdpInitPathInVHD=$winVolume + \\\"Windows\\\\system32\\\\RdpInit.exe\\\"\\u000d\\u000a    $tempfilename = $env:Temp + \\\"\\\\UploadGoldImageCheckRdpInit.exe\\\"\\u000d\\u000a\\u000d\\u000a    try\\u000d\\u000a    {\\u000d\\u000a        # Most of the powershell doesn't work with the volume path. Use the dos command copy the file and check the version.\\u000d\\u000a        (cmd \\/c copy $rdpInitPathInVHD $tempfilename) | Out-Null\\u000d\\u000a        $rdpInitVerInVHD=Get-FileVersion $tempfilename\\u000d\\u000a        Write-Verbose ([string]::Format($CurrentCultureTable[$RdpInitVersionInfo]) + $rdpInitVerInVHD)\\u000d\\u000a        $supportedVersion = new-Object Version(6, 3, 9600, 17211)\\u000d\\u000a        if ( $rdpInitVerInVHD -lt $supportedVersion)\\u000d\\u000a        {\\u000d\\u000a            Write-Error([string]::Format($CurrentCultureTable[$FailedRdpInitVersion], $vhdPath))\\u000d\\u000a            $isRdpInitUpToDate = $false\\u000d\\u000a        }\\u000d\\u000a        else\\u000d\\u000a        {\\u000d\\u000a            Write-Verbose ([string]::Format($CurrentCultureTable[$RdpInitVersionCheckSuccess], $vhdPath))\\u000d\\u000a        }\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    catch\\u000d\\u000a    {\\u000d\\u000a        Write-Error ([string]::Format($CurrentCultureTable[$FailedToFindMountedDriveVhd], $vhdPath))\\u000d\\u000a        $isRdpInitUpToDate = $false\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    if (Test-Path -Path $tempfilename -PathType Leaf)\\u000d\\u000a    {\\u000d\\u000a        Remove-Item $tempfilename\\u000d\\u000a    }\\u000d\\u000a    return $isRdpInitUpToDate\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000afunction Check-VHDSizeAndPartitionStyleRequirements([string] $vhdPath)\\u000d\\u000a{\\u000d\\u000a    $sizeAndPartitionStyleRequirementsSatisfied = $true\\u000d\\u000a\\u000d\\u000a    try\\u000d\\u000a    {\\u000d\\u000a        $disk = Get-DiskImage $vhdPath\\u000d\\u000a        # Disk size should be a multiple of 1MB\\u000d\\u000a        if (($disk.Size)%(1MB) -ne 0)\\u000d\\u000a        {\\u000d\\u000a            Write-Error ($CurrentCultureTable[$ImageSizeNotMultipleOfMBs])\\u000d\\u000a            return $false\\u000d\\u000a        }\\u000d\\u000a        \\u000d\\u000a        #disk size should be less than 128 GB, this is Azure limit for an OS disk\\u000d\\u000a        if ($disk.Size -gt 128GB)\\u000d\\u000a        {\\u000d\\u000a            Write-Error ($CurrentCultureTable[$ImageSizeGreaterThanMaxSizeLimit])\\u000d\\u000a            $sizeAndPartitionStyleRequirementsSatisfied = $false\\u000d\\u000a        }\\u000d\\u000a\\u000d\\u000a\\u0009\\u0009# Get the mounted disk number\\u000d\\u000a        $diskNumber = $disk.Number\\u000d\\u000a\\u000d\\u000a        #Get the PartitionStyle for the mounted disk and ensure it's MBR\\u000d\\u000a        $partitionStyle = (Get-Disk -Number $diskNumber).PartitionStyle\\u000d\\u000a        Write-Verbose ($CurrentCultureTable[$DiskPartitionStyle] + $partitionStyle)\\u000d\\u000a\\u000d\\u000a        if ($partitionStyle -ne \\\"MBR\\\")\\u000d\\u000a\\u0009\\u0009{\\u000d\\u000a\\u0009\\u0009\\u0009Write-Error ($CurrentCultureTable[$ImagePartitionStyleNotSupported])\\u000d\\u000a\\u0009\\u0009\\u0009$sizeAndPartitionStyleRequirementsSatisfied = $false\\u000d\\u000a\\u0009\\u0009}\\u000d\\u000a    }\\u000d\\u000a    catch\\u000d\\u000a    {\\u000d\\u000a        Write-Verbose $_\\u000d\\u000a        $sizeAndPartitionStyleRequirementsSatisfied = $false\\u000d\\u000a    } \\u000d\\u000a    return $sizeAndPartitionStyleRequirementsSatisfied\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000afunction Test-WindowsVolume()\\u000d\\u000a{\\u000d\\u000a    $winVolumeCount = 0\\u000d\\u000a    foreach( $volume in $global:volumeList)\\u000d\\u000a    {\\u000d\\u000a        if(Test-Path -LiteralPath ($volume + \\\"windows\\\\system32\\\\config\\\") -PathType Container)\\u000d\\u000a        {\\u000d\\u000a            $winVolume = $volume\\u000d\\u000a            $winVolumeCount++\\u000d\\u000a        }\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    Write-Verbose ($CurrentCultureTable[$NumberOfWindowsVolumes] + $winVolumeCount)\\u000d\\u000a\\u000d\\u000a    if($winVolumeCount -eq 0)\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$NoOsFoundOnTemplateImage])\\u000d\\u000a        return $null\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    if($winVolumeCount -gt 1)\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$MultipleOsFoundOnTemplateImage])\\u000d\\u000a        return $null\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    return $winVolume\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000afunction Unload-Reghive([string] $vhd_hive)\\u000d\\u000a{\\u000d\\u000a    $regUnloadRetries = 0\\u000d\\u000a    do\\u000d\\u000a    {\\u000d\\u000a        (reg unload ('hklm\\\\'+$vhd_hive) 2>&1) | Out-Null\\u000d\\u000a        if( (Test-Path('HKLM:\\\\'+ $vhd_hive)) )\\u000d\\u000a        {\\u000d\\u000a            Start-Sleep -Seconds 1\\u000d\\u000a        }\\u000d\\u000a        else\\u000d\\u000a        {\\u000d\\u000a            Write-Verbose ([string]::Format($CurrentCultureTable[$HiveUnloadSuccess], $vhd_hive))\\u000d\\u000a            return\\u000d\\u000a        }\\u000d\\u000a    } while( $regUnloadRetries++ -lt 30 )\\u000d\\u000a\\u000d\\u000a    if( (Test-Path('HKLM:\\\\'+ $vhd_hive)) )\\u000d\\u000a    {\\u000d\\u000a        Write-Error ([string]::Format($CurrentCultureTable[$HiveUnloadFailure], $vhd_hive))\\u000d\\u000a    }\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000afunction Test-MohoroImageRequirements()\\u000d\\u000a{\\u000d\\u000a    $validImage = $true\\u000d\\u000a\\u000d\\u000a    $global:volumeList = New-Object System.Collections.Generic.List[string]\\u000d\\u000a\\u000d\\u000a    #get list of current volumes if validating current OS\\u000d\\u000a    if ($validateCurrentOS)\\u000d\\u000a    {\\u000d\\u000a        if($false -eq (Get-VolumeList))\\u000d\\u000a        {\\u000d\\u000a            return $false\\u000d\\u000a        }\\u000d\\u000a    }\\u000d\\u000a    #else get the mounted volume list from the VHD\\u000d\\u000a    elseif($false -eq (Attach-VHD($vhdPath)))\\u000d\\u000a    {\\u000d\\u000a        return $false\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    $winVolume = Test-WindowsVolume\\u000d\\u000a    \\u000d\\u000a    if( $null -eq ($winVolume) )\\u000d\\u000a    {\\u000d\\u000a        if(!($validateCurrentOS))\\u000d\\u000a        {\\u000d\\u000a            Detach-VHD($vhdPath)\\u000d\\u000a        }\\u000d\\u000a        return $false\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    #check VHD size and partitioning style if uploading a VHD\\u000d\\u000a    if (!($validateCurrentOS) -and ($IsStorageModuleAvailable))\\u000d\\u000a    {\\u000d\\u000a       if ($false -eq (Check-VHDSizeAndPartitionStyleRequirements($vhdPath)))\\u000d\\u000a       {\\u000d\\u000a           Detach-VHD($vhdPath)\\u000d\\u000a           return $false\\u000d\\u000a       }\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    $validImage = Test-RdpInitInVhd($winVolume)\\u000d\\u000a\\u000d\\u000a    # use current OS registry hive if validating current OS\\u000d\\u000a    # else load software reg hive from the mounted VHD's volume\\u000d\\u000a    if($validateCurrentOS)\\u000d\\u000a    {\\u000d\\u000a        $vhd_hive = 'SOFTWARE'\\u000d\\u000a    }\\u000d\\u000a    else\\u000d\\u000a    {\\u000d\\u000a        $vhd_hive = 'vhd_sft'\\u000d\\u000a        (reg load ('hklm\\\\'+$vhd_hive) ($winVolume + \\\"windows\\\\system32\\\\config\\\\SOFTWARE\\\") 2>&1) | Out-Null\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    # verify Windows Server 2012 R2 (Blue) image\\u000d\\u000a    $osVer = (Get-ItemProperty ('HKLM:\\\\'+ $vhd_hive + '\\\\Microsoft\\\\Windows NT\\\\CurrentVersion') CurrentVersion).CurrentVersion\\u000d\\u000a    if ($osVer -ne '6.3')\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$UnsupportedOsScriptError])\\u000d\\u000a        $validImage = $false;\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    Remove-Variable osVer\\u000d\\u000a\\u000d\\u000a    # verify it is server\\u000d\\u000a    $osInstallationType = (Get-ItemProperty ('HKLM:\\\\'+ $vhd_hive + '\\\\Microsoft\\\\Windows NT\\\\CurrentVersion') InstallationType).InstallationType\\u000d\\u000a    if ($osInstallationType -ne 'Server')\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$UnsupportedOsSkuScriptError])\\u000d\\u000a        $validImage = $false;\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    Remove-Variable osInstallationType\\u000d\\u000a\\u000d\\u000a    # verify Standard or DataCenter edition\\u000d\\u000a    $edition = (Get-ItemProperty ('HKLM:\\\\'+ $vhd_hive + '\\\\Microsoft\\\\Windows NT\\\\CurrentVersion') EditionID).EditionID\\u000d\\u000a    if (!($edition.Contains( 'Datacenter') -or $edition.Contains( 'Standard')))\\u000d\\u000a    {\\u000d\\u000a        Write-Error ([string]::Format($CurrentCultureTable[$UnsupportedOsEditionScriptError], $edition))\\u000d\\u000a        $validImage = $false;\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    Remove-Variable edition\\u000d\\u000a\\u000d\\u000a    #skip sysprep checks if validating current OS\\u000d\\u000a    if(!($validateCurrentOS))\\u000d\\u000a    {\\u000d\\u000a\\u000d\\u000a        # verify sysprep state\\u000d\\u000a        $sysprepState = (Get-ItemProperty ('HKLM:\\\\'+ $vhd_hive + '\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Setup\\\\State') ImageState).ImageState\\u000d\\u000a        if($sysprepState -ne \\\"IMAGE_STATE_GENERALIZE_RESEAL_TO_OOBE\\\")\\u000d\\u000a        {\\u000d\\u000a            Write-Error ($CurrentCultureTable[$ImageIsntGeneralizedScriptError])\\u000d\\u000a            $validImage = $false;\\u000d\\u000a        }\\u000d\\u000a\\u000d\\u000a        Remove-Variable sysprepState\\u000d\\u000a\\u000d\\u000a        # verify sysprep vm mode\\u000d\\u000a        $oobeRegKeyPath = ('HKLM:\\\\'+ $vhd_hive + '\\\\Microsoft\\\\Windows\\\\CurrentVersion\\\\Setup\\\\OOBE')\\u000d\\u000a        $sysprepVmMode = (Get-ItemProperty $oobeRegKeyPath SysprepSetVMMode -ErrorAction SilentlyContinue).SysprepSetVMMode\\u000d\\u000a\\u000d\\u000a        if ($sysprepVmMode)\\u000d\\u000a        {\\u000d\\u000a            Write-Verbose ($CurrentCultureTable[$CurrentVmModeValue] + $sysprepVmMode)\\u000d\\u000a        }\\u000d\\u000a\\u000d\\u000a        if($sysprepVmMode -eq 1)\\u000d\\u000a        {\\u000d\\u000a            Write-Error ($CurrentCultureTable[$SysprepVmModeNotSupported])\\u000d\\u000a            $validImage = $false\\u000d\\u000a        }\\u000d\\u000a\\u000d\\u000a        Remove-Variable sysprepVmMode\\u000d\\u000a\\u000d\\u000a        # unload software reg hive\\u000d\\u000a        [GC]::Collect()\\u000d\\u000a\\u000d\\u000a        Unload-Reghive($vhd_hive)\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    # use current OS registry hive if validating current OS\\u000d\\u000a    # else load software reg hive from the mounted VHD's volume\\u000d\\u000a    if($validateCurrentOS)\\u000d\\u000a    {\\u000d\\u000a        $vhd_hive = 'SYSTEM'\\u000d\\u000a    }\\u000d\\u000a    else\\u000d\\u000a    {\\u000d\\u000a        $vhd_hive = 'vhd_sys'\\u000d\\u000a        (reg load ('hklm\\\\'+$vhd_hive) ($winVolume + \\\"windows\\\\system32\\\\config\\\\SYSTEM\\\") 2>&1) | Out-Null\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    # verify if RDSH role and Desktop experince is installed\\u000d\\u000a    $appCompat=$null\\u000d\\u000a    try\\u000d\\u000a    {\\u000d\\u000a        $appCompat = (Get-ItemProperty ('HKLM:\\\\'+ $vhd_hive + '\\\\ControlSet001\\\\Control\\\\Terminal Server') TSAppCompat ).TSAppCompat\\u000d\\u000a    }\\u000d\\u000a    catch\\u000d\\u000a    {\\u000d\\u000a        Write-Verbose($CurrentCultureTable[$FailedToReadAppServerRegistryKeyScriptError] + $_.Exception.Message)\\u000d\\u000a    }\\u000d\\u000a    if(-not($appCompat))\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$RdshRoleNotInstalledScriptError])\\u000d\\u000a        $validImage = $false;\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    Remove-Variable appCompat\\u000d\\u000a\\u0009\\u000d\\u000a    # verify if sysprep unattend registry key is set\\u000d\\u000a    $unattendRegPath = ('HKLM:\\\\'+ $vhd_hive + '\\\\Setup')\\u000d\\u000a    $unattendReg = (Get-ItemProperty $unattendRegPath UnattendFile -ErrorAction SilentlyContinue).UnattendFile \\u000d\\u000a\\u000d\\u000a    if ($unattendReg)\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$UnattendFileError])\\u000d\\u000a        $validImage = $false;\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    Remove-Variable unattendReg\\u000d\\u000a\\u000d\\u000a    # verify if efs is disabled\\u000d\\u000a    $fileSystemRegPath = ('HKLM:\\\\'+ $vhd_hive + '\\\\ControlSet001\\\\Control\\\\FileSystem')\\u000d\\u000a    $ntfsDisableEncryptionReg = (Get-ItemProperty $fileSystemRegPath NtfsDisableEncryption -ErrorAction SilentlyContinue).NtfsDisableEncryption \\u000d\\u000a\\u000d\\u000a    if ($ntfsDisableEncryptionReg -eq 0)\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$NtfsDisableEncryptionError])\\u000d\\u000a        $validImage = $false;\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    Remove-Variable ntfsDisableEncryptionReg\\u000d\\u000a\\u000d\\u000a\\u0009#verify that RDCB role is not installed\\u000d\\u000a\\u0009$rdcbIsInstalled = $false\\u000d\\u000a\\u0009$tssdisRegKeyValue = \\\"\\\"\\u000d\\u000a\\u0009try\\u000d\\u000a\\u0009{\\u000d\\u000a \\u0009\\u0009$tssdisRegKeyValue = Get-Item ('HKLM:\\\\' + $vhd_hive + '\\\\ControlSet001\\\\Services\\\\Tssdis') -ErrorAction Stop\\u000d\\u000a\\u0009\\u0009$rdcbIsInstalled = $true\\u000d\\u000a\\u0009}\\u000d\\u000a\\u0009catch\\u000d\\u000a\\u0009{\\u000d\\u000a\\u0009\\u0009if ($_.Exception.GetType().ToString() -ne \\\"System.Management.Automation.ItemNotFoundException\\\")\\u000d\\u000a\\u0009\\u0009{\\u000d\\u000a\\u0009\\u0009\\u0009Write-Verbose($CurrentCultureTable[$FailedToReadTssdisRegistryKeyScriptError] + $_.Exception.Message)\\u000d\\u000a\\u0009\\u0009}\\u000d\\u000a\\u0009}\\u000d\\u000a    if ($rdcbIsInstalled)\\u000d\\u000a    {\\u000d\\u000a\\u0009   Write-Error ($CurrentCultureTable[$RdcbRoleInstalledScriptError])\\u000d\\u000a\\u0009   $validImage = $false;\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    Remove-Variable tssdisRegKeyValue\\u000d\\u000a\\u000d\\u000a    # unload system reg hive\\u000d\\u000a    [GC]::Collect()\\u000d\\u000a\\u000d\\u000a    if(!($validateCurrentOS))\\u000d\\u000a    {\\u000d\\u000a        Unload-Reghive($vhd_hive)\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    # verify unattend file locations\\u000d\\u000a    if(Test-Path -LiteralPath ($winVolume + \\\"windows\\\\Panther\\\\Unattend\\\\Unattend.xml\\\") -PathType Leaf)\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$UnattendFileError] + \\\" $winDrive\\\\windows\\\\Panther\\\\Unattend\\\\Unattend.xml.\\\")\\u000d\\u000a        $validImage = $false\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    if(Test-Path -LiteralPath ($winVolume + \\\"windows\\\\Panther\\\\Unattend\\\\Autounattend.xml\\\") -PathType Leaf)\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$UnattendFileError] + \\\" $winDrive\\\\windows\\\\Panther\\\\Unattend\\\\Autounattend.xml.\\\")\\u000d\\u000a        $validImage = $false\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    if(Test-Path -LiteralPath ($winVolume + \\\"windows\\\\Panther\\\\Unattend.xml\\\") -PathType Leaf)\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$UnattendFileError] + \\\" $winDrive\\\\windows\\\\Panther\\\\Unattend.xml.\\\")\\u000d\\u000a        $validImage = $false\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    if(Test-Path -LiteralPath ($winVolume + \\\"windows\\\\Panther\\\\Autounattend.xml\\\") -PathType Leaf)\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$UnattendFileError] + \\\" $winDrive\\\\windows\\\\Panther\\\\Autounattend.xml.\\\")\\u000d\\u000a        $validImage = $false\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    if(Test-Path -LiteralPath ($winVolume + \\\"Unattend.xml\\\") -PathType Leaf)\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$UnattendFileError] + \\\" Found: $winDrive\\\\Unattend.xml.\\\")\\u000d\\u000a        $validImage = $false\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    if(Test-Path -LiteralPath ($winVolume + \\\"Autounattend.xml\\\") -PathType Leaf)\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$UnattendFileError] + \\\" $winDrive\\\\Autounattend.xml.\\\")\\u000d\\u000a        $validImage = $false\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    # detach VHD\\u000d\\u000a    if(!($validateCurrentOS))\\u000d\\u000a    {\\u000d\\u000a        Detach-VHD($vhdPath)\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    return $validImage\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000a###############\\u000d\\u000a# Main script #\\u000d\\u000a###############\\u000d\\u000a\\u000d\\u000a\\u000d\\u000a$verbosepreference='continue';\\u000d\\u000a\\u000d\\u000a$isRunningAsAdmin = Is-RunningAsAdmin\\u000d\\u000aif (!($isRunningAsAdmin))\\u000d\\u000a{\\u000d\\u000a    Write-Error ($CurrentCultureTable[$NotRunningAsAdminScriptError])\\u000d\\u000a    return\\u000d\\u000a}\\u000d\\u000aif(!($validateCurrentOS))\\u000d\\u000a{\\u000d\\u000a    #Get OS Version of the machine where this script is running\\u000d\\u000a    $IsStorageModuleAvailable = $false\\u000d\\u000a    $CurrentVersionKey = 'HKLM:\\\\SOFTWARE\\\\Microsoft\\\\Windows NT\\\\CurrentVersion'\\u000d\\u000a    $OsVersion = (Get-ItemProperty -Path $CurrentVersionKey -Name CurrentVersion).CurrentVersion\\u000d\\u000a    if ($OsVersion -ge 6.3)\\u000d\\u000a    {\\u000d\\u000a       $IsStorageModuleAvailable = $true\\u000d\\u000a    }\\u000d\\u000a    else\\u000d\\u000a    {\\u000d\\u000a       Write-Verbose ($CurrentCultureTable[$ClientMachineRunningOnDownlevelOs])\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    if ($IsStorageModuleAvailable)\\u000d\\u000a    {\\u000d\\u000a       #Import storage module and make sure it loaded correctly\\u000d\\u000a       Write-Verbose ($CurrentCultureTable[$ImportingStorageModuleScriptText])\\u000d\\u000a       try\\u000d\\u000a       {\\u000d\\u000a          Import-Module \\\"Storage\\\"\\u000d\\u000a       }\\u000d\\u000a       catch\\u000d\\u000a       {\\u000d\\u000a          Write-Error($CurrentCultureTable[$StorageModuleImportFailed])\\u000d\\u000a          return\\u000d\\u000a       }\\u000d\\u000a\\u000d\\u000a       $storageModule = get-module \\\"Storage\\\"\\u000d\\u000a       if($null -eq ($storageModule))\\u000d\\u000a       {\\u000d\\u000a           Write-Error ($CurrentCultureTable[$FailedToLoadStorageModuleError])\\u000d\\u000a           return\\u000d\\u000a       }\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    # Import Azure module and make sure azure module is loaded\\u000d\\u000a    Write-Verbose ($CurrentCultureTable[$ImportingAzureModuleScriptText])\\u000d\\u000a    Import-Module \\\"azure\\\"\\u000d\\u000a    $azmodule = get-module \\\"azure\\\" \\u000d\\u000a    if($null -eq ($azmodule))\\u000d\\u000a    {\\u000d\\u000a        Write-Error ($CurrentCultureTable[$FailedToLoadAzureModuleError])\\u000d\\u000a        return\\u000d\\u000a    }\\u000d\\u000a\\u000d\\u000a    if ([string]::IsNullOrEmpty($vhdPath))\\u000d\\u000a    {\\u000d\\u000a        $vhdPaths = Get-File\\u000d\\u000a        $vhdPath = $vhdPaths[0]\\u000d\\u000a    }\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000a$validImage = Test-MohoroImageRequirements\\u000d\\u000a\\u000d\\u000aif(!($validImage))\\u000d\\u000a{\\u000d\\u000a    Write-Error ($CurrentCultureTable[$NotRemoteAppReadyImageScriptError])\\u000d\\u000a    return\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000aif($validateCurrentOS)\\u000d\\u000a{\\u000d\\u000a    Write-Host($CurrentCultureTable[$CurrentOsCheckSuccess])\\u000d\\u000a    return\\u000d\\u000a}\\u000d\\u000a\\u000d\\u000aWrite-Output $CurrentCultureTable[$StartingImageUploadScriptText]\\u000d\\u000a$vhdContext = Add-AzureVhd -Destination ($uri+$sas) -LocalFilePath $vhdPath\\u000d\\u000aif($null -ne $vhdContext)\\u000d\\u000a{\\u000d\\u000a    # no need to load the storage lib, as it is already loaded by azure PS\\u000d\\u000a    $sasCred = New-Object Microsoft.WindowsAzure.Storage.Auth.StorageCredentials($sas)\\u000d\\u000a    $imageBlob = New-Object Microsoft.WindowsAzure.Storage.Blob.CloudPageBlob($uri, $sasCred)\\u000d\\u000a\\u000d\\u000a    $imageBlob.Metadata[\\\"Status\\\"] = \\\"UploadComplete\\\"\\u000d\\u000a    $imageBlob.SetMetadata()\\u000d\\u000a    $vhdContext\\u000d\\u000a    Write-Output $CurrentCultureTable[$ImageUploadCompleteScriptText]\\u000d\\u000a}\\u000d\\u000a\"",
      "ResponseHeaders": {
        "Content-Length": [
          "38872"
        ],
        "Content-Type": [
          "application/json; charset=utf-8"
        ],
        "x-ms-servedbyregion": [
          "uswest"
        ],
        "x-ms-request-id": [
          "165b5f9e7637607989cbca2178fc3ae6"
        ],
        "Cache-Control": [
          "no-cache"
        ],
        "Date": [
          "Sun, 01 Feb 2015 10:37:37 GMT"
        ],
        "Server": [
          "1.0.6190.5218",
          "(rd_rdfe_n.150128-1022)",
          "Microsoft-HTTPAPI/2.0"
        ]
      },
      "StatusCode": 200
    }
  ],
  "Names": {},
  "Variables": {
    "SubscriptionId": "30da001a-1a9e-48a1-8b77-e5abcfe38bdc"
  }
}