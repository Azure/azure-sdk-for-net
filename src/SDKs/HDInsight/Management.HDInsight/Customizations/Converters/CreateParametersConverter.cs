// Copyright (c) Microsoft Corporation. All rights reserved.
// Licensed under the MIT License. See License.txt in the project root for
// license information.
//
// Code generated by Microsoft (R) AutoRest Code Generator 1.0.1.0
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.

namespace Microsoft.Azure.Management.HDInsight
{
    using Microsoft.Azure.Management.HDInsight.Models;
    using System;
    using System.Collections.Generic;
    using System.Linq;

    public static class CreateParametersConverter
    {
        public static ClusterCreateParametersExtended GetExtendedClusterCreateParameters(string clusterName, ClusterCreateParameters createParameters)
        {
            //Deep copy so the createParameters object isn't touched.
            ClusterCreateParameters clusterCreateParameters = new ClusterCreateParameters(createParameters);

            //Convert to extended spec.
            ClusterCreateParametersExtended extendedParams = new ClusterCreateParametersExtended
            {
                Location = clusterCreateParameters.Location,
                Tags = clusterCreateParameters.Tags,
                Properties = new ClusterCreateProperties
                {
                    ClusterDefinition = new ClusterDefinition
                    {
                        Kind = clusterCreateParameters.ClusterType,
                        ComponentVersion = clusterCreateParameters.ComponentVersion,
                        Configurations = GetConfigurations(clusterName, clusterCreateParameters)
                    },
                    Tier = clusterCreateParameters.ClusterTier,
                    ClusterVersion = clusterCreateParameters.Version,
                    ComputeProfile = new ComputeProfile
                    {
                        Roles = GetRoleCollection(clusterCreateParameters)
                    },
                    OsType = OSType.Linux,
                    SecurityProfile = clusterCreateParameters.SecurityProfile,
                    StorageProfile = GetStorageProfile(clusterCreateParameters)
                }
            };

            return extendedParams;
        }

        public static string GetNodeSize(ClusterCreateParameters createProperties, ClusterNodeType nodeType)
        {
            switch (nodeType)
            {
                case ClusterNodeType.HeadNode:
                    if (!string.IsNullOrEmpty(createProperties.HeadNodeSize))
                    {
                        return createProperties.HeadNodeSize;
                    }
                    return DefaultVmSizes.HeadNode.GetSize(createProperties.ClusterType);
                case ClusterNodeType.WorkerNode:
                    if (!string.IsNullOrEmpty(createProperties.WorkerNodeSize))
                    {
                        return createProperties.WorkerNodeSize;
                    }
                    return DefaultVmSizes.WorkerNode.GetSize(createProperties.ClusterType);
                case ClusterNodeType.ZookeeperNode:
                    if (!string.IsNullOrEmpty(createProperties.ZookeeperNodeSize))
                    {
                        return createProperties.ZookeeperNodeSize;
                    }
                    return DefaultVmSizes.ZookeeperNode.GetSize(createProperties.ClusterType);
                case ClusterNodeType.EdgeNode:
                    if (!string.IsNullOrEmpty(createProperties.EdgeNodeSize))
                    {
                        return createProperties.EdgeNodeSize;
                    }
                    return DefaultVmSizes.EdgeNode.GetSize(createProperties.ClusterType);
                default:
                    throw new ArgumentOutOfRangeException("nodeType");
            }
        }

        private static Dictionary<string, Dictionary<string, string>> GetConfigurations(string clusterName, ClusterCreateParameters createProperties)
        {
            Dictionary<string, Dictionary<string, string>> configurations = new Dictionary<string, Dictionary<string, string>>(createProperties.Configurations);

            //Add storage account info to core config.
            AddStorageAccountsToCoreConfig(clusterName, createProperties, configurations);

            //Add cluster username/password to gateway config.
            AddClusterCredentialToGatewayConfig(createProperties, configurations);

            //Add ADL configurations if necessary.
            AddDataLakePropertiesIfNecessary(createProperties, configurations);

            //Add metastore configurations if necessary.
            AddMetastoreConfigsToConfigurations(createProperties, configurations);

            return configurations;
        }

        private static void AddStorageAccountsToCoreConfig(string clusterName, ClusterCreateParameters createProperties, IDictionary<string, Dictionary<string, string>> configurations)
        {
            //Note: Only HDI >v2.1 is supported.

            //Get existing core configs.
            Dictionary<string, string> coreConfig = GetExistingConfigurationsForType(configurations, ConfigurationKey.CoreSite);

            // Note: Only WASB and ADLS Gen 1 storage accounts will be populated directly into configurations.
            //       Other storage account types will be populated into StorageProfile.
            AzureStorageInfo azureStorageAccountInfo = createProperties.DefaultStorageInfo as AzureStorageInfo;
            AzureDataLakeStoreInfo azureDataLakeStorageInfo = createProperties.DefaultStorageInfo as AzureDataLakeStoreInfo;

            if (azureStorageAccountInfo != null)
            {
                //Add configurations for default WASB storage.
                string container = string.IsNullOrWhiteSpace(azureStorageAccountInfo.StorageContainer)
                    ? clusterName
                    : azureStorageAccountInfo.StorageContainer;

                coreConfig[Constants.StorageConfigurations.DefaultFsKey] = string.Format(Constants.StorageConfigurations.DefaultFsWasbValueFormat,
                    container, azureStorageAccountInfo.StorageAccountName);

                string defaultStorageConfigKey = string.Format(Constants.StorageConfigurations.WasbStorageAccountKeyFormat, azureStorageAccountInfo.StorageAccountName);
                if (!string.IsNullOrEmpty(azureStorageAccountInfo.StorageAccountKey))
                {
                    coreConfig[defaultStorageConfigKey] = azureStorageAccountInfo.StorageAccountKey;
                }
            }
            else if (azureDataLakeStorageInfo != null)
            {
                //Add configurations for default ADL storage.
                coreConfig[Constants.StorageConfigurations.DefaultFsKey] = Constants.StorageConfigurations.DefaultFsAdlValue;
                coreConfig[Constants.StorageConfigurations.AdlHostNameKey] = azureDataLakeStorageInfo.StorageAccountName;
                coreConfig[Constants.StorageConfigurations.AdlMountPointKey] = azureDataLakeStorageInfo.StorageRootPath;
            }

            //Add additional storage accounts.
            Dictionary<string, string> additionalStorageAccounts = createProperties.AdditionalStorageAccounts ?? new Dictionary<string, string>();
            foreach (KeyValuePair<string, string> storageAccount in additionalStorageAccounts)
            {
                string configKey = string.Format(Constants.StorageConfigurations.WasbStorageAccountKeyFormat, storageAccount.Key);
                coreConfig[configKey] = storageAccount.Value;
            }
            
            configurations[ConfigurationKey.CoreSite] = coreConfig;
        }

        private static void AddClusterCredentialToGatewayConfig(ClusterCreateParameters createProperties, IDictionary<string, Dictionary<string, string>> configurations)
        {
            Dictionary<string, string> gatewayConfig = GetExistingConfigurationsForType(configurations, ConfigurationKey.Gateway);

            if (!string.IsNullOrEmpty(createProperties.UserName))
            {
                gatewayConfig[Constants.GatewayConfigurations.CredentialIsEnabledKey] = "true";
                gatewayConfig[Constants.GatewayConfigurations.UserNameKey] = createProperties.UserName;
                gatewayConfig[Constants.GatewayConfigurations.PasswordKey] = createProperties.Password;
            }
            else
            {
                gatewayConfig[Constants.GatewayConfigurations.CredentialIsEnabledKey] = "false";
            }

            configurations[ConfigurationKey.Gateway] = gatewayConfig;
        }

        private static Dictionary<string, string> GetExistingConfigurationsForType(IDictionary<string, Dictionary<string, string>> configurations, string configurationType)
        {
            Dictionary<string, string> config;
            if (!configurations.TryGetValue(configurationType, out config))
            {
                config = new Dictionary<string, string>();
            }

            return config;
        }
        
        private static void AddDataLakePropertiesIfNecessary(ClusterCreateParameters createProperties, IDictionary<string, Dictionary<string, string>> configurations)
        {
            ServicePrincipal servicePrincipal = createProperties.Principal as ServicePrincipal;
            if (servicePrincipal == null) return;

            Dictionary<string, string> datalakeConfig = new Dictionary<string, string>
            {
                {Constants.DataLakeConfigurations.ApplicationIdKey, servicePrincipal.ApplicationId.ToString()},
                {
                    // Converting the Tenant ID to URI as RP expects this to be URI.
                    // ADL is only supported in a handful of regions in public Azure. We should be on the next API version before this goes to sovereign clouds.
                    Constants.DataLakeConfigurations.TenantIdKey, string.Format("{0}{1}", "https://login.windows.net/", servicePrincipal.AADTenantId)
                },
                {Constants.DataLakeConfigurations.CertificateKey, Convert.ToBase64String(servicePrincipal.CertificateFileBytes)},
                {Constants.DataLakeConfigurations.CertificatePasswordKey, servicePrincipal.CertificatePassword},
                {Constants.DataLakeConfigurations.ResourceUriKey, servicePrincipal.ResourceUri.ToString()}
            };

            configurations[ConfigurationKey.ClusterIdentity] = datalakeConfig;
        }

        private static void AddMetastoreConfigsToConfigurations(ClusterCreateParameters createProperties, IDictionary<string, Dictionary<string, string>> configurations)
        {
            Metastore hiveMetastore = createProperties.HiveMetastore;
            if (hiveMetastore != null)
            {
                if (!hiveMetastore.Server.Contains("."))
                {
                    throw new ArgumentException("Please provide the fully qualified metastore name.");
                }

                string connectionUrl =
                    string.Format(Constants.MetastoreConfigurations.ConnectionUrlFormat, hiveMetastore.Server, hiveMetastore.Database);

                configurations.Add(ConfigurationKey.HiveSite, new Dictionary<string, string>
                {
                    {Constants.MetastoreConfigurations.HiveSite.ConnectionUrlKey, connectionUrl},
                    {Constants.MetastoreConfigurations.HiveSite.ConnectionUserNameKey, hiveMetastore.User},
                    {Constants.MetastoreConfigurations.HiveSite.ConnectionPasswordKey, hiveMetastore.Password},
                    {Constants.MetastoreConfigurations.HiveSite.ConnectionDriverNameKey, Constants.MetastoreConfigurations.HiveSite.ConnectionDriverNameValue}
                });

                configurations.Add(ConfigurationKey.HiveEnv, new Dictionary<string, string>
                {
                    {Constants.MetastoreConfigurations.HiveEnv.DatabaseKey, Constants.MetastoreConfigurations.DatabaseValue},
                    {Constants.MetastoreConfigurations.HiveEnv.DatabaseNameKey, hiveMetastore.Database},
                    {Constants.MetastoreConfigurations.HiveEnv.DatabaseTypeKey, Constants.MetastoreConfigurations.DatabaseTypeValue},
                    {Constants.MetastoreConfigurations.HiveEnv.ExistingDatabaseKey, hiveMetastore.Database},
                    {Constants.MetastoreConfigurations.HiveEnv.ExistingHostKey, hiveMetastore.Server},
                    {Constants.MetastoreConfigurations.HiveEnv.HostNameKey, hiveMetastore.Server}
                });
            }

            Metastore oozieMetastore = createProperties.OozieMetastore;
            if (oozieMetastore != null)
            {
                if (Uri.CheckHostName(oozieMetastore.Server) != UriHostNameType.Dns)
                {
                    throw new ArgumentException("Please provide the fully qualified metastore name.");
                }
                string connectionUrl = string.Format(Constants.MetastoreConfigurations.ConnectionUrlFormat, oozieMetastore.Server, oozieMetastore.Database);

                configurations.Add(ConfigurationKey.OozieSite, new Dictionary<string, string>
                {
                    {Constants.MetastoreConfigurations.OozieSite.UrlKey, connectionUrl},
                    {Constants.MetastoreConfigurations.OozieSite.UserNameKey, oozieMetastore.User},
                    {Constants.MetastoreConfigurations.OozieSite.PasswordKey, oozieMetastore.Password},
                    {Constants.MetastoreConfigurations.OozieSite.DriverKey, Constants.MetastoreConfigurations.OozieSite.DriverValue},
                    {Constants.MetastoreConfigurations.OozieSite.SchemaKey, Constants.MetastoreConfigurations.OozieSite.SchemaValue}
                });

                configurations.Add(ConfigurationKey.OozieEnv, new Dictionary<string, string>
                {
                    {Constants.MetastoreConfigurations.OozieEnv.DatabaseKey, Constants.MetastoreConfigurations.DatabaseValue},
                    {Constants.MetastoreConfigurations.OozieEnv.DatabaseNameKey, oozieMetastore.Database},
                    {Constants.MetastoreConfigurations.OozieEnv.DatabaseTypeKey, Constants.MetastoreConfigurations.DatabaseTypeValue},
                    {Constants.MetastoreConfigurations.OozieEnv.ExistingDatabaseKey, oozieMetastore.Database},
                    {Constants.MetastoreConfigurations.OozieEnv.ExistingHostKey, oozieMetastore.Server},
                    {Constants.MetastoreConfigurations.OozieEnv.HostNameKey, oozieMetastore.Server}
                });
            }
        }

        private static IList<Role> GetRoleCollection(ClusterCreateParameters createProperties)
        {
            List<Role> roles = new List<Role>();

            OsProfile osProfile = GetOsProfile(createProperties);
            VirtualNetworkProfile vnetProfile = GetVnetProfile(createProperties);

            //Set up headnode and add to collection.
            List<ScriptAction> headNodeScriptActions = GetScriptActionsForRoleType(createProperties, ClusterNodeType.HeadNode);
            string headNodeSize = GetNodeSize(createProperties, ClusterNodeType.HeadNode);
            int headNodeInstanceCount = createProperties.ClusterType.Equals("Sandbox", StringComparison.OrdinalIgnoreCase) ? 1 : 2;
            Role headNode = GetRole(osProfile, vnetProfile, ClusterNodeType.HeadNode, headNodeScriptActions, headNodeInstanceCount, headNodeSize);
            roles.Add(headNode);

            //Sandbox clusters only contain a headnode. Return here.
            if (createProperties.ClusterType.Equals("Sandbox", StringComparison.OrdinalIgnoreCase))
            {
                return roles;
            }

            //Set up workernode and add to collection.
            List<ScriptAction> workerNodeScriptActions = GetScriptActionsForRoleType(createProperties, ClusterNodeType.WorkerNode);
            string workerNodeSize = GetNodeSize(createProperties, ClusterNodeType.WorkerNode);
            Role workerNode = GetRole(osProfile, vnetProfile, ClusterNodeType.WorkerNode, workerNodeScriptActions, createProperties.ClusterSizeInNodes, workerNodeSize);
            workerNode.DataDisksGroups = createProperties.WorkerNodeDataDisksGroups;
            roles.Add(workerNode);

            //Set up zookeepernode and add to collection.
            List<ScriptAction> zookeeperNodeScriptActions = GetScriptActionsForRoleType(createProperties, ClusterNodeType.ZookeeperNode);
            string zookeeperNodeSize = GetNodeSize(createProperties, ClusterNodeType.ZookeeperNode);
            Role zookeeperNode = GetRole(osProfile, vnetProfile, ClusterNodeType.ZookeeperNode, zookeeperNodeScriptActions, 3, zookeeperNodeSize);
            roles.Add(zookeeperNode);

            //RServer & MLServices clusters contain an additional edge node. Return here for all other types.
            if (!new[] { "RServer", "MLServices" }.Contains(createProperties.ClusterType, StringComparer.OrdinalIgnoreCase))
                {
                return roles;
            }

            //Set up edgenode and add to collection.
            string edgeNodeSize = GetNodeSize(createProperties, ClusterNodeType.EdgeNode);
            Role edgeNode = GetRole(osProfile, vnetProfile, ClusterNodeType.EdgeNode, null, 1, edgeNodeSize);
            roles.Add(edgeNode);

            return roles;
        }

        private static OsProfile GetOsProfile(ClusterCreateParameters createProperties)
        {
            List<SshPublicKey> sshPublicKeys = new List<SshPublicKey>();
            if (!string.IsNullOrEmpty(createProperties.SshPublicKey))
            {
                sshPublicKeys.Add(new SshPublicKey
                {
                    CertificateData = createProperties.SshPublicKey
                });
            }
            SshProfile sshProfile = null;
            if (sshPublicKeys.Count > 0)
            {
                sshProfile = new SshProfile
                {
                    PublicKeys = sshPublicKeys.ToArray()
                };
            }

            return new OsProfile
            {
                LinuxOperatingSystemProfile = new LinuxOperatingSystemProfile
                {
                    SshProfile = sshProfile,
                    Password = createProperties.SshPassword,
                    Username = createProperties.SshUserName
                }
            };
        }

        private static List<ScriptAction> GetScriptActionsForRoleType(ClusterCreateParameters createProperties, ClusterNodeType nodeType)
        {
            if (createProperties.ScriptActions == null) return null;
            List<ScriptAction> scriptActions;
            createProperties.ScriptActions.TryGetValue(nodeType, out scriptActions);
            return scriptActions;
        }

        private static VirtualNetworkProfile GetVnetProfile(ClusterCreateParameters createProperties)
        {
            VirtualNetworkProfile vnetProfile = new VirtualNetworkProfile();
            if (!string.IsNullOrEmpty(createProperties.VirtualNetworkId))
            {
                vnetProfile.Id = createProperties.VirtualNetworkId;
            }
            if (!string.IsNullOrEmpty(createProperties.SubnetName))
            {
                vnetProfile.Subnet = createProperties.SubnetName;
            }
            if (string.IsNullOrEmpty(createProperties.VirtualNetworkId) && string.IsNullOrEmpty(createProperties.SubnetName))
            {
                vnetProfile = null;
            }
            return vnetProfile;
        }

        private static Role GetRole(OsProfile osProfile, VirtualNetworkProfile vnetProfile, ClusterNodeType nodeType, List<ScriptAction> scriptActions, int instanceCount,
            string vmSize)
        {
            return new Role
            {
                Name = nodeType.ToString().ToLower(),
                TargetInstanceCount = instanceCount,
                HardwareProfile = new HardwareProfile
                {
                    VmSize = vmSize
                },
                VirtualNetworkProfile = vnetProfile,
                OsProfile = osProfile,
                ScriptActions = scriptActions
            };
        }

        private static StorageProfile GetStorageProfile(ClusterCreateParameters createProperties)
        {
            // Note: Only WASB and ADLS Gen 1 storage accounts will be populated directly into configurations.
            //       Other storage account types will be populated into StorageProfile.
            AzureDataLakeStoreGen2Info adlsGen2Info = createProperties.DefaultStorageInfo as AzureDataLakeStoreGen2Info;
            if (adlsGen2Info == null)
            {
                return null;
            }

            return new StorageProfile
            {
                Storageaccounts = new[]
                {
                    new StorageAccount
                    {
                        Name = adlsGen2Info.StorageAccountName,
                        FileSystem = adlsGen2Info.StorageFileSystem,
                        Key = adlsGen2Info.StorageAccountKey,
                        IsDefault = true
                    }
                }
            };
        }
    }
}
