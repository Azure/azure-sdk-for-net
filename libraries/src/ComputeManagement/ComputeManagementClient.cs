// 
// Copyright (c) Microsoft.  All rights reserved.
// 
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//   http://www.apache.org/licenses/LICENSE-2.0
// 
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// 
// See the License for the specific language governing permissions and
// limitations under the License.
// 

// Warning: This code was generated by a tool.
// 
// Changes to this file may cause incorrect behavior and will be lost if the
// code is regenerated.

using System;
using System.Collections.Generic;
using System.Globalization;
using System.Linq;
using System.Net;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Threading;
using System.Threading.Tasks;
using System.Xml.Linq;
using Microsoft.WindowsAzure;
using Microsoft.WindowsAzure.Common;
using Microsoft.WindowsAzure.Common.Internals;
using Microsoft.WindowsAzure.Management.Compute;
using Microsoft.WindowsAzure.Management.Compute.Models;

namespace Microsoft.WindowsAzure.Management.Compute.Models
{
    /// <summary>
    /// The set of access control rules for the endpoint
    /// </summary>
    public partial class AccessControlList
    {
        private IList<AccessControlListRule> _rules;
        
        /// <summary>
        /// The set of access control rules for the endpoint
        /// </summary>
        public IList<AccessControlListRule> Rules
        {
            get { return this._rules; }
            set { this._rules = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the AccessControlList class.
        /// </summary>
        public AccessControlList()
        {
            this._rules = new List<AccessControlListRule>();
        }
    }
    
    /// <summary>
    /// An access control rule for a public endpoint
    /// </summary>
    public partial class AccessControlListRule
    {
        private int? _order;
        
        /// <summary>
        /// the order of application for this Access Control List Rule
        /// </summary>
        public int? Order
        {
            get { return this._order; }
            set { this._order = value; }
        }
        
        private string _action;
        
        /// <summary>
        /// the action allowed by this Access Control List Rule
        /// </summary>
        public string Action
        {
            get { return this._action; }
            set { this._action = value; }
        }
        
        private string _remoteSubnet;
        
        /// <summary>
        /// the remote subnet that is granted access for this Access Control
        /// List Rule
        /// </summary>
        public string RemoteSubnet
        {
            get { return this._remoteSubnet; }
            set { this._remoteSubnet = value; }
        }
        
        private string _description;
        
        /// <summary>
        /// the description for this Access Control List Rule
        /// </summary>
        public string Description
        {
            get { return this._description; }
            set { this._description = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the AccessControlListRule class.
        /// </summary>
        public AccessControlListRule()
        {
        }
    }
    
    /// <summary>
    /// The service certificate format. Windows Azure supports the pfx and cer
    /// file formats.
    /// </summary>
    public enum CertificateFormat
    {
        Pfx = 0,
        
        Cer = 1,
    }
    
    /// <summary>
    /// Algorithm that was used to hash a service certificate.
    /// </summary>
    public static partial class CertificateThumbprintAlgorithms
    {
        public const string Sha1 = "sha1";
    }
    
    /// <summary>
    /// The response body contains the status of the specified asynchronous
    /// operation, indicating whether it has succeeded, is inprogress, or has
    /// failed. Note that this status is distinct from the HTTP status code
    /// returned for the Get Operation Status operation itself.  If the
    /// asynchronous operation succeeded, the response body includes the HTTP
    /// status code for the successful request.  If the asynchronous operation
    /// failed, the response body includes the HTTP status code for the failed
    /// request, and also includes error information regarding the failure.
    /// </summary>
    public partial class ComputeOperationStatusResponse : OperationResponse
    {
        private string _id;
        
        /// <summary>
        /// The request ID of the asynchronous request. This value is returned
        /// in the x-ms-request-id response header of the asynchronous request.
        /// </summary>
        public string Id
        {
            get { return this._id; }
            set { this._id = value; }
        }
        
        private OperationStatus _status;
        
        /// <summary>
        /// The status of the asynchronous request.
        /// </summary>
        public OperationStatus Status
        {
            get { return this._status; }
            set { this._status = value; }
        }
        
        private HttpStatusCode _httpStatusCode;
        
        /// <summary>
        /// The HTTP status code for the asynchronous request.
        /// </summary>
        public HttpStatusCode HttpStatusCode
        {
            get { return this._httpStatusCode; }
            set { this._httpStatusCode = value; }
        }
        
        private ComputeOperationStatusResponse.ErrorDetails _error;
        
        /// <summary>
        /// If the asynchronous operation failed, the response body includes
        /// the HTTP status code for the failed request, and also includes
        /// error information regarding the failure.
        /// </summary>
        public ComputeOperationStatusResponse.ErrorDetails Error
        {
            get { return this._error; }
            set { this._error = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the ComputeOperationStatusResponse
        /// class.
        /// </summary>
        public ComputeOperationStatusResponse()
        {
        }
        
        /// <summary>
        /// If the asynchronous operation failed, the response body includes
        /// the HTTP status code for the failed request, and also includes
        /// error information regarding the failure.
        /// </summary>
        public partial class ErrorDetails
        {
            private string _code;
            
            /// <summary>
            /// The management service error code returned if the asynchronous
            /// request failed.
            /// </summary>
            public string Code
            {
                get { return this._code; }
                set { this._code = value; }
            }
            
            private string _message;
            
            /// <summary>
            /// The management service error message returned if the
            /// asynchronous request failed.
            /// </summary>
            public string Message
            {
                get { return this._message; }
                set { this._message = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the ErrorDetails class.
            /// </summary>
            public ErrorDetails()
            {
            }
        }
    }
    
    /// <summary>
    /// Objects that provide system or application data.
    /// </summary>
    public partial class ConfigurationSet
    {
        private string _configurationSetType;
        
        /// <summary>
        /// Specifies the configuration type for the configuration set.
        /// </summary>
        public string ConfigurationSetType
        {
            get { return this._configurationSetType; }
            set { this._configurationSetType = value; }
        }
        
        private IList<InputEndpoint> _inputEndpoints;
        
        /// <summary>
        /// Contains a collection of external endpoints for the virtual
        /// machine.  This element is only used with the
        /// NetworkConfigurationSet type.
        /// </summary>
        public IList<InputEndpoint> InputEndpoints
        {
            get { return this._inputEndpoints; }
            set { this._inputEndpoints = value; }
        }
        
        private IList<string> _subnetNames;
        
        /// <summary>
        /// The list of Virtual Network subnet names that the deployment
        /// belongs to.  This element is only used with the
        /// NetworkConfigurationSet type.
        /// </summary>
        public IList<string> SubnetNames
        {
            get { return this._subnetNames; }
            set { this._subnetNames = value; }
        }
        
        private string _computerName;
        
        /// <summary>
        /// Optional. Specifies the computer name for the virtual machine. If
        /// the computer name is not specified, a name is created based on the
        /// name of the role.  Computer names must be 1 to 15 characters in
        /// length. This element is only used with the
        /// WindowsProvisioningConfiguration set.
        /// </summary>
        public string ComputerName
        {
            get { return this._computerName; }
            set { this._computerName = value; }
        }
        
        private string _adminPassword;
        
        /// <summary>
        /// Required. Specifies the string representing the administrator
        /// password to use for the virtual machine.
        /// </summary>
        public string AdminPassword
        {
            get { return this._adminPassword; }
            set { this._adminPassword = value; }
        }
        
        private bool? _resetPasswordOnFirstLogon;
        
        /// <summary>
        /// Optional. Specifies whether password should be reset the first time
        /// the administrator logs in.
        /// </summary>
        public bool? ResetPasswordOnFirstLogon
        {
            get { return this._resetPasswordOnFirstLogon; }
            set { this._resetPasswordOnFirstLogon = value; }
        }
        
        private bool? _enableAutomaticUpdates;
        
        /// <summary>
        /// Optional. Specifies whether automatic updates are enabled for the
        /// virtual machine. This element is only used with the
        /// WindowsProvisioningConfiguration set. The default value is false.
        /// </summary>
        public bool? EnableAutomaticUpdates
        {
            get { return this._enableAutomaticUpdates; }
            set { this._enableAutomaticUpdates = value; }
        }
        
        private string _timeZone;
        
        /// <summary>
        /// Optional.  Specifies the time zone for the virtual machine. This
        /// element is only used with the WindowsProvisioningConfiguration
        /// set.  For a complete list of supported time zone entries, you can:
        /// Refer to the values listed in the registry entry
        /// HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows
        /// NT\CurrentVersion\Time Zones on a computer running Windows 7,
        /// Windows Server 2008, and Windows Server 2008 R2.  You can use the
        /// tzutil command-line tool to list the valid time. The tzutil tool
        /// is installed by default on Windows 7, Windows Server 2008, and
        /// Windows Server 2008 R2.
        /// </summary>
        public string TimeZone
        {
            get { return this._timeZone; }
            set { this._timeZone = value; }
        }
        
        private DomainJoinSettings _domainJoin;
        
        /// <summary>
        /// Optional.  Contains properties that specify a domain to which the
        /// virtual machine will be joined. This element is only used with the
        /// WindowsProvisioningConfiguration set.
        /// </summary>
        public DomainJoinSettings DomainJoin
        {
            get { return this._domainJoin; }
            set { this._domainJoin = value; }
        }
        
        private IList<StoredCertificateSettings> _storedCertificateSettings;
        
        /// <summary>
        /// Optional. Contains a list of service certificates with which to
        /// provision to the new role. This element is only used with the
        /// WindowsProvisioningConfiguration set.
        /// </summary>
        public IList<StoredCertificateSettings> StoredCertificateSettings
        {
            get { return this._storedCertificateSettings; }
            set { this._storedCertificateSettings = value; }
        }
        
        private WindowsRemoteManagementSettings _windowsRemoteManagement;
        
        /// <summary>
        /// Optional. Configures the Windows Remote Management service on the
        /// virtual machine, which enables remote Windows PowerShell.
        /// </summary>
        public WindowsRemoteManagementSettings WindowsRemoteManagement
        {
            get { return this._windowsRemoteManagement; }
            set { this._windowsRemoteManagement = value; }
        }
        
        private string _adminUserName;
        
        /// <summary>
        /// Required. Specifies the name that is used to rename the default
        /// administrator account. This is a required parameter after version
        /// 2013-03-01.
        /// </summary>
        public string AdminUserName
        {
            get { return this._adminUserName; }
            set { this._adminUserName = value; }
        }
        
        private string _hostName;
        
        /// <summary>
        /// Required. Specifies the host name for the VM. Host names are ASCII
        /// character strings 1 to 64 characters in length. This element is
        /// only used with the LinuxProvisioningConfiguration set.
        /// </summary>
        public string HostName
        {
            get { return this._hostName; }
            set { this._hostName = value; }
        }
        
        private string _userName;
        
        /// <summary>
        /// Required. Specifies the name of a user to be created in the sudoer
        /// group of the virtual machine. User names are ASCII character
        /// strings 1 to 32 characters in length. This element is only used
        /// with the LinuxProvisioningConfiguration set.
        /// </summary>
        public string UserName
        {
            get { return this._userName; }
            set { this._userName = value; }
        }
        
        private string _userPassword;
        
        /// <summary>
        /// Required. Specifies the password for user name. Passwords are ASCII
        /// character strings 6 to 72 characters in length. This element is
        /// only used with the LinuxProvisioningConfiguration set.
        /// </summary>
        public string UserPassword
        {
            get { return this._userPassword; }
            set { this._userPassword = value; }
        }
        
        private bool? _disableSshPasswordAuthentication;
        
        /// <summary>
        /// Optional. Specifies whether or not SSH authentication is disabled
        /// for the password. This element is only used with the
        /// LinuxProvisioningConfiguration set. By default this value is set
        /// to true.
        /// </summary>
        public bool? DisableSshPasswordAuthentication
        {
            get { return this._disableSshPasswordAuthentication; }
            set { this._disableSshPasswordAuthentication = value; }
        }
        
        private SshSettings _sshSettings;
        
        /// <summary>
        /// Optional. Specifies the SSH public keys and key pairs to populate
        /// in the image during provisioning. This element is only used with
        /// the LinuxProvisioningConfiguration set.
        /// </summary>
        public SshSettings SshSettings
        {
            get { return this._sshSettings; }
            set { this._sshSettings = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the ConfigurationSet class.
        /// </summary>
        public ConfigurationSet()
        {
            this._inputEndpoints = new List<InputEndpoint>();
            this._subnetNames = new List<string>();
            this._storedCertificateSettings = new List<StoredCertificateSettings>();
        }
    }
    
    /// <summary>
    /// Specifies the configuration type for the configuration set.
    /// </summary>
    public static partial class ConfigurationSetTypes
    {
        public const string NetworkConfigurationSet = "NetworkConfigurationSet";
        
        public const string WindowsProvisioningConfiguration = "WindowsProvisioningConfiguration";
        
        public const string LinuxProvisioningConfiguration = "LinuxProvisioningConfiguration";
    }
    
    /// <summary>
    /// Objects that are used to create a data disk for a virtual machine.
    /// </summary>
    public partial class DataVirtualHardDisk
    {
        private Microsoft.WindowsAzure.Management.Compute.Models.VirtualHardDiskHostCaching? _hostCaching;
        
        /// <summary>
        /// Specifies the platform caching behavior of the data disk blob for
        /// read/write efficiency. The default vault is ReadOnly.
        /// </summary>
        public Microsoft.WindowsAzure.Management.Compute.Models.VirtualHardDiskHostCaching? HostCaching
        {
            get { return this._hostCaching; }
            set { this._hostCaching = value; }
        }
        
        private string _diskLabel;
        
        /// <summary>
        /// Specifies the friendly name of the VHD to use to create thedata
        /// disk for the virtual machine.
        /// </summary>
        public string DiskLabel
        {
            get { return this._diskLabel; }
            set { this._diskLabel = value; }
        }
        
        private string _diskName;
        
        /// <summary>
        /// Specifies the name of the VHD to use to create thedata disk for the
        /// virtual machine.
        /// </summary>
        public string DiskName
        {
            get { return this._diskName; }
            set { this._diskName = value; }
        }
        
        private int? _logicalUnitNumber;
        
        /// <summary>
        /// Specifies the Logical Unit Number (LUN) for the data disk. The LUN
        /// specifies the slot in which the data drive appears when mounted
        /// for usage by the virtual machine. This element is only listed when
        /// more than one data disk is attached to a virtual machine.
        /// </summary>
        public int? LogicalUnitNumber
        {
            get { return this._logicalUnitNumber; }
            set { this._logicalUnitNumber = value; }
        }
        
        private int _logicalDiskSizeInGB;
        
        /// <summary>
        /// Specifies the size, in GB, of an empty VHD to be attached to the
        /// virtual machine. The VHD can be created as part of disk attach or
        /// create virtual machine call by specifying the value for this
        /// property.  Windows Azure creates the empty VHD based on size
        /// preference and attaches the newly created VHD to the virtual
        /// machine.
        /// </summary>
        public int LogicalDiskSizeInGB
        {
            get { return this._logicalDiskSizeInGB; }
            set { this._logicalDiskSizeInGB = value; }
        }
        
        private Uri _mediaLink;
        
        /// <summary>
        /// Specifies the location of the disk in Windows Azure storage.
        /// </summary>
        public Uri MediaLink
        {
            get { return this._mediaLink; }
            set { this._mediaLink = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DataVirtualHardDisk class.
        /// </summary>
        public DataVirtualHardDisk()
        {
        }
    }
    
    public enum DeploymentChangeConfigurationMode
    {
        Auto = 0,
        
        Manual = 1,
    }
    
    /// <summary>
    /// Parameters supplied to the Change Configuration Deployment operation.
    /// </summary>
    public partial class DeploymentChangeConfigurationParameters
    {
        private string _configuration;
        
        /// <summary>
        /// Required. The base-64 encoded service configuration file for the
        /// deployment.
        /// </summary>
        public string Configuration
        {
            get { return this._configuration; }
            set { this._configuration = value; }
        }
        
        private bool? _treatWarningsAsError;
        
        /// <summary>
        /// Optional. Indicates whether to treat package validation warnings as
        /// errors. The default value is false. If set to true, the Created
        /// Deployment operation fails if there are validation warnings on the
        /// service package.
        /// </summary>
        public bool? TreatWarningsAsError
        {
            get { return this._treatWarningsAsError; }
            set { this._treatWarningsAsError = value; }
        }
        
        private Microsoft.WindowsAzure.Management.Compute.Models.DeploymentChangeConfigurationMode? _mode;
        
        /// <summary>
        /// Optional. Possible values are: Auto, Manual.  If not specified the
        /// default value is Auto. If set to Manual, WalkUpgradeDomain must be
        /// called to apply the update. If set to Auto, the update is
        /// automatically applied to each update domain for the service.
        /// </summary>
        public Microsoft.WindowsAzure.Management.Compute.Models.DeploymentChangeConfigurationMode? Mode
        {
            get { return this._mode; }
            set { this._mode = value; }
        }
        
        private IDictionary<string, string> _extendedProperties;
        
        /// <summary>
        /// Optional. Represents the name of an extended deployment property.
        /// Each extended property must have both a defined name and value.
        /// You can have a maximum of 25 extended property name/value pairs.
        /// The maximum length of the Name element is 64 characters, only
        /// alphanumeric characters and underscores are valid in the Name, and
        /// the name must start with a letter. Attempting to use other
        /// characters, starting the Name with a non-letter character, or
        /// entering a name that is identical to that of another extended
        /// property owned by the same hosted service, will result in a status
        /// code 400 (Bad Request) error.
        /// </summary>
        public IDictionary<string, string> ExtendedProperties
        {
            get { return this._extendedProperties; }
            set { this._extendedProperties = value; }
        }
        
        private ExtensionConfiguration _extensionConfiguration;
        
        /// <summary>
        /// Optional. Represents an extension that is added to the cloud
        /// service. In Windows Azure, a process can run as an extension of a
        /// cloud service. For example, Remote Desktop Access or the Windows
        /// Azure Diagnostics Agent can run as extensions to the cloud
        /// service. You must add an extension to the cloud service by using
        /// Add Extension before it can be added to the deployment.
        /// </summary>
        public ExtensionConfiguration ExtensionConfiguration
        {
            get { return this._extensionConfiguration; }
            set { this._extensionConfiguration = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// DeploymentChangeConfigurationParameters class.
        /// </summary>
        public DeploymentChangeConfigurationParameters()
        {
            this._extendedProperties = new Dictionary<string, string>();
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Create Deployment operation.
    /// </summary>
    public partial class DeploymentCreateParameters
    {
        private string _name;
        
        /// <summary>
        /// Required. The name for the deployment. The deployment name must be
        /// unique among other deployments for the cloud service.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private Uri _packageUri;
        
        /// <summary>
        /// Required. A URL that refers to the location of the service package
        /// in the Blob service. The service package can be located either in
        /// a storage account beneath the same subscription or a Shared Access
        /// Signature (SAS) URI from any storage account. For more info about
        /// Shared Access Signatures, see Delegating Access with a Shared
        /// Access Signature (REST API) at
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee395415.aspx.
        /// </summary>
        public Uri PackageUri
        {
            get { return this._packageUri; }
            set { this._packageUri = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// Required. A name for the hosted service that is base-64 encoded.
        /// The name can be up to 100 characters in length. It is recommended
        /// that the label be unique within the subscription. The name can be
        /// used identify the hosted service for your tracking purposes.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private string _configuration;
        
        /// <summary>
        /// Required. The base-64 encoded service configuration file for the
        /// deployment.
        /// </summary>
        public string Configuration
        {
            get { return this._configuration; }
            set { this._configuration = value; }
        }
        
        private bool? _startDeployment;
        
        /// <summary>
        /// Optional. Indicates whether to start the deployment immediately
        /// after it is created. The default value is false.  If false, the
        /// service model is still deployed to the virtual machines but the
        /// code is not run immediately. Instead, the service is Suspended
        /// until you call Update Deployment Status and set the status
        /// toRunning, at which time the service will be started. A deployed
        /// service still incurs charges, even if it is suspended.
        /// </summary>
        public bool? StartDeployment
        {
            get { return this._startDeployment; }
            set { this._startDeployment = value; }
        }
        
        private bool? _treatWarningsAsError;
        
        /// <summary>
        /// Optional. Indicates whether to treat package validation warnings as
        /// errors. The default value is false. If set to true, the Created
        /// Deployment operation fails if there are validation warnings on the
        /// service package.
        /// </summary>
        public bool? TreatWarningsAsError
        {
            get { return this._treatWarningsAsError; }
            set { this._treatWarningsAsError = value; }
        }
        
        private IDictionary<string, string> _extendedProperties;
        
        /// <summary>
        /// Optional. Represents the name of an extended deployment property.
        /// Each extended property must have both a defined name and value.
        /// You can have a maximum of 25 extended property name/value pairs.
        /// The maximum length of the Name element is 64 characters, only
        /// alphanumeric characters and underscores are valid in the Name, and
        /// the name must start with a letter. Attempting to use other
        /// characters, starting the Name with a non-letter character, or
        /// entering a name that is identical to that of another extended
        /// property owned by the same hosted service, will result in a status
        /// code 400 (Bad Request) error.
        /// </summary>
        public IDictionary<string, string> ExtendedProperties
        {
            get { return this._extendedProperties; }
            set { this._extendedProperties = value; }
        }
        
        private ExtensionConfiguration _extensionConfiguration;
        
        /// <summary>
        /// Optional. Represents an extension that is added to the cloud
        /// service. In Windows Azure, a process can run as an extension of a
        /// cloud service. For example, Remote Desktop Access or the Windows
        /// Azure Diagnostics Agent can run as extensions to the cloud
        /// service. You must add an extension to the cloud service by using
        /// Add Extension before it can be added to the deployment.
        /// </summary>
        public ExtensionConfiguration ExtensionConfiguration
        {
            get { return this._extensionConfiguration; }
            set { this._extensionConfiguration = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DeploymentCreateParameters class.
        /// </summary>
        public DeploymentCreateParameters()
        {
            this._extendedProperties = new Dictionary<string, string>();
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Get Package operation.
    /// </summary>
    public partial class DeploymentGetPackageParameters
    {
        private Uri _containerUri;
        
        /// <summary>
        /// Required. Specifies the URI of the container to which the packages
        /// will be saved.
        /// </summary>
        public Uri ContainerUri
        {
            get { return this._containerUri; }
            set { this._containerUri = value; }
        }
        
        private bool? _overwriteExisting;
        
        /// <summary>
        /// Optional. Specifies whether an existing package in the storage
        /// container should be overwritten. If true the packages with the
        /// same names under the specified storage container will be
        /// overwritten; otherwise false.
        /// </summary>
        public bool? OverwriteExisting
        {
            get { return this._overwriteExisting; }
            set { this._overwriteExisting = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DeploymentGetPackageParameters
        /// class.
        /// </summary>
        public DeploymentGetPackageParameters()
        {
        }
    }
    
    /// <summary>
    /// A deployment that exists in the cloud service.
    /// </summary>
    public partial class DeploymentGetResponse : OperationResponse
    {
        private string _name;
        
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private DeploymentSlot _deploymentSlot;
        
        /// <summary>
        /// The deployment environment in which this deployment is running.
        /// </summary>
        public DeploymentSlot DeploymentSlot
        {
            get { return this._deploymentSlot; }
            set { this._deploymentSlot = value; }
        }
        
        private string _privateId;
        
        /// <summary>
        /// The unique identifier for this deployment.
        /// </summary>
        public string PrivateId
        {
            get { return this._privateId; }
            set { this._privateId = value; }
        }
        
        private DeploymentStatus _status;
        
        /// <summary>
        /// The status of the deployment.
        /// </summary>
        public DeploymentStatus Status
        {
            get { return this._status; }
            set { this._status = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// The base-64 encoded user supplied name of the deployment. This name
        /// can be used identify the deployment for your tracking purposes.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private Uri _uri;
        
        /// <summary>
        /// The URL used to access the hosted service.  For example, if the
        /// service name is MyService you could access the access the service
        /// by calling: http://MyService.cloudapp.net
        /// </summary>
        public Uri Uri
        {
            get { return this._uri; }
            set { this._uri = value; }
        }
        
        private string _configuration;
        
        /// <summary>
        /// The base-64 encoded the configuration file of the deployment.
        /// </summary>
        public string Configuration
        {
            get { return this._configuration; }
            set { this._configuration = value; }
        }
        
        private IList<RoleInstance> _roleInstances;
        
        /// <summary>
        /// The list of role instances in the deployment.
        /// </summary>
        public IList<RoleInstance> RoleInstances
        {
            get { return this._roleInstances; }
            set { this._roleInstances = value; }
        }
        
        private UpgradeStatus _upgradeStatus;
        
        /// <summary>
        /// Specifies information about an update occurring on the deployment.
        /// </summary>
        public UpgradeStatus UpgradeStatus
        {
            get { return this._upgradeStatus; }
            set { this._upgradeStatus = value; }
        }
        
        private int _upgradeDomainCount;
        
        /// <summary>
        /// The number of upgrade domains available to this cloud service.
        /// </summary>
        public int UpgradeDomainCount
        {
            get { return this._upgradeDomainCount; }
            set { this._upgradeDomainCount = value; }
        }
        
        private IList<Role> _roles;
        
        /// <summary>
        /// The list of roles in the deployment.
        /// </summary>
        public IList<Role> Roles
        {
            get { return this._roles; }
            set { this._roles = value; }
        }
        
        private string _sdkVersion;
        
        /// <summary>
        /// The version of the Windows Azure SDK that was used to generate the
        /// .cspkg that created this deployment.  The first two numerical
        /// components of the returned version represent the version of the
        /// SDK used to create the package.
        /// </summary>
        public string SdkVersion
        {
            get { return this._sdkVersion; }
            set { this._sdkVersion = value; }
        }
        
        private bool _locked;
        
        /// <summary>
        /// Indicates whether the deployment is locked for new write
        /// operations. True if the deployment is locked because an existing
        /// operation is updating the deployment; otherwise false.
        /// </summary>
        public bool Locked
        {
            get { return this._locked; }
            set { this._locked = value; }
        }
        
        private string _rollbackAllowed;
        
        /// <summary>
        /// Indicates whether the Rollback Update Or Upgrade operation is
        /// allowed at this time. True if the operation is allowed; otherwise
        /// false.
        /// </summary>
        public string RollbackAllowed
        {
            get { return this._rollbackAllowed; }
            set { this._rollbackAllowed = value; }
        }
        
        private DateTime _createdTime;
        
        /// <summary>
        /// The time that the deployment was created.
        /// </summary>
        public DateTime CreatedTime
        {
            get { return this._createdTime; }
            set { this._createdTime = value; }
        }
        
        private DateTime _lastModifiedTime;
        
        /// <summary>
        /// The last time that the deployment was modified.
        /// </summary>
        public DateTime LastModifiedTime
        {
            get { return this._lastModifiedTime; }
            set { this._lastModifiedTime = value; }
        }
        
        private string _virtualNetworkName;
        
        /// <summary>
        /// The name of the Virtual Network that the virtual machine connects
        /// to.
        /// </summary>
        public string VirtualNetworkName
        {
            get { return this._virtualNetworkName; }
            set { this._virtualNetworkName = value; }
        }
        
        private IDictionary<string, string> _extendedProperties;
        
        /// <summary>
        /// Optional. Represents the name of an extended cloud service
        /// property. Each extended property must have both a defined name and
        /// value. You can have a maximum of 50 extended property name and
        /// value pairs.  The maximum length of the Name element is 64
        /// characters, only alphanumeric characters and underscores are valid
        /// in the name, and it must start with a letter. Attempting to use
        /// other characters, starting with a non-letter character, or
        /// entering a name that is identical to that of another extended
        /// property owned by the same service, will result in a status code
        /// 400 (Bad Request) error.  Each extended property value has a
        /// maximum length of 255 characters.
        /// </summary>
        public IDictionary<string, string> ExtendedProperties
        {
            get { return this._extendedProperties; }
            set { this._extendedProperties = value; }
        }
        
        private PersistentVMDowntime _persistentVMDowntime;
        
        /// <summary>
        /// Specifies information about when the virtual machine has been
        /// started and stopped.
        /// </summary>
        public PersistentVMDowntime PersistentVMDowntime
        {
            get { return this._persistentVMDowntime; }
            set { this._persistentVMDowntime = value; }
        }
        
        private IList<VirtualIPAddress> _virtualIPAddresses;
        
        /// <summary>
        /// The virtual IP addresses that are specified for thedeployment.
        /// </summary>
        public IList<VirtualIPAddress> VirtualIPAddresses
        {
            get { return this._virtualIPAddresses; }
            set { this._virtualIPAddresses = value; }
        }
        
        private DnsSettings _dnsSettings;
        
        /// <summary>
        /// The custom DNS settings that are specified for deployment.
        /// </summary>
        public DnsSettings DnsSettings
        {
            get { return this._dnsSettings; }
            set { this._dnsSettings = value; }
        }
        
        private ExtensionConfiguration _extensionConfiguration;
        
        /// <summary>
        /// Represents an extension that is added to the cloud service.
        /// </summary>
        public ExtensionConfiguration ExtensionConfiguration
        {
            get { return this._extensionConfiguration; }
            set { this._extensionConfiguration = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DeploymentGetResponse class.
        /// </summary>
        public DeploymentGetResponse()
        {
            this._roleInstances = new List<RoleInstance>();
            this._roles = new List<Role>();
            this._extendedProperties = new Dictionary<string, string>();
            this._virtualIPAddresses = new List<VirtualIPAddress>();
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Rollback Update Or Upgrade operation.
    /// </summary>
    public partial class DeploymentRollbackUpdateOrUpgradeParameters
    {
        private RollbackUpdateOrUpgradeMode _mode;
        
        /// <summary>
        /// Required. Specifies whether the rollback should proceed
        /// automatically.
        /// </summary>
        public RollbackUpdateOrUpgradeMode Mode
        {
            get { return this._mode; }
            set { this._mode = value; }
        }
        
        private bool _force;
        
        /// <summary>
        /// Required. Specifies whether the rollback should proceed even when
        /// it will cause local data to be lost from some role instances. True
        /// if the rollback should proceed; otherwise false.
        /// </summary>
        public bool Force
        {
            get { return this._force; }
            set { this._force = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// DeploymentRollbackUpdateOrUpgradeParameters class.
        /// </summary>
        public DeploymentRollbackUpdateOrUpgradeParameters()
        {
        }
    }
    
    /// <summary>
    /// The deployment environment in which this deployment is running.
    /// </summary>
    public enum DeploymentSlot
    {
        Staging = 0,
        
        Production = 1,
    }
    
    /// <summary>
    /// The status of the deployment.
    /// </summary>
    public enum DeploymentStatus
    {
        Running = 0,
        
        Suspended = 1,
        
        RunningTransitioning = 2,
        
        SuspendedTransitioning = 3,
        
        Starting = 4,
        
        Suspending = 5,
        
        Deploying = 6,
        
        Deleting = 7,
    }
    
    /// <summary>
    /// Parameters supplied to the Swap Deployment operation.
    /// </summary>
    public partial class DeploymentSwapParameters
    {
        private string _productionDeployment;
        
        /// <summary>
        /// The optional  name of the production deployment.
        /// </summary>
        public string ProductionDeployment
        {
            get { return this._productionDeployment; }
            set { this._productionDeployment = value; }
        }
        
        private string _sourceDeployment;
        
        /// <summary>
        /// Required. The name of the source deployment.
        /// </summary>
        public string SourceDeployment
        {
            get { return this._sourceDeployment; }
            set { this._sourceDeployment = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DeploymentSwapParameters class.
        /// </summary>
        public DeploymentSwapParameters()
        {
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Update Deployment Status operation.
    /// </summary>
    public partial class DeploymentUpdateStatusParameters
    {
        private UpdatedDeploymentStatus _status;
        
        /// <summary>
        /// Required. The new status of the deployment.
        /// </summary>
        public UpdatedDeploymentStatus Status
        {
            get { return this._status; }
            set { this._status = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DeploymentUpdateStatusParameters
        /// class.
        /// </summary>
        public DeploymentUpdateStatusParameters()
        {
        }
    }
    
    public enum DeploymentUpgradeMode
    {
        Auto = 0,
        
        Manual = 1,
        
        Simultaneous = 2,
    }
    
    /// <summary>
    /// Parameters supplied to the Upgrade Deployment operation.
    /// </summary>
    public partial class DeploymentUpgradeParameters
    {
        private DeploymentUpgradeMode _mode;
        
        /// <summary>
        /// Required. The type of update to initiate. Role instances are
        /// allocated to update domains when the service is deployed. Updates
        /// can be initiated manually in each update domain or initiated
        /// automatically in all update domains. Possible values are: Auto,
        /// Manual.  If not specified, the default value is Auto. If set to
        /// Manual, WalkUpgradeDomain must be called to apply the update. If
        /// set to Auto, the update is automatically applied to each update
        /// domain in sequence.
        /// </summary>
        public DeploymentUpgradeMode Mode
        {
            get { return this._mode; }
            set { this._mode = value; }
        }
        
        private Uri _packageUri;
        
        /// <summary>
        /// Required. A URL that refers to the location of the service package
        /// in the Blob service. The service package can be located either in
        /// a storage account beneath the same subscription or a Shared Access
        /// Signature (SAS) URI from any storage account. For more info about
        /// Shared Access Signatures, see Delegating Access with a Shared
        /// Access Signature (REST API) at
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee395415.aspx.
        /// </summary>
        public Uri PackageUri
        {
            get { return this._packageUri; }
            set { this._packageUri = value; }
        }
        
        private string _configuration;
        
        /// <summary>
        /// Required. The base-64 encoded service configuration file for the
        /// deployment.
        /// </summary>
        public string Configuration
        {
            get { return this._configuration; }
            set { this._configuration = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// Required. A name for the hosted service that is base-64 encoded.
        /// The name can be up to 100 characters in length. It is recommended
        /// that the label be unique within the subscription. The name can be
        /// used identify the hosted service for your tracking purposes.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private string _roleToUpgrade;
        
        /// <summary>
        /// Optional. The name of the specific role instance to update.
        /// </summary>
        public string RoleToUpgrade
        {
            get { return this._roleToUpgrade; }
            set { this._roleToUpgrade = value; }
        }
        
        private bool _force;
        
        /// <summary>
        /// Required. Specifies whether the rollback should proceed even when
        /// it will cause local data to be lost from some role instances. True
        /// if the rollback should proceed; otherwise false.
        /// </summary>
        public bool Force
        {
            get { return this._force; }
            set { this._force = value; }
        }
        
        private IDictionary<string, string> _extendedProperties;
        
        /// <summary>
        /// Optional. Represents the name of an extended deployment property.
        /// Each extended property must have both a defined name and value.
        /// You can have a maximum of 25 extended property name/value pairs.
        /// The maximum length of the Name element is 64 characters, only
        /// alphanumeric characters and underscores are valid in the Name, and
        /// the name must start with a letter. Attempting to use other
        /// characters, starting the Name with a non-letter character, or
        /// entering a name that is identical to that of another extended
        /// property owned by the same hosted service, will result in a status
        /// code 400 (Bad Request) error.
        /// </summary>
        public IDictionary<string, string> ExtendedProperties
        {
            get { return this._extendedProperties; }
            set { this._extendedProperties = value; }
        }
        
        private ExtensionConfiguration _extensionConfiguration;
        
        /// <summary>
        /// Optional. Represents an extension that is added to the cloud
        /// service. In Windows Azure, a process can run as an extension of a
        /// cloud service. For example, Remote Desktop Access or the Windows
        /// Azure Diagnostics Agent can run as extensions to the cloud
        /// service. You must add an extension to the cloud service by using
        /// Add Extension before it can be added to the deployment.
        /// </summary>
        public ExtensionConfiguration ExtensionConfiguration
        {
            get { return this._extensionConfiguration; }
            set { this._extensionConfiguration = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DeploymentUpgradeParameters class.
        /// </summary>
        public DeploymentUpgradeParameters()
        {
            this._extendedProperties = new Dictionary<string, string>();
        }
    }
    
    /// <summary>
    /// The type of the upgrade.
    /// </summary>
    public enum DeploymentUpgradeType
    {
        Auto = 0,
        
        Manual = 1,
    }
    
    /// <summary>
    /// Parameters supplied to the Walk Upgrade Domain operation.
    /// </summary>
    public partial class DeploymentWalkUpgradeDomainParameters
    {
        private int _upgradeDomain;
        
        /// <summary>
        /// Required. An integer value that identifies the update domain to
        /// update. Update domains are identified with a zero-based index: the
        /// first update domain has an ID of 0, the second has an ID of 1, and
        /// so on.
        /// </summary>
        public int UpgradeDomain
        {
            get { return this._upgradeDomain; }
            set { this._upgradeDomain = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// DeploymentWalkUpgradeDomainParameters class.
        /// </summary>
        public DeploymentWalkUpgradeDomainParameters()
        {
        }
    }
    
    /// <summary>
    /// Information about a DNS Server in the virtual network
    /// </summary>
    public partial class DnsServer
    {
        private string _name;
        
        /// <summary>
        /// The name of the DNS server
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private string _address;
        
        /// <summary>
        /// The DNS server address
        /// </summary>
        public string Address
        {
            get { return this._address; }
            set { this._address = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DnsServer class.
        /// </summary>
        public DnsServer()
        {
        }
    }
    
    /// <summary>
    /// The custom DNS settings that are specified for deployment.
    /// </summary>
    public partial class DnsSettings
    {
        private IList<DnsServer> _dnsServers;
        
        /// <summary>
        /// Contains a collection of objects that define the DNS server
        /// settings.
        /// </summary>
        public IList<DnsServer> DnsServers
        {
            get { return this._dnsServers; }
            set { this._dnsServers = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DnsSettings class.
        /// </summary>
        public DnsSettings()
        {
            this._dnsServers = new List<DnsServer>();
        }
    }
    
    /// <summary>
    /// Optional. Specifies the values to use to join the virtual machine to
    /// the domain.
    /// </summary>
    public partial class DomainJoinCredentials
    {
        private string _domain;
        
        /// <summary>
        /// Optional. Specifies the name of the domain used to authenticate an
        /// account. The value is a fully qualified DNS domain.  If the
        /// domains name is not specified, Username must specify the user
        /// principal name (UPN) format (user@fully-qualified-DNS-domain) or
        /// the fully-qualified-DNS-domain\username format.  Example:
        /// example.com
        /// </summary>
        public string Domain
        {
            get { return this._domain; }
            set { this._domain = value; }
        }
        
        private string _userName;
        
        /// <summary>
        /// Required. Specifies a user name in the domain that can be used to
        /// join the domain.
        /// </summary>
        public string UserName
        {
            get { return this._userName; }
            set { this._userName = value; }
        }
        
        private string _password;
        
        /// <summary>
        /// Required. Specifies the password to use to join the domain.
        /// </summary>
        public string Password
        {
            get { return this._password; }
            set { this._password = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DomainJoinCredentials class.
        /// </summary>
        public DomainJoinCredentials()
        {
        }
    }
    
    /// <summary>
    /// The configuration needed to provision the machine in the domain
    /// </summary>
    public partial class DomainJoinProvisioning
    {
        private string _accountData;
        
        /// <summary>
        /// The account infor for joining the domain
        /// </summary>
        public string AccountData
        {
            get { return this._accountData; }
            set { this._accountData = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DomainJoinProvisioning class.
        /// </summary>
        public DomainJoinProvisioning()
        {
        }
    }
    
    /// <summary>
    /// Optional.  Contains properties that specify a domain to which the
    /// virtual machine will be joined. This element is only used with the
    /// WindowsProvisioningConfiguration set.
    /// </summary>
    public partial class DomainJoinSettings
    {
        private DomainJoinCredentials _credentials;
        
        /// <summary>
        /// Optional. Specifies the values to use to join the virtual machine
        /// to the domain.
        /// </summary>
        public DomainJoinCredentials Credentials
        {
            get { return this._credentials; }
            set { this._credentials = value; }
        }
        
        private string _domainToJoin;
        
        /// <summary>
        /// Optional. Specifies the domain to join.
        /// </summary>
        public string DomainToJoin
        {
            get { return this._domainToJoin; }
            set { this._domainToJoin = value; }
        }
        
        private string _ldapMachineObjectOU;
        
        /// <summary>
        /// Optional. Specifies the Lightweight Directory Access Protocol
        /// (LDAP) X 500-distinguished name of the organizational unit (OU) in
        /// which the computer account is created. This account is in Active
        /// Directory on a domain controller in the domain to which the
        /// computer is being joined.  Example:
        /// OU=MyOu,OU=MyParentOu,DC=example.com,DC=MyCompany,DC=com
        /// </summary>
        public string LdapMachineObjectOU
        {
            get { return this._ldapMachineObjectOU; }
            set { this._ldapMachineObjectOU = value; }
        }
        
        private DomainJoinProvisioning _provisioning;
        
        /// <summary>
        /// Additional information for domain join provisioning
        /// </summary>
        public DomainJoinProvisioning Provisioning
        {
            get { return this._provisioning; }
            set { this._provisioning = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the DomainJoinSettings class.
        /// </summary>
        public DomainJoinSettings()
        {
        }
    }
    
    /// <summary>
    /// Represents an extension that is added to the cloud service
    /// </summary>
    public partial class ExtensionConfiguration
    {
        private IList<ExtensionConfiguration.Extension> _allRoles;
        
        /// <summary>
        /// Optional. Specifies a list of extensions that are applied to all
        /// roles in a deployment.
        /// </summary>
        public IList<ExtensionConfiguration.Extension> AllRoles
        {
            get { return this._allRoles; }
            set { this._allRoles = value; }
        }
        
        private IList<ExtensionConfiguration.NamedRole> _namedRoles;
        
        /// <summary>
        /// Optional. Specifies a list of extensions that are applied to
        /// specific roles in a deployment.
        /// </summary>
        public IList<ExtensionConfiguration.NamedRole> NamedRoles
        {
            get { return this._namedRoles; }
            set { this._namedRoles = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the ExtensionConfiguration class.
        /// </summary>
        public ExtensionConfiguration()
        {
            this._allRoles = new List<ExtensionConfiguration.Extension>();
            this._namedRoles = new List<ExtensionConfiguration.NamedRole>();
        }
        
        /// <summary>
        /// Specifies a list of extensions that are applied to specific roles
        /// in a deployment.
        /// </summary>
        public partial class NamedRole
        {
            private string _roleName;
            
            /// <summary>
            /// Required. Specifies the name of the role.
            /// </summary>
            public string RoleName
            {
                get { return this._roleName; }
                set { this._roleName = value; }
            }
            
            private IList<ExtensionConfiguration.Extension> _extensions;
            
            /// <summary>
            /// Required. Represents an extension that is to be deployed to a
            /// role in a cloud service.
            /// </summary>
            public IList<ExtensionConfiguration.Extension> Extensions
            {
                get { return this._extensions; }
                set { this._extensions = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the NamedRole class.
            /// </summary>
            public NamedRole()
            {
                this._extensions = new List<ExtensionConfiguration.Extension>();
            }
        }
        
        /// <summary>
        /// Represents an extension that is to be deployed to a role in a cloud
        /// service.
        /// </summary>
        public partial class Extension
        {
            private string _id;
            
            /// <summary>
            /// Required. The identifier of the extension. The identifier is
            /// created when the extension is added to the cloud service. You
            /// can find the Id of an extension that was added to a cloud
            /// service by using List Extensions.
            /// </summary>
            public string Id
            {
                get { return this._id; }
                set { this._id = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the Extension class.
            /// </summary>
            public Extension()
            {
            }
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Add Extension operation.
    /// </summary>
    public partial class HostedServiceAddExtensionParameters
    {
        private string _providerNamespace;
        
        /// <summary>
        /// The provider namespace of the extension. The provider namespace for
        /// Windows Azure extensions is Microsoft.Windows.Azure.Extensions.
        /// </summary>
        public string ProviderNamespace
        {
            get { return this._providerNamespace; }
            set { this._providerNamespace = value; }
        }
        
        private string _type;
        
        /// <summary>
        /// Required. The type of the extension.
        /// </summary>
        public string Type
        {
            get { return this._type; }
            set { this._type = value; }
        }
        
        private string _id;
        
        /// <summary>
        /// The identifier of the extension.
        /// </summary>
        public string Id
        {
            get { return this._id; }
            set { this._id = value; }
        }
        
        private string _thumbprint;
        
        /// <summary>
        /// The thumbprint of the certificate that is used to encrypt the
        /// configuration specified in PrivateConfiguration. If this element
        /// is not specified, a certificate may be automatically generated and
        /// added to the cloud service.
        /// </summary>
        public string Thumbprint
        {
            get { return this._thumbprint; }
            set { this._thumbprint = value; }
        }
        
        private string _thumbprintAlgorithm;
        
        /// <summary>
        /// The thumbprint algorithm of the certificate that is used toencrypt
        /// the configuration specified in PrivateConfiguration.
        /// </summary>
        public string ThumbprintAlgorithm
        {
            get { return this._thumbprintAlgorithm; }
            set { this._thumbprintAlgorithm = value; }
        }
        
        private string _publicConfiguration;
        
        /// <summary>
        /// The public configuration that is defined using the schema returned
        /// by the List Available Extensions operation.
        /// </summary>
        public string PublicConfiguration
        {
            get { return this._publicConfiguration; }
            set { this._publicConfiguration = value; }
        }
        
        private string _privateConfiguration;
        
        /// <summary>
        /// The private configuration that is defined using the schema returned
        /// by the List Available Extensions operation.
        /// </summary>
        public string PrivateConfiguration
        {
            get { return this._privateConfiguration; }
            set { this._privateConfiguration = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// HostedServiceAddExtensionParameters class.
        /// </summary>
        public HostedServiceAddExtensionParameters()
        {
        }
    }
    
    /// <summary>
    /// The Check Hosted Service Name Availability operation response.
    /// </summary>
    public partial class HostedServiceCheckNameAvailabilityResponse : OperationResponse
    {
        private bool _isAvailable;
        
        /// <summary>
        /// A boolean value that indicates whether the name is available for
        /// you to use. True if the name is available; otherwise false.  The
        /// operation returns false for reserved or profane words.
        /// </summary>
        public bool IsAvailable
        {
            get { return this._isAvailable; }
            set { this._isAvailable = value; }
        }
        
        private string _reason;
        
        /// <summary>
        /// Describes why the name cannot be used to create the cloud service.
        /// </summary>
        public string Reason
        {
            get { return this._reason; }
            set { this._reason = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// HostedServiceCheckNameAvailabilityResponse class.
        /// </summary>
        public HostedServiceCheckNameAvailabilityResponse()
        {
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Create Hosted Service operation.
    /// </summary>
    public partial class HostedServiceCreateParameters
    {
        private string _serviceName;
        
        /// <summary>
        /// Required. A name for the cloud service that is unique within
        /// Windows Azure. This name is the DNS prefix name and can be used to
        /// access the service.
        /// </summary>
        public string ServiceName
        {
            get { return this._serviceName; }
            set { this._serviceName = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// Required. A name for the cloud service that is base-64 encoded. The
        /// name can be up to 100 characters in length. The name can be used
        /// identify the storage account for your tracking purposes.
        /// </summary>
        public string Label
        {
            get
            {
                if (this._label == null)
                {
                    return this.ServiceName;
                }
                else
                {
                    return this._label;
                }
            }
            set { this._label = value; }
        }
        
        private string _description;
        
        /// <summary>
        /// Optional. A description for the cloud service. The description can
        /// be up to 1024 characters in length.
        /// </summary>
        public string Description
        {
            get { return this._description; }
            set { this._description = value; }
        }
        
        private string _location;
        
        /// <summary>
        /// Required if AffinityGroup is not specified. The location where the
        /// cloud service will be created.  Specify either Location or
        /// AffinityGroup, but not both. To list available locations, use the
        /// List Locations operation.
        /// </summary>
        public string Location
        {
            get { return this._location; }
            set { this._location = value; }
        }
        
        private string _affinityGroup;
        
        /// <summary>
        /// Required if Location is not specified. The name of an existing
        /// affinity group associated with this subscription. This name is a
        /// GUID and can be retrieved by examining the name element of the
        /// response body returned by the List Affinity Groups operation.
        /// Specify either Location or AffinityGroup, but not both. To list
        /// available affinity groups, use the List Affinity Groups operation.
        /// </summary>
        public string AffinityGroup
        {
            get { return this._affinityGroup; }
            set { this._affinityGroup = value; }
        }
        
        private IDictionary<string, string> _extendedProperties;
        
        /// <summary>
        /// Optional. Represents the name of an extended cloud service
        /// property. Each extended property must have both a defined name and
        /// value. You can have a maximum of 50 extended property name and
        /// value pairs.  The maximum length of the Name element is 64
        /// characters, only alphanumeric characters and underscores are valid
        /// in the name, and it must start with a letter. Attempting to use
        /// other characters, starting with a non-letter character, or
        /// entering a name that is identical to that of another extended
        /// property owned by the same service, will result in a status code
        /// 400 (Bad Request) error.  Each extended property value has a
        /// maximum length of 255 characters.
        /// </summary>
        public IDictionary<string, string> ExtendedProperties
        {
            get { return this._extendedProperties; }
            set { this._extendedProperties = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the HostedServiceCreateParameters
        /// class.
        /// </summary>
        public HostedServiceCreateParameters()
        {
            this._extendedProperties = new Dictionary<string, string>();
        }
    }
    
    /// <summary>
    /// The detailed Get Hosted Service operation response.
    /// </summary>
    public partial class HostedServiceGetDetailedResponse : HostedServiceGetResponse
    {
        private IList<HostedServiceGetDetailedResponse.Deployment> _deployments;
        
        /// <summary>
        /// The deployments that exist in the cloud service.
        /// </summary>
        public IList<HostedServiceGetDetailedResponse.Deployment> Deployments
        {
            get { return this._deployments; }
            set { this._deployments = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the HostedServiceGetDetailedResponse
        /// class.
        /// </summary>
        public HostedServiceGetDetailedResponse()
        {
            this._deployments = new List<HostedServiceGetDetailedResponse.Deployment>();
        }
        
        /// <summary>
        /// A deployment that exists in the cloud service.
        /// </summary>
        public partial class Deployment
        {
            private string _name;
            
            public string Name
            {
                get { return this._name; }
                set { this._name = value; }
            }
            
            private DeploymentSlot _deploymentSlot;
            
            /// <summary>
            /// The deployment environment in which this deployment is running.
            /// </summary>
            public DeploymentSlot DeploymentSlot
            {
                get { return this._deploymentSlot; }
                set { this._deploymentSlot = value; }
            }
            
            private string _privateId;
            
            /// <summary>
            /// The unique identifier for this deployment.
            /// </summary>
            public string PrivateId
            {
                get { return this._privateId; }
                set { this._privateId = value; }
            }
            
            private DeploymentStatus _status;
            
            /// <summary>
            /// The status of the deployment.
            /// </summary>
            public DeploymentStatus Status
            {
                get { return this._status; }
                set { this._status = value; }
            }
            
            private string _label;
            
            /// <summary>
            /// The base-64 encoded user supplied name of the deployment. This
            /// name can be used identify the deployment for your tracking
            /// purposes.
            /// </summary>
            public string Label
            {
                get { return this._label; }
                set { this._label = value; }
            }
            
            private Uri _uri;
            
            /// <summary>
            /// The URL used to access the hosted service.  For example, if the
            /// service name is MyService you could access the access the
            /// service by calling: http://MyService.cloudapp.net
            /// </summary>
            public Uri Uri
            {
                get { return this._uri; }
                set { this._uri = value; }
            }
            
            private string _configuration;
            
            /// <summary>
            /// The base-64 encoded the configuration file of the deployment.
            /// </summary>
            public string Configuration
            {
                get { return this._configuration; }
                set { this._configuration = value; }
            }
            
            private IList<RoleInstance> _roleInstances;
            
            /// <summary>
            /// The list of role instances in the deployment.
            /// </summary>
            public IList<RoleInstance> RoleInstances
            {
                get { return this._roleInstances; }
                set { this._roleInstances = value; }
            }
            
            private UpgradeStatus _upgradeStatus;
            
            /// <summary>
            /// Specifies information about an update occurring on the
            /// deployment.
            /// </summary>
            public UpgradeStatus UpgradeStatus
            {
                get { return this._upgradeStatus; }
                set { this._upgradeStatus = value; }
            }
            
            private int _upgradeDomainCount;
            
            /// <summary>
            /// The number of upgrade domains available to this cloud service.
            /// </summary>
            public int UpgradeDomainCount
            {
                get { return this._upgradeDomainCount; }
                set { this._upgradeDomainCount = value; }
            }
            
            private IList<Role> _roles;
            
            /// <summary>
            /// The list of roles in the deployment.
            /// </summary>
            public IList<Role> Roles
            {
                get { return this._roles; }
                set { this._roles = value; }
            }
            
            private string _sdkVersion;
            
            /// <summary>
            /// The version of the Windows Azure SDK that was used to generate
            /// the .cspkg that created this deployment.  The first two
            /// numerical components of the returned version represent the
            /// version of the SDK used to create the package.
            /// </summary>
            public string SdkVersion
            {
                get { return this._sdkVersion; }
                set { this._sdkVersion = value; }
            }
            
            private bool _locked;
            
            /// <summary>
            /// Indicates whether the deployment is locked for new write
            /// operations. True if the deployment is locked because an
            /// existing operation is updating the deployment; otherwise false.
            /// </summary>
            public bool Locked
            {
                get { return this._locked; }
                set { this._locked = value; }
            }
            
            private string _rollbackAllowed;
            
            /// <summary>
            /// Indicates whether the Rollback Update Or Upgrade operation is
            /// allowed at this time. True if the operation is allowed;
            /// otherwise false.
            /// </summary>
            public string RollbackAllowed
            {
                get { return this._rollbackAllowed; }
                set { this._rollbackAllowed = value; }
            }
            
            private DateTime _createdTime;
            
            /// <summary>
            /// The time that the deployment was created.
            /// </summary>
            public DateTime CreatedTime
            {
                get { return this._createdTime; }
                set { this._createdTime = value; }
            }
            
            private string _lastModifiedTime;
            
            /// <summary>
            /// The last time that the deployment was modified.
            /// </summary>
            public string LastModifiedTime
            {
                get { return this._lastModifiedTime; }
                set { this._lastModifiedTime = value; }
            }
            
            private string _virtualNetworkName;
            
            /// <summary>
            /// The name of the Virtual Network that the virtual machine
            /// connects to.
            /// </summary>
            public string VirtualNetworkName
            {
                get { return this._virtualNetworkName; }
                set { this._virtualNetworkName = value; }
            }
            
            private IDictionary<string, string> _extendedProperties;
            
            /// <summary>
            /// Optional. Represents the name of an extended cloud service
            /// property. Each extended property must have both a defined name
            /// and value. You can have a maximum of 50 extended property name
            /// and value pairs.  The maximum length of the Name element is 64
            /// characters, only alphanumeric characters and underscores are
            /// valid in the name, and it must start with a letter. Attempting
            /// to use other characters, starting with a non-letter character,
            /// or entering a name that is identical to that of another
            /// extended property owned by the same service, will result in a
            /// status code 400 (Bad Request) error.  Each extended property
            /// value has a maximum length of 255 characters.
            /// </summary>
            public IDictionary<string, string> ExtendedProperties
            {
                get { return this._extendedProperties; }
                set { this._extendedProperties = value; }
            }
            
            private PersistentVMDowntime _persistentVMDowntime;
            
            /// <summary>
            /// Specifies information about when the virtual machine has been
            /// started and stopped.
            /// </summary>
            public PersistentVMDowntime PersistentVMDowntime
            {
                get { return this._persistentVMDowntime; }
                set { this._persistentVMDowntime = value; }
            }
            
            private IList<VirtualIPAddress> _virtualIPAddresses;
            
            /// <summary>
            /// The virtual IP addresses that are specified for thedeployment.
            /// </summary>
            public IList<VirtualIPAddress> VirtualIPAddresses
            {
                get { return this._virtualIPAddresses; }
                set { this._virtualIPAddresses = value; }
            }
            
            private DnsSettings _dnsSettings;
            
            /// <summary>
            /// The custom DNS settings that are specified for deployment.
            /// </summary>
            public DnsSettings DnsSettings
            {
                get { return this._dnsSettings; }
                set { this._dnsSettings = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the Deployment class.
            /// </summary>
            public Deployment()
            {
                this._roleInstances = new List<RoleInstance>();
                this._roles = new List<Role>();
                this._extendedProperties = new Dictionary<string, string>();
                this._virtualIPAddresses = new List<VirtualIPAddress>();
            }
        }
    }
    
    /// <summary>
    /// The Get Extension operation response.
    /// </summary>
    public partial class HostedServiceGetExtensionResponse : OperationResponse
    {
        private string _providerNamespace;
        
        /// <summary>
        /// The provider namespace of the extension. The provider namespace for
        /// Windows Azure extensions is Microsoft.Windows.Azure.Extensions.
        /// </summary>
        public string ProviderNamespace
        {
            get { return this._providerNamespace; }
            set { this._providerNamespace = value; }
        }
        
        private string _type;
        
        /// <summary>
        /// Required. The type of the extension.
        /// </summary>
        public string Type
        {
            get { return this._type; }
            set { this._type = value; }
        }
        
        private string _id;
        
        /// <summary>
        /// The identifier of the extension.
        /// </summary>
        public string Id
        {
            get { return this._id; }
            set { this._id = value; }
        }
        
        private string _version;
        
        /// <summary>
        /// The version of the extension.
        /// </summary>
        public string Version
        {
            get { return this._version; }
            set { this._version = value; }
        }
        
        private string _thumbprint;
        
        /// <summary>
        /// The thumbprint of the certificate that is used to encrypt the
        /// configuration specified in PrivateConfiguration. If this element
        /// is not specified, a certificate may be automatically generated and
        /// added to the cloud service.
        /// </summary>
        public string Thumbprint
        {
            get { return this._thumbprint; }
            set { this._thumbprint = value; }
        }
        
        private string _thumbprintAlgorithm;
        
        /// <summary>
        /// The thumbprint algorithm of the certificate that is used toencrypt
        /// the configuration specified in PrivateConfiguration.
        /// </summary>
        public string ThumbprintAlgorithm
        {
            get { return this._thumbprintAlgorithm; }
            set { this._thumbprintAlgorithm = value; }
        }
        
        private string _publicConfiguration;
        
        /// <summary>
        /// The public configuration that is defined using the schema returned
        /// by the List Available Extensions operation.
        /// </summary>
        public string PublicConfiguration
        {
            get { return this._publicConfiguration; }
            set { this._publicConfiguration = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the HostedServiceGetExtensionResponse
        /// class.
        /// </summary>
        public HostedServiceGetExtensionResponse()
        {
        }
    }
    
    /// <summary>
    /// The Get Hosted Service operation response.
    /// </summary>
    public partial class HostedServiceGetResponse : OperationResponse
    {
        private Uri _uri;
        
        /// <summary>
        /// The Service Management API request URI used to performGet Hosted
        /// Service Properties requests against the cloud service.
        /// </summary>
        public Uri Uri
        {
            get { return this._uri; }
            set { this._uri = value; }
        }
        
        private string _serviceName;
        
        /// <summary>
        /// The name of the cloud service. This name is the DNS prefix name and
        /// can be used to access the cloud service. For example, if the cloud
        /// service name is MyService you could access the access the cloud
        /// service by calling: http://MyService.cloudapp.net
        /// </summary>
        public string ServiceName
        {
            get { return this._serviceName; }
            set { this._serviceName = value; }
        }
        
        private HostedServiceProperties _properties;
        
        /// <summary>
        /// The properties that are assigned to the cloud service.
        /// </summary>
        public HostedServiceProperties Properties
        {
            get { return this._properties; }
            set { this._properties = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the HostedServiceGetResponse class.
        /// </summary>
        public HostedServiceGetResponse()
        {
        }
    }
    
    /// <summary>
    /// The List Available Extensions operation response.
    /// </summary>
    public partial class HostedServiceListAvailableExtensionsResponse : OperationResponse, IEnumerable<HostedServiceListAvailableExtensionsResponse.ExtensionImage>
    {
        private IList<HostedServiceListAvailableExtensionsResponse.ExtensionImage> _extensionImages;
        
        /// <summary>
        /// The extensions that are available to add to your cloud service.
        /// </summary>
        public IList<HostedServiceListAvailableExtensionsResponse.ExtensionImage> ExtensionImages
        {
            get { return this._extensionImages; }
            set { this._extensionImages = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// HostedServiceListAvailableExtensionsResponse class.
        /// </summary>
        public HostedServiceListAvailableExtensionsResponse()
        {
            this._extensionImages = new List<HostedServiceListAvailableExtensionsResponse.ExtensionImage>();
        }
        
        /// <summary>
        /// Gets the sequence of ExtensionImages.
        /// </summary>
        public IEnumerator<HostedServiceListAvailableExtensionsResponse.ExtensionImage> GetEnumerator()
        {
            return this.ExtensionImages.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of ExtensionImages.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// An extension available to add to your cloud service.
        /// </summary>
        public partial class ExtensionImage
        {
            private string _providerNamespace;
            
            /// <summary>
            /// The provider namespace of the extension. The provider namespace
            /// for Windows Azure extensions is
            /// Microsoft.Windows.Azure.Extensions.
            /// </summary>
            public string ProviderNamespace
            {
                get { return this._providerNamespace; }
                set { this._providerNamespace = value; }
            }
            
            private string _type;
            
            /// <summary>
            /// Required. The type of the extension.
            /// </summary>
            public string Type
            {
                get { return this._type; }
                set { this._type = value; }
            }
            
            private string _label;
            
            /// <summary>
            /// The label that is used to identify the extension.
            /// </summary>
            public string Label
            {
                get { return this._label; }
                set { this._label = value; }
            }
            
            private string _version;
            
            /// <summary>
            /// The version of the extension.
            /// </summary>
            public string Version
            {
                get { return this._version; }
                set { this._version = value; }
            }
            
            private string _description;
            
            /// <summary>
            /// The description of the extension.
            /// </summary>
            public string Description
            {
                get { return this._description; }
                set { this._description = value; }
            }
            
            private string _thumbprintAlgorithm;
            
            /// <summary>
            /// The thumbprint algorithm of the certificate that is used for
            /// encryption.
            /// </summary>
            public string ThumbprintAlgorithm
            {
                get { return this._thumbprintAlgorithm; }
                set { this._thumbprintAlgorithm = value; }
            }
            
            private HostingResources _hostingResources;
            
            /// <summary>
            /// The type of resource that supports the extension. This value
            /// can be WebRole, WorkerRole, or WebRole|WorkerRole.
            /// </summary>
            public HostingResources HostingResources
            {
                get { return this._hostingResources; }
                set { this._hostingResources = value; }
            }
            
            private string _publicConfigurationSchema;
            
            /// <summary>
            /// The base64-encoded schema of the public configuration.
            /// </summary>
            public string PublicConfigurationSchema
            {
                get { return this._publicConfigurationSchema; }
                set { this._publicConfigurationSchema = value; }
            }
            
            private string _privateConfigurationSchema;
            
            /// <summary>
            /// The base64-encoded schema of the private configuration.
            /// </summary>
            public string PrivateConfigurationSchema
            {
                get { return this._privateConfigurationSchema; }
                set { this._privateConfigurationSchema = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the ExtensionImage class.
            /// </summary>
            public ExtensionImage()
            {
            }
        }
    }
    
    /// <summary>
    /// The List Extensions operation response.
    /// </summary>
    public partial class HostedServiceListExtensionsResponse : OperationResponse, IEnumerable<HostedServiceListExtensionsResponse.Extension>
    {
        private IList<HostedServiceListExtensionsResponse.Extension> _extensions;
        
        /// <summary>
        /// The extensions that were added to a cloud service.
        /// </summary>
        public IList<HostedServiceListExtensionsResponse.Extension> Extensions
        {
            get { return this._extensions; }
            set { this._extensions = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// HostedServiceListExtensionsResponse class.
        /// </summary>
        public HostedServiceListExtensionsResponse()
        {
            this._extensions = new List<HostedServiceListExtensionsResponse.Extension>();
        }
        
        /// <summary>
        /// Gets the sequence of Extensions.
        /// </summary>
        public IEnumerator<HostedServiceListExtensionsResponse.Extension> GetEnumerator()
        {
            return this.Extensions.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of Extensions.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// An extension that were added to a cloud service.
        /// </summary>
        public partial class Extension
        {
            private string _providerNamespace;
            
            /// <summary>
            /// The provider namespace of the extension. The provider namespace
            /// for Windows Azure extensions is
            /// Microsoft.Windows.Azure.Extensions.
            /// </summary>
            public string ProviderNamespace
            {
                get { return this._providerNamespace; }
                set { this._providerNamespace = value; }
            }
            
            private string _type;
            
            /// <summary>
            /// Required. The type of the extension.
            /// </summary>
            public string Type
            {
                get { return this._type; }
                set { this._type = value; }
            }
            
            private string _id;
            
            /// <summary>
            /// The identifier of the extension.
            /// </summary>
            public string Id
            {
                get { return this._id; }
                set { this._id = value; }
            }
            
            private string _version;
            
            /// <summary>
            /// The version of the extension.
            /// </summary>
            public string Version
            {
                get { return this._version; }
                set { this._version = value; }
            }
            
            private string _thumbprint;
            
            /// <summary>
            /// The thumbprint of the certificate that is used to encrypt the
            /// configuration specified in PrivateConfiguration. If this
            /// element is not specified, a certificate may be automatically
            /// generated and added to the cloud service.
            /// </summary>
            public string Thumbprint
            {
                get { return this._thumbprint; }
                set { this._thumbprint = value; }
            }
            
            private string _thumbprintAlgorithm;
            
            /// <summary>
            /// The thumbprint algorithm of the certificate that is used
            /// toencrypt the configuration specified in PrivateConfiguration.
            /// </summary>
            public string ThumbprintAlgorithm
            {
                get { return this._thumbprintAlgorithm; }
                set { this._thumbprintAlgorithm = value; }
            }
            
            private string _publicConfiguration;
            
            /// <summary>
            /// The public configuration that is defined using the schema
            /// returned by the List Available Extensions operation.
            /// </summary>
            public string PublicConfiguration
            {
                get { return this._publicConfiguration; }
                set { this._publicConfiguration = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the Extension class.
            /// </summary>
            public Extension()
            {
            }
        }
    }
    
    /// <summary>
    /// The Get Hosted Service operation response.
    /// </summary>
    public partial class HostedServiceListResponse : OperationResponse, IEnumerable<HostedServiceListResponse.HostedService>
    {
        private IList<HostedServiceListResponse.HostedService> _hostedServices;
        
        /// <summary>
        /// The hosted services associated with your subscription.
        /// </summary>
        public IList<HostedServiceListResponse.HostedService> HostedServices
        {
            get { return this._hostedServices; }
            set { this._hostedServices = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the HostedServiceListResponse class.
        /// </summary>
        public HostedServiceListResponse()
        {
            this._hostedServices = new List<HostedServiceListResponse.HostedService>();
        }
        
        /// <summary>
        /// Gets the sequence of HostedServices.
        /// </summary>
        public IEnumerator<HostedServiceListResponse.HostedService> GetEnumerator()
        {
            return this.HostedServices.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of HostedServices.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// A hosted service associated with your subscription.
        /// </summary>
        public partial class HostedService
        {
            private Uri _uri;
            
            /// <summary>
            /// The Service Management API request URI used to perform Get
            /// Hosted Service Properties requests against the cloud service.
            /// </summary>
            public Uri Uri
            {
                get { return this._uri; }
                set { this._uri = value; }
            }
            
            private string _serviceName;
            
            /// <summary>
            /// The name of the cloud service. This name is the DNS prefix name
            /// and can be used to access the cloud service. For example, if
            /// the cloud service name is MyService you could access the cloud
            /// service by calling: http://MyService.cloudapp.net
            /// </summary>
            public string ServiceName
            {
                get { return this._serviceName; }
                set { this._serviceName = value; }
            }
            
            private HostedServiceProperties _properties;
            
            /// <summary>
            /// The properties that are assigned to the cloud service.
            /// </summary>
            public HostedServiceProperties Properties
            {
                get { return this._properties; }
                set { this._properties = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the HostedService class.
            /// </summary>
            public HostedService()
            {
            }
        }
    }
    
    /// <summary>
    /// The properties that are assigned to the cloud service.
    /// </summary>
    public partial class HostedServiceProperties
    {
        private string _description;
        
        /// <summary>
        /// The description for the cloud service.
        /// </summary>
        public string Description
        {
            get { return this._description; }
            set { this._description = value; }
        }
        
        private string _affinityGroup;
        
        /// <summary>
        /// The affinity group with which this cloud service is associated, if
        /// any. If the service is associated with an affinity group, the
        /// Location element is not returned.
        /// </summary>
        public string AffinityGroup
        {
            get { return this._affinityGroup; }
            set { this._affinityGroup = value; }
        }
        
        private string _location;
        
        /// <summary>
        /// The geo-location of the cloud service in Windows Azure, if the
        /// service is not associated with an affinity group. If a location
        /// has been specified, the AffinityGroup element is not returned.
        /// </summary>
        public string Location
        {
            get { return this._location; }
            set { this._location = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// The base-64 encoded user supplied name of the cloud service. This
        /// name can be used identify the service for your tracking purposes.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private HostedServiceStatus _status;
        
        /// <summary>
        /// The status of the cloud service.
        /// </summary>
        public HostedServiceStatus Status
        {
            get { return this._status; }
            set { this._status = value; }
        }
        
        private DateTime _dateCreated;
        
        /// <summary>
        /// The date that the cloud service was created, in
        /// [4DigitYear]-[2DigitMonth]-[2DigitDay]T[2DigitHour]:[2DigitMinute]:[2DigitSecond]Z
        /// format. The date 2011-05-11T16:15:26Z is an example that could
        /// bereturned by the DateCreated or DateLastModified elements.
        /// </summary>
        public DateTime DateCreated
        {
            get { return this._dateCreated; }
            set { this._dateCreated = value; }
        }
        
        private DateTime _dateLastModified;
        
        /// <summary>
        /// The date that the cloud service was last updated, in
        /// [4DigitYear]-[2DigitMonth]-[2DigitDay]T[2DigitHour]:[2DigitMinute]:[2DigitSecond]Z
        /// format. The date 2011-05-11T16:15:26Z is an example that could be
        /// returned by the DateCreated or DateLastModified elements.
        /// </summary>
        public DateTime DateLastModified
        {
            get { return this._dateLastModified; }
            set { this._dateLastModified = value; }
        }
        
        private IDictionary<string, string> _extendedProperties;
        
        /// <summary>
        /// Optional. Represents the name of an extended cloud service
        /// property. Each extended property must have both a defined name and
        /// value. You can have a maximum of 50 extended property name and
        /// value pairs.  The maximum length of the Name element is 64
        /// characters, only alphanumeric characters and underscores are valid
        /// in the name, and it must start with a letter. Attempting to use
        /// other characters, starting with a non-letter character, or
        /// entering a name that is identical to that of another extended
        /// property owned by the same service, will result in a status code
        /// 400 (Bad Request) error.  Each extended property value has a
        /// maximum length of 255 characters.
        /// </summary>
        public IDictionary<string, string> ExtendedProperties
        {
            get { return this._extendedProperties; }
            set { this._extendedProperties = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the HostedServiceProperties class.
        /// </summary>
        public HostedServiceProperties()
        {
            this._extendedProperties = new Dictionary<string, string>();
        }
    }
    
    /// <summary>
    /// The status of the cloud service.
    /// </summary>
    public enum HostedServiceStatus
    {
        Created = 0,
        
        Creating = 1,
        
        Deleting = 2,
        
        Deleted = 3,
        
        Changing = 4,
        
        ResolvingDns = 5,
    }
    
    /// <summary>
    /// Parameters supplied to the Update Hosted Service operation.
    /// </summary>
    public partial class HostedServiceUpdateParameters
    {
        private string _label;
        
        /// <summary>
        /// Optional. A name for the cloud service that is base64-encoded. The
        /// name may be up to 100 characters in length. You must specify a
        /// value for either Label or Description, or for both.  It is
        /// recommended that the label be unique within the subscription. The
        /// name can be used identify the service for your tracking purposes.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private string _description;
        
        /// <summary>
        /// Optional. A description for the cloud service. The description may
        /// be up to 1024 characters in length. You must specify a value for
        /// either Label or Description, or for both.
        /// </summary>
        public string Description
        {
            get { return this._description; }
            set { this._description = value; }
        }
        
        private IDictionary<string, string> _extendedProperties;
        
        /// <summary>
        /// Optional. Represents the name of an extended cloud service
        /// property. Each extended property must have both a defined name and
        /// value. You can have a maximum of 50 extended property name and
        /// value pairs.  The maximum length of the Name element is 64
        /// characters, only alphanumeric characters and underscores are valid
        /// in the name, and it must start with a letter. Attempting to use
        /// other characters, starting with a non-letter character, or
        /// entering a name that is identical to that of another extended
        /// property owned by the same service, will result in a status code
        /// 400 (Bad Request) error.  Each extended property value has a
        /// maximum length of 255 characters.
        /// </summary>
        public IDictionary<string, string> ExtendedProperties
        {
            get { return this._extendedProperties; }
            set { this._extendedProperties = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the HostedServiceUpdateParameters
        /// class.
        /// </summary>
        public HostedServiceUpdateParameters()
        {
            this._extendedProperties = new Dictionary<string, string>();
        }
    }
    
    public enum HostingResources
    {
        WebRole = 0,
        
        WorkerRole = 1,
        
        WebOrWorkerRole = 2,
    }
    
    /// <summary>
    /// Objects that provide input endpoint details.
    /// </summary>
    public partial class InputEndpoint
    {
        private string _loadBalancedEndpointSetName;
        
        /// <summary>
        /// Specifies a name for a set of load-balanced endpoints. Specifying
        /// this name in multiple endpoints adds them all to the set. This
        /// element is only listed for Virtual Machine deployments.
        /// </summary>
        public string LoadBalancedEndpointSetName
        {
            get { return this._loadBalancedEndpointSetName; }
            set { this._loadBalancedEndpointSetName = value; }
        }
        
        private int? _localPort;
        
        /// <summary>
        /// Specifies the internal port on which the virtual machine is
        /// listening to serve the endpoint. This element is only listed for
        /// Virtual Machine deployments.
        /// </summary>
        public int? LocalPort
        {
            get { return this._localPort; }
            set { this._localPort = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// Specifies the name for the external endpoint. This element is only
        /// listed for Virtual Machine deployments.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private int? _port;
        
        /// <summary>
        /// The size of the role instance.
        /// </summary>
        public int? Port
        {
            get { return this._port; }
            set { this._port = value; }
        }
        
        private LoadBalancerProbe _loadBalancerProbe;
        
        /// <summary>
        /// Contains properties that specify the endpoint settings which the
        /// Windows Azure load balancer uses to monitor the availability of
        /// this virtual machine before forwarding traffic to the endpoint.
        /// </summary>
        public LoadBalancerProbe LoadBalancerProbe
        {
            get { return this._loadBalancerProbe; }
            set { this._loadBalancerProbe = value; }
        }
        
        private string _protocol;
        
        /// <summary>
        /// Specifies the transport protocol for the endpoint.
        /// </summary>
        public string Protocol
        {
            get { return this._protocol; }
            set { this._protocol = value; }
        }
        
        private string _virtualIPAddress;
        
        /// <summary>
        /// The ip of the role instance.
        /// </summary>
        public string VirtualIPAddress
        {
            get { return this._virtualIPAddress; }
            set { this._virtualIPAddress = value; }
        }
        
        private bool? _enableDirectServerReturn;
        
        /// <summary>
        /// Specifies whether direct server return is enabled for the endpoint
        /// </summary>
        public bool? EnableDirectServerReturn
        {
            get { return this._enableDirectServerReturn; }
            set { this._enableDirectServerReturn = value; }
        }
        
        private AccessControlList _accessControlList;
        
        /// <summary>
        /// Specifies the list of access control rules for the endpoint
        /// </summary>
        public AccessControlList AccessControlList
        {
            get { return this._accessControlList; }
            set { this._accessControlList = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the InputEndpoint class.
        /// </summary>
        public InputEndpoint()
        {
        }
    }
    
    /// <summary>
    /// Specifies the transport protocol for an endpoint.
    /// </summary>
    public static partial class InputEndpointTransportProtocol
    {
        public const string Tcp = "tcp";
        
        public const string Udp = "udp";
        
        public const string Http = "http";
    }
    
    /// <summary>
    /// Objects that provide instance endpoint details.
    /// </summary>
    public partial class InstanceEndpoint
    {
        private int? _localPort;
        
        /// <summary>
        /// Specifies the internal port on which the virtual machine is
        /// listening to serve the endpoint. This element is only listed for
        /// Virtual Machine deployments.
        /// </summary>
        public int? LocalPort
        {
            get { return this._localPort; }
            set { this._localPort = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// Specifies the name for the external endpoint. This element is only
        /// listed for Virtual Machine deployments.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private int _port;
        
        /// <summary>
        /// The external port of the role instance endpoint.
        /// </summary>
        public int Port
        {
            get { return this._port; }
            set { this._port = value; }
        }
        
        private string _protocol;
        
        /// <summary>
        /// Specifies the transport protocol for the endpoint.
        /// </summary>
        public string Protocol
        {
            get { return this._protocol; }
            set { this._protocol = value; }
        }
        
        private string _virtualIPAddress;
        
        /// <summary>
        /// The Virtual IP of the role endpoint.
        /// </summary>
        public string VirtualIPAddress
        {
            get { return this._virtualIPAddress; }
            set { this._virtualIPAddress = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the InstanceEndpoint class.
        /// </summary>
        public InstanceEndpoint()
        {
        }
    }
    
    /// <summary>
    /// Contains properties that specify the endpoint settings which the
    /// Windows Azure load balancer uses to monitor the availability of this
    /// virtual machine before forwarding traffic to the endpoint
    /// </summary>
    public partial class LoadBalancerProbe
    {
        private string _path;
        
        /// <summary>
        /// Specifies the relative path name to inspect to determine the
        /// virtual machine availability status. If Protocol is set to TCP,
        /// this value must be NULL.
        /// </summary>
        public string Path
        {
            get { return this._path; }
            set { this._path = value; }
        }
        
        private int _port;
        
        /// <summary>
        /// Specifies the port to use to inspect the virtual machine
        /// availability status.
        /// </summary>
        public int Port
        {
            get { return this._port; }
            set { this._port = value; }
        }
        
        private LoadBalancerProbeTransportProtocol _protocol;
        
        /// <summary>
        /// Specifies the protocol to use to inspect the virtual machine
        /// availability status.
        /// </summary>
        public LoadBalancerProbeTransportProtocol Protocol
        {
            get { return this._protocol; }
            set { this._protocol = value; }
        }
        
        private int? _intervalInSeconds;
        
        /// <summary>
        /// Specifies the interval for the load balancer probe in seconds. The
        /// minimum value is 5 seconds. If not specified, the default is 15
        /// seconds.
        /// </summary>
        public int? IntervalInSeconds
        {
            get { return this._intervalInSeconds; }
            set { this._intervalInSeconds = value; }
        }
        
        private int? _timeoutInSeconds;
        
        /// <summary>
        /// Specifies the timeout for the load balancer probe in seconds. The
        /// minimum value is 11 seconds. If not specified, the default is 31
        /// seconds.
        /// </summary>
        public int? TimeoutInSeconds
        {
            get { return this._timeoutInSeconds; }
            set { this._timeoutInSeconds = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the LoadBalancerProbe class.
        /// </summary>
        public LoadBalancerProbe()
        {
        }
    }
    
    /// <summary>
    /// Specifies the protocol to use to inspect the virtual machine
    /// availability status.
    /// </summary>
    public enum LoadBalancerProbeTransportProtocol
    {
        Tcp = 0,
        
        Http = 1,
    }
    
    /// <summary>
    /// Describes an operating system family.
    /// </summary>
    public static partial class OperatingSystemFamilies
    {
        public const int WindowsServer2008SP2 = 1;
        
        public const int WindowsServer2008R2 = 2;
        
        public const int WindowsServer2012 = 3;
    }
    
    /// <summary>
    /// The List Operating System Families operation response.
    /// </summary>
    public partial class OperatingSystemListFamiliesResponse : OperationResponse, IEnumerable<OperatingSystemListFamiliesResponse.OperatingSystemFamily>
    {
        private IList<OperatingSystemListFamiliesResponse.OperatingSystemFamily> _operatingSystemFamilies;
        
        /// <summary>
        /// The operating system families that are valid for your subscription.
        /// </summary>
        public IList<OperatingSystemListFamiliesResponse.OperatingSystemFamily> OperatingSystemFamilies
        {
            get { return this._operatingSystemFamilies; }
            set { this._operatingSystemFamilies = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// OperatingSystemListFamiliesResponse class.
        /// </summary>
        public OperatingSystemListFamiliesResponse()
        {
            this._operatingSystemFamilies = new List<OperatingSystemListFamiliesResponse.OperatingSystemFamily>();
        }
        
        /// <summary>
        /// Gets the sequence of OperatingSystemFamilies.
        /// </summary>
        public IEnumerator<OperatingSystemListFamiliesResponse.OperatingSystemFamily> GetEnumerator()
        {
            return this.OperatingSystemFamilies.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of OperatingSystemFamilies.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// An operating system family that is valid for your subscription.
        /// </summary>
        public partial class OperatingSystemFamily
        {
            private int _name;
            
            /// <summary>
            /// Indicates which operating system family this version belongs
            /// to. A value of 1 corresponds to the Windows Azure guest
            /// operating system that is substantially compatible with Windows
            /// Server 2008 SP2. A value of 2 corresponds to the Windows Azure
            /// guest operating system that is substantially compatible with
            /// Windows Server 2008 R2.
            /// </summary>
            public int Name
            {
                get { return this._name; }
                set { this._name = value; }
            }
            
            private string _label;
            
            /// <summary>
            /// The base-64 encoded label of the operating system family.
            /// </summary>
            public string Label
            {
                get { return this._label; }
                set { this._label = value; }
            }
            
            private IList<OperatingSystemListFamiliesResponse.OperatingSystem> _operatingSystems;
            
            /// <summary>
            /// The available operating systems in your subscription belonging
            /// to this family.
            /// </summary>
            public IList<OperatingSystemListFamiliesResponse.OperatingSystem> OperatingSystems
            {
                get { return this._operatingSystems; }
                set { this._operatingSystems = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the OperatingSystemFamily class.
            /// </summary>
            public OperatingSystemFamily()
            {
                this._operatingSystems = new List<OperatingSystemListFamiliesResponse.OperatingSystem>();
            }
        }
        
        /// <summary>
        /// An operating system that is valid for your subscription.
        /// </summary>
        public partial class OperatingSystem
        {
            private string _version;
            
            /// <summary>
            /// The operating system version. This value corresponds to the
            /// configuration value for specifying that your service is to run
            /// on a particular version of the Windows Azure guest operating
            /// system. See Configuring Settings for the Windows Azure Guest
            /// OS for additional details.
            /// </summary>
            public string Version
            {
                get { return this._version; }
                set { this._version = value; }
            }
            
            private string _label;
            
            /// <summary>
            /// The base-64 encoded label of the operating system version.
            /// </summary>
            public string Label
            {
                get { return this._label; }
                set { this._label = value; }
            }
            
            private bool _isDefault;
            
            /// <summary>
            /// Indicates whether this operating system version is the default
            /// version for a service that has not otherwise specified a
            /// particular version. The default operating system version is
            /// applied to services that are configured for auto-upgrade. An
            /// operating system family has exactly one default operating
            /// system version at any given time, for which the IsDefault
            /// element is set to true; for all other versions, IsDefault is
            /// set to false.
            /// </summary>
            public bool IsDefault
            {
                get { return this._isDefault; }
                set { this._isDefault = value; }
            }
            
            private bool _isActive;
            
            /// <summary>
            /// Indicates whether this operating system version is currently
            /// active for running a service. If an operating system version
            /// is active, you can manually configure your service to run on
            /// that version.  An operating system version may be inactive for
            /// one of two reasons:  1. It is not yet active as it is in the
            /// process of being rolled out to Windows Azure data centers. If
            /// your service is configured to use auto-upgrade, it will be
            /// upgraded to the new operating system version during the
            /// rollout. If you are manually configuring your operating system
            /// version, you can upgrade to the latest version once it becomes
            /// active.  2. It is no longer supported for running a service.
            /// In this case you will either need to manually configure your
            /// service to run on a newer version, or configure your service
            /// to use auto-upgrade to manage operating system upgrades.
            /// </summary>
            public bool IsActive
            {
                get { return this._isActive; }
                set { this._isActive = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the OperatingSystem class.
            /// </summary>
            public OperatingSystem()
            {
            }
        }
    }
    
    /// <summary>
    /// The List Operating Systems operation response.
    /// </summary>
    public partial class OperatingSystemListResponse : OperationResponse, IEnumerable<OperatingSystemListResponse.OperatingSystem>
    {
        private IList<OperatingSystemListResponse.OperatingSystem> _operatingSystems;
        
        /// <summary>
        /// The operating systems that are valid for your subscription.
        /// </summary>
        public IList<OperatingSystemListResponse.OperatingSystem> OperatingSystems
        {
            get { return this._operatingSystems; }
            set { this._operatingSystems = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the OperatingSystemListResponse class.
        /// </summary>
        public OperatingSystemListResponse()
        {
            this._operatingSystems = new List<OperatingSystemListResponse.OperatingSystem>();
        }
        
        /// <summary>
        /// Gets the sequence of OperatingSystems.
        /// </summary>
        public IEnumerator<OperatingSystemListResponse.OperatingSystem> GetEnumerator()
        {
            return this.OperatingSystems.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of OperatingSystems.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// An operating system that is valid for your subscription.
        /// </summary>
        public partial class OperatingSystem
        {
            private string _version;
            
            /// <summary>
            /// The operating system version. This value corresponds to the
            /// configuration value for specifying that your service is to run
            /// on a particular version of the Windows Azure guest operating
            /// system. See Configuring Settings for the Windows Azure Guest
            /// OS for additional details.
            /// </summary>
            public string Version
            {
                get { return this._version; }
                set { this._version = value; }
            }
            
            private string _label;
            
            /// <summary>
            /// The base-64 encoded label of the operating system version.
            /// </summary>
            public string Label
            {
                get { return this._label; }
                set { this._label = value; }
            }
            
            private bool _isDefault;
            
            /// <summary>
            /// Indicates whether this operating system version is the default
            /// version for a service that has not otherwise specified a
            /// particular version. The default operating system version is
            /// applied to services that are configured for auto-upgrade. An
            /// operating system family has exactly one default operating
            /// system version at any given time, for which the IsDefault
            /// element is set to true; for all other versions, IsDefault is
            /// set to false.
            /// </summary>
            public bool IsDefault
            {
                get { return this._isDefault; }
                set { this._isDefault = value; }
            }
            
            private bool _isActive;
            
            /// <summary>
            /// Indicates whether this operating system version is currently
            /// active for running a service. If an operating system version
            /// is active, you can manually configure your service to run on
            /// that version.  An operating system version may be inactive for
            /// one of two reasons:  1. It is not yet active as it is in the
            /// process of being rolled out to Windows Azure data centers. If
            /// your service is configured to use auto-upgrade, it will be
            /// upgraded to the new operating system version during the
            /// rollout. If you are manually configuring your operating system
            /// version, you can upgrade to the latest version once it becomes
            /// active.  2. It is no longer supported for running a service.
            /// In this case you will either need to manually configure your
            /// service to run on a newer version, or configure your service
            /// to use auto-upgrade to manage operating system upgrades.
            /// </summary>
            public bool IsActive
            {
                get { return this._isActive; }
                set { this._isActive = value; }
            }
            
            private int _family;
            
            /// <summary>
            /// Indicates which operating system family this version belongs
            /// to. A value of 1 corresponds to the Windows Azure guest
            /// operating system that is substantially compatible with Windows
            /// Server 2008 SP2. A value of 2 corresponds to the Windows Azure
            /// guest operating system that is substantially compatible with
            /// Windows Server 2008 R2.
            /// </summary>
            public int Family
            {
                get { return this._family; }
                set { this._family = value; }
            }
            
            private string _familyLabel;
            
            /// <summary>
            /// The base-64 encoded label of the operating system family.
            /// </summary>
            public string FamilyLabel
            {
                get { return this._familyLabel; }
                set { this._familyLabel = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the OperatingSystem class.
            /// </summary>
            public OperatingSystem()
            {
            }
        }
    }
    
    /// <summary>
    /// The status of the asynchronous request.
    /// </summary>
    public enum OperationStatus
    {
        /// <summary>
        /// The asynchronous request is in progress.
        /// </summary>
        InProgress = 0,
        
        /// <summary>
        /// The asynchronous request succeeded.
        /// </summary>
        Succeeded = 1,
        
        /// <summary>
        /// The asynchronous request failed.
        /// </summary>
        Failed = 2,
    }
    
    /// <summary>
    /// The parameters Windows Azure uses to create theoperating system disk
    /// for the virtual machine.
    /// </summary>
    public partial class OSVirtualHardDisk
    {
        private Microsoft.WindowsAzure.Management.Compute.Models.VirtualHardDiskHostCaching? _hostCaching;
        
        /// <summary>
        /// Specifies the platform caching behavior of the operating system
        /// disk blob for read/write efficiency.
        /// </summary>
        public Microsoft.WindowsAzure.Management.Compute.Models.VirtualHardDiskHostCaching? HostCaching
        {
            get { return this._hostCaching; }
            set { this._hostCaching = value; }
        }
        
        private string _diskLabel;
        
        /// <summary>
        /// Specifies the friendly name an operating system image in the image
        /// repository.
        /// </summary>
        public string DiskLabel
        {
            get { return this._diskLabel; }
            set { this._diskLabel = value; }
        }
        
        private string _diskName;
        
        /// <summary>
        /// Specifies the name an operating system image in the image
        /// repository.
        /// </summary>
        public string DiskName
        {
            get { return this._diskName; }
            set { this._diskName = value; }
        }
        
        private Uri _mediaLink;
        
        /// <summary>
        /// Specifies the location of the operating system disk in Windows
        /// Azure storage.
        /// </summary>
        public Uri MediaLink
        {
            get { return this._mediaLink; }
            set { this._mediaLink = value; }
        }
        
        private string _sourceImageName;
        
        /// <summary>
        /// Specifies the name of the source image that was used to provision
        /// the virtual machine.
        /// </summary>
        public string SourceImageName
        {
            get { return this._sourceImageName; }
            set { this._sourceImageName = value; }
        }
        
        private string _operatingSystem;
        
        /// <summary>
        /// The operating system running in the virtual machine.
        /// </summary>
        public string OperatingSystem
        {
            get { return this._operatingSystem; }
            set { this._operatingSystem = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the OSVirtualHardDisk class.
        /// </summary>
        public OSVirtualHardDisk()
        {
        }
    }
    
    /// <summary>
    /// Contains information about when the virtual machine has been started
    /// and stopped.
    /// </summary>
    public partial class PersistentVMDowntime
    {
        private DateTime _startTime;
        
        /// <summary>
        /// The time that the virtual machine was started.
        /// </summary>
        public DateTime StartTime
        {
            get { return this._startTime; }
            set { this._startTime = value; }
        }
        
        private DateTime _endTime;
        
        /// <summary>
        /// The time that the virtual machine was stopped.
        /// </summary>
        public DateTime EndTime
        {
            get { return this._endTime; }
            set { this._endTime = value; }
        }
        
        private string _status;
        
        /// <summary>
        /// The status of the virtual machine.
        /// </summary>
        public string Status
        {
            get { return this._status; }
            set { this._status = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the PersistentVMDowntime class.
        /// </summary>
        public PersistentVMDowntime()
        {
        }
    }
    
    /// <summary>
    /// Required. Specifies the action that is performed after the capture
    /// operation finishes.
    /// </summary>
    public enum PostCaptureAction
    {
        /// <summary>
        /// Causes the virtual machine to be deleted after the image has been
        /// captured
        /// </summary>
        Delete = 0,
        
        /// <summary>
        /// Causes the virtual machine to be redeployed after the image is
        /// captured by using the specified information in
        /// ProvisioningConfiguration
        /// </summary>
        Reprovision = 1,
    }
    
    public enum PostShutdownAction
    {
        Stopped = 0,
        
        StoppedDeallocated = 1,
    }
    
    /// <summary>
    /// Details of a role in a deployment.
    /// </summary>
    public partial class Role
    {
        private string _roleName;
        
        /// <summary>
        /// The name of the role.
        /// </summary>
        public string RoleName
        {
            get { return this._roleName; }
            set { this._roleName = value; }
        }
        
        private string _oSVersion;
        
        /// <summary>
        /// The version of the operating system on which the role instances are
        /// running.
        /// </summary>
        public string OSVersion
        {
            get { return this._oSVersion; }
            set { this._oSVersion = value; }
        }
        
        private string _roleType;
        
        /// <summary>
        /// Specifies the type of the role. This element is only listed for
        /// Virtual Machine deployments and by default is PersistentVMRole.
        /// </summary>
        public string RoleType
        {
            get { return this._roleType; }
            set { this._roleType = value; }
        }
        
        private IList<ConfigurationSet> _configurationSets;
        
        /// <summary>
        /// A collection of values that represents system or application
        /// configuration settings.
        /// </summary>
        public IList<ConfigurationSet> ConfigurationSets
        {
            get { return this._configurationSets; }
            set { this._configurationSets = value; }
        }
        
        private string _availabilitySetName;
        
        /// <summary>
        /// The name of the role.
        /// </summary>
        public string AvailabilitySetName
        {
            get { return this._availabilitySetName; }
            set { this._availabilitySetName = value; }
        }
        
        private IList<DataVirtualHardDisk> _dataVirtualHardDisks;
        
        /// <summary>
        /// Contains the parameters Windows Azure uses to create a data disk
        /// for a virtual machine.
        /// </summary>
        public IList<DataVirtualHardDisk> DataVirtualHardDisks
        {
            get { return this._dataVirtualHardDisks; }
            set { this._dataVirtualHardDisks = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// The friendly name for the role
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private OSVirtualHardDisk _oSVirtualHardDisk;
        
        /// <summary>
        /// Contains the parameters Windows Azure uses to create the operating
        /// system disk for the virtual machine.
        /// </summary>
        public OSVirtualHardDisk OSVirtualHardDisk
        {
            get { return this._oSVirtualHardDisk; }
            set { this._oSVirtualHardDisk = value; }
        }
        
        private Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? _roleSize;
        
        /// <summary>
        /// The size of the role instance.
        /// </summary>
        public Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? RoleSize
        {
            get { return this._roleSize; }
            set { this._roleSize = value; }
        }
        
        private string _defaultWinRmCertificateThumbprint;
        
        /// <summary>
        /// The read-only thumbprint of the certificate that is used with the
        /// HTTPS listener for WinRM.
        /// </summary>
        public string DefaultWinRmCertificateThumbprint
        {
            get { return this._defaultWinRmCertificateThumbprint; }
            set { this._defaultWinRmCertificateThumbprint = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the Role class.
        /// </summary>
        public Role()
        {
            this._configurationSets = new List<ConfigurationSet>();
            this._dataVirtualHardDisks = new List<DataVirtualHardDisk>();
        }
    }
    
    /// <summary>
    /// Details of a specific role instance.
    /// </summary>
    public partial class RoleInstance
    {
        private string _roleName;
        
        /// <summary>
        /// The name of the role.
        /// </summary>
        public string RoleName
        {
            get { return this._roleName; }
            set { this._roleName = value; }
        }
        
        private string _instanceName;
        
        /// <summary>
        /// TThe name of the specific role instance, if an instance of the role
        /// is running.
        /// </summary>
        public string InstanceName
        {
            get { return this._instanceName; }
            set { this._instanceName = value; }
        }
        
        private string _instanceStatus;
        
        /// <summary>
        /// The current status of this instance.
        /// </summary>
        public string InstanceStatus
        {
            get { return this._instanceStatus; }
            set { this._instanceStatus = value; }
        }
        
        private int? _instanceUpgradeDomain;
        
        /// <summary>
        /// The update domain that this role instance belongs to. During an
        /// Upgrade Deployment, all roles in the same update domain are
        /// updated at the same time.
        /// </summary>
        public int? InstanceUpgradeDomain
        {
            get { return this._instanceUpgradeDomain; }
            set { this._instanceUpgradeDomain = value; }
        }
        
        private int? _instanceFaultDomain;
        
        /// <summary>
        /// The fault domain that this role instance belongs to. Role instances
        /// that are part of the same fault domain may all be vulnerable to
        /// the failure of the same piece of shared hardware.
        /// </summary>
        public int? InstanceFaultDomain
        {
            get { return this._instanceFaultDomain; }
            set { this._instanceFaultDomain = value; }
        }
        
        private Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? _instanceSize;
        
        /// <summary>
        /// The size of the role instance.
        /// </summary>
        public Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? InstanceSize
        {
            get { return this._instanceSize; }
            set { this._instanceSize = value; }
        }
        
        private string _instanceStateDetails;
        
        /// <summary>
        /// The instance state is returned as a string that, when present,
        /// provides a snapshot of the state of the virtual machine at the
        /// time the operation was called.
        /// </summary>
        public string InstanceStateDetails
        {
            get { return this._instanceStateDetails; }
            set { this._instanceStateDetails = value; }
        }
        
        private string _instanceErrorCode;
        
        /// <summary>
        /// An error code that can be provided to WindowsAzure support to
        /// assist in resolution of errors. Typicallythis field will be empty.
        /// </summary>
        public string InstanceErrorCode
        {
            get { return this._instanceErrorCode; }
            set { this._instanceErrorCode = value; }
        }
        
        private string _iPAddress;
        
        /// <summary>
        /// The IP address of the role instance (DIP).
        /// </summary>
        public string IPAddress
        {
            get { return this._iPAddress; }
            set { this._iPAddress = value; }
        }
        
        private IList<InstanceEndpoint> _instanceEndpoints;
        
        /// <summary>
        /// The list of instance endpoints for the role.
        /// </summary>
        public IList<InstanceEndpoint> InstanceEndpoints
        {
            get { return this._instanceEndpoints; }
            set { this._instanceEndpoints = value; }
        }
        
        private RoleInstancePowerState _powerState;
        
        /// <summary>
        /// The running state of the role instance.
        /// </summary>
        public RoleInstancePowerState PowerState
        {
            get { return this._powerState; }
            set { this._powerState = value; }
        }
        
        private string _hostName;
        
        /// <summary>
        /// The DNS host name of the service in which the role instance is
        /// running. This element is only listed for Virtual Machine
        /// deployments.
        /// </summary>
        public string HostName
        {
            get { return this._hostName; }
            set { this._hostName = value; }
        }
        
        private string _remoteAccessCertificateThumbprint;
        
        /// <summary>
        /// The thumbprint of the RDP server certificate (in Windows) or SSH
        /// server certificate (in Linux). The thumbprint is only used for
        /// Virtual Machines that have been created from an image.
        /// </summary>
        public string RemoteAccessCertificateThumbprint
        {
            get { return this._remoteAccessCertificateThumbprint; }
            set { this._remoteAccessCertificateThumbprint = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the RoleInstance class.
        /// </summary>
        public RoleInstance()
        {
            this._instanceEndpoints = new List<InstanceEndpoint>();
        }
    }
    
    /// <summary>
    /// The running state of the role instance.
    /// </summary>
    public enum RoleInstancePowerState
    {
        Starting = 0,
        
        Started = 1,
        
        Stopping = 2,
        
        Stopped = 3,
        
        Unknown = 4,
    }
    
    /// <summary>
    /// The current status of a role instance.
    /// </summary>
    public static partial class RoleInstanceStatus
    {
        /// <summary>
        /// The role state is currently unknown. The state should automatically
        /// be resolved once the role state is detected, so no action is
        /// required.
        /// </summary>
        public const string RoleStateUnknown = "RoleStateUnknown";
        
        /// <summary>
        /// The host agent is currently creating resources for the Virtual
        /// Machine.
        /// </summary>
        public const string CreatingVM = "CreatingVM";
        
        /// <summary>
        /// The host agent is starting the Virtual Machine.
        /// </summary>
        public const string StartingVM = "StartingVM";
        
        /// <summary>
        /// Windows Azure is creating resources for the role.
        /// </summary>
        public const string CreatingRole = "CreatingRole";
        
        /// <summary>
        /// Windows Azure is starting the role.
        /// </summary>
        public const string StartingRole = "StartingRole";
        
        /// <summary>
        /// The role instance has started and is ready to be used.
        /// </summary>
        public const string ReadyRole = "ReadyRole";
        
        /// <summary>
        /// The role instance is unavailable for requests. This state is
        /// usually generated while the role is being created or stopped.
        /// </summary>
        public const string BusyRole = "BusyRole";
        
        /// <summary>
        /// Windows Azure is stopping the role.
        /// </summary>
        public const string StoppingRole = "StoppingRole";
        
        /// <summary>
        /// The host agent is stopping the Virtual Machine. This status also
        /// indicates that the role has already been stopped.
        /// </summary>
        public const string StoppingVM = "StoppingVM";
        
        /// <summary>
        /// The Virtual Machine is being deleted by the host agent.
        /// </summary>
        public const string DeletingVM = "DeletingVM";
        
        /// <summary>
        /// The Virtual Machine is not running. This is the final state of the
        /// shutdown process, and no other status messages should be received
        /// after StoppedVM.
        /// </summary>
        public const string StoppedVM = "StoppedVM";
        
        /// <summary>
        /// The role has unexpectedly stopped or has failed to start. This
        /// status indicates that there is a problem with the role that is
        /// causing it to crash or preventing it from starting, and must be
        /// corrected before the role can be started. The InstanceStateDetails
        /// and InstanceErrorCode fields can hold information about the role
        /// error that caused this state, which may be useful for identifying
        /// and debugging the problem.
        /// </summary>
        public const string RestartingRole = "RestartingRole";
        
        /// <summary>
        /// The role has continually crashed after being started by Windows
        /// Azure. This status indicates that there is a problem with the role
        /// that prevents it from starting, and may be generated after the
        /// StartingRole even ReadyRole statuses are received. The problem in
        /// the role must be found and corrected before the role can be
        /// started. The InstanceStateDetails and InstanceErrorCode fields can
        /// hold information about the role error that caused this state,
        /// which may be useful for identifying and debugging the problem.
        /// </summary>
        public const string CyclingRole = "CyclingRole";
        
        /// <summary>
        /// The role has continually failed to start. This status indicates
        /// that there is a problem with the role that prevents it from
        /// starting, and may be generated after the process returns
        /// StartingRole. The problem in the role must be found and corrected
        /// before the role can be started. The InstanceStateDetails and
        /// InstanceErrorCode fields can hold information about the role error
        /// that caused this state, which may be useful for identifying and
        /// debugging the problem.
        /// </summary>
        public const string FailedStartingRole = "FailedStartingRole";
        
        /// <summary>
        /// A Windows Azure or container error is preventing the Virtual
        /// Machine from starting. This status is generated by Windows Azure,
        /// and does not indicate an error with the role. It may be generated
        /// after the StartingRole state.
        /// </summary>
        public const string FailedStartingVM = "FailedStartingVM";
        
        /// <summary>
        /// The role has timed out before receiving a status message and is not
        /// responding to requests.
        /// </summary>
        public const string UnresponsiveRole = "UnresponsiveRole";
    }
    
    public enum RollbackUpdateOrUpgradeMode
    {
        /// <summary>
        /// The rollback proceeds without further user input.
        /// </summary>
        Auto = 0,
        
        /// <summary>
        /// You must call the Walk Upgrade Domain operation to apply the
        /// rollback to each upgrade domain.
        /// </summary>
        Manual = 1,
    }
    
    /// <summary>
    /// Parameters supplied to the Create Service Certificate operation.
    /// </summary>
    public partial class ServiceCertificateCreateParameters
    {
        private byte[] _data;
        
        /// <summary>
        /// The base-64 encoded form of the pfx or .cer file.
        /// </summary>
        public byte[] Data
        {
            get { return this._data; }
            set { this._data = value; }
        }
        
        private CertificateFormat _certificateFormat;
        
        /// <summary>
        /// The service certificate format. Windows Azure supports the pfx and
        /// cer file formats.
        /// </summary>
        public CertificateFormat CertificateFormat
        {
            get { return this._certificateFormat; }
            set { this._certificateFormat = value; }
        }
        
        private string _password;
        
        /// <summary>
        /// The password for a .pfx certificate. A .cer certificate does not
        /// require a password.
        /// </summary>
        public string Password
        {
            get { return this._password; }
            set { this._password = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// ServiceCertificateCreateParameters class.
        /// </summary>
        public ServiceCertificateCreateParameters()
        {
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Delete Service Certificate operation.
    /// </summary>
    public partial class ServiceCertificateDeleteParameters
    {
        private string _serviceName;
        
        /// <summary>
        /// The DNS prefix name of your service.
        /// </summary>
        public string ServiceName
        {
            get { return this._serviceName; }
            set { this._serviceName = value; }
        }
        
        private string _thumbprintAlgorithm;
        
        /// <summary>
        /// The algorithm for the certificate's thumbprint.
        /// </summary>
        public string ThumbprintAlgorithm
        {
            get { return this._thumbprintAlgorithm; }
            set { this._thumbprintAlgorithm = value; }
        }
        
        private string _thumbprint;
        
        /// <summary>
        /// The hexadecimal representation of the thumbprint.
        /// </summary>
        public string Thumbprint
        {
            get { return this._thumbprint; }
            set { this._thumbprint = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// ServiceCertificateDeleteParameters class.
        /// </summary>
        public ServiceCertificateDeleteParameters()
        {
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Get Service Certificate operation.
    /// </summary>
    public partial class ServiceCertificateGetParameters
    {
        private string _serviceName;
        
        /// <summary>
        /// The DNS prefix name of your service.
        /// </summary>
        public string ServiceName
        {
            get { return this._serviceName; }
            set { this._serviceName = value; }
        }
        
        private string _thumbprintAlgorithm;
        
        /// <summary>
        /// The algorithm for the certificate's thumbprint.
        /// </summary>
        public string ThumbprintAlgorithm
        {
            get { return this._thumbprintAlgorithm; }
            set { this._thumbprintAlgorithm = value; }
        }
        
        private string _thumbprint;
        
        /// <summary>
        /// The hexadecimal representation of the thumbprint.
        /// </summary>
        public string Thumbprint
        {
            get { return this._thumbprint; }
            set { this._thumbprint = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the ServiceCertificateGetParameters
        /// class.
        /// </summary>
        public ServiceCertificateGetParameters()
        {
        }
    }
    
    /// <summary>
    /// The Get Service Certificate operation response.
    /// </summary>
    public partial class ServiceCertificateGetResponse : OperationResponse
    {
        private byte[] _data;
        
        /// <summary>
        /// The public portion of the X.509 service certificate as a base-64
        /// encoded form of the .cer file.
        /// </summary>
        public byte[] Data
        {
            get { return this._data; }
            set { this._data = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the ServiceCertificateGetResponse
        /// class.
        /// </summary>
        public ServiceCertificateGetResponse()
        {
        }
    }
    
    /// <summary>
    /// The List Service Certificates operation response.
    /// </summary>
    public partial class ServiceCertificateListResponse : OperationResponse, IEnumerable<ServiceCertificateListResponse.Certificate>
    {
        private IList<ServiceCertificateListResponse.Certificate> _certificates;
        
        /// <summary>
        /// The service certificates that are valid for your subscription.
        /// </summary>
        public IList<ServiceCertificateListResponse.Certificate> Certificates
        {
            get { return this._certificates; }
            set { this._certificates = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the ServiceCertificateListResponse
        /// class.
        /// </summary>
        public ServiceCertificateListResponse()
        {
            this._certificates = new List<ServiceCertificateListResponse.Certificate>();
        }
        
        /// <summary>
        /// Gets the sequence of Certificates.
        /// </summary>
        public IEnumerator<ServiceCertificateListResponse.Certificate> GetEnumerator()
        {
            return this.Certificates.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of Certificates.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// A service certificate that is valid for your subscription.
        /// </summary>
        public partial class Certificate
        {
            private Uri _certificateUri;
            
            /// <summary>
            /// The Service Management API request URI used to perform Get
            /// Service Certificate requests against the certificate store.
            /// </summary>
            public Uri CertificateUri
            {
                get { return this._certificateUri; }
                set { this._certificateUri = value; }
            }
            
            private string _thumbprint;
            
            /// <summary>
            /// The X509 certificate thumb print property of the service
            /// certificate.
            /// </summary>
            public string Thumbprint
            {
                get { return this._thumbprint; }
                set { this._thumbprint = value; }
            }
            
            private string _thumbprintAlgorithm;
            
            /// <summary>
            /// The algorithm that was used to hash the service certificate.
            /// Currently SHA-1 is the only supported algorithm.
            /// </summary>
            public string ThumbprintAlgorithm
            {
                get { return this._thumbprintAlgorithm; }
                set { this._thumbprintAlgorithm = value; }
            }
            
            private byte[] _data;
            
            /// <summary>
            /// The public part of the service certificate as a base-64 encoded
            /// .cer file.
            /// </summary>
            public byte[] Data
            {
                get { return this._data; }
                set { this._data = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the Certificate class.
            /// </summary>
            public Certificate()
            {
            }
        }
    }
    
    /// <summary>
    /// Contains an SSH key pair to be installed on the virtual machine.
    /// </summary>
    public partial class SshSettingKeyPair
    {
        private string _fingerprint;
        
        /// <summary>
        /// Required. Specifies the SHA1 fingerprint of an X509 certificate
        /// associated with the hosted service that includes the SSH keypair.
        /// </summary>
        public string Fingerprint
        {
            get { return this._fingerprint; }
            set { this._fingerprint = value; }
        }
        
        private string _path;
        
        /// <summary>
        /// Required. Specifies the full path of a file, on the virtual
        /// machine, which stores the SSH private key. The file is overwritten
        /// when multiple keys are written to it. The SSH public key is stored
        /// in the same directory and has the same name as the private key
        /// file with .pub suffix.  Example: /home/user/.ssh/id_rsa
        /// </summary>
        public string Path
        {
            get { return this._path; }
            set { this._path = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the SshSettingKeyPair class.
        /// </summary>
        public SshSettingKeyPair()
        {
        }
    }
    
    /// <summary>
    /// Specifies a public key in the SSH settings.
    /// </summary>
    public partial class SshSettingPublicKey
    {
        private string _fingerprint;
        
        /// <summary>
        /// Required. Specifies the SHA1 fingerprint of an X509 certificate
        /// associated with the hosted service that includes the SSH public
        /// key.
        /// </summary>
        public string Fingerprint
        {
            get { return this._fingerprint; }
            set { this._fingerprint = value; }
        }
        
        private string _path;
        
        /// <summary>
        /// Required. Specifies the full path of a file, on the virtual
        /// machine, which stores the SSH public key. If the file already
        /// exists, the specified key is appended to the file.
        /// Example:/home/user/.ssh/authorized_keys
        /// </summary>
        public string Path
        {
            get { return this._path; }
            set { this._path = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the SshSettingPublicKey class.
        /// </summary>
        public SshSettingPublicKey()
        {
        }
    }
    
    /// <summary>
    /// Optional. Specifies the SSH public keys and key pairs to populate in
    /// the image during provisioning. This element is only used with the
    /// LinuxProvisioningConfiguration set.
    /// </summary>
    public partial class SshSettings
    {
        private IList<SshSettingPublicKey> _publicKeys;
        
        /// <summary>
        /// Optional. Specifies the collection of SSH public keys.
        /// </summary>
        public IList<SshSettingPublicKey> PublicKeys
        {
            get { return this._publicKeys; }
            set { this._publicKeys = value; }
        }
        
        private IList<SshSettingKeyPair> _keyPairs;
        
        /// <summary>
        /// Optional. Specifies the collection of SSH public keys.
        /// </summary>
        public IList<SshSettingKeyPair> KeyPairs
        {
            get { return this._keyPairs; }
            set { this._keyPairs = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the SshSettings class.
        /// </summary>
        public SshSettings()
        {
            this._publicKeys = new List<SshSettingPublicKey>();
            this._keyPairs = new List<SshSettingKeyPair>();
        }
    }
    
    /// <summary>
    /// Service certificates with which to provision to the new virtual
    /// machine. Stored certificate settings reference certificates that
    /// already exist in the Windows Azure hosted service. Prior to
    /// configuring the stored certificates for the virtual machine, you must
    /// call the Add Service Certificate operation or add the certificate via
    /// the Windows Azure Management portal.
    /// </summary>
    public partial class StoredCertificateSettings
    {
        private string _storeName;
        
        /// <summary>
        /// Required. Specifies the name of the certificate store from which
        /// retrieve certificate.  For example, My.
        /// </summary>
        public string StoreName
        {
            get { return this._storeName; }
            set { this._storeName = value; }
        }
        
        private string _thumbprint;
        
        /// <summary>
        /// Required. Specifies the thumbprint of the certificate to be
        /// provisioned. The thumbprint must specify an existing service
        /// certificate.
        /// </summary>
        public string Thumbprint
        {
            get { return this._thumbprint; }
            set { this._thumbprint = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the StoredCertificateSettings class.
        /// </summary>
        public StoredCertificateSettings()
        {
        }
    }
    
    public enum UpdatedDeploymentStatus
    {
        Running = 0,
        
        Suspended = 1,
    }
    
    /// <summary>
    /// The current state of the upgrade.
    /// </summary>
    public enum UpgradeDomainState
    {
        Before = 0,
        
        During = 1,
    }
    
    /// <summary>
    /// Contains upgrade details of the deployment.
    /// </summary>
    public partial class UpgradeStatus
    {
        private DeploymentUpgradeType _upgradeType;
        
        /// <summary>
        /// The type of the upgrade. Possible values are Auto and Manual.
        /// </summary>
        public DeploymentUpgradeType UpgradeType
        {
            get { return this._upgradeType; }
            set { this._upgradeType = value; }
        }
        
        private UpgradeDomainState _currentUpgradeDomainState;
        
        /// <summary>
        /// The current state of the upgrade. Possible values are Before and
        /// During
        /// </summary>
        public UpgradeDomainState CurrentUpgradeDomainState
        {
            get { return this._currentUpgradeDomainState; }
            set { this._currentUpgradeDomainState = value; }
        }
        
        private int _currentUpgradeDomain;
        
        /// <summary>
        /// An integer value that identifies the current upgrade domain.
        /// Upgrade domains are identified with a zero-based index: the first
        /// upgrade domain has an ID of 0, the second has an ID of 1, and so
        /// on.
        /// </summary>
        public int CurrentUpgradeDomain
        {
            get { return this._currentUpgradeDomain; }
            set { this._currentUpgradeDomain = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the UpgradeStatus class.
        /// </summary>
        public UpgradeStatus()
        {
        }
    }
    
    /// <summary>
    /// Specifies the platform caching behavior of the data disk blob for
    /// read/write efficiency.
    /// </summary>
    public enum VirtualHardDiskHostCaching
    {
        None = 0,
        
        ReadOnly = 1,
        
        ReadWrite = 2,
    }
    
    /// <summary>
    /// The virtual IP address of the deployment.
    /// </summary>
    public partial class VirtualIPAddress
    {
        private string _address;
        
        /// <summary>
        /// The virtual IP address of the deployment.
        /// </summary>
        public string Address
        {
            get { return this._address; }
            set { this._address = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualIPAddress class.
        /// </summary>
        public VirtualIPAddress()
        {
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Capture Virtual Machine operation.
    /// </summary>
    public partial class VirtualMachineCaptureParameters
    {
        private PostCaptureAction _postCaptureAction;
        
        /// <summary>
        /// Required. Specifies the action that is performed after the capture
        /// operation finishes.  Possible values are:  Delete  this value
        /// causes the virtual machine to be deleted after the image has been
        /// captured.   Reprovision  this value causes the virtual machine to
        /// be redeployed after the image is captured by using the specified
        /// information in ProvisioningConfiguration.
        /// </summary>
        public PostCaptureAction PostCaptureAction
        {
            get { return this._postCaptureAction; }
            set { this._postCaptureAction = value; }
        }
        
        private ConfigurationSet _provisioningConfiguration;
        
        /// <summary>
        /// Optional. Provides information to be used to redeploy the virtual
        /// machine after the image has been captured. This element is only
        /// used when the PostCaptureAction is set to Reprovision.
        /// </summary>
        public ConfigurationSet ProvisioningConfiguration
        {
            get { return this._provisioningConfiguration; }
            set { this._provisioningConfiguration = value; }
        }
        
        private string _targetImageLabel;
        
        /// <summary>
        /// Required. Specifies the friendly name of the captured image. This
        /// is the value that appears in the Name column for the image in the
        /// Windows Azure Management Portal.
        /// </summary>
        public string TargetImageLabel
        {
            get { return this._targetImageLabel; }
            set { this._targetImageLabel = value; }
        }
        
        private string _targetImageName;
        
        /// <summary>
        /// Required. Specifies the image name of the captured image.
        /// </summary>
        public string TargetImageName
        {
            get { return this._targetImageName; }
            set { this._targetImageName = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualMachineCaptureParameters
        /// class.
        /// </summary>
        public VirtualMachineCaptureParameters()
        {
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Create Virtual Machine Deployment operation.
    /// </summary>
    public partial class VirtualMachineCreateDeploymentParameters
    {
        private string _name;
        
        /// <summary>
        /// Required. A name for the deployment. The deployment name must be
        /// unique among other deployments for the hosted service.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private DeploymentSlot _deploymentSlot;
        
        /// <summary>
        /// Required. Specifies the environment in which to deploy the virtual
        /// machine.  Possible values are: Staging, Production.
        /// </summary>
        public DeploymentSlot DeploymentSlot
        {
            get { return this._deploymentSlot; }
            set { this._deploymentSlot = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// Required. A name for the hosted service. The name can be up to 100
        /// characters in length.  It is recommended that the label be unique
        /// within the subscription. The name can be used identify the hosted
        /// service for tracking purposes.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private IList<Role> _roles;
        
        /// <summary>
        /// Required. Contains the provisioning details for the new virtual
        /// machine deployment.
        /// </summary>
        public IList<Role> Roles
        {
            get { return this._roles; }
            set { this._roles = value; }
        }
        
        private string _virtualNetworkName;
        
        /// <summary>
        /// Optional. Specifies the name of an existing virtual network to
        /// which the deployment will belong.  Virtual networks are created by
        /// calling the Set Network Configuration operation.
        /// </summary>
        public string VirtualNetworkName
        {
            get { return this._virtualNetworkName; }
            set { this._virtualNetworkName = value; }
        }
        
        private DnsSettings _dnsSettings;
        
        /// <summary>
        /// Optional. Contains a list of DNS servers to associate with
        /// themachine.
        /// </summary>
        public DnsSettings DnsSettings
        {
            get { return this._dnsSettings; }
            set { this._dnsSettings = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineCreateDeploymentParameters class.
        /// </summary>
        public VirtualMachineCreateDeploymentParameters()
        {
            this._roles = new List<Role>();
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Create Virtual Machine operation.
    /// </summary>
    public partial class VirtualMachineCreateParameters
    {
        private string _roleName;
        
        /// <summary>
        /// Required. Specifies the name for the virtual machine. The name must
        /// be unique within the deployment.
        /// </summary>
        public string RoleName
        {
            get { return this._roleName; }
            set { this._roleName = value; }
        }
        
        private string _availabilitySetName;
        
        /// <summary>
        /// Optional. Specifies the name of an availability set to which to add
        /// the virtual machine. This value controls the virtual machine
        /// allocation in the Windows Azure environment. Virtual machines
        /// specified in the same availability set are allocated to different
        /// nodes to maximize availability.
        /// </summary>
        public string AvailabilitySetName
        {
            get { return this._availabilitySetName; }
            set { this._availabilitySetName = value; }
        }
        
        private Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? _roleSize;
        
        /// <summary>
        /// The size of the virtual machine.
        /// </summary>
        public Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? RoleSize
        {
            get { return this._roleSize; }
            set { this._roleSize = value; }
        }
        
        private IList<ConfigurationSet> _configurationSets;
        
        /// <summary>
        /// Contains the collection of configuration sets that contain system
        /// and application configuration settings.
        /// </summary>
        public IList<ConfigurationSet> ConfigurationSets
        {
            get { return this._configurationSets; }
            set { this._configurationSets = value; }
        }
        
        private IList<DataVirtualHardDisk> _dataVirtualHardDisks;
        
        /// <summary>
        /// Contains the parameters Windows Azure used to create the data disk
        /// for the virtual machine.
        /// </summary>
        public IList<DataVirtualHardDisk> DataVirtualHardDisks
        {
            get { return this._dataVirtualHardDisks; }
            set { this._dataVirtualHardDisks = value; }
        }
        
        private OSVirtualHardDisk _oSVirtualHardDisk;
        
        /// <summary>
        /// Contains the parameters Windows Azure used to create the operating
        /// system disk for the virtual machine.
        /// </summary>
        public OSVirtualHardDisk OSVirtualHardDisk
        {
            get { return this._oSVirtualHardDisk; }
            set { this._oSVirtualHardDisk = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualMachineCreateParameters
        /// class.
        /// </summary>
        public VirtualMachineCreateParameters()
        {
            this._configurationSets = new List<ConfigurationSet>();
            this._dataVirtualHardDisks = new List<DataVirtualHardDisk>();
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Create Virtual Machine Data Disk operation.
    /// </summary>
    public partial class VirtualMachineDiskCreateDataDiskParameters
    {
        private VirtualHardDiskHostCaching _hostCaching;
        
        /// <summary>
        /// Required. Specifies the platform caching behavior of data disk blob
        /// for read/write efficiency. The default vault is ReadOnly. Possible
        /// values are: None, ReadOnly, ReadWrite.  Warning: Setting this
        /// property impacts the consistency of the disk.
        /// </summary>
        public VirtualHardDiskHostCaching HostCaching
        {
            get { return this._hostCaching; }
            set { this._hostCaching = value; }
        }
        
        private string _diskLabel;
        
        /// <summary>
        /// Optional. Specifies the description of the data disk. When you
        /// attach a disk, either by directly referencing a media using the
        /// MediaLink element or specifying the target disk size, you can use
        /// the DiskLabel element to customize the name property of the target
        /// data disk.
        /// </summary>
        public string DiskLabel
        {
            get { return this._diskLabel; }
            set { this._diskLabel = value; }
        }
        
        private string _diskName;
        
        /// <summary>
        /// Optional. Specifies the name of the disk. Windows Azure uses the
        /// specified disk to create the data disk for the machine and
        /// populates this field with the disk name.
        /// </summary>
        public string DiskName
        {
            get { return this._diskName; }
            set { this._diskName = value; }
        }
        
        private int? _logicalUnitNumber;
        
        /// <summary>
        /// Optional. Specifies the Logical Unit Number (LUN) for the disk. The
        /// LUN specifies the slot in which the data drive appears when
        /// mounted for usage by the virtual machine.  Valid LUN values are 0
        /// through 15.
        /// </summary>
        public int? LogicalUnitNumber
        {
            get { return this._logicalUnitNumber; }
            set { this._logicalUnitNumber = value; }
        }
        
        private double _logicalDiskSizeInGB;
        
        /// <summary>
        /// Optional. Specifies the size, in GB, of an empty disk to be
        /// attached to the role. The disk can be created as part of disk
        /// attach or create VM role call by specifying the value for this
        /// property.  Windows Azure creates the empty disk based on size
        /// preference and attaches the newly created disk to the Role.
        /// </summary>
        public double LogicalDiskSizeInGB
        {
            get { return this._logicalDiskSizeInGB; }
            set { this._logicalDiskSizeInGB = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// Required. Specifies the location of the blob in Windows Azure blob
        /// store where the media for the disk is located. The blob location
        /// must belong to the storage account in the subscription specified
        /// by the SubscriptionId value in the operation call. Example:
        /// http://example.blob.core.windows.net/disks/mydisk.vhd
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        private Uri _sourceMediaLinkUri;
        
        /// <summary>
        /// Optional. Specifies the location of a blob in account storage which
        /// is mounted as a data disk when the virtual machine is created.
        /// </summary>
        public Uri SourceMediaLinkUri
        {
            get { return this._sourceMediaLinkUri; }
            set { this._sourceMediaLinkUri = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineDiskCreateDataDiskParameters class.
        /// </summary>
        public VirtualMachineDiskCreateDataDiskParameters()
        {
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Create Virtual Disk Image operation.
    /// </summary>
    public partial class VirtualMachineDiskCreateDiskParameters
    {
        private string _operatingSystemType;
        
        /// <summary>
        /// Required. The operating system type of the disk. Possible values
        /// are: Linux, Windows.
        /// </summary>
        public string OperatingSystemType
        {
            get { return this._operatingSystemType; }
            set { this._operatingSystemType = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// Required. Specifies the friendly name of the disk.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// Required. Specifies the location of the blob in Windows Azure
        /// storage. The blob location must belong to a storage account in the
        /// subscription specified by the SubscriptionId value in the
        /// operation call.  Example:
        /// http://example.blob.core.windows.net/disks/mydisk.vhd
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// Required. Specifies a name for the disk. Windows Azure uses the
        /// name to identify the disk when creating virtual machines from the
        /// disk.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineDiskCreateDiskParameters class.
        /// </summary>
        public VirtualMachineDiskCreateDiskParameters()
        {
        }
    }
    
    /// <summary>
    /// A virtual machine disk associated with your subscription.
    /// </summary>
    public partial class VirtualMachineDiskCreateDiskResponse : OperationResponse
    {
        private string _operatingSystem;
        
        /// <summary>
        /// The Operating System type for the disk.
        /// </summary>
        public string OperatingSystem
        {
            get { return this._operatingSystem; }
            set { this._operatingSystem = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// The friendly name of the disk
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private string _affinityGroup;
        
        /// <summary>
        /// The affinity group in which the disk is located. The AffinityGroup
        /// value is derived from storage account that contains the blob in
        /// which the media is located. If the storage account does not belong
        /// to an affinity group the value is NULL.
        /// </summary>
        public string AffinityGroup
        {
            get { return this._affinityGroup; }
            set { this._affinityGroup = value; }
        }
        
        private string _location;
        
        /// <summary>
        /// The geo-location in which the disk is located. The Location value
        /// is derived from storage account that contains the blob in which
        /// the disk is located. If the storage account belongs to an affinity
        /// group the value is NULL.
        /// </summary>
        public string Location
        {
            get { return this._location; }
            set { this._location = value; }
        }
        
        private double _logicalSizeInGB;
        
        /// <summary>
        /// The size, in GB, of the disk.
        /// </summary>
        public double LogicalSizeInGB
        {
            get { return this._logicalSizeInGB; }
            set { this._logicalSizeInGB = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// The location of the blob in the blob store in which the media for
        /// the disk is located. The blob location belongs to a storage
        /// account in the subscription specified by the SubscriptionId value
        /// in the operation call. Example:
        /// http://example.blob.core.windows.net/disks/mydisk.vhd
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// The name of the disk. This is the name that is used when creating
        /// one or more virtual machines using the disk.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private string _sourceImageName;
        
        /// <summary>
        /// The name of the OS Image from which the disk was created. This
        /// property is populated automatically when a disk is created from an
        /// OS image by calling the Add Role, Create Deployment, or Provision
        /// Disk operations.
        /// </summary>
        public string SourceImageName
        {
            get { return this._sourceImageName; }
            set { this._sourceImageName = value; }
        }
        
        private VirtualMachineDiskCreateDiskResponse.VirtualMachineDiskUsageDetails _usageDetails;
        
        /// <summary>
        /// Contains properties that specify a virtual machine that currently
        /// using the disk. A disk cannot be deleted as long as it is attached
        /// to a virtual machine.
        /// </summary>
        public VirtualMachineDiskCreateDiskResponse.VirtualMachineDiskUsageDetails UsageDetails
        {
            get { return this._usageDetails; }
            set { this._usageDetails = value; }
        }
        
        private bool? _isPremium;
        
        /// <summary>
        /// Specifies whether the comtained image is a premium image
        /// </summary>
        public bool? IsPremium
        {
            get { return this._isPremium; }
            set { this._isPremium = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineDiskCreateDiskResponse class.
        /// </summary>
        public VirtualMachineDiskCreateDiskResponse()
        {
        }
        
        /// <summary>
        /// Contains properties that specify a virtual machine that currently
        /// using the disk. A disk cannot be deleted as long as it is attached
        /// to a virtual machine.
        /// </summary>
        public partial class VirtualMachineDiskUsageDetails
        {
            private string _hostedServiceName;
            
            /// <summary>
            /// The hosted service in which the disk is being used.
            /// </summary>
            public string HostedServiceName
            {
                get { return this._hostedServiceName; }
                set { this._hostedServiceName = value; }
            }
            
            private string _deploymentName;
            
            /// <summary>
            /// The deployment in which the disk is being used.
            /// </summary>
            public string DeploymentName
            {
                get { return this._deploymentName; }
                set { this._deploymentName = value; }
            }
            
            private string _roleName;
            
            /// <summary>
            /// The virtual machine that the disk is attached to.
            /// </summary>
            public string RoleName
            {
                get { return this._roleName; }
                set { this._roleName = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the
            /// VirtualMachineDiskUsageDetails class.
            /// </summary>
            public VirtualMachineDiskUsageDetails()
            {
            }
        }
    }
    
    /// <summary>
    /// The Get Data Disk operation response.
    /// </summary>
    public partial class VirtualMachineDiskGetDataDiskResponse : OperationResponse
    {
        private VirtualHardDiskHostCaching _hostCaching;
        
        /// <summary>
        /// The current value of the platform caching behavior of data disk
        /// blob for read/write efficiency. Possible values are: None,
        /// ReadOnly, ReadWrite.
        /// </summary>
        public VirtualHardDiskHostCaching HostCaching
        {
            get { return this._hostCaching; }
            set { this._hostCaching = value; }
        }
        
        private string _diskLabel;
        
        /// <summary>
        /// The description of the data disk.
        /// </summary>
        public string DiskLabel
        {
            get { return this._diskLabel; }
            set { this._diskLabel = value; }
        }
        
        private string _diskName;
        
        /// <summary>
        /// The name of the data disk.
        /// </summary>
        public string DiskName
        {
            get { return this._diskName; }
            set { this._diskName = value; }
        }
        
        private int? _logicalUnitNumber;
        
        /// <summary>
        /// The Logical Unit Number (LUN) for the disk. The LUN specifies the
        /// slot in which the data drive appears when mounted for usage by the
        /// virtual machine.
        /// </summary>
        public int? LogicalUnitNumber
        {
            get { return this._logicalUnitNumber; }
            set { this._logicalUnitNumber = value; }
        }
        
        private double _logicalDiskSizeInGB;
        
        /// <summary>
        /// The size, in GB, of the data disk.
        /// </summary>
        public double LogicalDiskSizeInGB
        {
            get { return this._logicalDiskSizeInGB; }
            set { this._logicalDiskSizeInGB = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// The location of physical blob backing the data disk. The blob
        /// location is in storage account in the subscription specified by
        /// the SubscriptionId value in the operation call.
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineDiskGetDataDiskResponse class.
        /// </summary>
        public VirtualMachineDiskGetDataDiskResponse()
        {
        }
    }
    
    /// <summary>
    /// A virtual machine disk associated with your subscription.
    /// </summary>
    public partial class VirtualMachineDiskGetDiskResponse : OperationResponse
    {
        private string _affinityGroup;
        
        /// <summary>
        /// The affinity group in which the disk is located. The AffinityGroup
        /// value is derived from storage account that contains the blob in
        /// which the media is located. If the storage account does not belong
        /// to an affinity group the value is NULL.
        /// </summary>
        public string AffinityGroup
        {
            get { return this._affinityGroup; }
            set { this._affinityGroup = value; }
        }
        
        private string _location;
        
        /// <summary>
        /// The geo-location in which the disk is located. The Location value
        /// is derived from storage account that contains the blob in which
        /// the disk is located. If the storage account belongs to an affinity
        /// group the value is NULL.
        /// </summary>
        public string Location
        {
            get { return this._location; }
            set { this._location = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// The friendly name of the disk.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private double _logicalSizeInGB;
        
        /// <summary>
        /// The size, in GB, of the disk.
        /// </summary>
        public double LogicalSizeInGB
        {
            get { return this._logicalSizeInGB; }
            set { this._logicalSizeInGB = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// The location of the blob in the blob store in which the media for
        /// the disk is located. The blob location belongs to a storage
        /// account in the subscription specified by the SubscriptionId value
        /// in the operation call. Example:
        /// http://example.blob.core.windows.net/disks/mydisk.vhd
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// The name of the disk. This is the name that is used when creating
        /// one or more virtual machines using the disk.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private string _operatingSystemType;
        
        /// <summary>
        /// The operating system type of the OS image.  Possible Values are:
        /// Linux, Windows, NULL.
        /// </summary>
        public string OperatingSystemType
        {
            get { return this._operatingSystemType; }
            set { this._operatingSystemType = value; }
        }
        
        private string _sourceImageName;
        
        /// <summary>
        /// The name of the OS Image from which the disk was created. This
        /// property is populated automatically when a disk is created from an
        /// OS image by calling the Add Role, Create Deployment, or Provision
        /// Disk operations.
        /// </summary>
        public string SourceImageName
        {
            get { return this._sourceImageName; }
            set { this._sourceImageName = value; }
        }
        
        private VirtualMachineDiskGetDiskResponse.VirtualMachineDiskUsageDetails _usageDetails;
        
        /// <summary>
        /// Contains properties that specify a virtual machine that currently
        /// using the disk. A disk cannot be deleted as long as it is attached
        /// to a virtual machine.
        /// </summary>
        public VirtualMachineDiskGetDiskResponse.VirtualMachineDiskUsageDetails UsageDetails
        {
            get { return this._usageDetails; }
            set { this._usageDetails = value; }
        }
        
        private bool? _isCorrupted;
        
        /// <summary>
        /// Specifies thether the disk is known to be corrupt
        /// </summary>
        public bool? IsCorrupted
        {
            get { return this._isCorrupted; }
            set { this._isCorrupted = value; }
        }
        
        private bool? _isPremium;
        
        /// <summary>
        /// Specifies whether or not the disk contains a premium virtual
        /// machine image.
        /// </summary>
        public bool? IsPremium
        {
            get { return this._isPremium; }
            set { this._isPremium = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualMachineDiskGetDiskResponse
        /// class.
        /// </summary>
        public VirtualMachineDiskGetDiskResponse()
        {
        }
        
        /// <summary>
        /// Contains properties that specify a virtual machine that currently
        /// using the disk. A disk cannot be deleted as long as it is attached
        /// to a virtual machine.
        /// </summary>
        public partial class VirtualMachineDiskUsageDetails
        {
            private string _hostedServiceName;
            
            /// <summary>
            /// The hosted service in which the disk is being used.
            /// </summary>
            public string HostedServiceName
            {
                get { return this._hostedServiceName; }
                set { this._hostedServiceName = value; }
            }
            
            private string _deploymentName;
            
            /// <summary>
            /// The deployment in which the disk is being used.
            /// </summary>
            public string DeploymentName
            {
                get { return this._deploymentName; }
                set { this._deploymentName = value; }
            }
            
            private string _roleName;
            
            /// <summary>
            /// The virtual machine that the disk is attached to.
            /// </summary>
            public string RoleName
            {
                get { return this._roleName; }
                set { this._roleName = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the
            /// VirtualMachineDiskUsageDetails class.
            /// </summary>
            public VirtualMachineDiskUsageDetails()
            {
            }
        }
    }
    
    /// <summary>
    /// The List Disks operation response.
    /// </summary>
    public partial class VirtualMachineDiskListResponse : OperationResponse, IEnumerable<VirtualMachineDiskListResponse.VirtualMachineDisk>
    {
        private IList<VirtualMachineDiskListResponse.VirtualMachineDisk> _disks;
        
        /// <summary>
        /// The virtual machine disks associated with your subscription.
        /// </summary>
        public IList<VirtualMachineDiskListResponse.VirtualMachineDisk> Disks
        {
            get { return this._disks; }
            set { this._disks = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualMachineDiskListResponse
        /// class.
        /// </summary>
        public VirtualMachineDiskListResponse()
        {
            this._disks = new List<VirtualMachineDiskListResponse.VirtualMachineDisk>();
        }
        
        /// <summary>
        /// Gets the sequence of Disks.
        /// </summary>
        public IEnumerator<VirtualMachineDiskListResponse.VirtualMachineDisk> GetEnumerator()
        {
            return this.Disks.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of Disks.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// A virtual machine disk associated with your subscription.
        /// </summary>
        public partial class VirtualMachineDisk
        {
            private string _affinityGroup;
            
            /// <summary>
            /// The affinity group in which the disk is located. The
            /// AffinityGroup value is derived from storage account that
            /// contains the blob in which the media is located. If the
            /// storage account does not belong to an affinity group the value
            /// is NULL.
            /// </summary>
            public string AffinityGroup
            {
                get { return this._affinityGroup; }
                set { this._affinityGroup = value; }
            }
            
            private string _location;
            
            /// <summary>
            /// The geo-location in which the disk is located. The Location
            /// value is derived from storage account that contains the blob
            /// in which the disk is located. If the storage account belongs
            /// to an affinity group the value is NULL.
            /// </summary>
            public string Location
            {
                get { return this._location; }
                set { this._location = value; }
            }
            
            private string _label;
            
            /// <summary>
            /// The friendly name of the disk.
            /// </summary>
            public string Label
            {
                get { return this._label; }
                set { this._label = value; }
            }
            
            private double _logicalSizeInGB;
            
            /// <summary>
            /// The size, in GB, of the disk.
            /// </summary>
            public double LogicalSizeInGB
            {
                get { return this._logicalSizeInGB; }
                set { this._logicalSizeInGB = value; }
            }
            
            private Uri _mediaLinkUri;
            
            /// <summary>
            /// The location of the blob in the blob store in which the media
            /// for the disk is located. The blob location belongs to a
            /// storage account in the subscription specified by the
            /// SubscriptionId value in the operation call. Example:
            /// http://example.blob.core.windows.net/disks/mydisk.vhd
            /// </summary>
            public Uri MediaLinkUri
            {
                get { return this._mediaLinkUri; }
                set { this._mediaLinkUri = value; }
            }
            
            private string _name;
            
            /// <summary>
            /// The name of the disk. This is the name that is used when
            /// creating one or more virtual machines using the disk.
            /// </summary>
            public string Name
            {
                get { return this._name; }
                set { this._name = value; }
            }
            
            private string _operatingSystemType;
            
            /// <summary>
            /// The operating system type of the OS image.  Possible Values
            /// are: Linux, Windows, NULL.
            /// </summary>
            public string OperatingSystemType
            {
                get { return this._operatingSystemType; }
                set { this._operatingSystemType = value; }
            }
            
            private string _sourceImageName;
            
            /// <summary>
            /// The name of the OS Image from which the disk was created. This
            /// property is populated automatically when a disk is created
            /// from an OS image by calling the Add Role, Create Deployment,
            /// or Provision Disk operations.
            /// </summary>
            public string SourceImageName
            {
                get { return this._sourceImageName; }
                set { this._sourceImageName = value; }
            }
            
            private VirtualMachineDiskListResponse.VirtualMachineDiskUsageDetails _usageDetails;
            
            /// <summary>
            /// Contains properties that specify a virtual machine that
            /// currently using the disk. A disk cannot be deleted as long as
            /// it is attached to a virtual machine.
            /// </summary>
            public VirtualMachineDiskListResponse.VirtualMachineDiskUsageDetails UsageDetails
            {
                get { return this._usageDetails; }
                set { this._usageDetails = value; }
            }
            
            private bool? _isCorrupted;
            
            /// <summary>
            /// Specifies thether the disk is known to be corrupt
            /// </summary>
            public bool? IsCorrupted
            {
                get { return this._isCorrupted; }
                set { this._isCorrupted = value; }
            }
            
            private bool? _isPremium;
            
            /// <summary>
            /// Specifies whether or not the disk contains a premium virtual
            /// machine image.
            /// </summary>
            public bool? IsPremium
            {
                get { return this._isPremium; }
                set { this._isPremium = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the VirtualMachineDisk class.
            /// </summary>
            public VirtualMachineDisk()
            {
            }
        }
        
        /// <summary>
        /// Contains properties that specify a virtual machine that currently
        /// using the disk. A disk cannot be deleted as long as it is attached
        /// to a virtual machine.
        /// </summary>
        public partial class VirtualMachineDiskUsageDetails
        {
            private string _hostedServiceName;
            
            /// <summary>
            /// The hosted service in which the disk is being used.
            /// </summary>
            public string HostedServiceName
            {
                get { return this._hostedServiceName; }
                set { this._hostedServiceName = value; }
            }
            
            private string _deploymentName;
            
            /// <summary>
            /// The deployment in which the disk is being used.
            /// </summary>
            public string DeploymentName
            {
                get { return this._deploymentName; }
                set { this._deploymentName = value; }
            }
            
            private string _roleName;
            
            /// <summary>
            /// The virtual machine that the disk is attached to.
            /// </summary>
            public string RoleName
            {
                get { return this._roleName; }
                set { this._roleName = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the
            /// VirtualMachineDiskUsageDetails class.
            /// </summary>
            public VirtualMachineDiskUsageDetails()
            {
            }
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Update Virtual Machine Data Disk operation.
    /// </summary>
    public partial class VirtualMachineDiskUpdateDataDiskParameters
    {
        private VirtualHardDiskHostCaching _hostCaching;
        
        /// <summary>
        /// Required. Specifies the platform caching behavior of data disk blob
        /// for read/write efficiency. The default vault is ReadOnly. Possible
        /// values are: None, ReadOnly, ReadWrite.  Warning: Setting this
        /// property impacts the consistency of the disk.
        /// </summary>
        public VirtualHardDiskHostCaching HostCaching
        {
            get { return this._hostCaching; }
            set { this._hostCaching = value; }
        }
        
        private string _diskLabel;
        
        /// <summary>
        /// Optional. Specifies the description of the data disk. When you
        /// attach a disk, either by directly referencing a media using the
        /// MediaLink element or specifying the target disk size, you can use
        /// the DiskLabel element to customize the name property of the target
        /// data disk.
        /// </summary>
        public string DiskLabel
        {
            get { return this._diskLabel; }
            set { this._diskLabel = value; }
        }
        
        private string _diskName;
        
        /// <summary>
        /// Optional. Specifies the name of the disk. Windows Azure uses the
        /// specified disk to create the data disk for the machine and
        /// populates this field with the disk name.
        /// </summary>
        public string DiskName
        {
            get { return this._diskName; }
            set { this._diskName = value; }
        }
        
        private int? _logicalUnitNumber;
        
        /// <summary>
        /// Optional. Specifies the Logical Unit Number (LUN) for the disk. The
        /// LUN specifies the slot in which the data drive appears when
        /// mounted for usage by the virtual machine.  Valid LUN values are 0
        /// through 15.
        /// </summary>
        public int? LogicalUnitNumber
        {
            get { return this._logicalUnitNumber; }
            set { this._logicalUnitNumber = value; }
        }
        
        private double _logicalDiskSizeInGB;
        
        /// <summary>
        /// Optional. Specifies the size, in GB, of an empty disk to be
        /// attached to the role. The disk can be created as part of disk
        /// attach or create VM role call by specifying the value for this
        /// property.  Windows Azure creates the empty disk based on size
        /// preference and attaches the newly created disk to the Role.
        /// </summary>
        public double LogicalDiskSizeInGB
        {
            get { return this._logicalDiskSizeInGB; }
            set { this._logicalDiskSizeInGB = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// Required. Specifies the location of the blob in Windows Azure blob
        /// store where the media for the disk is located. The blob location
        /// must belong to the storage account in the subscription specified
        /// by the SubscriptionId value in the operation call. Example:
        /// http://example.blob.core.windows.net/disks/mydisk.vhd
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineDiskUpdateDataDiskParameters class.
        /// </summary>
        public VirtualMachineDiskUpdateDataDiskParameters()
        {
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Update Virtual Disk Image operation.
    /// </summary>
    public partial class VirtualMachineDiskUpdateDiskParameters
    {
        private bool? _hasOperatingSystem;
        
        /// <summary>
        /// Optional.  Specifies whether the disk contains an operation system.
        /// Note: Only a disk with an operating system installed can be
        /// mounted as OS Drive.
        /// </summary>
        public bool? HasOperatingSystem
        {
            get { return this._hasOperatingSystem; }
            set { this._hasOperatingSystem = value; }
        }
        
        private string _operatingSystemType;
        
        /// <summary>
        /// Optional. The operating system type of the disk. Possible values
        /// are: Linux, Windows.
        /// </summary>
        public string OperatingSystemType
        {
            get { return this._operatingSystemType; }
            set { this._operatingSystemType = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// Required. Specifies the friendly name of the disk.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// Optional. Specifies the location of the blob in Windows Azure
        /// storage. The blob location must belong to a storage account in the
        /// subscription specified by the SubscriptionId value in the
        /// operation call.  Example:
        /// http://example.blob.core.windows.net/disks/mydisk.vhd
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// Required. Specifies a name for the disk. Windows Azure uses the
        /// name to identify the disk when creating virtual machines from the
        /// disk.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineDiskUpdateDiskParameters class.
        /// </summary>
        public VirtualMachineDiskUpdateDiskParameters()
        {
        }
    }
    
    /// <summary>
    /// A virtual machine disk associated with your subscription.
    /// </summary>
    public partial class VirtualMachineDiskUpdateDiskResponse : OperationResponse
    {
        private string _operatingSystem;
        
        /// <summary>
        /// The Operating System type for the disk.
        /// </summary>
        public string OperatingSystem
        {
            get { return this._operatingSystem; }
            set { this._operatingSystem = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// The friendly name of the disk
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private string _affinityGroup;
        
        /// <summary>
        /// The affinity group in which the disk is located. The AffinityGroup
        /// value is derived from storage account that contains the blob in
        /// which the media is located. If the storage account does not belong
        /// to an affinity group the value is NULL.
        /// </summary>
        public string AffinityGroup
        {
            get { return this._affinityGroup; }
            set { this._affinityGroup = value; }
        }
        
        private string _location;
        
        /// <summary>
        /// The geo-location in which the disk is located. The Location value
        /// is derived from storage account that contains the blob in which
        /// the disk is located. If the storage account belongs to an affinity
        /// group the value is NULL.
        /// </summary>
        public string Location
        {
            get { return this._location; }
            set { this._location = value; }
        }
        
        private double _logicalSizeInGB;
        
        /// <summary>
        /// The size, in GB, of the disk.
        /// </summary>
        public double LogicalSizeInGB
        {
            get { return this._logicalSizeInGB; }
            set { this._logicalSizeInGB = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// The location of the blob in the blob store in which the media for
        /// the disk is located. The blob location belongs to a storage
        /// account in the subscription specified by the SubscriptionId value
        /// in the operation call. Example:
        /// http://example.blob.core.windows.net/disks/mydisk.vhd
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// The name of the disk. This is the name that is used when creating
        /// one or more virtual machines using the disk.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private bool? _isPremium;
        
        /// <summary>
        /// Specifies whether the comtained image is a premium image
        /// </summary>
        public bool? IsPremium
        {
            get { return this._isPremium; }
            set { this._isPremium = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineDiskUpdateDiskResponse class.
        /// </summary>
        public VirtualMachineDiskUpdateDiskResponse()
        {
        }
    }
    
    /// <summary>
    /// The Download RDP file operation response.
    /// </summary>
    public partial class VirtualMachineGetRemoteDesktopFileResponse : OperationResponse
    {
        private byte[] _remoteDesktopFile;
        
        /// <summary>
        /// A Remote Desktop Protocol (.rdp) file that can be used to establish
        /// a remote desktop session to the virtual machine
        /// </summary>
        public byte[] RemoteDesktopFile
        {
            get { return this._remoteDesktopFile; }
            set { this._remoteDesktopFile = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineGetRemoteDesktopFileResponse class.
        /// </summary>
        public VirtualMachineGetRemoteDesktopFileResponse()
        {
        }
    }
    
    /// <summary>
    /// The Get Virtual Machine operation response.
    /// </summary>
    public partial class VirtualMachineGetResponse : OperationResponse
    {
        private string _roleName;
        
        /// <summary>
        /// The name for the virtual machine. The name is unique within Windows
        /// Azure.
        /// </summary>
        public string RoleName
        {
            get { return this._roleName; }
            set { this._roleName = value; }
        }
        
        private string _osVersion;
        
        /// <summary>
        /// The version of the operating system on which the role instances are
        /// running.
        /// </summary>
        public string OsVersion
        {
            get { return this._osVersion; }
            set { this._osVersion = value; }
        }
        
        private VirtualMachineRoleType _roleType;
        
        /// <summary>
        /// The type of the role for the virtual machine. The only supported
        /// value is PersistentVMRole.
        /// </summary>
        public VirtualMachineRoleType RoleType
        {
            get { return this._roleType; }
            set { this._roleType = value; }
        }
        
        private string _availabilitySetName;
        
        /// <summary>
        /// The name of the availability set the virtual machine belongs to.
        /// This value controls the virtual machine allocation in the Windows
        /// Azure environment. Virtual machines specified in the same
        /// availability set are allocated to different nodes to maximize
        /// availability.
        /// </summary>
        public string AvailabilitySetName
        {
            get { return this._availabilitySetName; }
            set { this._availabilitySetName = value; }
        }
        
        private VirtualMachineRoleSize _roleSize;
        
        /// <summary>
        /// The size of the virtual machine.
        /// </summary>
        public VirtualMachineRoleSize RoleSize
        {
            get { return this._roleSize; }
            set { this._roleSize = value; }
        }
        
        private string _defaultWinRmCertificateThumbprint;
        
        /// <summary>
        /// The read-only thumbprint of the certificate that is used with the
        /// HTTPS listener for WinRM.
        /// </summary>
        public string DefaultWinRmCertificateThumbprint
        {
            get { return this._defaultWinRmCertificateThumbprint; }
            set { this._defaultWinRmCertificateThumbprint = value; }
        }
        
        private IList<ConfigurationSet> _configurationSets;
        
        /// <summary>
        /// Contains the collection of configuration sets that contain system
        /// and application configuration settings.
        /// </summary>
        public IList<ConfigurationSet> ConfigurationSets
        {
            get { return this._configurationSets; }
            set { this._configurationSets = value; }
        }
        
        private IList<DataVirtualHardDisk> _dataVirtualHardDisks;
        
        /// <summary>
        /// Contains the parameters Windows Azure used to create the data disk
        /// for the virtual machine.
        /// </summary>
        public IList<DataVirtualHardDisk> DataVirtualHardDisks
        {
            get { return this._dataVirtualHardDisks; }
            set { this._dataVirtualHardDisks = value; }
        }
        
        private OSVirtualHardDisk _oSVirtualHardDisk;
        
        /// <summary>
        /// Contains the parameters Windows Azure used to create the operating
        /// system disk for the virtual machine.
        /// </summary>
        public OSVirtualHardDisk OSVirtualHardDisk
        {
            get { return this._oSVirtualHardDisk; }
            set { this._oSVirtualHardDisk = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualMachineGetResponse class.
        /// </summary>
        public VirtualMachineGetResponse()
        {
            this._configurationSets = new List<ConfigurationSet>();
            this._dataVirtualHardDisks = new List<DataVirtualHardDisk>();
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Create Virtual Machine Image operation.
    /// </summary>
    public partial class VirtualMachineImageCreateParameters
    {
        private string _label;
        
        /// <summary>
        /// Required. Specifies the friendly name of the image.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// Required. Specifies the location of the blob in Windows Azure
        /// storage. The blob location must belong to a storage account in the
        /// subscription specified by the SubscriptionId value in the
        /// operation call.  Example:
        /// http://example.blob.core.windows.net/disks/mydisk.vhd
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// Required. Specifies a name that Windows Azure uses to identify the
        /// image when creating one or more virtual machines.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private string _operatingSystemType;
        
        /// <summary>
        /// Required. The operating system type of the OS image. Possible
        /// values are: Linux, Windows.
        /// </summary>
        public string OperatingSystemType
        {
            get { return this._operatingSystemType; }
            set { this._operatingSystemType = value; }
        }
        
        private string _eula;
        
        /// <summary>
        /// Optional. Specifies the End User License Agreement that is
        /// associated with the image. The value for this element is a string,
        /// but it is recommended that the value be a URL that points to a
        /// EULA.
        /// </summary>
        public string Eula
        {
            get { return this._eula; }
            set { this._eula = value; }
        }
        
        private string _description;
        
        /// <summary>
        /// Optional. Specifies the description of the OS image.
        /// </summary>
        public string Description
        {
            get { return this._description; }
            set { this._description = value; }
        }
        
        private string _imageFamily;
        
        /// <summary>
        /// Optional. Specifies a value that can be used to group OS images.
        /// </summary>
        public string ImageFamily
        {
            get { return this._imageFamily; }
            set { this._imageFamily = value; }
        }
        
        private System.DateTime? _publishedDate;
        
        /// <summary>
        /// Optional. Specifies the date when the OS image was added to the
        /// image repository.
        /// </summary>
        public System.DateTime? PublishedDate
        {
            get { return this._publishedDate; }
            set { this._publishedDate = value; }
        }
        
        private bool _isPremium;
        
        /// <summary>
        /// Indicates if the image contains software or associated services
        /// that will incur charges above the core price for the virtual
        /// machine.
        /// </summary>
        public bool IsPremium
        {
            get { return this._isPremium; }
            set { this._isPremium = value; }
        }
        
        private bool _showInGui;
        
        /// <summary>
        /// Specifies whether the image should appear in the image gallery.
        /// </summary>
        public bool ShowInGui
        {
            get { return this._showInGui; }
            set { this._showInGui = value; }
        }
        
        private Uri _privacyUri;
        
        /// <summary>
        /// Optional. Specifies the URI that points to a document that contains
        /// the privacy policy related to the OS image.
        /// </summary>
        public Uri PrivacyUri
        {
            get { return this._privacyUri; }
            set { this._privacyUri = value; }
        }
        
        private Uri _iconUri;
        
        /// <summary>
        /// Optional. Specifies the Uri to the icon that is displayed for the
        /// image in the Management Portal.
        /// </summary>
        public Uri IconUri
        {
            get { return this._iconUri; }
            set { this._iconUri = value; }
        }
        
        private Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? _recommendedVMSize;
        
        /// <summary>
        /// Optional. Specifies the size to use for the virtual machine that is
        /// created from the OS image.
        /// </summary>
        public Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? RecommendedVMSize
        {
            get { return this._recommendedVMSize; }
            set { this._recommendedVMSize = value; }
        }
        
        private Uri _smallIconUri;
        
        /// <summary>
        /// Specifies the URI to the small icon that is displayed when the
        /// image is presented in the Windows Azure Management Portal.  The
        /// SmallIconUri element is only available using version 2013-03-01 or
        /// higher.
        /// </summary>
        public Uri SmallIconUri
        {
            get { return this._smallIconUri; }
            set { this._smallIconUri = value; }
        }
        
        private string _language;
        
        /// <summary>
        /// Specifies the language of the image.  The Language element is only
        /// available using version 2013-03-01 or higher.
        /// </summary>
        public string Language
        {
            get { return this._language; }
            set { this._language = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineImageCreateParameters class.
        /// </summary>
        public VirtualMachineImageCreateParameters()
        {
        }
    }
    
    /// <summary>
    /// Parameters returned from the Create Virtual Machine Image operation.
    /// </summary>
    public partial class VirtualMachineImageCreateResponse : OperationResponse
    {
        private string _location;
        
        /// <summary>
        /// The geo-location in which this media is located. The Location value
        /// is derived from storage account that contains the blob in which
        /// the media is located. If the storage account belongs to an
        /// affinity group the value is NULL.  If the version is set to
        /// 2012-08-01 or later, the locations are returned for platform
        /// images; otherwise, this value is NULL for platform images.
        /// </summary>
        public string Location
        {
            get { return this._location; }
            set { this._location = value; }
        }
        
        private string _category;
        
        /// <summary>
        /// The repository classification of the image. All user images have
        /// the category User.
        /// </summary>
        public string Category
        {
            get { return this._category; }
            set { this._category = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// Specifies the friendly name of the image.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private double _logicalSizeInGB;
        
        /// <summary>
        /// The size, in GB, of the image.
        /// </summary>
        public double LogicalSizeInGB
        {
            get { return this._logicalSizeInGB; }
            set { this._logicalSizeInGB = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// Specifies the location of the blob in Windows Azure storage. The
        /// blob location must belong to a storage account in the subscription
        /// specified by the SubscriptionId value in the operation call.
        /// Example: http://example.blob.core.windows.net/disks/mydisk.vhd
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// Specifies a name that Windows Azure uses to identify the image when
        /// creating one or more virtual machines.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private string _operatingSystemType;
        
        /// <summary>
        /// The operating system type of the OS image. Possible values are:
        /// Linux, Windows.
        /// </summary>
        public string OperatingSystemType
        {
            get { return this._operatingSystemType; }
            set { this._operatingSystemType = value; }
        }
        
        private string _eula;
        
        /// <summary>
        /// Specifies the End User License Agreement that is associated with
        /// the image. The value for this element is a string, but it is
        /// recommended that the value be a URL that points to a EULA.
        /// </summary>
        public string Eula
        {
            get { return this._eula; }
            set { this._eula = value; }
        }
        
        private string _description;
        
        /// <summary>
        /// Specifies the description of the OS image.
        /// </summary>
        public string Description
        {
            get { return this._description; }
            set { this._description = value; }
        }
        
        private string _imageFamily;
        
        /// <summary>
        /// Specifies a value that can be used to group OS images.
        /// </summary>
        public string ImageFamily
        {
            get { return this._imageFamily; }
            set { this._imageFamily = value; }
        }
        
        private System.DateTime? _publishedDate;
        
        /// <summary>
        /// Specifies the date when the OS image was added to the image
        /// repository.
        /// </summary>
        public System.DateTime? PublishedDate
        {
            get { return this._publishedDate; }
            set { this._publishedDate = value; }
        }
        
        private string _publisherName;
        
        /// <summary>
        /// Specifies the name of the publisher of the image.
        /// </summary>
        public string PublisherName
        {
            get { return this._publisherName; }
            set { this._publisherName = value; }
        }
        
        private bool? _isPremium;
        
        /// <summary>
        /// Indicates if the image contains software or associated services
        /// that will incur charges above the core price for the virtual
        /// machine.
        /// </summary>
        public bool? IsPremium
        {
            get { return this._isPremium; }
            set { this._isPremium = value; }
        }
        
        private bool? _showInGui;
        
        /// <summary>
        /// Specifies whether the image should appear in the image gallery.
        /// </summary>
        public bool? ShowInGui
        {
            get { return this._showInGui; }
            set { this._showInGui = value; }
        }
        
        private Uri _privacyUri;
        
        /// <summary>
        /// Specifies the URI that points to a document that contains the
        /// privacy policy related to the OS image.
        /// </summary>
        public Uri PrivacyUri
        {
            get { return this._privacyUri; }
            set { this._privacyUri = value; }
        }
        
        private Uri _iconUri;
        
        /// <summary>
        /// Specifies the Uri to the icon that is displayed for the image in
        /// the Management Portal.
        /// </summary>
        public Uri IconUri
        {
            get { return this._iconUri; }
            set { this._iconUri = value; }
        }
        
        private VirtualMachineRoleSize _recommendedVMSize;
        
        /// <summary>
        /// Specifies the size to use for the virtual machine that is created
        /// from the OS image.
        /// </summary>
        public VirtualMachineRoleSize RecommendedVMSize
        {
            get { return this._recommendedVMSize; }
            set { this._recommendedVMSize = value; }
        }
        
        private Uri _smallIconUri;
        
        /// <summary>
        /// Specifies the URI to the small icon that is displayed when the
        /// image is presented in the Windows Azure Management Portal.  The
        /// SmallIconUri element is only available using version 2013-03-01 or
        /// higher.
        /// </summary>
        public Uri SmallIconUri
        {
            get { return this._smallIconUri; }
            set { this._smallIconUri = value; }
        }
        
        private string _language;
        
        /// <summary>
        /// Specifies the language of the image.  The Language element is only
        /// available using version 2013-03-01 or higher.
        /// </summary>
        public string Language
        {
            get { return this._language; }
            set { this._language = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualMachineImageCreateResponse
        /// class.
        /// </summary>
        public VirtualMachineImageCreateResponse()
        {
        }
    }
    
    /// <summary>
    /// A virtual machine image associated with your subscription.
    /// </summary>
    public partial class VirtualMachineImageGetResponse : OperationResponse
    {
        private string _affinityGroup;
        
        /// <summary>
        /// The affinity in which the media is located. The AffinityGroup value
        /// is derived from storage account that contains the blob in which
        /// the media is located. If the storage account does not belong to an
        /// affinity group the value is NULL and the element is not displayed
        /// in the response.  This value is NULL for platform images.
        /// </summary>
        public string AffinityGroup
        {
            get { return this._affinityGroup; }
            set { this._affinityGroup = value; }
        }
        
        private string _category;
        
        /// <summary>
        /// The repository classification of the image. All user images have
        /// the category User.
        /// </summary>
        public string Category
        {
            get { return this._category; }
            set { this._category = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// An identifier for the image.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private string _location;
        
        /// <summary>
        /// The geo-location in which this media is located. The Location value
        /// is derived from storage account that contains the blob in which
        /// the media is located. If the storage account belongs to an
        /// affinity group the value is NULL.  If the version is set to
        /// 2012-08-01 or later, the locations are returned for platform
        /// images; otherwise, this value is NULL for platform images.
        /// </summary>
        public string Location
        {
            get { return this._location; }
            set { this._location = value; }
        }
        
        private double _logicalSizeInGB;
        
        /// <summary>
        /// The size, in GB, of the image.
        /// </summary>
        public double LogicalSizeInGB
        {
            get { return this._logicalSizeInGB; }
            set { this._logicalSizeInGB = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// The location of the blob in Windows Azure storage. The blob
        /// location belongs to a storage account in the subscription
        /// specified by the SubscriptionId value in the operation call.
        /// Example: http://example.blob.core.windows.net/disks/myimage.vhd
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// The name of the operating system image. This is the name that is
        /// used when creating one or more virtual machines using the image.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private string _operatingSystemType;
        
        /// <summary>
        /// The operating system type of the OS image. Possible values are:
        /// Linux, Windows.
        /// </summary>
        public string OperatingSystemType
        {
            get { return this._operatingSystemType; }
            set { this._operatingSystemType = value; }
        }
        
        private string _eula;
        
        /// <summary>
        /// Specifies the End User License Agreement that is associated with
        /// the image. The value for this element is a string, but it is
        /// recommended that the value be a URL that points to a EULA.
        /// </summary>
        public string Eula
        {
            get { return this._eula; }
            set { this._eula = value; }
        }
        
        private string _description;
        
        /// <summary>
        /// Specifies the description of the image.
        /// </summary>
        public string Description
        {
            get { return this._description; }
            set { this._description = value; }
        }
        
        private string _imageFamily;
        
        /// <summary>
        /// Specifies a value that can be used to group images.
        /// </summary>
        public string ImageFamily
        {
            get { return this._imageFamily; }
            set { this._imageFamily = value; }
        }
        
        private bool? _showInGui;
        
        /// <summary>
        /// Indicates whther the image should be shown in the windows azure
        /// portal
        /// </summary>
        public bool? ShowInGui
        {
            get { return this._showInGui; }
            set { this._showInGui = value; }
        }
        
        private DateTime _publishedDate;
        
        /// <summary>
        /// Specifies the date when the image was added to the image repository.
        /// </summary>
        public DateTime PublishedDate
        {
            get { return this._publishedDate; }
            set { this._publishedDate = value; }
        }
        
        private bool? _isPremium;
        
        /// <summary>
        /// Indicates whether the image contains software or associated
        /// services that will incur charges above the core price for the
        /// virtual machine. For additional details, see the PricingDetailLink
        /// element.
        /// </summary>
        public bool? IsPremium
        {
            get { return this._isPremium; }
            set { this._isPremium = value; }
        }
        
        private Uri _iconUri;
        
        /// <summary>
        /// Provides the URI to the icon for this Operating System Image
        /// </summary>
        public Uri IconUri
        {
            get { return this._iconUri; }
            set { this._iconUri = value; }
        }
        
        private Uri _privacyUri;
        
        /// <summary>
        /// Specifies the URI that points to a document that contains the
        /// privacy policy related to the image.
        /// </summary>
        public Uri PrivacyUri
        {
            get { return this._privacyUri; }
            set { this._privacyUri = value; }
        }
        
        private VirtualMachineRoleSize _recommendedVMSize;
        
        /// <summary>
        /// Optional. Specifies the size to use for the virtual machine that is
        /// created from the OS image.
        /// </summary>
        public VirtualMachineRoleSize RecommendedVMSize
        {
            get { return this._recommendedVMSize; }
            set { this._recommendedVMSize = value; }
        }
        
        private string _publisherName;
        
        /// <summary>
        /// The name of the publisher of this OS Image in Windows Azure
        /// </summary>
        public string PublisherName
        {
            get { return this._publisherName; }
            set { this._publisherName = value; }
        }
        
        private Uri _smallIconUri;
        
        /// <summary>
        /// Specifies the URI to the small icon that is displayed when the
        /// image is presented in the Windows Azure Management Portal.  The
        /// SmallIconUri element is only available using version 2013-03-01 or
        /// higher.
        /// </summary>
        public Uri SmallIconUri
        {
            get { return this._smallIconUri; }
            set { this._smallIconUri = value; }
        }
        
        private string _language;
        
        /// <summary>
        /// Specifies the language of the image.  The Language element is only
        /// available using version 2013-03-01 or higher.
        /// </summary>
        public string Language
        {
            get { return this._language; }
            set { this._language = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualMachineImageGetResponse
        /// class.
        /// </summary>
        public VirtualMachineImageGetResponse()
        {
        }
    }
    
    /// <summary>
    /// The List OS Images operation response.
    /// </summary>
    public partial class VirtualMachineImageListResponse : OperationResponse, IEnumerable<VirtualMachineImageListResponse.VirtualMachineImage>
    {
        private IList<VirtualMachineImageListResponse.VirtualMachineImage> _images;
        
        /// <summary>
        /// The virtual machine images associated with your subscription.
        /// </summary>
        public IList<VirtualMachineImageListResponse.VirtualMachineImage> Images
        {
            get { return this._images; }
            set { this._images = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualMachineImageListResponse
        /// class.
        /// </summary>
        public VirtualMachineImageListResponse()
        {
            this._images = new List<VirtualMachineImageListResponse.VirtualMachineImage>();
        }
        
        /// <summary>
        /// Gets the sequence of Images.
        /// </summary>
        public IEnumerator<VirtualMachineImageListResponse.VirtualMachineImage> GetEnumerator()
        {
            return this.Images.GetEnumerator();
        }
        
        /// <summary>
        /// Gets the sequence of Images.
        /// </summary>
        System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
        {
            return this.GetEnumerator();
        }
        
        /// <summary>
        /// A virtual machine image associated with your subscription.
        /// </summary>
        public partial class VirtualMachineImage
        {
            private string _affinityGroup;
            
            /// <summary>
            /// The affinity in which the media is located. The AffinityGroup
            /// value is derived from storage account that contains the blob
            /// in which the media is located. If the storage account does not
            /// belong to an affinity group the value is NULL and the element
            /// is not displayed in the response.  This value is NULL for
            /// platform images.
            /// </summary>
            public string AffinityGroup
            {
                get { return this._affinityGroup; }
                set { this._affinityGroup = value; }
            }
            
            private string _category;
            
            /// <summary>
            /// The repository classification of the image. All user images
            /// have the category User.
            /// </summary>
            public string Category
            {
                get { return this._category; }
                set { this._category = value; }
            }
            
            private string _label;
            
            /// <summary>
            /// An identifier for the image.
            /// </summary>
            public string Label
            {
                get { return this._label; }
                set { this._label = value; }
            }
            
            private string _location;
            
            /// <summary>
            /// The geo-location in which this media is located. The Location
            /// value is derived from storage account that contains the blob
            /// in which the media is located. If the storage account belongs
            /// to an affinity group the value is NULL.  If the version is set
            /// to 2012-08-01 or later, the locations are returned for
            /// platform images; otherwise, this value is NULL for platform
            /// images.
            /// </summary>
            public string Location
            {
                get { return this._location; }
                set { this._location = value; }
            }
            
            private double _logicalSizeInGB;
            
            /// <summary>
            /// The size, in GB, of the image.
            /// </summary>
            public double LogicalSizeInGB
            {
                get { return this._logicalSizeInGB; }
                set { this._logicalSizeInGB = value; }
            }
            
            private Uri _mediaLinkUri;
            
            /// <summary>
            /// The location of the blob in Windows Azure storage. The blob
            /// location belongs to a storage account in the subscription
            /// specified by the SubscriptionId value in the operation call.
            /// Example:
            /// http://example.blob.core.windows.net/disks/myimage.vhd
            /// </summary>
            public Uri MediaLinkUri
            {
                get { return this._mediaLinkUri; }
                set { this._mediaLinkUri = value; }
            }
            
            private string _name;
            
            /// <summary>
            /// The name of the operating system image. This is the name that
            /// is used when creating one or more virtual machines using the
            /// image.
            /// </summary>
            public string Name
            {
                get { return this._name; }
                set { this._name = value; }
            }
            
            private string _operatingSystemType;
            
            /// <summary>
            /// The operating system type of the OS image. Possible values are:
            /// Linux, Windows.
            /// </summary>
            public string OperatingSystemType
            {
                get { return this._operatingSystemType; }
                set { this._operatingSystemType = value; }
            }
            
            private string _eula;
            
            /// <summary>
            /// Specifies the End User License Agreement that is associated
            /// with the image. The value for this element is a string, but it
            /// is recommended that the value be a URL that points to a EULA.
            /// </summary>
            public string Eula
            {
                get { return this._eula; }
                set { this._eula = value; }
            }
            
            private string _description;
            
            /// <summary>
            /// Specifies the description of the image.
            /// </summary>
            public string Description
            {
                get { return this._description; }
                set { this._description = value; }
            }
            
            private string _imageFamily;
            
            /// <summary>
            /// Specifies a value that can be used to group images.
            /// </summary>
            public string ImageFamily
            {
                get { return this._imageFamily; }
                set { this._imageFamily = value; }
            }
            
            private DateTime _publishedDate;
            
            /// <summary>
            /// Specifies the date when the image was added to the image
            /// repository.
            /// </summary>
            public DateTime PublishedDate
            {
                get { return this._publishedDate; }
                set { this._publishedDate = value; }
            }
            
            private bool? _isPremium;
            
            /// <summary>
            /// Indicates whether the image contains software or associated
            /// services that will incur charges above the core price for the
            /// virtual machine. For additional details, see the
            /// PricingDetailLink element.
            /// </summary>
            public bool? IsPremium
            {
                get { return this._isPremium; }
                set { this._isPremium = value; }
            }
            
            private Uri _privacyUri;
            
            /// <summary>
            /// Specifies the URI that points to a document that contains the
            /// privacy policy related to the image.
            /// </summary>
            public Uri PrivacyUri
            {
                get { return this._privacyUri; }
                set { this._privacyUri = value; }
            }
            
            private VirtualMachineRoleSize _recommendedVMSize;
            
            /// <summary>
            /// Optional. Specifies the size to use for the virtual machine
            /// that is created from the OS image.
            /// </summary>
            public VirtualMachineRoleSize RecommendedVMSize
            {
                get { return this._recommendedVMSize; }
                set { this._recommendedVMSize = value; }
            }
            
            private string _publisherName;
            
            /// <summary>
            /// The name of the publisher of this OS Image in Windows Azure
            /// </summary>
            public string PublisherName
            {
                get { return this._publisherName; }
                set { this._publisherName = value; }
            }
            
            private Uri _pricingDetailUri;
            
            /// <summary>
            /// Specifies a URL for an image with IsPremium set to true, which
            /// contains the pricing details for a virtual machine that is
            /// created from the image.  The PricingDetailLink element is only
            /// available using version 2012-12-01 or higher.
            /// </summary>
            public Uri PricingDetailUri
            {
                get { return this._pricingDetailUri; }
                set { this._pricingDetailUri = value; }
            }
            
            private Uri _smallIconUri;
            
            /// <summary>
            /// Specifies the URI to the small icon that is displayed when the
            /// image is presented in the Windows Azure Management Portal.
            /// The SmallIconUri element is only available using version
            /// 2013-03-01 or higher.
            /// </summary>
            public Uri SmallIconUri
            {
                get { return this._smallIconUri; }
                set { this._smallIconUri = value; }
            }
            
            private string _language;
            
            /// <summary>
            /// Specifies the language of the image.  The Language element is
            /// only available using version 2013-03-01 or higher.
            /// </summary>
            public string Language
            {
                get { return this._language; }
                set { this._language = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the VirtualMachineImage class.
            /// </summary>
            public VirtualMachineImage()
            {
            }
        }
    }
    
    /// <summary>
    /// Known values for the operating system type of the OS in a virtual
    /// machine image.
    /// </summary>
    public static partial class VirtualMachineImageOperatingSystemType
    {
        public const string Linux = "Linux";
        
        public const string Windows = "Windows";
    }
    
    /// <summary>
    /// Parameters supplied to the Update Virtual Machine Image operation.
    /// </summary>
    public partial class VirtualMachineImageUpdateParameters
    {
        private string _label;
        
        /// <summary>
        /// Required. Specifies the friendly name of the image to be updated.
        /// You cannot use this operation to update images provided by the
        /// Windows Azure platform.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private string _eula;
        
        /// <summary>
        /// Optional. Specifies the End User License Agreement that is
        /// associated with the image. The value for this element is a string,
        /// but it is recommended that the value be a URL that points to a
        /// EULA.
        /// </summary>
        public string Eula
        {
            get { return this._eula; }
            set { this._eula = value; }
        }
        
        private string _description;
        
        /// <summary>
        /// Optional. Specifies the description of the OS image.
        /// </summary>
        public string Description
        {
            get { return this._description; }
            set { this._description = value; }
        }
        
        private string _imageFamily;
        
        /// <summary>
        /// Optional. Specifies a value that can be used to group OS images.
        /// </summary>
        public string ImageFamily
        {
            get { return this._imageFamily; }
            set { this._imageFamily = value; }
        }
        
        private System.DateTime? _publishedDate;
        
        /// <summary>
        /// Optional. Specifies the date when the OS image was added to the
        /// image repository.
        /// </summary>
        public System.DateTime? PublishedDate
        {
            get { return this._publishedDate; }
            set { this._publishedDate = value; }
        }
        
        private bool _isPremium;
        
        /// <summary>
        /// Indicates if the image contains software or associated services
        /// that will incur charges above the core price for the virtual
        /// machine.
        /// </summary>
        public bool IsPremium
        {
            get { return this._isPremium; }
            set { this._isPremium = value; }
        }
        
        private Uri _privacyUri;
        
        /// <summary>
        /// Optional. Specifies the URI that points to a document that contains
        /// the privacy policy related to the OS image.
        /// </summary>
        public Uri PrivacyUri
        {
            get { return this._privacyUri; }
            set { this._privacyUri = value; }
        }
        
        private Uri _iconUri;
        
        /// <summary>
        /// Optional. Specifies the Uri to the icon that is displayed for the
        /// image in the Management Portal.
        /// </summary>
        public Uri IconUri
        {
            get { return this._iconUri; }
            set { this._iconUri = value; }
        }
        
        private Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? _recommendedVMSize;
        
        /// <summary>
        /// Optional. Specifies the size to use for the virtual machine that is
        /// created from the OS image.
        /// </summary>
        public Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? RecommendedVMSize
        {
            get { return this._recommendedVMSize; }
            set { this._recommendedVMSize = value; }
        }
        
        private Uri _smallIconUri;
        
        /// <summary>
        /// Specifies the URI to the small icon that is displayed when the
        /// image is presented in the Windows Azure Management Portal.  The
        /// SmallIconUri element is only available using version 2013-03-01 or
        /// higher.
        /// </summary>
        public Uri SmallIconUri
        {
            get { return this._smallIconUri; }
            set { this._smallIconUri = value; }
        }
        
        private string _language;
        
        /// <summary>
        /// Specifies the language of the image.  The Language element is only
        /// available using version 2013-03-01 or higher.
        /// </summary>
        public string Language
        {
            get { return this._language; }
            set { this._language = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineImageUpdateParameters class.
        /// </summary>
        public VirtualMachineImageUpdateParameters()
        {
        }
    }
    
    /// <summary>
    /// Parameters returned from the Create Virtual Machine Image operation.
    /// </summary>
    public partial class VirtualMachineImageUpdateResponse : OperationResponse
    {
        private string _location;
        
        /// <summary>
        /// The geo-location in which this media is located. The Location value
        /// is derived from storage account that contains the blob in which
        /// the media is located. If the storage account belongs to an
        /// affinity group the value is NULL.  If the version is set to
        /// 2012-08-01 or later, the locations are returned for platform
        /// images; otherwise, this value is NULL for platform images.
        /// </summary>
        public string Location
        {
            get { return this._location; }
            set { this._location = value; }
        }
        
        private string _category;
        
        /// <summary>
        /// The repository classification of the image. All user images have
        /// the category User.
        /// </summary>
        public string Category
        {
            get { return this._category; }
            set { this._category = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// Specifies the friendly name of the image.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private double _logicalSizeInGB;
        
        /// <summary>
        /// The size, in GB, of the image.
        /// </summary>
        public double LogicalSizeInGB
        {
            get { return this._logicalSizeInGB; }
            set { this._logicalSizeInGB = value; }
        }
        
        private Uri _mediaLinkUri;
        
        /// <summary>
        /// Specifies the location of the blob in Windows Azure storage. The
        /// blob location must belong to a storage account in the subscription
        /// specified by the SubscriptionId value in the operation call.
        /// Example: http://example.blob.core.windows.net/disks/mydisk.vhd
        /// </summary>
        public Uri MediaLinkUri
        {
            get { return this._mediaLinkUri; }
            set { this._mediaLinkUri = value; }
        }
        
        private string _name;
        
        /// <summary>
        /// Specifies a name that Windows Azure uses to identify the image when
        /// creating one or more virtual machines.
        /// </summary>
        public string Name
        {
            get { return this._name; }
            set { this._name = value; }
        }
        
        private string _operatingSystemType;
        
        /// <summary>
        /// The operating system type of the OS image. Possible values are:
        /// Linux, Windows.
        /// </summary>
        public string OperatingSystemType
        {
            get { return this._operatingSystemType; }
            set { this._operatingSystemType = value; }
        }
        
        private string _eula;
        
        /// <summary>
        /// Specifies the End User License Agreement that is associated with
        /// the image. The value for this element is a string, but it is
        /// recommended that the value be a URL that points to a EULA.
        /// </summary>
        public string Eula
        {
            get { return this._eula; }
            set { this._eula = value; }
        }
        
        private string _description;
        
        /// <summary>
        /// Specifies the description of the OS image.
        /// </summary>
        public string Description
        {
            get { return this._description; }
            set { this._description = value; }
        }
        
        private string _imageFamily;
        
        /// <summary>
        /// Specifies a value that can be used to group OS images.
        /// </summary>
        public string ImageFamily
        {
            get { return this._imageFamily; }
            set { this._imageFamily = value; }
        }
        
        private System.DateTime? _publishedDate;
        
        /// <summary>
        /// Specifies the date when the OS image was added to the image
        /// repository.
        /// </summary>
        public System.DateTime? PublishedDate
        {
            get { return this._publishedDate; }
            set { this._publishedDate = value; }
        }
        
        private string _publisherName;
        
        /// <summary>
        /// Specifies the name of the publisher of the image.
        /// </summary>
        public string PublisherName
        {
            get { return this._publisherName; }
            set { this._publisherName = value; }
        }
        
        private bool? _isPremium;
        
        /// <summary>
        /// Indicates if the image contains software or associated services
        /// that will incur charges above the core price for the virtual
        /// machine.
        /// </summary>
        public bool? IsPremium
        {
            get { return this._isPremium; }
            set { this._isPremium = value; }
        }
        
        private bool? _showInGui;
        
        /// <summary>
        /// Specifies whether the image should appear in the image gallery.
        /// </summary>
        public bool? ShowInGui
        {
            get { return this._showInGui; }
            set { this._showInGui = value; }
        }
        
        private Uri _privacyUri;
        
        /// <summary>
        /// Specifies the URI that points to a document that contains the
        /// privacy policy related to the OS image.
        /// </summary>
        public Uri PrivacyUri
        {
            get { return this._privacyUri; }
            set { this._privacyUri = value; }
        }
        
        private Uri _iconUri;
        
        /// <summary>
        /// Specifies the Uri to the icon that is displayed for the image in
        /// the Management Portal.
        /// </summary>
        public Uri IconUri
        {
            get { return this._iconUri; }
            set { this._iconUri = value; }
        }
        
        private VirtualMachineRoleSize _recommendedVMSize;
        
        /// <summary>
        /// Specifies the size to use for the virtual machine that is created
        /// from the OS image.
        /// </summary>
        public VirtualMachineRoleSize RecommendedVMSize
        {
            get { return this._recommendedVMSize; }
            set { this._recommendedVMSize = value; }
        }
        
        private Uri _smallIconUri;
        
        /// <summary>
        /// Specifies the URI to the small icon that is displayed when the
        /// image is presented in the Windows Azure Management Portal.  The
        /// SmallIconUri element is only available using version 2013-03-01 or
        /// higher.
        /// </summary>
        public Uri SmallIconUri
        {
            get { return this._smallIconUri; }
            set { this._smallIconUri = value; }
        }
        
        private string _language;
        
        /// <summary>
        /// Specifies the language of the image.  The Language element is only
        /// available using version 2013-03-01 or higher.
        /// </summary>
        public string Language
        {
            get { return this._language; }
            set { this._language = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualMachineImageUpdateResponse
        /// class.
        /// </summary>
        public VirtualMachineImageUpdateResponse()
        {
        }
    }
    
    /// <summary>
    /// The size of a virtual machine.
    /// </summary>
    public enum VirtualMachineRoleSize
    {
        Small = 0,
        
        ExtraSmall = 1,
        
        Large = 2,
        
        Medium = 3,
        
        ExtraLarge = 4,
        
        A5 = 5,
        
        A6 = 6,
        
        A7 = 7,
    }
    
    /// <summary>
    /// The type of the role for the virtual machine.
    /// </summary>
    public enum VirtualMachineRoleType
    {
        PersistentVMRole = 0,
    }
    
    /// <summary>
    /// The parameters required for shutting down the virtual machine
    /// </summary>
    public partial class VirtualMachineShutdownParameters
    {
        private PostShutdownAction _postShutdownAction;
        
        /// <summary>
        /// The state of the vm after shotdown (stopped or stopped and
        /// deallocated)
        /// </summary>
        public PostShutdownAction PostShutdownAction
        {
            get { return this._postShutdownAction; }
            set { this._postShutdownAction = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualMachineShutdownParameters
        /// class.
        /// </summary>
        public VirtualMachineShutdownParameters()
        {
        }
    }
    
    /// <summary>
    /// Parameters for the shutdown roles operation
    /// </summary>
    public partial class VirtualMachineShutdownRolesParameters
    {
        private IList<string> _roles;
        
        /// <summary>
        /// The set of roles to shut down
        /// </summary>
        public IList<string> Roles
        {
            get { return this._roles; }
            set { this._roles = value; }
        }
        
        private Microsoft.WindowsAzure.Management.Compute.Models.PostShutdownAction? _postShutdownAction;
        
        /// <summary>
        /// The state of the roles after shutdown.  Possible values include
        /// Stopped or StoppedDeallocated
        /// </summary>
        public Microsoft.WindowsAzure.Management.Compute.Models.PostShutdownAction? PostShutdownAction
        {
            get { return this._postShutdownAction; }
            set { this._postShutdownAction = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineShutdownRolesParameters class.
        /// </summary>
        public VirtualMachineShutdownRolesParameters()
        {
            this._roles = new List<string>();
        }
    }
    
    /// <summary>
    /// Parameters for the start roles operation
    /// </summary>
    public partial class VirtualMachineStartRolesParameters
    {
        private IList<string> _roles;
        
        /// <summary>
        /// The set of roles to shut down
        /// </summary>
        public IList<string> Roles
        {
            get { return this._roles; }
            set { this._roles = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineStartRolesParameters class.
        /// </summary>
        public VirtualMachineStartRolesParameters()
        {
            this._roles = new List<string>();
        }
    }
    
    /// <summary>
    /// The set of parameters required to update a load balanced endpoint set
    /// </summary>
    public partial class VirtualMachineUpdateLoadBalancedSetParameters
    {
        private IList<VirtualMachineUpdateLoadBalancedSetParameters.InputEndpoint> _loadBalancedEndpoints;
        
        /// <summary>
        /// A list of load balanced InputEndpoints to update.
        /// </summary>
        public IList<VirtualMachineUpdateLoadBalancedSetParameters.InputEndpoint> LoadBalancedEndpoints
        {
            get { return this._loadBalancedEndpoints; }
            set { this._loadBalancedEndpoints = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the
        /// VirtualMachineUpdateLoadBalancedSetParameters class.
        /// </summary>
        public VirtualMachineUpdateLoadBalancedSetParameters()
        {
            this._loadBalancedEndpoints = new List<VirtualMachineUpdateLoadBalancedSetParameters.InputEndpoint>();
        }
        
        /// <summary>
        /// The modeled external endpoint for a persistent VM role
        /// </summary>
        public partial class InputEndpoint
        {
            private string _loadBalancedEndpointSetName;
            
            /// <summary>
            /// Specifies whether this endpoint is part of shared LoadBalanced
            /// endpoint and served by multiple role instances. If not
            /// specified a BadRequest error will be returned. It must also be
            /// in use by the deployment (at least one role in the deployment
            /// must have an endpoint whose LoadBalancedEndpointSetName
            /// matches this) otherwise a BadRequest error will be returned.
            /// </summary>
            public string LoadBalancedEndpointSetName
            {
                get { return this._loadBalancedEndpointSetName; }
                set { this._loadBalancedEndpointSetName = value; }
            }
            
            private int? _localPort;
            
            /// <summary>
            /// Specifies the internal port on which a service running inside
            /// the VM is listening to serve this endpoint. WARNING: If
            /// specified then ALL the endpoints of this LB set on all the
            /// roles will be updated to have THIS local port. To keep unique
            /// local ports on each role for a load balanced endpoint specify
            /// this as 0 (zero) and if you need to change those use
            /// UpdateRole. In case of port conflict with a local port (or
            /// probe port) on a role a BadRequestwill be returned.
            /// </summary>
            public int? LocalPort
            {
                get { return this._localPort; }
                set { this._localPort = value; }
            }
            
            private string _name;
            
            /// <summary>
            /// Optional.  The name of the InputEndpoint.  The name is ignored
            /// if specified
            /// </summary>
            public string Name
            {
                get { return this._name; }
                set { this._name = value; }
            }
            
            private int? _port;
            
            /// <summary>
            /// An integer specifying the public port for this endpoint.
            /// Allowed values are between 1 and 65535 inclusive. A unqiue
            /// Port and Protocol combination must be specified for each
            /// InputEndpoint in the list.
            /// </summary>
            public int? Port
            {
                get { return this._port; }
                set { this._port = value; }
            }
            
            private LoadBalancerProbe _loadBalancerProbe;
            
            /// <summary>
            /// Optional. This represents an endpoint setting which platform
            /// load balancer must monitor to detect the availability of this
            /// role before forwarding traffic to this endpoint. If not
            /// specified the probe settings (if any) from the existing load
            /// balanced endpoint definition  will be retained.
            /// </summary>
            public LoadBalancerProbe LoadBalancerProbe
            {
                get { return this._loadBalancerProbe; }
                set { this._loadBalancerProbe = value; }
            }
            
            private string _protocol;
            
            /// <summary>
            /// Specifies the transport protocol for the endpoint.
            /// </summary>
            public string Protocol
            {
                get { return this._protocol; }
                set { this._protocol = value; }
            }
            
            private string _virtualIPAddress;
            
            /// <summary>
            /// The virtual IP address of the endpoint.
            /// </summary>
            public string VirtualIPAddress
            {
                get { return this._virtualIPAddress; }
                set { this._virtualIPAddress = value; }
            }
            
            private bool? _enableDirectServerReturn;
            
            /// <summary>
            /// Optional. A Boolean specifying whether this endpoint uses
            /// Direct Server Return
            /// </summary>
            public bool? EnableDirectServerReturn
            {
                get { return this._enableDirectServerReturn; }
                set { this._enableDirectServerReturn = value; }
            }
            
            private IList<AccessControlListRule> _rules;
            
            /// <summary>
            /// A collection of access control rules which control the external
            /// network traffic reaching to this endpoint. NOTES: (1) To
            /// remove the ACLs from a load-balanced endpoint just omit this
            /// element. (2) ACLs are set as specified. There is no merge done
            /// with existing ACLs.
            /// </summary>
            public IList<AccessControlListRule> Rules
            {
                get { return this._rules; }
                set { this._rules = value; }
            }
            
            /// <summary>
            /// Initializes a new instance of the InputEndpoint class.
            /// </summary>
            public InputEndpoint()
            {
                this._rules = new List<AccessControlListRule>();
            }
        }
    }
    
    /// <summary>
    /// Parameters supplied to the Update Virtual Machine operation.
    /// </summary>
    public partial class VirtualMachineUpdateParameters
    {
        private string _roleName;
        
        /// <summary>
        /// Required. Specifies the name for the virtual machine. The name must
        /// be unique within the deployment.
        /// </summary>
        public string RoleName
        {
            get { return this._roleName; }
            set { this._roleName = value; }
        }
        
        private string _label;
        
        /// <summary>
        /// Optional. Specifies the friendly name for the virtual machine.
        /// </summary>
        public string Label
        {
            get { return this._label; }
            set { this._label = value; }
        }
        
        private string _availabilitySetName;
        
        /// <summary>
        /// Optional. Specifies the name of an availability set to which to add
        /// the virtual machine. This value controls the virtual machine
        /// allocation in the Windows Azure environment. Virtual machines
        /// specified in the same availability set are allocated to different
        /// nodes to maximize availability.
        /// </summary>
        public string AvailabilitySetName
        {
            get { return this._availabilitySetName; }
            set { this._availabilitySetName = value; }
        }
        
        private Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? _roleSize;
        
        /// <summary>
        /// The size of the virtual machine.
        /// </summary>
        public Microsoft.WindowsAzure.Management.Compute.Models.VirtualMachineRoleSize? RoleSize
        {
            get { return this._roleSize; }
            set { this._roleSize = value; }
        }
        
        private IList<ConfigurationSet> _configurationSets;
        
        /// <summary>
        /// Contains the collection of configuration sets that contain system
        /// and application configuration settings.
        /// </summary>
        public IList<ConfigurationSet> ConfigurationSets
        {
            get { return this._configurationSets; }
            set { this._configurationSets = value; }
        }
        
        private IList<DataVirtualHardDisk> _dataVirtualHardDisks;
        
        /// <summary>
        /// Contains the parameters Windows Azure used to create the data disk
        /// for the virtual machine.
        /// </summary>
        public IList<DataVirtualHardDisk> DataVirtualHardDisks
        {
            get { return this._dataVirtualHardDisks; }
            set { this._dataVirtualHardDisks = value; }
        }
        
        private OSVirtualHardDisk _oSVirtualHardDisk;
        
        /// <summary>
        /// Contains the parameters Windows Azure used to create the operating
        /// system disk for the virtual machine.
        /// </summary>
        public OSVirtualHardDisk OSVirtualHardDisk
        {
            get { return this._oSVirtualHardDisk; }
            set { this._oSVirtualHardDisk = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the VirtualMachineUpdateParameters
        /// class.
        /// </summary>
        public VirtualMachineUpdateParameters()
        {
            this._configurationSets = new List<ConfigurationSet>();
            this._dataVirtualHardDisks = new List<DataVirtualHardDisk>();
        }
    }
    
    /// <summary>
    /// Specifies the type of listener for enabling remote Windows PowerShell.
    /// </summary>
    public enum VirtualMachineWindowsRemoteManagementListenerType
    {
        Http = 0,
        
        Https = 1,
    }
    
    /// <summary>
    /// Contains the type and certificate information for the listener.
    /// </summary>
    public partial class WindowsRemoteManagementListener
    {
        private VirtualMachineWindowsRemoteManagementListenerType _listenerType;
        
        /// <summary>
        /// Specifies the type of listener. This value can be Http or Https.
        /// The value is case sensitive.
        /// </summary>
        public VirtualMachineWindowsRemoteManagementListenerType ListenerType
        {
            get { return this._listenerType; }
            set { this._listenerType = value; }
        }
        
        private string _certificateThumbprint;
        
        /// <summary>
        /// Optional. Specifies the certificate thumbprint for the secure
        /// connection. If Type is Https then this value is an optional value
        /// that is set to the thumbprint of the service certificate that is
        /// used to provision the WinRM HTTPS listener. If this value is not
        /// specified, a self-signed certificate is generated and used for the
        /// virtual machine.
        /// </summary>
        public string CertificateThumbprint
        {
            get { return this._certificateThumbprint; }
            set { this._certificateThumbprint = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the WindowsRemoteManagementListener
        /// class.
        /// </summary>
        public WindowsRemoteManagementListener()
        {
        }
    }
    
    /// <summary>
    /// Optional. Configures the Windows Remote Management service on the
    /// virtual machine, which enables remote Windows PowerShell.
    /// </summary>
    public partial class WindowsRemoteManagementSettings
    {
        private IList<WindowsRemoteManagementListener> _listeners;
        
        /// <summary>
        /// Required. Contains a collection of information for enabling remote
        /// Windows PowerShell.
        /// </summary>
        public IList<WindowsRemoteManagementListener> Listeners
        {
            get { return this._listeners; }
            set { this._listeners = value; }
        }
        
        /// <summary>
        /// Initializes a new instance of the WindowsRemoteManagementSettings
        /// class.
        /// </summary>
        public WindowsRemoteManagementSettings()
        {
            this._listeners = new List<WindowsRemoteManagementListener>();
        }
    }
}

namespace Microsoft.WindowsAzure.Management.Compute
{
    /// <summary>
    /// The Service Management API provides programmatic access to much of the
    /// functionality available through the Management Portal. The Service
    /// Management API is a REST API. All API operations are performed over
    /// SSL and mutually authenticated using X.509 v3 certificates.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460799.aspx for
    /// more information)
    /// </summary>
    public partial interface IComputeManagementClient
    {
        /// <summary>
        /// When you create a Windows Azure subscription, it is uniquely
        /// identified by a subscription ID. The subscription ID forms part of
        /// the URI for every call that you make to the Service Management
        /// API.  The Windows Azure Service ManagementAPI use mutual
        /// authentication of management certificates over SSL to ensure that
        /// a request made to the service is secure.  No anonymous requests
        /// are allowed.
        /// </summary>
        SubscriptionCloudCredentials Credentials
        {
            get; 
        }
        
        /// <summary>
        /// The URI used as the base for all Service Management requests.
        /// </summary>
        Uri BaseUri
        {
            get; 
        }
        
        /// <summary>
        /// The Service Management API includes operations for managing the
        /// deployments beneath your subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460812.aspx
        /// for more information)
        /// </summary>
        IDeploymentOperations Deployments
        {
            get; 
        }
        
        /// <summary>
        /// The Service Management API includes operations for managing the
        /// hosted services beneath your subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460812.aspx
        /// for more information)
        /// </summary>
        IHostedServiceOperations HostedServices
        {
            get; 
        }
        
        /// <summary>
        /// Operations for determining the version of the Windows Azure Guest
        /// Operating System on which your service is running.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ff684169.aspx
        /// for more information)
        /// </summary>
        IOperatingSystemOperations OperatingSystems
        {
            get; 
        }
        
        /// <summary>
        /// Operations for managing service certificates for your subscription.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee795178.aspx
        /// for more information)
        /// </summary>
        IServiceCertificateOperations ServiceCertificates
        {
            get; 
        }
        
        /// <summary>
        /// The Service Management API includes operations for managing the
        /// disks in your subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157188.aspx
        /// for more information)
        /// </summary>
        IVirtualMachineDiskOperations VirtualMachineDisks
        {
            get; 
        }
        
        /// <summary>
        /// The Service Management API includes operations for managing the OS
        /// images in your subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157175.aspx
        /// for more information)
        /// </summary>
        IVirtualMachineImageOperations VirtualMachineImages
        {
            get; 
        }
        
        /// <summary>
        /// The Service Management API includes operations for managing the
        /// virtual machines in your subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157206.aspx
        /// for more information)
        /// </summary>
        IVirtualMachineOperations VirtualMachines
        {
            get; 
        }
        
        /// <summary>
        /// The Get Operation Status operation returns the status of
        /// thespecified operation. After calling an asynchronous operation,
        /// you can call Get Operation Status to determine whether the
        /// operation has succeeded, failed, or is still in progress.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460783.aspx
        /// for more information)
        /// </summary>
        /// <param name='requestId'>
        /// The request ID for the request you wish to track. The request ID is
        /// returned in the x-ms-request-id response header for every request.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> GetOperationStatusAsync(string requestId, CancellationToken cancellationToken);
    }
    
    /// <summary>
    /// The Service Management API provides programmatic access to much of the
    /// functionality available through the Management Portal. The Service
    /// Management API is a REST API. All API operations are performed over
    /// SSL and mutually authenticated using X.509 v3 certificates.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460799.aspx for
    /// more information)
    /// </summary>
    public static partial class ComputeManagementClientExtensions
    {
        /// <summary>
        /// The Get Operation Status operation returns the status of
        /// thespecified operation. After calling an asynchronous operation,
        /// you can call Get Operation Status to determine whether the
        /// operation has succeeded, failed, or is still in progress.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460783.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IComputeManagementClient.
        /// </param>
        /// <param name='requestId'>
        /// The request ID for the request you wish to track. The request ID is
        /// returned in the x-ms-request-id response header for every request.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse GetOperationStatus(this IComputeManagementClient operations, string requestId)
        {
            try
            {
                return operations.GetOperationStatusAsync(requestId).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Operation Status operation returns the status of
        /// thespecified operation. After calling an asynchronous operation,
        /// you can call Get Operation Status to determine whether the
        /// operation has succeeded, failed, or is still in progress.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460783.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IComputeManagementClient.
        /// </param>
        /// <param name='requestId'>
        /// The request ID for the request you wish to track. The request ID is
        /// returned in the x-ms-request-id response header for every request.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> GetOperationStatusAsync(this IComputeManagementClient operations, string requestId)
        {
            return operations.GetOperationStatusAsync(requestId, CancellationToken.None);
        }
    }
    
    /// <summary>
    /// The Service Management API provides programmatic access to much of the
    /// functionality available through the Management Portal. The Service
    /// Management API is a REST API. All API operations are performed over
    /// SSL and mutually authenticated using X.509 v3 certificates.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460799.aspx for
    /// more information)
    /// </summary>
    public partial class ComputeManagementClient : ServiceClient<ComputeManagementClient>, IComputeManagementClient
    {
        private SubscriptionCloudCredentials _credentials;
        
        /// <summary>
        /// When you create a Windows Azure subscription, it is uniquely
        /// identified by a subscription ID. The subscription ID forms part of
        /// the URI for every call that you make to the Service Management
        /// API.  The Windows Azure Service ManagementAPI use mutual
        /// authentication of management certificates over SSL to ensure that
        /// a request made to the service is secure.  No anonymous requests
        /// are allowed.
        /// </summary>
        public SubscriptionCloudCredentials Credentials
        {
            get { return this._credentials; }
        }
        
        private Uri _baseUri;
        
        /// <summary>
        /// The URI used as the base for all Service Management requests.
        /// </summary>
        public Uri BaseUri
        {
            get { return this._baseUri; }
        }
        
        private IDeploymentOperations _deployments;
        
        /// <summary>
        /// The Service Management API includes operations for managing the
        /// deployments beneath your subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460812.aspx
        /// for more information)
        /// </summary>
        public virtual IDeploymentOperations Deployments
        {
            get { return this._deployments; }
        }
        
        private IHostedServiceOperations _hostedServices;
        
        /// <summary>
        /// The Service Management API includes operations for managing the
        /// hosted services beneath your subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460812.aspx
        /// for more information)
        /// </summary>
        public virtual IHostedServiceOperations HostedServices
        {
            get { return this._hostedServices; }
        }
        
        private IOperatingSystemOperations _operatingSystems;
        
        /// <summary>
        /// Operations for determining the version of the Windows Azure Guest
        /// Operating System on which your service is running.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ff684169.aspx
        /// for more information)
        /// </summary>
        public virtual IOperatingSystemOperations OperatingSystems
        {
            get { return this._operatingSystems; }
        }
        
        private IServiceCertificateOperations _serviceCertificates;
        
        /// <summary>
        /// Operations for managing service certificates for your subscription.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee795178.aspx
        /// for more information)
        /// </summary>
        public virtual IServiceCertificateOperations ServiceCertificates
        {
            get { return this._serviceCertificates; }
        }
        
        private IVirtualMachineDiskOperations _virtualMachineDisks;
        
        /// <summary>
        /// The Service Management API includes operations for managing the
        /// disks in your subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157188.aspx
        /// for more information)
        /// </summary>
        public virtual IVirtualMachineDiskOperations VirtualMachineDisks
        {
            get { return this._virtualMachineDisks; }
        }
        
        private IVirtualMachineImageOperations _virtualMachineImages;
        
        /// <summary>
        /// The Service Management API includes operations for managing the OS
        /// images in your subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157175.aspx
        /// for more information)
        /// </summary>
        public virtual IVirtualMachineImageOperations VirtualMachineImages
        {
            get { return this._virtualMachineImages; }
        }
        
        private IVirtualMachineOperations _virtualMachines;
        
        /// <summary>
        /// The Service Management API includes operations for managing the
        /// virtual machines in your subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157206.aspx
        /// for more information)
        /// </summary>
        public virtual IVirtualMachineOperations VirtualMachines
        {
            get { return this._virtualMachines; }
        }
        
        /// <summary>
        /// Initializes a new instance of the ComputeManagementClient class.
        /// </summary>
        private ComputeManagementClient()
            : base()
        {
            this._deployments = new DeploymentOperations(this);
            this._hostedServices = new HostedServiceOperations(this);
            this._operatingSystems = new OperatingSystemOperations(this);
            this._serviceCertificates = new ServiceCertificateOperations(this);
            this._virtualMachineDisks = new VirtualMachineDiskOperations(this);
            this._virtualMachineImages = new VirtualMachineImageOperations(this);
            this._virtualMachines = new VirtualMachineOperations(this);
            this.HttpClient.Timeout = TimeSpan.FromSeconds(300);
        }
        
        /// <summary>
        /// Initializes a new instance of the ComputeManagementClient class.
        /// </summary>
        /// <param name='credentials'>
        /// When you create a Windows Azure subscription, it is uniquely
        /// identified by a subscription ID. The subscription ID forms part of
        /// the URI for every call that you make to the Service Management
        /// API.  The Windows Azure Service ManagementAPI use mutual
        /// authentication of management certificates over SSL to ensure that
        /// a request made to the service is secure.  No anonymous requests
        /// are allowed.
        /// </param>
        /// <param name='baseUri'>
        /// The URI used as the base for all Service Management requests.
        /// </param>
        public ComputeManagementClient(SubscriptionCloudCredentials credentials, Uri baseUri)
            : this()
        {
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            if (baseUri == null)
            {
                throw new ArgumentNullException("baseUri");
            }
            this._credentials = credentials;
            this._baseUri = baseUri;
            
            this.Credentials.InitializeServiceClient(this);
        }
        
        /// <summary>
        /// Initializes a new instance of the ComputeManagementClient class.
        /// </summary>
        /// <param name='credentials'>
        /// When you create a Windows Azure subscription, it is uniquely
        /// identified by a subscription ID. The subscription ID forms part of
        /// the URI for every call that you make to the Service Management
        /// API.  The Windows Azure Service ManagementAPI use mutual
        /// authentication of management certificates over SSL to ensure that
        /// a request made to the service is secure.  No anonymous requests
        /// are allowed.
        /// </param>
        public ComputeManagementClient(SubscriptionCloudCredentials credentials)
            : this()
        {
            if (credentials == null)
            {
                throw new ArgumentNullException("credentials");
            }
            this._credentials = credentials;
            this._baseUri = new Uri("https://management.core.windows.net");
            
            this.Credentials.InitializeServiceClient(this);
        }
        
        /// <summary>
        /// The Get Operation Status operation returns the status of
        /// thespecified operation. After calling an asynchronous operation,
        /// you can call Get Operation Status to determine whether the
        /// operation has succeeded, failed, or is still in progress.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460783.aspx
        /// for more information)
        /// </summary>
        /// <param name='requestId'>
        /// The request ID for the request you wish to track. The request ID is
        /// returned in the x-ms-request-id response header for every request.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> GetOperationStatusAsync(string requestId, CancellationToken cancellationToken)
        {
            // Validate
            if (requestId == null)
            {
                throw new ArgumentNullException("requestId");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("requestId", requestId);
                Tracing.Enter(invocationId, this, "GetOperationStatusAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.BaseUri + "/" + this.Credentials.SubscriptionId + "/operations/" + requestId;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    ComputeOperationStatusResponse result = new ComputeOperationStatusResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement operationElement = responseDoc.Element(XName.Get("Operation", "http://schemas.microsoft.com/windowsazure"));
                    if (operationElement != null)
                    {
                        XElement idElement = operationElement.Element(XName.Get("ID", "http://schemas.microsoft.com/windowsazure"));
                        if (idElement != null)
                        {
                            string idInstance = idElement.Value;
                            result.Id = idInstance;
                        }
                        
                        XElement statusElement = operationElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                        if (statusElement != null)
                        {
                            OperationStatus statusInstance = (OperationStatus)Enum.Parse(typeof(OperationStatus), statusElement.Value, false);
                            result.Status = statusInstance;
                        }
                        
                        XElement httpStatusCodeElement = operationElement.Element(XName.Get("HttpStatusCode", "http://schemas.microsoft.com/windowsazure"));
                        if (httpStatusCodeElement != null)
                        {
                            HttpStatusCode httpStatusCodeInstance = (HttpStatusCode)Enum.Parse(typeof(HttpStatusCode), httpStatusCodeElement.Value, false);
                            result.HttpStatusCode = httpStatusCodeInstance;
                        }
                        
                        XElement errorElement = operationElement.Element(XName.Get("Error", "http://schemas.microsoft.com/windowsazure"));
                        if (errorElement != null)
                        {
                            ComputeOperationStatusResponse.ErrorDetails errorInstance = new ComputeOperationStatusResponse.ErrorDetails();
                            result.Error = errorInstance;
                            
                            XElement codeElement = errorElement.Element(XName.Get("Code", "http://schemas.microsoft.com/windowsazure"));
                            if (codeElement != null)
                            {
                                string codeInstance = codeElement.Value;
                                errorInstance.Code = codeInstance;
                            }
                            
                            XElement messageElement = errorElement.Element(XName.Get("Message", "http://schemas.microsoft.com/windowsazure"));
                            if (messageElement != null)
                            {
                                string messageInstance = messageElement.Value;
                                errorInstance.Message = messageInstance;
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// Parse enum values for type LoadBalancerProbeTransportProtocol.
        /// </summary>
        /// <param name='value'>
        /// The value to parse.
        /// </param>
        /// <returns>
        /// The enum value.
        /// </returns>
        internal static LoadBalancerProbeTransportProtocol ParseLoadBalancerProbeTransportProtocol(string value)
        {
            if (value == "tcp")
            {
                return LoadBalancerProbeTransportProtocol.Tcp;
            }
            if (value == "http")
            {
                return LoadBalancerProbeTransportProtocol.Http;
            }
            throw new ArgumentOutOfRangeException("value");
        }
        
        /// <summary>
        /// Convert an enum of type LoadBalancerProbeTransportProtocol to a
        /// string.
        /// </summary>
        /// <param name='value'>
        /// The value to convert to a string.
        /// </param>
        /// <returns>
        /// The enum value as a string.
        /// </returns>
        internal static string LoadBalancerProbeTransportProtocolToString(LoadBalancerProbeTransportProtocol value)
        {
            if (value == LoadBalancerProbeTransportProtocol.Tcp)
            {
                return "tcp";
            }
            if (value == LoadBalancerProbeTransportProtocol.Http)
            {
                return "http";
            }
            throw new ArgumentOutOfRangeException("value");
        }
        
        /// <summary>
        /// Parse enum values for type RollbackUpdateOrUpgradeMode.
        /// </summary>
        /// <param name='value'>
        /// The value to parse.
        /// </param>
        /// <returns>
        /// The enum value.
        /// </returns>
        internal static RollbackUpdateOrUpgradeMode ParseRollbackUpdateOrUpgradeMode(string value)
        {
            if (value == "auto")
            {
                return RollbackUpdateOrUpgradeMode.Auto;
            }
            if (value == "manual")
            {
                return RollbackUpdateOrUpgradeMode.Manual;
            }
            throw new ArgumentOutOfRangeException("value");
        }
        
        /// <summary>
        /// Convert an enum of type RollbackUpdateOrUpgradeMode to a string.
        /// </summary>
        /// <param name='value'>
        /// The value to convert to a string.
        /// </param>
        /// <returns>
        /// The enum value as a string.
        /// </returns>
        internal static string RollbackUpdateOrUpgradeModeToString(RollbackUpdateOrUpgradeMode value)
        {
            if (value == RollbackUpdateOrUpgradeMode.Auto)
            {
                return "auto";
            }
            if (value == RollbackUpdateOrUpgradeMode.Manual)
            {
                return "manual";
            }
            throw new ArgumentOutOfRangeException("value");
        }
        
        /// <summary>
        /// Parse enum values for type HostingResources.
        /// </summary>
        /// <param name='value'>
        /// The value to parse.
        /// </param>
        /// <returns>
        /// The enum value.
        /// </returns>
        internal static HostingResources ParseHostingResources(string value)
        {
            if (value == "WebRole")
            {
                return HostingResources.WebRole;
            }
            if (value == "WorkerRole")
            {
                return HostingResources.WorkerRole;
            }
            if (value == "WebRole|WorkerRole")
            {
                return HostingResources.WebOrWorkerRole;
            }
            throw new ArgumentOutOfRangeException("value");
        }
        
        /// <summary>
        /// Convert an enum of type HostingResources to a string.
        /// </summary>
        /// <param name='value'>
        /// The value to convert to a string.
        /// </param>
        /// <returns>
        /// The enum value as a string.
        /// </returns>
        internal static string HostingResourcesToString(HostingResources value)
        {
            if (value == HostingResources.WebRole)
            {
                return "WebRole";
            }
            if (value == HostingResources.WorkerRole)
            {
                return "WorkerRole";
            }
            if (value == HostingResources.WebOrWorkerRole)
            {
                return "WebRole|WorkerRole";
            }
            throw new ArgumentOutOfRangeException("value");
        }
        
        /// <summary>
        /// Parse enum values for type CertificateFormat.
        /// </summary>
        /// <param name='value'>
        /// The value to parse.
        /// </param>
        /// <returns>
        /// The enum value.
        /// </returns>
        internal static CertificateFormat ParseCertificateFormat(string value)
        {
            if (value == "pfx")
            {
                return CertificateFormat.Pfx;
            }
            if (value == "cer")
            {
                return CertificateFormat.Cer;
            }
            throw new ArgumentOutOfRangeException("value");
        }
        
        /// <summary>
        /// Convert an enum of type CertificateFormat to a string.
        /// </summary>
        /// <param name='value'>
        /// The value to convert to a string.
        /// </param>
        /// <returns>
        /// The enum value as a string.
        /// </returns>
        internal static string CertificateFormatToString(CertificateFormat value)
        {
            if (value == CertificateFormat.Pfx)
            {
                return "pfx";
            }
            if (value == CertificateFormat.Cer)
            {
                return "cer";
            }
            throw new ArgumentOutOfRangeException("value");
        }
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the
    /// deployments beneath your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460812.aspx for
    /// more information)
    /// </summary>
    public partial interface IDeploymentOperations
    {
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to change deployment configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginChangingConfigurationBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentChangeConfigurationParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to change deployment configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> ChangeConfigurationBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentChangeConfigurationParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to change configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginChangingConfigurationByNameAsync(string serviceName, string deploymentName, DeploymentChangeConfigurationParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to change configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> ChangeConfigurationByNameAsync(string serviceName, string deploymentName, DeploymentChangeConfigurationParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Create Deployment operation uploads a new service package and
        /// creates a new deployment in the staging or production
        /// environments.  The Create Deployment operation is an asynchronous
        /// operation. To determine whether the management service has
        /// finished processing the request, call Get Operation Status. For
        /// more information on asynchronous operations, see Tracking
        /// Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460813.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to create a deployment for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to create a deployment for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginCreatingAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentCreateParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Create Deployment operation uploads a new service package and
        /// creates a new deployment in the staging or production
        /// environments.  The Create Deployment operation is an asynchronous
        /// operation. To determine whether the management service has
        /// finished processing the request, call Get Operation Status. For
        /// more information on asynchronous operations, see Tracking
        /// Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460813.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to create a deployment for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to create a deployment for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> CreateAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentCreateParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginDeletingByNameAsync(string serviceName, string deploymentName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> DeleteByNameAsync(string serviceName, string deploymentName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginDeletingBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> DeleteBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get Deployment operation returns configuration information,
        /// status, and system properties for a deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460804.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A deployment that exists in the cloud service.
        /// </returns>
        Task<DeploymentGetResponse> GetByNameAsync(string serviceName, string deploymentName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get Deployment operation returns configuration information,
        /// status, and system properties for a deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460804.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A deployment that exists in the cloud service.
        /// </returns>
        Task<DeploymentGetResponse> GetBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get Package operation retrieves a cloud service package for a
        /// deployment and stores the package files in Windows Azure Blob
        /// storage.  The following package files are placed in storage:
        /// Service configuration file - The cloud service configuration file
        /// (.cscfg) provides configuration settings for the cloud service and
        /// individual roles, including the number of role instances.
        /// Service package - The service package (.cspkg) contains the
        /// application code and the service definition file.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154121.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Package operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> GetPackageByNameAsync(string serviceName, string deploymentName, DeploymentGetPackageParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get Package operation retrieves a cloud service package for a
        /// deployment and stores the package files in Windows Azure Blob
        /// storage.  The following package files are placed in storage:
        /// Service configuration file - The cloud service configuration file
        /// (.cscfg) provides configuration settings for the cloud service and
        /// individual roles, including the number of role instances.
        /// Service package - The service package (.cspkg) contains the
        /// application code and the service definition file.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154121.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Package operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> GetPackageBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentGetPackageParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginRebootingRoleInstanceByDeploymentNameAsync(string serviceName, string deploymentName, string roleInstanceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> RebootRoleInstanceByDeploymentNameAsync(string serviceName, string deploymentName, string roleInstanceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginRebootingRoleInstanceByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> RebootRoleInstanceByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginReimagingRoleInstanceByDeploymentNameAsync(string serviceName, string deploymentName, string roleInstanceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> ReimageRoleInstanceByDeploymentNameAsync(string serviceName, string deploymentName, string roleInstanceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginReimagingRoleInstanceByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> ReimageRoleInstanceByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Rollback Update Or Upgrade operation cancels an in-progress
        /// configuration update and returns the deployment to its state
        /// before the update was started.  The Rollback Update Or Upgrade
        /// operation can only be called when an update is in progress on the
        /// deployment. The deployment status can be detected by calling the
        /// Get Deployment operation or Get Hosted Service Properties
        /// operation and inspecting the RollbackAllowed element. If the value
        /// returned is true a rollback can be performed.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/hh403977.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Rollback Update Or Upgrade operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> RollbackUpdateOrUpgradeByDeploymentNameAsync(string serviceName, string deploymentName, DeploymentRollbackUpdateOrUpgradeParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Rollback Update Or Upgrade operation cancels an in-progress
        /// configuration update and returns the deployment to its state
        /// before the update was started.  The Rollback Update Or Upgrade
        /// operation can only be called when an update is in progress on the
        /// deployment. The deployment status can be detected by calling the
        /// Get Deployment operation or Get Hosted Service Properties
        /// operation and inspecting the RollbackAllowed element. If the value
        /// returned is true a rollback can be performed.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/hh403977.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Rollback Update Or Upgrade operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> RollbackUpdateOrUpgradeByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentRollbackUpdateOrUpgradeParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Swap Deployment operation initiates a virtual IP address swap
        /// between the staging and production deployment environments for a
        /// service. If the service is currently running in the staging
        /// environment, it will be swapped to the production environment. If
        /// it is running in the production environment, it will be swapped to
        /// staging. For more information on this type of upgrade, see
        /// Performing Virtual IP Swap Upgrades.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460814.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Swap Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginSwappingAsync(string serviceName, DeploymentSwapParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Swap Deployment operation initiates a virtual IP address swap
        /// between the staging and production deployment environments for a
        /// service. If the service is currently running in the staging
        /// environment, it will be swapped to the production environment. If
        /// it is running in the production environment, it will be swapped to
        /// staging. For more information on this type of upgrade, see
        /// Performing Virtual IP Swap Upgrades.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460814.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Swap Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> SwapAsync(string serviceName, DeploymentSwapParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginUpdatingStatusByDeploymentNameAsync(string serviceName, string deploymentName, DeploymentUpdateStatusParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> UpdateStatusByDeploymentNameAsync(string serviceName, string deploymentName, DeploymentUpdateStatusParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginUpdatingStatusByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentUpdateStatusParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> UpdateStatusByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentUpdateStatusParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.  To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginUpgradingBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentUpgradeParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> UpgradeBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentUpgradeParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginUpgradingByNameAsync(string serviceName, string deploymentName, DeploymentUpgradeParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> UpgradeByNameAsync(string serviceName, string deploymentName, DeploymentUpgradeParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginWalkingUpgradeDomainByDeploymentNameAsync(string serviceName, string deploymentName, DeploymentWalkUpgradeDomainParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> WalkUpgradeDomainByDeploymentNameAsync(string serviceName, string deploymentName, DeploymentWalkUpgradeDomainParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginWalkingUpgradeDomainByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentWalkUpgradeDomainParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> WalkUpgradeDomainByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentWalkUpgradeDomainParameters parameters, CancellationToken cancellationToken);
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the
    /// deployments beneath your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460812.aspx for
    /// more information)
    /// </summary>
    public static partial class DeploymentOperationsExtensions
    {
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to change deployment configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginChangingConfigurationBySlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentChangeConfigurationParameters parameters)
        {
            try
            {
                return operations.BeginChangingConfigurationBySlotAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to change deployment configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginChangingConfigurationBySlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentChangeConfigurationParameters parameters)
        {
            return operations.BeginChangingConfigurationBySlotAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to change deployment configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse ChangeConfigurationBySlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentChangeConfigurationParameters parameters)
        {
            try
            {
                return operations.ChangeConfigurationBySlotAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to change deployment configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> ChangeConfigurationBySlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentChangeConfigurationParameters parameters)
        {
            return operations.ChangeConfigurationBySlotAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to change configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginChangingConfigurationByName(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentChangeConfigurationParameters parameters)
        {
            try
            {
                return operations.BeginChangingConfigurationByNameAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to change configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginChangingConfigurationByNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentChangeConfigurationParameters parameters)
        {
            return operations.BeginChangingConfigurationByNameAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to change configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse ChangeConfigurationByName(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentChangeConfigurationParameters parameters)
        {
            try
            {
                return operations.ChangeConfigurationByNameAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to change configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> ChangeConfigurationByNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentChangeConfigurationParameters parameters)
        {
            return operations.ChangeConfigurationByNameAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Create Deployment operation uploads a new service package and
        /// creates a new deployment in the staging or production
        /// environments.  The Create Deployment operation is an asynchronous
        /// operation. To determine whether the management service has
        /// finished processing the request, call Get Operation Status. For
        /// more information on asynchronous operations, see Tracking
        /// Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460813.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to create a deployment for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to create a deployment for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Deployment operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginCreating(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentCreateParameters parameters)
        {
            try
            {
                return operations.BeginCreatingAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Create Deployment operation uploads a new service package and
        /// creates a new deployment in the staging or production
        /// environments.  The Create Deployment operation is an asynchronous
        /// operation. To determine whether the management service has
        /// finished processing the request, call Get Operation Status. For
        /// more information on asynchronous operations, see Tracking
        /// Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460813.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to create a deployment for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to create a deployment for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Deployment operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginCreatingAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentCreateParameters parameters)
        {
            return operations.BeginCreatingAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Create Deployment operation uploads a new service package and
        /// creates a new deployment in the staging or production
        /// environments.  The Create Deployment operation is an asynchronous
        /// operation. To determine whether the management service has
        /// finished processing the request, call Get Operation Status. For
        /// more information on asynchronous operations, see Tracking
        /// Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460813.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to create a deployment for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to create a deployment for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Deployment operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse Create(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentCreateParameters parameters)
        {
            try
            {
                return operations.CreateAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Create Deployment operation uploads a new service package and
        /// creates a new deployment in the staging or production
        /// environments.  The Create Deployment operation is an asynchronous
        /// operation. To determine whether the management service has
        /// finished processing the request, call Get Operation Status. For
        /// more information on asynchronous operations, see Tracking
        /// Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460813.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to create a deployment for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to create a deployment for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Deployment operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> CreateAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentCreateParameters parameters)
        {
            return operations.CreateAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginDeletingByName(this IDeploymentOperations operations, string serviceName, string deploymentName)
        {
            try
            {
                return operations.BeginDeletingByNameAsync(serviceName, deploymentName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginDeletingByNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName)
        {
            return operations.BeginDeletingByNameAsync(serviceName, deploymentName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse DeleteByName(this IDeploymentOperations operations, string serviceName, string deploymentName)
        {
            try
            {
                return operations.DeleteByNameAsync(serviceName, deploymentName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> DeleteByNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName)
        {
            return operations.DeleteByNameAsync(serviceName, deploymentName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginDeletingBySlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot)
        {
            try
            {
                return operations.BeginDeletingBySlotAsync(serviceName, deploymentSlot).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginDeletingBySlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot)
        {
            return operations.BeginDeletingBySlotAsync(serviceName, deploymentSlot, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse DeleteBySlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot)
        {
            try
            {
                return operations.DeleteBySlotAsync(serviceName, deploymentSlot).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> DeleteBySlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot)
        {
            return operations.DeleteBySlotAsync(serviceName, deploymentSlot, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get Deployment operation returns configuration information,
        /// status, and system properties for a deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460804.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <returns>
        /// A deployment that exists in the cloud service.
        /// </returns>
        public static DeploymentGetResponse GetByName(this IDeploymentOperations operations, string serviceName, string deploymentName)
        {
            try
            {
                return operations.GetByNameAsync(serviceName, deploymentName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Deployment operation returns configuration information,
        /// status, and system properties for a deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460804.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <returns>
        /// A deployment that exists in the cloud service.
        /// </returns>
        public static Task<DeploymentGetResponse> GetByNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName)
        {
            return operations.GetByNameAsync(serviceName, deploymentName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get Deployment operation returns configuration information,
        /// status, and system properties for a deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460804.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <returns>
        /// A deployment that exists in the cloud service.
        /// </returns>
        public static DeploymentGetResponse GetBySlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot)
        {
            try
            {
                return operations.GetBySlotAsync(serviceName, deploymentSlot).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Deployment operation returns configuration information,
        /// status, and system properties for a deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460804.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <returns>
        /// A deployment that exists in the cloud service.
        /// </returns>
        public static Task<DeploymentGetResponse> GetBySlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot)
        {
            return operations.GetBySlotAsync(serviceName, deploymentSlot, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get Package operation retrieves a cloud service package for a
        /// deployment and stores the package files in Windows Azure Blob
        /// storage.  The following package files are placed in storage:
        /// Service configuration file - The cloud service configuration file
        /// (.cscfg) provides configuration settings for the cloud service and
        /// individual roles, including the number of role instances.
        /// Service package - The service package (.cspkg) contains the
        /// application code and the service definition file.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154121.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Package operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse GetPackageByName(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentGetPackageParameters parameters)
        {
            try
            {
                return operations.GetPackageByNameAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Package operation retrieves a cloud service package for a
        /// deployment and stores the package files in Windows Azure Blob
        /// storage.  The following package files are placed in storage:
        /// Service configuration file - The cloud service configuration file
        /// (.cscfg) provides configuration settings for the cloud service and
        /// individual roles, including the number of role instances.
        /// Service package - The service package (.cspkg) contains the
        /// application code and the service definition file.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154121.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Package operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> GetPackageByNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentGetPackageParameters parameters)
        {
            return operations.GetPackageByNameAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get Package operation retrieves a cloud service package for a
        /// deployment and stores the package files in Windows Azure Blob
        /// storage.  The following package files are placed in storage:
        /// Service configuration file - The cloud service configuration file
        /// (.cscfg) provides configuration settings for the cloud service and
        /// individual roles, including the number of role instances.
        /// Service package - The service package (.cspkg) contains the
        /// application code and the service definition file.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154121.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Package operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse GetPackageBySlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentGetPackageParameters parameters)
        {
            try
            {
                return operations.GetPackageBySlotAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Package operation retrieves a cloud service package for a
        /// deployment and stores the package files in Windows Azure Blob
        /// storage.  The following package files are placed in storage:
        /// Service configuration file - The cloud service configuration file
        /// (.cscfg) provides configuration settings for the cloud service and
        /// individual roles, including the number of role instances.
        /// Service package - The service package (.cspkg) contains the
        /// application code and the service definition file.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154121.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Package operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> GetPackageBySlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentGetPackageParameters parameters)
        {
            return operations.GetPackageBySlotAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginRebootingRoleInstanceByDeploymentName(this IDeploymentOperations operations, string serviceName, string deploymentName, string roleInstanceName)
        {
            try
            {
                return operations.BeginRebootingRoleInstanceByDeploymentNameAsync(serviceName, deploymentName, roleInstanceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginRebootingRoleInstanceByDeploymentNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, string roleInstanceName)
        {
            return operations.BeginRebootingRoleInstanceByDeploymentNameAsync(serviceName, deploymentName, roleInstanceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse RebootRoleInstanceByDeploymentName(this IDeploymentOperations operations, string serviceName, string deploymentName, string roleInstanceName)
        {
            try
            {
                return operations.RebootRoleInstanceByDeploymentNameAsync(serviceName, deploymentName, roleInstanceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> RebootRoleInstanceByDeploymentNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, string roleInstanceName)
        {
            return operations.RebootRoleInstanceByDeploymentNameAsync(serviceName, deploymentName, roleInstanceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginRebootingRoleInstanceByDeploymentSlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName)
        {
            try
            {
                return operations.BeginRebootingRoleInstanceByDeploymentSlotAsync(serviceName, deploymentSlot, roleInstanceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginRebootingRoleInstanceByDeploymentSlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName)
        {
            return operations.BeginRebootingRoleInstanceByDeploymentSlotAsync(serviceName, deploymentSlot, roleInstanceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse RebootRoleInstanceByDeploymentSlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName)
        {
            try
            {
                return operations.RebootRoleInstanceByDeploymentSlotAsync(serviceName, deploymentSlot, roleInstanceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> RebootRoleInstanceByDeploymentSlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName)
        {
            return operations.RebootRoleInstanceByDeploymentSlotAsync(serviceName, deploymentSlot, roleInstanceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginReimagingRoleInstanceByDeploymentName(this IDeploymentOperations operations, string serviceName, string deploymentName, string roleInstanceName)
        {
            try
            {
                return operations.BeginReimagingRoleInstanceByDeploymentNameAsync(serviceName, deploymentName, roleInstanceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginReimagingRoleInstanceByDeploymentNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, string roleInstanceName)
        {
            return operations.BeginReimagingRoleInstanceByDeploymentNameAsync(serviceName, deploymentName, roleInstanceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse ReimageRoleInstanceByDeploymentName(this IDeploymentOperations operations, string serviceName, string deploymentName, string roleInstanceName)
        {
            try
            {
                return operations.ReimageRoleInstanceByDeploymentNameAsync(serviceName, deploymentName, roleInstanceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> ReimageRoleInstanceByDeploymentNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, string roleInstanceName)
        {
            return operations.ReimageRoleInstanceByDeploymentNameAsync(serviceName, deploymentName, roleInstanceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginReimagingRoleInstanceByDeploymentSlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName)
        {
            try
            {
                return operations.BeginReimagingRoleInstanceByDeploymentSlotAsync(serviceName, deploymentSlot, roleInstanceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginReimagingRoleInstanceByDeploymentSlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName)
        {
            return operations.BeginReimagingRoleInstanceByDeploymentSlotAsync(serviceName, deploymentSlot, roleInstanceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse ReimageRoleInstanceByDeploymentSlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName)
        {
            try
            {
                return operations.ReimageRoleInstanceByDeploymentSlotAsync(serviceName, deploymentSlot, roleInstanceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> ReimageRoleInstanceByDeploymentSlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName)
        {
            return operations.ReimageRoleInstanceByDeploymentSlotAsync(serviceName, deploymentSlot, roleInstanceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Rollback Update Or Upgrade operation cancels an in-progress
        /// configuration update and returns the deployment to its state
        /// before the update was started.  The Rollback Update Or Upgrade
        /// operation can only be called when an update is in progress on the
        /// deployment. The deployment status can be detected by calling the
        /// Get Deployment operation or Get Hosted Service Properties
        /// operation and inspecting the RollbackAllowed element. If the value
        /// returned is true a rollback can be performed.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/hh403977.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Rollback Update Or Upgrade operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse RollbackUpdateOrUpgradeByDeploymentName(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentRollbackUpdateOrUpgradeParameters parameters)
        {
            try
            {
                return operations.RollbackUpdateOrUpgradeByDeploymentNameAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Rollback Update Or Upgrade operation cancels an in-progress
        /// configuration update and returns the deployment to its state
        /// before the update was started.  The Rollback Update Or Upgrade
        /// operation can only be called when an update is in progress on the
        /// deployment. The deployment status can be detected by calling the
        /// Get Deployment operation or Get Hosted Service Properties
        /// operation and inspecting the RollbackAllowed element. If the value
        /// returned is true a rollback can be performed.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/hh403977.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Rollback Update Or Upgrade operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> RollbackUpdateOrUpgradeByDeploymentNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentRollbackUpdateOrUpgradeParameters parameters)
        {
            return operations.RollbackUpdateOrUpgradeByDeploymentNameAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Rollback Update Or Upgrade operation cancels an in-progress
        /// configuration update and returns the deployment to its state
        /// before the update was started.  The Rollback Update Or Upgrade
        /// operation can only be called when an update is in progress on the
        /// deployment. The deployment status can be detected by calling the
        /// Get Deployment operation or Get Hosted Service Properties
        /// operation and inspecting the RollbackAllowed element. If the value
        /// returned is true a rollback can be performed.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/hh403977.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Rollback Update Or Upgrade operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse RollbackUpdateOrUpgradeByDeploymentSlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentRollbackUpdateOrUpgradeParameters parameters)
        {
            try
            {
                return operations.RollbackUpdateOrUpgradeByDeploymentSlotAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Rollback Update Or Upgrade operation cancels an in-progress
        /// configuration update and returns the deployment to its state
        /// before the update was started.  The Rollback Update Or Upgrade
        /// operation can only be called when an update is in progress on the
        /// deployment. The deployment status can be detected by calling the
        /// Get Deployment operation or Get Hosted Service Properties
        /// operation and inspecting the RollbackAllowed element. If the value
        /// returned is true a rollback can be performed.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/hh403977.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Rollback Update Or Upgrade operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> RollbackUpdateOrUpgradeByDeploymentSlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentRollbackUpdateOrUpgradeParameters parameters)
        {
            return operations.RollbackUpdateOrUpgradeByDeploymentSlotAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Swap Deployment operation initiates a virtual IP address swap
        /// between the staging and production deployment environments for a
        /// service. If the service is currently running in the staging
        /// environment, it will be swapped to the production environment. If
        /// it is running in the production environment, it will be swapped to
        /// staging. For more information on this type of upgrade, see
        /// Performing Virtual IP Swap Upgrades.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460814.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Swap Deployment operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginSwapping(this IDeploymentOperations operations, string serviceName, DeploymentSwapParameters parameters)
        {
            try
            {
                return operations.BeginSwappingAsync(serviceName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Swap Deployment operation initiates a virtual IP address swap
        /// between the staging and production deployment environments for a
        /// service. If the service is currently running in the staging
        /// environment, it will be swapped to the production environment. If
        /// it is running in the production environment, it will be swapped to
        /// staging. For more information on this type of upgrade, see
        /// Performing Virtual IP Swap Upgrades.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460814.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Swap Deployment operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginSwappingAsync(this IDeploymentOperations operations, string serviceName, DeploymentSwapParameters parameters)
        {
            return operations.BeginSwappingAsync(serviceName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Swap Deployment operation initiates a virtual IP address swap
        /// between the staging and production deployment environments for a
        /// service. If the service is currently running in the staging
        /// environment, it will be swapped to the production environment. If
        /// it is running in the production environment, it will be swapped to
        /// staging. For more information on this type of upgrade, see
        /// Performing Virtual IP Swap Upgrades.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460814.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Swap Deployment operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse Swap(this IDeploymentOperations operations, string serviceName, DeploymentSwapParameters parameters)
        {
            try
            {
                return operations.SwapAsync(serviceName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Swap Deployment operation initiates a virtual IP address swap
        /// between the staging and production deployment environments for a
        /// service. If the service is currently running in the staging
        /// environment, it will be swapped to the production environment. If
        /// it is running in the production environment, it will be swapped to
        /// staging. For more information on this type of upgrade, see
        /// Performing Virtual IP Swap Upgrades.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460814.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Swap Deployment operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> SwapAsync(this IDeploymentOperations operations, string serviceName, DeploymentSwapParameters parameters)
        {
            return operations.SwapAsync(serviceName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginUpdatingStatusByDeploymentName(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentUpdateStatusParameters parameters)
        {
            try
            {
                return operations.BeginUpdatingStatusByDeploymentNameAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginUpdatingStatusByDeploymentNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentUpdateStatusParameters parameters)
        {
            return operations.BeginUpdatingStatusByDeploymentNameAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse UpdateStatusByDeploymentName(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentUpdateStatusParameters parameters)
        {
            try
            {
                return operations.UpdateStatusByDeploymentNameAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> UpdateStatusByDeploymentNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentUpdateStatusParameters parameters)
        {
            return operations.UpdateStatusByDeploymentNameAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginUpdatingStatusByDeploymentSlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentUpdateStatusParameters parameters)
        {
            try
            {
                return operations.BeginUpdatingStatusByDeploymentSlotAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginUpdatingStatusByDeploymentSlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentUpdateStatusParameters parameters)
        {
            return operations.BeginUpdatingStatusByDeploymentSlotAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse UpdateStatusByDeploymentSlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentUpdateStatusParameters parameters)
        {
            try
            {
                return operations.UpdateStatusByDeploymentSlotAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> UpdateStatusByDeploymentSlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentUpdateStatusParameters parameters)
        {
            return operations.UpdateStatusByDeploymentSlotAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.  To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginUpgradingBySlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentUpgradeParameters parameters)
        {
            try
            {
                return operations.BeginUpgradingBySlotAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.  To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginUpgradingBySlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentUpgradeParameters parameters)
        {
            return operations.BeginUpgradingBySlotAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse UpgradeBySlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentUpgradeParameters parameters)
        {
            try
            {
                return operations.UpgradeBySlotAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> UpgradeBySlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentUpgradeParameters parameters)
        {
            return operations.UpgradeBySlotAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginUpgradingByName(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentUpgradeParameters parameters)
        {
            try
            {
                return operations.BeginUpgradingByNameAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginUpgradingByNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentUpgradeParameters parameters)
        {
            return operations.BeginUpgradingByNameAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse UpgradeByName(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentUpgradeParameters parameters)
        {
            try
            {
                return operations.UpgradeByNameAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> UpgradeByNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentUpgradeParameters parameters)
        {
            return operations.UpgradeByNameAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginWalkingUpgradeDomainByDeploymentName(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentWalkUpgradeDomainParameters parameters)
        {
            try
            {
                return operations.BeginWalkingUpgradeDomainByDeploymentNameAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginWalkingUpgradeDomainByDeploymentNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentWalkUpgradeDomainParameters parameters)
        {
            return operations.BeginWalkingUpgradeDomainByDeploymentNameAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse WalkUpgradeDomainByDeploymentName(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentWalkUpgradeDomainParameters parameters)
        {
            try
            {
                return operations.WalkUpgradeDomainByDeploymentNameAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> WalkUpgradeDomainByDeploymentNameAsync(this IDeploymentOperations operations, string serviceName, string deploymentName, DeploymentWalkUpgradeDomainParameters parameters)
        {
            return operations.WalkUpgradeDomainByDeploymentNameAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginWalkingUpgradeDomainByDeploymentSlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentWalkUpgradeDomainParameters parameters)
        {
            try
            {
                return operations.BeginWalkingUpgradeDomainByDeploymentSlotAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginWalkingUpgradeDomainByDeploymentSlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentWalkUpgradeDomainParameters parameters)
        {
            return operations.BeginWalkingUpgradeDomainByDeploymentSlotAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse WalkUpgradeDomainByDeploymentSlot(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentWalkUpgradeDomainParameters parameters)
        {
            try
            {
                return operations.WalkUpgradeDomainByDeploymentSlotAsync(serviceName, deploymentSlot, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IDeploymentOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> WalkUpgradeDomainByDeploymentSlotAsync(this IDeploymentOperations operations, string serviceName, DeploymentSlot deploymentSlot, DeploymentWalkUpgradeDomainParameters parameters)
        {
            return operations.WalkUpgradeDomainByDeploymentSlotAsync(serviceName, deploymentSlot, parameters, CancellationToken.None);
        }
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the
    /// deployments beneath your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460812.aspx for
    /// more information)
    /// </summary>
    internal partial class DeploymentOperations : IServiceOperations<ComputeManagementClient>, IDeploymentOperations
    {
        /// <summary>
        /// Initializes a new instance of the DeploymentOperations class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        internal DeploymentOperations(ComputeManagementClient client)
        {
            this._client = client;
        }
        
        private ComputeManagementClient _client;
        
        /// <summary>
        /// Gets a reference to the
        /// Microsoft.WindowsAzure.Management.Compute.ComputeManagementClient.
        /// </summary>
        public ComputeManagementClient Client
        {
            get { return this._client; }
        }
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to change deployment configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginChangingConfigurationBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentChangeConfigurationParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.Configuration == null)
            {
                throw new ArgumentNullException("parameters.Configuration");
            }
            if (parameters.ExtensionConfiguration != null)
            {
                foreach (ExtensionConfiguration.Extension allRolesParameterItem in parameters.ExtensionConfiguration.AllRoles)
                {
                    if (allRolesParameterItem.Id == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.AllRoles.Id");
                    }
                }
                foreach (ExtensionConfiguration.NamedRole namedRolesParameterItem in parameters.ExtensionConfiguration.NamedRoles)
                {
                    if (namedRolesParameterItem.RoleName == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.RoleName");
                    }
                    if (namedRolesParameterItem.Extensions == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.Extensions");
                    }
                    foreach (ExtensionConfiguration.Extension extensionsParameterItem in namedRolesParameterItem.Extensions)
                    {
                        if (extensionsParameterItem.Id == null)
                        {
                            throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.Extensions.Id");
                        }
                    }
                }
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginChangingConfigurationBySlotAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deploymentslots/" + deploymentSlot + "/?comp=config";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement changeConfigurationElement = new XElement(XName.Get("ChangeConfiguration", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(changeConfigurationElement);
                
                XElement configurationElement = new XElement(XName.Get("Configuration", "http://schemas.microsoft.com/windowsazure"));
                configurationElement.Value = TypeConversion.ToBase64String(parameters.Configuration);
                changeConfigurationElement.Add(configurationElement);
                
                if (parameters.TreatWarningsAsError != null)
                {
                    XElement treatWarningsAsErrorElement = new XElement(XName.Get("TreatWarningsAsError", "http://schemas.microsoft.com/windowsazure"));
                    treatWarningsAsErrorElement.Value = parameters.TreatWarningsAsError.ToString().ToLower();
                    changeConfigurationElement.Add(treatWarningsAsErrorElement);
                }
                
                if (parameters.Mode != null)
                {
                    XElement modeElement = new XElement(XName.Get("Mode", "http://schemas.microsoft.com/windowsazure"));
                    modeElement.Value = parameters.Mode.ToString();
                    changeConfigurationElement.Add(modeElement);
                }
                
                if (parameters.ExtendedProperties != null)
                {
                    XElement extendedPropertiesDictionaryElement = new XElement(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                    foreach (KeyValuePair<string, string> pair in parameters.ExtendedProperties)
                    {
                        string extendedPropertiesKey = pair.Key;
                        string extendedPropertiesValue = pair.Value;
                        XElement extendedPropertiesElement = new XElement(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesDictionaryElement.Add(extendedPropertiesElement);
                        
                        XElement extendedPropertiesKeyElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesKeyElement.Value = extendedPropertiesKey;
                        extendedPropertiesElement.Add(extendedPropertiesKeyElement);
                        
                        XElement extendedPropertiesValueElement = new XElement(XName.Get("Value", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesValueElement.Value = extendedPropertiesValue;
                        extendedPropertiesElement.Add(extendedPropertiesValueElement);
                    }
                    changeConfigurationElement.Add(extendedPropertiesDictionaryElement);
                }
                
                if (parameters.ExtensionConfiguration != null)
                {
                    XElement extensionConfigurationElement = new XElement(XName.Get("ExtensionConfiguration", "http://schemas.microsoft.com/windowsazure"));
                    changeConfigurationElement.Add(extensionConfigurationElement);
                    
                    if (parameters.ExtensionConfiguration.AllRoles != null)
                    {
                        XElement allRolesSequenceElement = new XElement(XName.Get("AllRoles", "http://schemas.microsoft.com/windowsazure"));
                        foreach (ExtensionConfiguration.Extension allRolesItem in parameters.ExtensionConfiguration.AllRoles)
                        {
                            XElement extensionElement = new XElement(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                            allRolesSequenceElement.Add(extensionElement);
                            
                            XElement idElement = new XElement(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                            idElement.Value = allRolesItem.Id;
                            extensionElement.Add(idElement);
                        }
                        extensionConfigurationElement.Add(allRolesSequenceElement);
                    }
                    
                    if (parameters.ExtensionConfiguration.NamedRoles != null)
                    {
                        XElement namedRolesSequenceElement = new XElement(XName.Get("NamedRoles", "http://schemas.microsoft.com/windowsazure"));
                        foreach (ExtensionConfiguration.NamedRole namedRolesItem in parameters.ExtensionConfiguration.NamedRoles)
                        {
                            XElement roleElement = new XElement(XName.Get("Role", "http://schemas.microsoft.com/windowsazure"));
                            namedRolesSequenceElement.Add(roleElement);
                            
                            XElement roleNameElement = new XElement(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                            roleNameElement.Value = namedRolesItem.RoleName;
                            roleElement.Add(roleNameElement);
                            
                            XElement extensionsSequenceElement = new XElement(XName.Get("Extensions", "http://schemas.microsoft.com/windowsazure"));
                            foreach (ExtensionConfiguration.Extension extensionsItem in namedRolesItem.Extensions)
                            {
                                XElement extensionElement2 = new XElement(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                                extensionsSequenceElement.Add(extensionElement2);
                                
                                XElement idElement2 = new XElement(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                                idElement2.Value = extensionsItem.Id;
                                extensionElement2.Add(idElement2);
                            }
                            roleElement.Add(extensionsSequenceElement);
                        }
                        extensionConfigurationElement.Add(namedRolesSequenceElement);
                    }
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to change deployment configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> ChangeConfigurationBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentChangeConfigurationParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "ChangeConfigurationBySlotAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginChangingConfigurationBySlotAsync(serviceName, deploymentSlot, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to change configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginChangingConfigurationByNameAsync(string serviceName, string deploymentName, DeploymentChangeConfigurationParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.Configuration == null)
            {
                throw new ArgumentNullException("parameters.Configuration");
            }
            if (parameters.ExtensionConfiguration != null)
            {
                foreach (ExtensionConfiguration.Extension allRolesParameterItem in parameters.ExtensionConfiguration.AllRoles)
                {
                    if (allRolesParameterItem.Id == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.AllRoles.Id");
                    }
                }
                foreach (ExtensionConfiguration.NamedRole namedRolesParameterItem in parameters.ExtensionConfiguration.NamedRoles)
                {
                    if (namedRolesParameterItem.RoleName == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.RoleName");
                    }
                    if (namedRolesParameterItem.Extensions == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.Extensions");
                    }
                    foreach (ExtensionConfiguration.Extension extensionsParameterItem in namedRolesParameterItem.Extensions)
                    {
                        if (extensionsParameterItem.Id == null)
                        {
                            throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.Extensions.Id");
                        }
                    }
                }
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginChangingConfigurationByNameAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/?comp=config";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement changeConfigurationElement = new XElement(XName.Get("ChangeConfiguration", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(changeConfigurationElement);
                
                XElement configurationElement = new XElement(XName.Get("Configuration", "http://schemas.microsoft.com/windowsazure"));
                configurationElement.Value = TypeConversion.ToBase64String(parameters.Configuration);
                changeConfigurationElement.Add(configurationElement);
                
                if (parameters.TreatWarningsAsError != null)
                {
                    XElement treatWarningsAsErrorElement = new XElement(XName.Get("TreatWarningsAsError", "http://schemas.microsoft.com/windowsazure"));
                    treatWarningsAsErrorElement.Value = parameters.TreatWarningsAsError.ToString().ToLower();
                    changeConfigurationElement.Add(treatWarningsAsErrorElement);
                }
                
                if (parameters.Mode != null)
                {
                    XElement modeElement = new XElement(XName.Get("Mode", "http://schemas.microsoft.com/windowsazure"));
                    modeElement.Value = parameters.Mode.ToString();
                    changeConfigurationElement.Add(modeElement);
                }
                
                if (parameters.ExtendedProperties != null)
                {
                    XElement extendedPropertiesDictionaryElement = new XElement(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                    foreach (KeyValuePair<string, string> pair in parameters.ExtendedProperties)
                    {
                        string extendedPropertiesKey = pair.Key;
                        string extendedPropertiesValue = pair.Value;
                        XElement extendedPropertiesElement = new XElement(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesDictionaryElement.Add(extendedPropertiesElement);
                        
                        XElement extendedPropertiesKeyElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesKeyElement.Value = extendedPropertiesKey;
                        extendedPropertiesElement.Add(extendedPropertiesKeyElement);
                        
                        XElement extendedPropertiesValueElement = new XElement(XName.Get("Value", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesValueElement.Value = extendedPropertiesValue;
                        extendedPropertiesElement.Add(extendedPropertiesValueElement);
                    }
                    changeConfigurationElement.Add(extendedPropertiesDictionaryElement);
                }
                
                if (parameters.ExtensionConfiguration != null)
                {
                    XElement extensionConfigurationElement = new XElement(XName.Get("ExtensionConfiguration", "http://schemas.microsoft.com/windowsazure"));
                    changeConfigurationElement.Add(extensionConfigurationElement);
                    
                    if (parameters.ExtensionConfiguration.AllRoles != null)
                    {
                        XElement allRolesSequenceElement = new XElement(XName.Get("AllRoles", "http://schemas.microsoft.com/windowsazure"));
                        foreach (ExtensionConfiguration.Extension allRolesItem in parameters.ExtensionConfiguration.AllRoles)
                        {
                            XElement extensionElement = new XElement(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                            allRolesSequenceElement.Add(extensionElement);
                            
                            XElement idElement = new XElement(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                            idElement.Value = allRolesItem.Id;
                            extensionElement.Add(idElement);
                        }
                        extensionConfigurationElement.Add(allRolesSequenceElement);
                    }
                    
                    if (parameters.ExtensionConfiguration.NamedRoles != null)
                    {
                        XElement namedRolesSequenceElement = new XElement(XName.Get("NamedRoles", "http://schemas.microsoft.com/windowsazure"));
                        foreach (ExtensionConfiguration.NamedRole namedRolesItem in parameters.ExtensionConfiguration.NamedRoles)
                        {
                            XElement roleElement = new XElement(XName.Get("Role", "http://schemas.microsoft.com/windowsazure"));
                            namedRolesSequenceElement.Add(roleElement);
                            
                            XElement roleNameElement = new XElement(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                            roleNameElement.Value = namedRolesItem.RoleName;
                            roleElement.Add(roleNameElement);
                            
                            XElement extensionsSequenceElement = new XElement(XName.Get("Extensions", "http://schemas.microsoft.com/windowsazure"));
                            foreach (ExtensionConfiguration.Extension extensionsItem in namedRolesItem.Extensions)
                            {
                                XElement extensionElement2 = new XElement(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                                extensionsSequenceElement.Add(extensionElement2);
                                
                                XElement idElement2 = new XElement(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                                idElement2.Value = extensionsItem.Id;
                                extensionElement2.Add(idElement2);
                            }
                            roleElement.Add(extensionsSequenceElement);
                        }
                        extensionConfigurationElement.Add(namedRolesSequenceElement);
                    }
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Change Deployment Configuration operation initiates a change to
        /// the deployment configuration.  The Change Deployment Configuration
        /// operation is an asynchronous operation. To determine whether the
        /// Management service has finished processing the request, call Get
        /// Operation Status.  For more information on asynchronous
        /// operations, see Tracking Asynchronous Service Management Requests.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460809.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to change deployment configuration for.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to change configuration for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Change Configuration Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> ChangeConfigurationByNameAsync(string serviceName, string deploymentName, DeploymentChangeConfigurationParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "ChangeConfigurationByNameAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginChangingConfigurationByNameAsync(serviceName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Create Deployment operation uploads a new service package and
        /// creates a new deployment in the staging or production
        /// environments.  The Create Deployment operation is an asynchronous
        /// operation. To determine whether the management service has
        /// finished processing the request, call Get Operation Status. For
        /// more information on asynchronous operations, see Tracking
        /// Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460813.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to create a deployment for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to create a deployment for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginCreatingAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentCreateParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.Name == null)
            {
                throw new ArgumentNullException("parameters.Name");
            }
            if (parameters.PackageUri == null)
            {
                throw new ArgumentNullException("parameters.PackageUri");
            }
            if (parameters.Label == null)
            {
                throw new ArgumentNullException("parameters.Label");
            }
            if (parameters.Label.Length > 100)
            {
                throw new ArgumentOutOfRangeException("parameters.Label");
            }
            if (parameters.Configuration == null)
            {
                throw new ArgumentNullException("parameters.Configuration");
            }
            if (parameters.ExtensionConfiguration != null)
            {
                foreach (ExtensionConfiguration.Extension allRolesParameterItem in parameters.ExtensionConfiguration.AllRoles)
                {
                    if (allRolesParameterItem.Id == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.AllRoles.Id");
                    }
                }
                foreach (ExtensionConfiguration.NamedRole namedRolesParameterItem in parameters.ExtensionConfiguration.NamedRoles)
                {
                    if (namedRolesParameterItem.RoleName == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.RoleName");
                    }
                    if (namedRolesParameterItem.Extensions == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.Extensions");
                    }
                    foreach (ExtensionConfiguration.Extension extensionsParameterItem in namedRolesParameterItem.Extensions)
                    {
                        if (extensionsParameterItem.Id == null)
                        {
                            throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.Extensions.Id");
                        }
                    }
                }
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginCreatingAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deploymentslots/" + deploymentSlot;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement createDeploymentElement = new XElement(XName.Get("CreateDeployment", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(createDeploymentElement);
                
                XElement nameElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                nameElement.Value = parameters.Name;
                createDeploymentElement.Add(nameElement);
                
                XElement packageUrlElement = new XElement(XName.Get("PackageUrl", "http://schemas.microsoft.com/windowsazure"));
                packageUrlElement.Value = parameters.PackageUri.ToString();
                createDeploymentElement.Add(packageUrlElement);
                
                XElement labelElement = new XElement(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                labelElement.Value = TypeConversion.ToBase64String(parameters.Label);
                createDeploymentElement.Add(labelElement);
                
                XElement configurationElement = new XElement(XName.Get("Configuration", "http://schemas.microsoft.com/windowsazure"));
                configurationElement.Value = TypeConversion.ToBase64String(parameters.Configuration);
                createDeploymentElement.Add(configurationElement);
                
                if (parameters.StartDeployment != null)
                {
                    XElement startDeploymentElement = new XElement(XName.Get("StartDeployment", "http://schemas.microsoft.com/windowsazure"));
                    startDeploymentElement.Value = parameters.StartDeployment.ToString().ToLower();
                    createDeploymentElement.Add(startDeploymentElement);
                }
                
                if (parameters.TreatWarningsAsError != null)
                {
                    XElement treatWarningsAsErrorElement = new XElement(XName.Get("TreatWarningsAsError", "http://schemas.microsoft.com/windowsazure"));
                    treatWarningsAsErrorElement.Value = parameters.TreatWarningsAsError.ToString().ToLower();
                    createDeploymentElement.Add(treatWarningsAsErrorElement);
                }
                
                if (parameters.ExtendedProperties != null)
                {
                    XElement extendedPropertiesDictionaryElement = new XElement(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                    foreach (KeyValuePair<string, string> pair in parameters.ExtendedProperties)
                    {
                        string extendedPropertiesKey = pair.Key;
                        string extendedPropertiesValue = pair.Value;
                        XElement extendedPropertiesElement = new XElement(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesDictionaryElement.Add(extendedPropertiesElement);
                        
                        XElement extendedPropertiesKeyElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesKeyElement.Value = extendedPropertiesKey;
                        extendedPropertiesElement.Add(extendedPropertiesKeyElement);
                        
                        XElement extendedPropertiesValueElement = new XElement(XName.Get("Value", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesValueElement.Value = extendedPropertiesValue;
                        extendedPropertiesElement.Add(extendedPropertiesValueElement);
                    }
                    createDeploymentElement.Add(extendedPropertiesDictionaryElement);
                }
                
                if (parameters.ExtensionConfiguration != null)
                {
                    XElement extensionConfigurationElement = new XElement(XName.Get("ExtensionConfiguration", "http://schemas.microsoft.com/windowsazure"));
                    createDeploymentElement.Add(extensionConfigurationElement);
                    
                    if (parameters.ExtensionConfiguration.AllRoles != null)
                    {
                        XElement allRolesSequenceElement = new XElement(XName.Get("AllRoles", "http://schemas.microsoft.com/windowsazure"));
                        foreach (ExtensionConfiguration.Extension allRolesItem in parameters.ExtensionConfiguration.AllRoles)
                        {
                            XElement extensionElement = new XElement(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                            allRolesSequenceElement.Add(extensionElement);
                            
                            XElement idElement = new XElement(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                            idElement.Value = allRolesItem.Id;
                            extensionElement.Add(idElement);
                        }
                        extensionConfigurationElement.Add(allRolesSequenceElement);
                    }
                    
                    if (parameters.ExtensionConfiguration.NamedRoles != null)
                    {
                        XElement namedRolesSequenceElement = new XElement(XName.Get("NamedRoles", "http://schemas.microsoft.com/windowsazure"));
                        foreach (ExtensionConfiguration.NamedRole namedRolesItem in parameters.ExtensionConfiguration.NamedRoles)
                        {
                            XElement roleElement = new XElement(XName.Get("Role", "http://schemas.microsoft.com/windowsazure"));
                            namedRolesSequenceElement.Add(roleElement);
                            
                            XElement roleNameElement = new XElement(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                            roleNameElement.Value = namedRolesItem.RoleName;
                            roleElement.Add(roleNameElement);
                            
                            XElement extensionsSequenceElement = new XElement(XName.Get("Extensions", "http://schemas.microsoft.com/windowsazure"));
                            foreach (ExtensionConfiguration.Extension extensionsItem in namedRolesItem.Extensions)
                            {
                                XElement extensionElement2 = new XElement(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                                extensionsSequenceElement.Add(extensionElement2);
                                
                                XElement idElement2 = new XElement(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                                idElement2.Value = extensionsItem.Id;
                                extensionElement2.Add(idElement2);
                            }
                            roleElement.Add(extensionsSequenceElement);
                        }
                        extensionConfigurationElement.Add(namedRolesSequenceElement);
                    }
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Create Deployment operation uploads a new service package and
        /// creates a new deployment in the staging or production
        /// environments.  The Create Deployment operation is an asynchronous
        /// operation. To determine whether the management service has
        /// finished processing the request, call Get Operation Status. For
        /// more information on asynchronous operations, see Tracking
        /// Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460813.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to create a deployment for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to create a deployment for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> CreateAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentCreateParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "CreateAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginCreatingAsync(serviceName, deploymentSlot, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginDeletingByNameAsync(string serviceName, string deploymentName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                Tracing.Enter(invocationId, this, "BeginDeletingByNameAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Delete;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> DeleteByNameAsync(string serviceName, string deploymentName, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                Tracing.Enter(invocationId, this, "DeleteByNameAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginDeletingByNameAsync(serviceName, deploymentName, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginDeletingBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                Tracing.Enter(invocationId, this, "BeginDeletingBySlotAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deploymentslots/" + deploymentSlot;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Delete;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Deployment operation deletes the specified deployment.
        /// The Delete Deployment operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460815.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> DeleteBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                Tracing.Enter(invocationId, this, "DeleteBySlotAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginDeletingBySlotAsync(serviceName, deploymentSlot, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get Deployment operation returns configuration information,
        /// status, and system properties for a deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460804.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A deployment that exists in the cloud service.
        /// </returns>
        public async Task<DeploymentGetResponse> GetByNameAsync(string serviceName, string deploymentName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                Tracing.Enter(invocationId, this, "GetByNameAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    DeploymentGetResponse result = new DeploymentGetResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement deploymentElement = responseDoc.Element(XName.Get("Deployment", "http://schemas.microsoft.com/windowsazure"));
                    if (deploymentElement != null)
                    {
                        XElement nameElement = deploymentElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        if (nameElement != null)
                        {
                            string nameInstance = nameElement.Value;
                            result.Name = nameInstance;
                        }
                        
                        XElement deploymentSlotElement = deploymentElement.Element(XName.Get("DeploymentSlot", "http://schemas.microsoft.com/windowsazure"));
                        if (deploymentSlotElement != null)
                        {
                            DeploymentSlot deploymentSlotInstance = (DeploymentSlot)Enum.Parse(typeof(DeploymentSlot), deploymentSlotElement.Value, false);
                            result.DeploymentSlot = deploymentSlotInstance;
                        }
                        
                        XElement privateIDElement = deploymentElement.Element(XName.Get("PrivateID", "http://schemas.microsoft.com/windowsazure"));
                        if (privateIDElement != null)
                        {
                            string privateIDInstance = privateIDElement.Value;
                            result.PrivateId = privateIDInstance;
                        }
                        
                        XElement statusElement = deploymentElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                        if (statusElement != null)
                        {
                            DeploymentStatus statusInstance = (DeploymentStatus)Enum.Parse(typeof(DeploymentStatus), statusElement.Value, false);
                            result.Status = statusInstance;
                        }
                        
                        XElement labelElement = deploymentElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                        if (labelElement != null)
                        {
                            string labelInstance = TypeConversion.FromBase64String(labelElement.Value);
                            result.Label = labelInstance;
                        }
                        
                        XElement urlElement = deploymentElement.Element(XName.Get("Url", "http://schemas.microsoft.com/windowsazure"));
                        if (urlElement != null)
                        {
                            Uri urlInstance = TypeConversion.TryParseUri(urlElement.Value);
                            result.Uri = urlInstance;
                        }
                        
                        XElement configurationElement = deploymentElement.Element(XName.Get("Configuration", "http://schemas.microsoft.com/windowsazure"));
                        if (configurationElement != null)
                        {
                            string configurationInstance = TypeConversion.FromBase64String(configurationElement.Value);
                            result.Configuration = configurationInstance;
                        }
                        
                        XElement roleInstanceListSequenceElement = deploymentElement.Element(XName.Get("RoleInstanceList", "http://schemas.microsoft.com/windowsazure"));
                        if (roleInstanceListSequenceElement != null)
                        {
                            foreach (XElement roleInstanceListElement in roleInstanceListSequenceElement.Elements(XName.Get("RoleInstance", "http://schemas.microsoft.com/windowsazure")))
                            {
                                RoleInstance roleInstanceInstance = new RoleInstance();
                                result.RoleInstances.Add(roleInstanceInstance);
                                
                                XElement roleNameElement = roleInstanceListElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                                if (roleNameElement != null)
                                {
                                    string roleNameInstance = roleNameElement.Value;
                                    roleInstanceInstance.RoleName = roleNameInstance;
                                }
                                
                                XElement instanceNameElement = roleInstanceListElement.Element(XName.Get("InstanceName", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceNameElement != null)
                                {
                                    string instanceNameInstance = instanceNameElement.Value;
                                    roleInstanceInstance.InstanceName = instanceNameInstance;
                                }
                                
                                XElement instanceStatusElement = roleInstanceListElement.Element(XName.Get("InstanceStatus", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceStatusElement != null)
                                {
                                    string instanceStatusInstance = instanceStatusElement.Value;
                                    roleInstanceInstance.InstanceStatus = instanceStatusInstance;
                                }
                                
                                XElement instanceUpgradeDomainElement = roleInstanceListElement.Element(XName.Get("InstanceUpgradeDomain", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceUpgradeDomainElement != null && string.IsNullOrEmpty(instanceUpgradeDomainElement.Value) == false)
                                {
                                    int instanceUpgradeDomainInstance = int.Parse(instanceUpgradeDomainElement.Value, CultureInfo.InvariantCulture);
                                    roleInstanceInstance.InstanceUpgradeDomain = instanceUpgradeDomainInstance;
                                }
                                
                                XElement instanceFaultDomainElement = roleInstanceListElement.Element(XName.Get("InstanceFaultDomain", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceFaultDomainElement != null && string.IsNullOrEmpty(instanceFaultDomainElement.Value) == false)
                                {
                                    int instanceFaultDomainInstance = int.Parse(instanceFaultDomainElement.Value, CultureInfo.InvariantCulture);
                                    roleInstanceInstance.InstanceFaultDomain = instanceFaultDomainInstance;
                                }
                                
                                XElement instanceSizeElement = roleInstanceListElement.Element(XName.Get("InstanceSize", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceSizeElement != null && string.IsNullOrEmpty(instanceSizeElement.Value) == false)
                                {
                                    VirtualMachineRoleSize instanceSizeInstance = (VirtualMachineRoleSize)Enum.Parse(typeof(VirtualMachineRoleSize), instanceSizeElement.Value, false);
                                    roleInstanceInstance.InstanceSize = instanceSizeInstance;
                                }
                                
                                XElement instanceStateDetailsElement = roleInstanceListElement.Element(XName.Get("InstanceStateDetails", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceStateDetailsElement != null)
                                {
                                    string instanceStateDetailsInstance = instanceStateDetailsElement.Value;
                                    roleInstanceInstance.InstanceStateDetails = instanceStateDetailsInstance;
                                }
                                
                                XElement instanceErrorCodeElement = roleInstanceListElement.Element(XName.Get("InstanceErrorCode", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceErrorCodeElement != null)
                                {
                                    string instanceErrorCodeInstance = instanceErrorCodeElement.Value;
                                    roleInstanceInstance.InstanceErrorCode = instanceErrorCodeInstance;
                                }
                                
                                XElement ipAddressElement = roleInstanceListElement.Element(XName.Get("IpAddress", "http://schemas.microsoft.com/windowsazure"));
                                if (ipAddressElement != null)
                                {
                                    string ipAddressInstance = ipAddressElement.Value;
                                    roleInstanceInstance.IPAddress = ipAddressInstance;
                                }
                                
                                XElement instanceEndpointsSequenceElement = roleInstanceListElement.Element(XName.Get("InstanceEndpoints", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceEndpointsSequenceElement != null)
                                {
                                    foreach (XElement instanceEndpointsElement in instanceEndpointsSequenceElement.Elements(XName.Get("InstanceEndpoint", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        InstanceEndpoint instanceEndpointInstance = new InstanceEndpoint();
                                        roleInstanceInstance.InstanceEndpoints.Add(instanceEndpointInstance);
                                        
                                        XElement localPortElement = instanceEndpointsElement.Element(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                                        if (localPortElement != null && string.IsNullOrEmpty(localPortElement.Value) == false)
                                        {
                                            int localPortInstance = int.Parse(localPortElement.Value, CultureInfo.InvariantCulture);
                                            instanceEndpointInstance.LocalPort = localPortInstance;
                                        }
                                        
                                        XElement nameElement2 = instanceEndpointsElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                        if (nameElement2 != null)
                                        {
                                            string nameInstance2 = nameElement2.Value;
                                            instanceEndpointInstance.Name = nameInstance2;
                                        }
                                        
                                        XElement portElement = instanceEndpointsElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                        if (portElement != null)
                                        {
                                            int portInstance = int.Parse(portElement.Value, CultureInfo.InvariantCulture);
                                            instanceEndpointInstance.Port = portInstance;
                                        }
                                        
                                        XElement protocolElement = instanceEndpointsElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                        if (protocolElement != null)
                                        {
                                            string protocolInstance = protocolElement.Value;
                                            instanceEndpointInstance.Protocol = protocolInstance;
                                        }
                                        
                                        XElement vipElement = instanceEndpointsElement.Element(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                                        if (vipElement != null)
                                        {
                                            string vipInstance = vipElement.Value;
                                            instanceEndpointInstance.VirtualIPAddress = vipInstance;
                                        }
                                    }
                                }
                                
                                XElement powerStateElement = roleInstanceListElement.Element(XName.Get("PowerState", "http://schemas.microsoft.com/windowsazure"));
                                if (powerStateElement != null)
                                {
                                    RoleInstancePowerState powerStateInstance = (RoleInstancePowerState)Enum.Parse(typeof(RoleInstancePowerState), powerStateElement.Value, false);
                                    roleInstanceInstance.PowerState = powerStateInstance;
                                }
                                
                                XElement hostNameElement = roleInstanceListElement.Element(XName.Get("HostName", "http://schemas.microsoft.com/windowsazure"));
                                if (hostNameElement != null)
                                {
                                    string hostNameInstance = hostNameElement.Value;
                                    roleInstanceInstance.HostName = hostNameInstance;
                                }
                                
                                XElement remoteAccessCertificateThumbprintElement = roleInstanceListElement.Element(XName.Get("RemoteAccessCertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                if (remoteAccessCertificateThumbprintElement != null)
                                {
                                    string remoteAccessCertificateThumbprintInstance = remoteAccessCertificateThumbprintElement.Value;
                                    roleInstanceInstance.RemoteAccessCertificateThumbprint = remoteAccessCertificateThumbprintInstance;
                                }
                            }
                        }
                        
                        XElement upgradeStatusElement = deploymentElement.Element(XName.Get("UpgradeStatus", "http://schemas.microsoft.com/windowsazure"));
                        if (upgradeStatusElement != null)
                        {
                            UpgradeStatus upgradeStatusInstance = new UpgradeStatus();
                            result.UpgradeStatus = upgradeStatusInstance;
                            
                            XElement upgradeTypeElement = upgradeStatusElement.Element(XName.Get("UpgradeType", "http://schemas.microsoft.com/windowsazure"));
                            if (upgradeTypeElement != null)
                            {
                                DeploymentUpgradeType upgradeTypeInstance = (DeploymentUpgradeType)Enum.Parse(typeof(DeploymentUpgradeType), upgradeTypeElement.Value, false);
                                upgradeStatusInstance.UpgradeType = upgradeTypeInstance;
                            }
                            
                            XElement currentUpgradeDomainStateElement = upgradeStatusElement.Element(XName.Get("CurrentUpgradeDomainState", "http://schemas.microsoft.com/windowsazure"));
                            if (currentUpgradeDomainStateElement != null)
                            {
                                UpgradeDomainState currentUpgradeDomainStateInstance = (UpgradeDomainState)Enum.Parse(typeof(UpgradeDomainState), currentUpgradeDomainStateElement.Value, false);
                                upgradeStatusInstance.CurrentUpgradeDomainState = currentUpgradeDomainStateInstance;
                            }
                            
                            XElement currentUpgradeDomainElement = upgradeStatusElement.Element(XName.Get("CurrentUpgradeDomain", "http://schemas.microsoft.com/windowsazure"));
                            if (currentUpgradeDomainElement != null)
                            {
                                int currentUpgradeDomainInstance = int.Parse(currentUpgradeDomainElement.Value, CultureInfo.InvariantCulture);
                                upgradeStatusInstance.CurrentUpgradeDomain = currentUpgradeDomainInstance;
                            }
                        }
                        
                        XElement upgradeDomainCountElement = deploymentElement.Element(XName.Get("UpgradeDomainCount", "http://schemas.microsoft.com/windowsazure"));
                        if (upgradeDomainCountElement != null)
                        {
                            int upgradeDomainCountInstance = int.Parse(upgradeDomainCountElement.Value, CultureInfo.InvariantCulture);
                            result.UpgradeDomainCount = upgradeDomainCountInstance;
                        }
                        
                        XElement roleListSequenceElement = deploymentElement.Element(XName.Get("RoleList", "http://schemas.microsoft.com/windowsazure"));
                        if (roleListSequenceElement != null)
                        {
                            foreach (XElement roleListElement in roleListSequenceElement.Elements(XName.Get("Role", "http://schemas.microsoft.com/windowsazure")))
                            {
                                Role roleInstance = new Role();
                                result.Roles.Add(roleInstance);
                                
                                XElement roleNameElement2 = roleListElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                                if (roleNameElement2 != null)
                                {
                                    string roleNameInstance2 = roleNameElement2.Value;
                                    roleInstance.RoleName = roleNameInstance2;
                                }
                                
                                XElement oSVersionElement = roleListElement.Element(XName.Get("OSVersion", "http://schemas.microsoft.com/windowsazure"));
                                if (oSVersionElement != null)
                                {
                                    string oSVersionInstance = oSVersionElement.Value;
                                    roleInstance.OSVersion = oSVersionInstance;
                                }
                                
                                XElement roleTypeElement = roleListElement.Element(XName.Get("RoleType", "http://schemas.microsoft.com/windowsazure"));
                                if (roleTypeElement != null)
                                {
                                    string roleTypeInstance = roleTypeElement.Value;
                                    roleInstance.RoleType = roleTypeInstance;
                                }
                                
                                XElement configurationSetsSequenceElement = roleListElement.Element(XName.Get("ConfigurationSets", "http://schemas.microsoft.com/windowsazure"));
                                if (configurationSetsSequenceElement != null)
                                {
                                    foreach (XElement configurationSetsElement in configurationSetsSequenceElement.Elements(XName.Get("ConfigurationSet", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        ConfigurationSet configurationSetInstance = new ConfigurationSet();
                                        roleInstance.ConfigurationSets.Add(configurationSetInstance);
                                        
                                        XElement configurationSetTypeElement = configurationSetsElement.Element(XName.Get("ConfigurationSetType", "http://schemas.microsoft.com/windowsazure"));
                                        if (configurationSetTypeElement != null)
                                        {
                                            string configurationSetTypeInstance = configurationSetTypeElement.Value;
                                            configurationSetInstance.ConfigurationSetType = configurationSetTypeInstance;
                                        }
                                        
                                        XElement inputEndpointsSequenceElement = configurationSetsElement.Element(XName.Get("InputEndpoints", "http://schemas.microsoft.com/windowsazure"));
                                        if (inputEndpointsSequenceElement != null)
                                        {
                                            foreach (XElement inputEndpointsElement in inputEndpointsSequenceElement.Elements(XName.Get("InputEndpoint", "http://schemas.microsoft.com/windowsazure")))
                                            {
                                                InputEndpoint inputEndpointInstance = new InputEndpoint();
                                                configurationSetInstance.InputEndpoints.Add(inputEndpointInstance);
                                                
                                                XElement loadBalancedEndpointSetNameElement = inputEndpointsElement.Element(XName.Get("LoadBalancedEndpointSetName", "http://schemas.microsoft.com/windowsazure"));
                                                if (loadBalancedEndpointSetNameElement != null)
                                                {
                                                    string loadBalancedEndpointSetNameInstance = loadBalancedEndpointSetNameElement.Value;
                                                    inputEndpointInstance.LoadBalancedEndpointSetName = loadBalancedEndpointSetNameInstance;
                                                }
                                                
                                                XElement localPortElement2 = inputEndpointsElement.Element(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                                                if (localPortElement2 != null && string.IsNullOrEmpty(localPortElement2.Value) == false)
                                                {
                                                    int localPortInstance2 = int.Parse(localPortElement2.Value, CultureInfo.InvariantCulture);
                                                    inputEndpointInstance.LocalPort = localPortInstance2;
                                                }
                                                
                                                XElement nameElement3 = inputEndpointsElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                                if (nameElement3 != null)
                                                {
                                                    string nameInstance3 = nameElement3.Value;
                                                    inputEndpointInstance.Name = nameInstance3;
                                                }
                                                
                                                XElement portElement2 = inputEndpointsElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                                if (portElement2 != null && string.IsNullOrEmpty(portElement2.Value) == false)
                                                {
                                                    int portInstance2 = int.Parse(portElement2.Value, CultureInfo.InvariantCulture);
                                                    inputEndpointInstance.Port = portInstance2;
                                                }
                                                
                                                XElement loadBalancerProbeElement = inputEndpointsElement.Element(XName.Get("LoadBalancerProbe", "http://schemas.microsoft.com/windowsazure"));
                                                if (loadBalancerProbeElement != null)
                                                {
                                                    LoadBalancerProbe loadBalancerProbeInstance = new LoadBalancerProbe();
                                                    inputEndpointInstance.LoadBalancerProbe = loadBalancerProbeInstance;
                                                    
                                                    XElement pathElement = loadBalancerProbeElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                                    if (pathElement != null)
                                                    {
                                                        string pathInstance = pathElement.Value;
                                                        loadBalancerProbeInstance.Path = pathInstance;
                                                    }
                                                    
                                                    XElement portElement3 = loadBalancerProbeElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                                    if (portElement3 != null)
                                                    {
                                                        int portInstance3 = int.Parse(portElement3.Value, CultureInfo.InvariantCulture);
                                                        loadBalancerProbeInstance.Port = portInstance3;
                                                    }
                                                    
                                                    XElement protocolElement2 = loadBalancerProbeElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                                    if (protocolElement2 != null)
                                                    {
                                                        LoadBalancerProbeTransportProtocol protocolInstance2 = ComputeManagementClient.ParseLoadBalancerProbeTransportProtocol(protocolElement2.Value);
                                                        loadBalancerProbeInstance.Protocol = protocolInstance2;
                                                    }
                                                    
                                                    XElement intervalInSecondsElement = loadBalancerProbeElement.Element(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                                    if (intervalInSecondsElement != null && string.IsNullOrEmpty(intervalInSecondsElement.Value) == false)
                                                    {
                                                        int intervalInSecondsInstance = int.Parse(intervalInSecondsElement.Value, CultureInfo.InvariantCulture);
                                                        loadBalancerProbeInstance.IntervalInSeconds = intervalInSecondsInstance;
                                                    }
                                                    
                                                    XElement timeoutInSecondsElement = loadBalancerProbeElement.Element(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                                    if (timeoutInSecondsElement != null && string.IsNullOrEmpty(timeoutInSecondsElement.Value) == false)
                                                    {
                                                        int timeoutInSecondsInstance = int.Parse(timeoutInSecondsElement.Value, CultureInfo.InvariantCulture);
                                                        loadBalancerProbeInstance.TimeoutInSeconds = timeoutInSecondsInstance;
                                                    }
                                                }
                                                
                                                XElement protocolElement3 = inputEndpointsElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                                if (protocolElement3 != null)
                                                {
                                                    string protocolInstance3 = protocolElement3.Value;
                                                    inputEndpointInstance.Protocol = protocolInstance3;
                                                }
                                                
                                                XElement vipElement2 = inputEndpointsElement.Element(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                                                if (vipElement2 != null)
                                                {
                                                    string vipInstance2 = vipElement2.Value;
                                                    inputEndpointInstance.VirtualIPAddress = vipInstance2;
                                                }
                                                
                                                XElement enableDirectServerReturnElement = inputEndpointsElement.Element(XName.Get("EnableDirectServerReturn", "http://schemas.microsoft.com/windowsazure"));
                                                if (enableDirectServerReturnElement != null && string.IsNullOrEmpty(enableDirectServerReturnElement.Value) == false)
                                                {
                                                    bool enableDirectServerReturnInstance = bool.Parse(enableDirectServerReturnElement.Value);
                                                    inputEndpointInstance.EnableDirectServerReturn = enableDirectServerReturnInstance;
                                                }
                                                
                                                XElement accessControlListElement = inputEndpointsElement.Element(XName.Get("AccessControlList", "http://schemas.microsoft.com/windowsazure"));
                                                if (accessControlListElement != null)
                                                {
                                                    AccessControlList accessControlListInstance = new AccessControlList();
                                                    inputEndpointInstance.AccessControlList = accessControlListInstance;
                                                    
                                                    XElement rulesSequenceElement = accessControlListElement.Element(XName.Get("Rules", "http://schemas.microsoft.com/windowsazure"));
                                                    if (rulesSequenceElement != null)
                                                    {
                                                        foreach (XElement rulesElement in rulesSequenceElement.Elements(XName.Get("Rule", "http://schemas.microsoft.com/windowsazure")))
                                                        {
                                                            AccessControlListRule ruleInstance = new AccessControlListRule();
                                                            accessControlListInstance.Rules.Add(ruleInstance);
                                                            
                                                            XElement orderElement = rulesElement.Element(XName.Get("Order", "http://schemas.microsoft.com/windowsazure"));
                                                            if (orderElement != null && string.IsNullOrEmpty(orderElement.Value) == false)
                                                            {
                                                                int orderInstance = int.Parse(orderElement.Value, CultureInfo.InvariantCulture);
                                                                ruleInstance.Order = orderInstance;
                                                            }
                                                            
                                                            XElement actionElement = rulesElement.Element(XName.Get("Action", "http://schemas.microsoft.com/windowsazure"));
                                                            if (actionElement != null)
                                                            {
                                                                string actionInstance = actionElement.Value;
                                                                ruleInstance.Action = actionInstance;
                                                            }
                                                            
                                                            XElement remoteSubnetElement = rulesElement.Element(XName.Get("RemoteSubnet", "http://schemas.microsoft.com/windowsazure"));
                                                            if (remoteSubnetElement != null)
                                                            {
                                                                string remoteSubnetInstance = remoteSubnetElement.Value;
                                                                ruleInstance.RemoteSubnet = remoteSubnetInstance;
                                                            }
                                                            
                                                            XElement descriptionElement = rulesElement.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                                                            if (descriptionElement != null)
                                                            {
                                                                string descriptionInstance = descriptionElement.Value;
                                                                ruleInstance.Description = descriptionInstance;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        
                                        XElement subnetNamesSequenceElement = configurationSetsElement.Element(XName.Get("SubnetNames", "http://schemas.microsoft.com/windowsazure"));
                                        if (subnetNamesSequenceElement != null)
                                        {
                                            foreach (XElement subnetNamesElement in subnetNamesSequenceElement.Elements(XName.Get("SubnetName", "http://schemas.microsoft.com/windowsazure")))
                                            {
                                                configurationSetInstance.SubnetNames.Add(subnetNamesElement.Value);
                                            }
                                        }
                                        
                                        XElement computerNameElement = configurationSetsElement.Element(XName.Get("ComputerName", "http://schemas.microsoft.com/windowsazure"));
                                        if (computerNameElement != null)
                                        {
                                            string computerNameInstance = computerNameElement.Value;
                                            configurationSetInstance.ComputerName = computerNameInstance;
                                        }
                                        
                                        XElement adminPasswordElement = configurationSetsElement.Element(XName.Get("AdminPassword", "http://schemas.microsoft.com/windowsazure"));
                                        if (adminPasswordElement != null)
                                        {
                                            string adminPasswordInstance = adminPasswordElement.Value;
                                            configurationSetInstance.AdminPassword = adminPasswordInstance;
                                        }
                                        
                                        XElement resetPasswordOnFirstLogonElement = configurationSetsElement.Element(XName.Get("ResetPasswordOnFirstLogon", "http://schemas.microsoft.com/windowsazure"));
                                        if (resetPasswordOnFirstLogonElement != null && string.IsNullOrEmpty(resetPasswordOnFirstLogonElement.Value) == false)
                                        {
                                            bool resetPasswordOnFirstLogonInstance = bool.Parse(resetPasswordOnFirstLogonElement.Value);
                                            configurationSetInstance.ResetPasswordOnFirstLogon = resetPasswordOnFirstLogonInstance;
                                        }
                                        
                                        XElement enableAutomaticUpdatesElement = configurationSetsElement.Element(XName.Get("EnableAutomaticUpdates", "http://schemas.microsoft.com/windowsazure"));
                                        if (enableAutomaticUpdatesElement != null && string.IsNullOrEmpty(enableAutomaticUpdatesElement.Value) == false)
                                        {
                                            bool enableAutomaticUpdatesInstance = bool.Parse(enableAutomaticUpdatesElement.Value);
                                            configurationSetInstance.EnableAutomaticUpdates = enableAutomaticUpdatesInstance;
                                        }
                                        
                                        XElement timeZoneElement = configurationSetsElement.Element(XName.Get("TimeZone", "http://schemas.microsoft.com/windowsazure"));
                                        if (timeZoneElement != null)
                                        {
                                            string timeZoneInstance = timeZoneElement.Value;
                                            configurationSetInstance.TimeZone = timeZoneInstance;
                                        }
                                        
                                        XElement domainJoinElement = configurationSetsElement.Element(XName.Get("DomainJoin", "http://schemas.microsoft.com/windowsazure"));
                                        if (domainJoinElement != null)
                                        {
                                            DomainJoinSettings domainJoinInstance = new DomainJoinSettings();
                                            configurationSetInstance.DomainJoin = domainJoinInstance;
                                            
                                            XElement credentialsElement = domainJoinElement.Element(XName.Get("Credentials", "http://schemas.microsoft.com/windowsazure"));
                                            if (credentialsElement != null)
                                            {
                                                DomainJoinCredentials credentialsInstance = new DomainJoinCredentials();
                                                domainJoinInstance.Credentials = credentialsInstance;
                                                
                                                XElement domainElement = credentialsElement.Element(XName.Get("Domain", "http://schemas.microsoft.com/windowsazure"));
                                                if (domainElement != null)
                                                {
                                                    string domainInstance = domainElement.Value;
                                                    credentialsInstance.Domain = domainInstance;
                                                }
                                                
                                                XElement usernameElement = credentialsElement.Element(XName.Get("Username", "http://schemas.microsoft.com/windowsazure"));
                                                if (usernameElement != null)
                                                {
                                                    string usernameInstance = usernameElement.Value;
                                                    credentialsInstance.UserName = usernameInstance;
                                                }
                                                
                                                XElement passwordElement = credentialsElement.Element(XName.Get("Password", "http://schemas.microsoft.com/windowsazure"));
                                                if (passwordElement != null)
                                                {
                                                    string passwordInstance = passwordElement.Value;
                                                    credentialsInstance.Password = passwordInstance;
                                                }
                                            }
                                            
                                            XElement joinDomainElement = domainJoinElement.Element(XName.Get("JoinDomain", "http://schemas.microsoft.com/windowsazure"));
                                            if (joinDomainElement != null)
                                            {
                                                string joinDomainInstance = joinDomainElement.Value;
                                                domainJoinInstance.DomainToJoin = joinDomainInstance;
                                            }
                                            
                                            XElement machineObjectOUElement = domainJoinElement.Element(XName.Get("MachineObjectOU", "http://schemas.microsoft.com/windowsazure"));
                                            if (machineObjectOUElement != null)
                                            {
                                                string machineObjectOUInstance = machineObjectOUElement.Value;
                                                domainJoinInstance.LdapMachineObjectOU = machineObjectOUInstance;
                                            }
                                            
                                            XElement provisioningElement = domainJoinElement.Element(XName.Get("Provisioning", "http://schemas.microsoft.com/windowsazure"));
                                            if (provisioningElement != null)
                                            {
                                                DomainJoinProvisioning provisioningInstance = new DomainJoinProvisioning();
                                                domainJoinInstance.Provisioning = provisioningInstance;
                                                
                                                XElement accountDataElement = provisioningElement.Element(XName.Get("AccountData", "http://schemas.microsoft.com/windowsazure"));
                                                if (accountDataElement != null)
                                                {
                                                    string accountDataInstance = accountDataElement.Value;
                                                    provisioningInstance.AccountData = accountDataInstance;
                                                }
                                            }
                                        }
                                        
                                        XElement storedCertificateSettingsSequenceElement = configurationSetsElement.Element(XName.Get("StoredCertificateSettings", "http://schemas.microsoft.com/windowsazure"));
                                        if (storedCertificateSettingsSequenceElement != null)
                                        {
                                            foreach (XElement storedCertificateSettingsElement in storedCertificateSettingsSequenceElement.Elements(XName.Get("CertificateSetting", "http://schemas.microsoft.com/windowsazure")))
                                            {
                                                StoredCertificateSettings certificateSettingInstance = new StoredCertificateSettings();
                                                configurationSetInstance.StoredCertificateSettings.Add(certificateSettingInstance);
                                                
                                                XElement storeLocationElement = storedCertificateSettingsElement.Element(XName.Get("StoreLocation", "http://schemas.microsoft.com/windowsazure"));
                                                if (storeLocationElement != null)
                                                {
                                                }
                                                
                                                XElement storeNameElement = storedCertificateSettingsElement.Element(XName.Get("StoreName", "http://schemas.microsoft.com/windowsazure"));
                                                if (storeNameElement != null)
                                                {
                                                    string storeNameInstance = storeNameElement.Value;
                                                    certificateSettingInstance.StoreName = storeNameInstance;
                                                }
                                                
                                                XElement thumbprintElement = storedCertificateSettingsElement.Element(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                                                if (thumbprintElement != null)
                                                {
                                                    string thumbprintInstance = thumbprintElement.Value;
                                                    certificateSettingInstance.Thumbprint = thumbprintInstance;
                                                }
                                            }
                                        }
                                        
                                        XElement winRMElement = configurationSetsElement.Element(XName.Get("WinRM", "http://schemas.microsoft.com/windowsazure"));
                                        if (winRMElement != null)
                                        {
                                            WindowsRemoteManagementSettings winRMInstance = new WindowsRemoteManagementSettings();
                                            configurationSetInstance.WindowsRemoteManagement = winRMInstance;
                                            
                                            XElement listenersSequenceElement = winRMElement.Element(XName.Get("Listeners", "http://schemas.microsoft.com/windowsazure"));
                                            if (listenersSequenceElement != null)
                                            {
                                                foreach (XElement listenersElement in listenersSequenceElement.Elements(XName.Get("Listener", "http://schemas.microsoft.com/windowsazure")))
                                                {
                                                    WindowsRemoteManagementListener listenerInstance = new WindowsRemoteManagementListener();
                                                    winRMInstance.Listeners.Add(listenerInstance);
                                                    
                                                    XElement protocolElement4 = listenersElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                                    if (protocolElement4 != null)
                                                    {
                                                        VirtualMachineWindowsRemoteManagementListenerType protocolInstance4 = (VirtualMachineWindowsRemoteManagementListenerType)Enum.Parse(typeof(VirtualMachineWindowsRemoteManagementListenerType), protocolElement4.Value, false);
                                                        listenerInstance.ListenerType = protocolInstance4;
                                                    }
                                                    
                                                    XElement certificateThumbprintElement = listenersElement.Element(XName.Get("CertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                                    if (certificateThumbprintElement != null)
                                                    {
                                                        string certificateThumbprintInstance = certificateThumbprintElement.Value;
                                                        listenerInstance.CertificateThumbprint = certificateThumbprintInstance;
                                                    }
                                                }
                                            }
                                        }
                                        
                                        XElement adminUsernameElement = configurationSetsElement.Element(XName.Get("AdminUsername", "http://schemas.microsoft.com/windowsazure"));
                                        if (adminUsernameElement != null)
                                        {
                                            string adminUsernameInstance = adminUsernameElement.Value;
                                            configurationSetInstance.AdminUserName = adminUsernameInstance;
                                        }
                                        
                                        XElement hostNameElement2 = configurationSetsElement.Element(XName.Get("HostName", "http://schemas.microsoft.com/windowsazure"));
                                        if (hostNameElement2 != null)
                                        {
                                            string hostNameInstance2 = hostNameElement2.Value;
                                            configurationSetInstance.HostName = hostNameInstance2;
                                        }
                                        
                                        XElement userNameElement = configurationSetsElement.Element(XName.Get("UserName", "http://schemas.microsoft.com/windowsazure"));
                                        if (userNameElement != null)
                                        {
                                            string userNameInstance = userNameElement.Value;
                                            configurationSetInstance.UserName = userNameInstance;
                                        }
                                        
                                        XElement userPasswordElement = configurationSetsElement.Element(XName.Get("UserPassword", "http://schemas.microsoft.com/windowsazure"));
                                        if (userPasswordElement != null)
                                        {
                                            string userPasswordInstance = userPasswordElement.Value;
                                            configurationSetInstance.UserPassword = userPasswordInstance;
                                        }
                                        
                                        XElement disableSshPasswordAuthenticationElement = configurationSetsElement.Element(XName.Get("DisableSshPasswordAuthentication", "http://schemas.microsoft.com/windowsazure"));
                                        if (disableSshPasswordAuthenticationElement != null && string.IsNullOrEmpty(disableSshPasswordAuthenticationElement.Value) == false)
                                        {
                                            bool disableSshPasswordAuthenticationInstance = bool.Parse(disableSshPasswordAuthenticationElement.Value);
                                            configurationSetInstance.DisableSshPasswordAuthentication = disableSshPasswordAuthenticationInstance;
                                        }
                                        
                                        XElement sSHElement = configurationSetsElement.Element(XName.Get("SSH", "http://schemas.microsoft.com/windowsazure"));
                                        if (sSHElement != null)
                                        {
                                            SshSettings sSHInstance = new SshSettings();
                                            configurationSetInstance.SshSettings = sSHInstance;
                                            
                                            XElement publicKeysSequenceElement = sSHElement.Element(XName.Get("PublicKeys", "http://schemas.microsoft.com/windowsazure"));
                                            if (publicKeysSequenceElement != null)
                                            {
                                                foreach (XElement publicKeysElement in publicKeysSequenceElement.Elements(XName.Get("PublicKey", "http://schemas.microsoft.com/windowsazure")))
                                                {
                                                    SshSettingPublicKey publicKeyInstance = new SshSettingPublicKey();
                                                    sSHInstance.PublicKeys.Add(publicKeyInstance);
                                                    
                                                    XElement fingerPrintElement = publicKeysElement.Element(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                                    if (fingerPrintElement != null)
                                                    {
                                                        string fingerPrintInstance = fingerPrintElement.Value;
                                                        publicKeyInstance.Fingerprint = fingerPrintInstance;
                                                    }
                                                    
                                                    XElement pathElement2 = publicKeysElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                                    if (pathElement2 != null)
                                                    {
                                                        string pathInstance2 = pathElement2.Value;
                                                        publicKeyInstance.Path = pathInstance2;
                                                    }
                                                }
                                            }
                                            
                                            XElement keyPairsSequenceElement = sSHElement.Element(XName.Get("KeyPairs", "http://schemas.microsoft.com/windowsazure"));
                                            if (keyPairsSequenceElement != null)
                                            {
                                                foreach (XElement keyPairsElement in keyPairsSequenceElement.Elements(XName.Get("KeyPair", "http://schemas.microsoft.com/windowsazure")))
                                                {
                                                    SshSettingKeyPair keyPairInstance = new SshSettingKeyPair();
                                                    sSHInstance.KeyPairs.Add(keyPairInstance);
                                                    
                                                    XElement fingerPrintElement2 = keyPairsElement.Element(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                                    if (fingerPrintElement2 != null)
                                                    {
                                                        string fingerPrintInstance2 = fingerPrintElement2.Value;
                                                        keyPairInstance.Fingerprint = fingerPrintInstance2;
                                                    }
                                                    
                                                    XElement pathElement3 = keyPairsElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                                    if (pathElement3 != null)
                                                    {
                                                        string pathInstance3 = pathElement3.Value;
                                                        keyPairInstance.Path = pathInstance3;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                XElement availabilitySetNameElement = roleListElement.Element(XName.Get("AvailabilitySetName", "http://schemas.microsoft.com/windowsazure"));
                                if (availabilitySetNameElement != null)
                                {
                                    string availabilitySetNameInstance = availabilitySetNameElement.Value;
                                    roleInstance.AvailabilitySetName = availabilitySetNameInstance;
                                }
                                
                                XElement dataVirtualHardDisksSequenceElement = roleListElement.Element(XName.Get("DataVirtualHardDisks", "http://schemas.microsoft.com/windowsazure"));
                                if (dataVirtualHardDisksSequenceElement != null)
                                {
                                    foreach (XElement dataVirtualHardDisksElement in dataVirtualHardDisksSequenceElement.Elements(XName.Get("DataVirtualHardDisk", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        DataVirtualHardDisk dataVirtualHardDiskInstance = new DataVirtualHardDisk();
                                        roleInstance.DataVirtualHardDisks.Add(dataVirtualHardDiskInstance);
                                        
                                        XElement hostCachingElement = dataVirtualHardDisksElement.Element(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                                        if (hostCachingElement != null && string.IsNullOrEmpty(hostCachingElement.Value) == false)
                                        {
                                            VirtualHardDiskHostCaching hostCachingInstance = (VirtualHardDiskHostCaching)Enum.Parse(typeof(VirtualHardDiskHostCaching), hostCachingElement.Value, false);
                                            dataVirtualHardDiskInstance.HostCaching = hostCachingInstance;
                                        }
                                        
                                        XElement diskLabelElement = dataVirtualHardDisksElement.Element(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                                        if (diskLabelElement != null)
                                        {
                                            string diskLabelInstance = diskLabelElement.Value;
                                            dataVirtualHardDiskInstance.DiskLabel = diskLabelInstance;
                                        }
                                        
                                        XElement diskNameElement = dataVirtualHardDisksElement.Element(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                                        if (diskNameElement != null)
                                        {
                                            string diskNameInstance = diskNameElement.Value;
                                            dataVirtualHardDiskInstance.DiskName = diskNameInstance;
                                        }
                                        
                                        XElement lunElement = dataVirtualHardDisksElement.Element(XName.Get("Lun", "http://schemas.microsoft.com/windowsazure"));
                                        if (lunElement != null && string.IsNullOrEmpty(lunElement.Value) == false)
                                        {
                                            int lunInstance = int.Parse(lunElement.Value, CultureInfo.InvariantCulture);
                                            dataVirtualHardDiskInstance.LogicalUnitNumber = lunInstance;
                                        }
                                        
                                        XElement logicalDiskSizeInGBElement = dataVirtualHardDisksElement.Element(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                                        if (logicalDiskSizeInGBElement != null)
                                        {
                                            int logicalDiskSizeInGBInstance = int.Parse(logicalDiskSizeInGBElement.Value, CultureInfo.InvariantCulture);
                                            dataVirtualHardDiskInstance.LogicalDiskSizeInGB = logicalDiskSizeInGBInstance;
                                        }
                                        
                                        XElement mediaLinkElement = dataVirtualHardDisksElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                                        if (mediaLinkElement != null)
                                        {
                                            Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement.Value);
                                            dataVirtualHardDiskInstance.MediaLink = mediaLinkInstance;
                                        }
                                    }
                                }
                                
                                XElement labelElement2 = roleListElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                                if (labelElement2 != null)
                                {
                                    string labelInstance2 = labelElement2.Value;
                                    roleInstance.Label = labelInstance2;
                                }
                                
                                XElement oSVirtualHardDiskElement = roleListElement.Element(XName.Get("OSVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                                if (oSVirtualHardDiskElement != null)
                                {
                                    OSVirtualHardDisk oSVirtualHardDiskInstance = new OSVirtualHardDisk();
                                    roleInstance.OSVirtualHardDisk = oSVirtualHardDiskInstance;
                                    
                                    XElement hostCachingElement2 = oSVirtualHardDiskElement.Element(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                                    if (hostCachingElement2 != null && string.IsNullOrEmpty(hostCachingElement2.Value) == false)
                                    {
                                        VirtualHardDiskHostCaching hostCachingInstance2 = (VirtualHardDiskHostCaching)Enum.Parse(typeof(VirtualHardDiskHostCaching), hostCachingElement2.Value, false);
                                        oSVirtualHardDiskInstance.HostCaching = hostCachingInstance2;
                                    }
                                    
                                    XElement diskLabelElement2 = oSVirtualHardDiskElement.Element(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                                    if (diskLabelElement2 != null)
                                    {
                                        string diskLabelInstance2 = diskLabelElement2.Value;
                                        oSVirtualHardDiskInstance.DiskLabel = diskLabelInstance2;
                                    }
                                    
                                    XElement diskNameElement2 = oSVirtualHardDiskElement.Element(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                                    if (diskNameElement2 != null)
                                    {
                                        string diskNameInstance2 = diskNameElement2.Value;
                                        oSVirtualHardDiskInstance.DiskName = diskNameInstance2;
                                    }
                                    
                                    XElement mediaLinkElement2 = oSVirtualHardDiskElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                                    if (mediaLinkElement2 != null)
                                    {
                                        Uri mediaLinkInstance2 = TypeConversion.TryParseUri(mediaLinkElement2.Value);
                                        oSVirtualHardDiskInstance.MediaLink = mediaLinkInstance2;
                                    }
                                    
                                    XElement sourceImageNameElement = oSVirtualHardDiskElement.Element(XName.Get("SourceImageName", "http://schemas.microsoft.com/windowsazure"));
                                    if (sourceImageNameElement != null)
                                    {
                                        string sourceImageNameInstance = sourceImageNameElement.Value;
                                        oSVirtualHardDiskInstance.SourceImageName = sourceImageNameInstance;
                                    }
                                    
                                    XElement osElement = oSVirtualHardDiskElement.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                                    if (osElement != null)
                                    {
                                        string osInstance = osElement.Value;
                                        oSVirtualHardDiskInstance.OperatingSystem = osInstance;
                                    }
                                }
                                
                                XElement roleSizeElement = roleListElement.Element(XName.Get("RoleSize", "http://schemas.microsoft.com/windowsazure"));
                                if (roleSizeElement != null && string.IsNullOrEmpty(roleSizeElement.Value) == false)
                                {
                                    VirtualMachineRoleSize roleSizeInstance = (VirtualMachineRoleSize)Enum.Parse(typeof(VirtualMachineRoleSize), roleSizeElement.Value, false);
                                    roleInstance.RoleSize = roleSizeInstance;
                                }
                                
                                XElement defaultWinRmCertificateThumbprintElement = roleListElement.Element(XName.Get("DefaultWinRmCertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                if (defaultWinRmCertificateThumbprintElement != null)
                                {
                                    string defaultWinRmCertificateThumbprintInstance = defaultWinRmCertificateThumbprintElement.Value;
                                    roleInstance.DefaultWinRmCertificateThumbprint = defaultWinRmCertificateThumbprintInstance;
                                }
                            }
                        }
                        
                        XElement sdkVersionElement = deploymentElement.Element(XName.Get("SdkVersion", "http://schemas.microsoft.com/windowsazure"));
                        if (sdkVersionElement != null)
                        {
                            string sdkVersionInstance = sdkVersionElement.Value;
                            result.SdkVersion = sdkVersionInstance;
                        }
                        
                        XElement lockedElement = deploymentElement.Element(XName.Get("Locked", "http://schemas.microsoft.com/windowsazure"));
                        if (lockedElement != null)
                        {
                            bool lockedInstance = bool.Parse(lockedElement.Value);
                            result.Locked = lockedInstance;
                        }
                        
                        XElement rollbackAllowedElement = deploymentElement.Element(XName.Get("RollbackAllowed", "http://schemas.microsoft.com/windowsazure"));
                        if (rollbackAllowedElement != null)
                        {
                            string rollbackAllowedInstance = rollbackAllowedElement.Value;
                            result.RollbackAllowed = rollbackAllowedInstance;
                        }
                        
                        XElement createdTimeElement = deploymentElement.Element(XName.Get("CreatedTime", "http://schemas.microsoft.com/windowsazure"));
                        if (createdTimeElement != null)
                        {
                            DateTime createdTimeInstance = DateTime.Parse(createdTimeElement.Value, CultureInfo.InvariantCulture);
                            result.CreatedTime = createdTimeInstance;
                        }
                        
                        XElement lastModifiedTimeElement = deploymentElement.Element(XName.Get("LastModifiedTime", "http://schemas.microsoft.com/windowsazure"));
                        if (lastModifiedTimeElement != null)
                        {
                            DateTime lastModifiedTimeInstance = DateTime.Parse(lastModifiedTimeElement.Value, CultureInfo.InvariantCulture);
                            result.LastModifiedTime = lastModifiedTimeInstance;
                        }
                        
                        XElement virtualNetworkNameElement = deploymentElement.Element(XName.Get("VirtualNetworkName", "http://schemas.microsoft.com/windowsazure"));
                        if (virtualNetworkNameElement != null)
                        {
                            string virtualNetworkNameInstance = virtualNetworkNameElement.Value;
                            result.VirtualNetworkName = virtualNetworkNameInstance;
                        }
                        
                        XElement extendedPropertiesSequenceElement = deploymentElement.Element(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                        if (extendedPropertiesSequenceElement != null)
                        {
                            foreach (XElement extendedPropertiesElement in extendedPropertiesSequenceElement.Elements(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure")))
                            {
                                string extendedPropertiesKey = extendedPropertiesElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure")).Value;
                                string extendedPropertiesValue = extendedPropertiesElement.Element(XName.Get("Value", "http://schemas.microsoft.com/windowsazure")).Value;
                                result.ExtendedProperties.Add(extendedPropertiesKey, extendedPropertiesValue);
                            }
                        }
                        
                        XElement persistentVMDowntimeElement = deploymentElement.Element(XName.Get("PersistentVMDowntime", "http://schemas.microsoft.com/windowsazure"));
                        if (persistentVMDowntimeElement != null)
                        {
                            PersistentVMDowntime persistentVMDowntimeInstance = new PersistentVMDowntime();
                            result.PersistentVMDowntime = persistentVMDowntimeInstance;
                            
                            XElement startTimeElement = persistentVMDowntimeElement.Element(XName.Get("StartTime", "http://schemas.microsoft.com/windowsazure"));
                            if (startTimeElement != null)
                            {
                                DateTime startTimeInstance = DateTime.Parse(startTimeElement.Value, CultureInfo.InvariantCulture);
                                persistentVMDowntimeInstance.StartTime = startTimeInstance;
                            }
                            
                            XElement endTimeElement = persistentVMDowntimeElement.Element(XName.Get("EndTime", "http://schemas.microsoft.com/windowsazure"));
                            if (endTimeElement != null)
                            {
                                DateTime endTimeInstance = DateTime.Parse(endTimeElement.Value, CultureInfo.InvariantCulture);
                                persistentVMDowntimeInstance.EndTime = endTimeInstance;
                            }
                            
                            XElement statusElement2 = persistentVMDowntimeElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                            if (statusElement2 != null)
                            {
                                string statusInstance2 = statusElement2.Value;
                                persistentVMDowntimeInstance.Status = statusInstance2;
                            }
                        }
                        
                        XElement virtualIPsSequenceElement = deploymentElement.Element(XName.Get("VirtualIPs", "http://schemas.microsoft.com/windowsazure"));
                        if (virtualIPsSequenceElement != null)
                        {
                            foreach (XElement virtualIPsElement in virtualIPsSequenceElement.Elements(XName.Get("VirtualIPAddress", "http://schemas.microsoft.com/windowsazure")))
                            {
                                VirtualIPAddress virtualIPAddressInstance = new VirtualIPAddress();
                                result.VirtualIPAddresses.Add(virtualIPAddressInstance);
                                
                                XElement addressElement = virtualIPsElement.Element(XName.Get("Address", "http://schemas.microsoft.com/windowsazure"));
                                if (addressElement != null)
                                {
                                    string addressInstance = addressElement.Value;
                                    virtualIPAddressInstance.Address = addressInstance;
                                }
                            }
                        }
                        
                        XElement dnsElement = deploymentElement.Element(XName.Get("Dns", "http://schemas.microsoft.com/windowsazure"));
                        if (dnsElement != null)
                        {
                            DnsSettings dnsInstance = new DnsSettings();
                            result.DnsSettings = dnsInstance;
                            
                            XElement dnsServersSequenceElement = dnsElement.Element(XName.Get("DnsServers", "http://schemas.microsoft.com/windowsazure"));
                            if (dnsServersSequenceElement != null)
                            {
                                foreach (XElement dnsServersElement in dnsServersSequenceElement.Elements(XName.Get("DnsServer", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    DnsServer dnsServerInstance = new DnsServer();
                                    dnsInstance.DnsServers.Add(dnsServerInstance);
                                    
                                    XElement nameElement4 = dnsServersElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                    if (nameElement4 != null)
                                    {
                                        string nameInstance4 = nameElement4.Value;
                                        dnsServerInstance.Name = nameInstance4;
                                    }
                                    
                                    XElement addressElement2 = dnsServersElement.Element(XName.Get("Address", "http://schemas.microsoft.com/windowsazure"));
                                    if (addressElement2 != null)
                                    {
                                        string addressInstance2 = addressElement2.Value;
                                        dnsServerInstance.Address = addressInstance2;
                                    }
                                }
                            }
                        }
                        
                        XElement extensionConfigurationElement = deploymentElement.Element(XName.Get("ExtensionConfiguration", "http://schemas.microsoft.com/windowsazure"));
                        if (extensionConfigurationElement != null)
                        {
                            ExtensionConfiguration extensionConfigurationInstance = new ExtensionConfiguration();
                            result.ExtensionConfiguration = extensionConfigurationInstance;
                            
                            XElement allRolesSequenceElement = extensionConfigurationElement.Element(XName.Get("AllRoles", "http://schemas.microsoft.com/windowsazure"));
                            if (allRolesSequenceElement != null)
                            {
                                foreach (XElement allRolesElement in allRolesSequenceElement.Elements(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    ExtensionConfiguration.Extension extensionInstance = new ExtensionConfiguration.Extension();
                                    extensionConfigurationInstance.AllRoles.Add(extensionInstance);
                                    
                                    XElement idElement = allRolesElement.Element(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                                    if (idElement != null)
                                    {
                                        string idInstance = idElement.Value;
                                        extensionInstance.Id = idInstance;
                                    }
                                }
                            }
                            
                            XElement namedRolesSequenceElement = extensionConfigurationElement.Element(XName.Get("NamedRoles", "http://schemas.microsoft.com/windowsazure"));
                            if (namedRolesSequenceElement != null)
                            {
                                foreach (XElement namedRolesElement in namedRolesSequenceElement.Elements(XName.Get("Role", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    ExtensionConfiguration.NamedRole roleInstance2 = new ExtensionConfiguration.NamedRole();
                                    extensionConfigurationInstance.NamedRoles.Add(roleInstance2);
                                    
                                    XElement roleNameElement3 = namedRolesElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                                    if (roleNameElement3 != null)
                                    {
                                        string roleNameInstance3 = roleNameElement3.Value;
                                        roleInstance2.RoleName = roleNameInstance3;
                                    }
                                    
                                    XElement extensionsSequenceElement = namedRolesElement.Element(XName.Get("Extensions", "http://schemas.microsoft.com/windowsazure"));
                                    if (extensionsSequenceElement != null)
                                    {
                                        foreach (XElement extensionsElement in extensionsSequenceElement.Elements(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure")))
                                        {
                                            ExtensionConfiguration.Extension extensionInstance2 = new ExtensionConfiguration.Extension();
                                            roleInstance2.Extensions.Add(extensionInstance2);
                                            
                                            XElement idElement2 = extensionsElement.Element(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                                            if (idElement2 != null)
                                            {
                                                string idInstance2 = idElement2.Value;
                                                extensionInstance2.Id = idInstance2;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get Deployment operation returns configuration information,
        /// status, and system properties for a deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460804.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A deployment that exists in the cloud service.
        /// </returns>
        public async Task<DeploymentGetResponse> GetBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                Tracing.Enter(invocationId, this, "GetBySlotAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deploymentslots/" + deploymentSlot;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    DeploymentGetResponse result = new DeploymentGetResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement deploymentElement = responseDoc.Element(XName.Get("Deployment", "http://schemas.microsoft.com/windowsazure"));
                    if (deploymentElement != null)
                    {
                        XElement nameElement = deploymentElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        if (nameElement != null)
                        {
                            string nameInstance = nameElement.Value;
                            result.Name = nameInstance;
                        }
                        
                        XElement deploymentSlotElement = deploymentElement.Element(XName.Get("DeploymentSlot", "http://schemas.microsoft.com/windowsazure"));
                        if (deploymentSlotElement != null)
                        {
                            DeploymentSlot deploymentSlotInstance = (DeploymentSlot)Enum.Parse(typeof(DeploymentSlot), deploymentSlotElement.Value, false);
                            result.DeploymentSlot = deploymentSlotInstance;
                        }
                        
                        XElement privateIDElement = deploymentElement.Element(XName.Get("PrivateID", "http://schemas.microsoft.com/windowsazure"));
                        if (privateIDElement != null)
                        {
                            string privateIDInstance = privateIDElement.Value;
                            result.PrivateId = privateIDInstance;
                        }
                        
                        XElement statusElement = deploymentElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                        if (statusElement != null)
                        {
                            DeploymentStatus statusInstance = (DeploymentStatus)Enum.Parse(typeof(DeploymentStatus), statusElement.Value, false);
                            result.Status = statusInstance;
                        }
                        
                        XElement labelElement = deploymentElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                        if (labelElement != null)
                        {
                            string labelInstance = TypeConversion.FromBase64String(labelElement.Value);
                            result.Label = labelInstance;
                        }
                        
                        XElement urlElement = deploymentElement.Element(XName.Get("Url", "http://schemas.microsoft.com/windowsazure"));
                        if (urlElement != null)
                        {
                            Uri urlInstance = TypeConversion.TryParseUri(urlElement.Value);
                            result.Uri = urlInstance;
                        }
                        
                        XElement configurationElement = deploymentElement.Element(XName.Get("Configuration", "http://schemas.microsoft.com/windowsazure"));
                        if (configurationElement != null)
                        {
                            string configurationInstance = TypeConversion.FromBase64String(configurationElement.Value);
                            result.Configuration = configurationInstance;
                        }
                        
                        XElement roleInstanceListSequenceElement = deploymentElement.Element(XName.Get("RoleInstanceList", "http://schemas.microsoft.com/windowsazure"));
                        if (roleInstanceListSequenceElement != null)
                        {
                            foreach (XElement roleInstanceListElement in roleInstanceListSequenceElement.Elements(XName.Get("RoleInstance", "http://schemas.microsoft.com/windowsazure")))
                            {
                                RoleInstance roleInstanceInstance = new RoleInstance();
                                result.RoleInstances.Add(roleInstanceInstance);
                                
                                XElement roleNameElement = roleInstanceListElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                                if (roleNameElement != null)
                                {
                                    string roleNameInstance = roleNameElement.Value;
                                    roleInstanceInstance.RoleName = roleNameInstance;
                                }
                                
                                XElement instanceNameElement = roleInstanceListElement.Element(XName.Get("InstanceName", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceNameElement != null)
                                {
                                    string instanceNameInstance = instanceNameElement.Value;
                                    roleInstanceInstance.InstanceName = instanceNameInstance;
                                }
                                
                                XElement instanceStatusElement = roleInstanceListElement.Element(XName.Get("InstanceStatus", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceStatusElement != null)
                                {
                                    string instanceStatusInstance = instanceStatusElement.Value;
                                    roleInstanceInstance.InstanceStatus = instanceStatusInstance;
                                }
                                
                                XElement instanceUpgradeDomainElement = roleInstanceListElement.Element(XName.Get("InstanceUpgradeDomain", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceUpgradeDomainElement != null && string.IsNullOrEmpty(instanceUpgradeDomainElement.Value) == false)
                                {
                                    int instanceUpgradeDomainInstance = int.Parse(instanceUpgradeDomainElement.Value, CultureInfo.InvariantCulture);
                                    roleInstanceInstance.InstanceUpgradeDomain = instanceUpgradeDomainInstance;
                                }
                                
                                XElement instanceFaultDomainElement = roleInstanceListElement.Element(XName.Get("InstanceFaultDomain", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceFaultDomainElement != null && string.IsNullOrEmpty(instanceFaultDomainElement.Value) == false)
                                {
                                    int instanceFaultDomainInstance = int.Parse(instanceFaultDomainElement.Value, CultureInfo.InvariantCulture);
                                    roleInstanceInstance.InstanceFaultDomain = instanceFaultDomainInstance;
                                }
                                
                                XElement instanceSizeElement = roleInstanceListElement.Element(XName.Get("InstanceSize", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceSizeElement != null && string.IsNullOrEmpty(instanceSizeElement.Value) == false)
                                {
                                    VirtualMachineRoleSize instanceSizeInstance = (VirtualMachineRoleSize)Enum.Parse(typeof(VirtualMachineRoleSize), instanceSizeElement.Value, false);
                                    roleInstanceInstance.InstanceSize = instanceSizeInstance;
                                }
                                
                                XElement instanceStateDetailsElement = roleInstanceListElement.Element(XName.Get("InstanceStateDetails", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceStateDetailsElement != null)
                                {
                                    string instanceStateDetailsInstance = instanceStateDetailsElement.Value;
                                    roleInstanceInstance.InstanceStateDetails = instanceStateDetailsInstance;
                                }
                                
                                XElement instanceErrorCodeElement = roleInstanceListElement.Element(XName.Get("InstanceErrorCode", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceErrorCodeElement != null)
                                {
                                    string instanceErrorCodeInstance = instanceErrorCodeElement.Value;
                                    roleInstanceInstance.InstanceErrorCode = instanceErrorCodeInstance;
                                }
                                
                                XElement ipAddressElement = roleInstanceListElement.Element(XName.Get("IpAddress", "http://schemas.microsoft.com/windowsazure"));
                                if (ipAddressElement != null)
                                {
                                    string ipAddressInstance = ipAddressElement.Value;
                                    roleInstanceInstance.IPAddress = ipAddressInstance;
                                }
                                
                                XElement instanceEndpointsSequenceElement = roleInstanceListElement.Element(XName.Get("InstanceEndpoints", "http://schemas.microsoft.com/windowsazure"));
                                if (instanceEndpointsSequenceElement != null)
                                {
                                    foreach (XElement instanceEndpointsElement in instanceEndpointsSequenceElement.Elements(XName.Get("InstanceEndpoint", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        InstanceEndpoint instanceEndpointInstance = new InstanceEndpoint();
                                        roleInstanceInstance.InstanceEndpoints.Add(instanceEndpointInstance);
                                        
                                        XElement localPortElement = instanceEndpointsElement.Element(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                                        if (localPortElement != null && string.IsNullOrEmpty(localPortElement.Value) == false)
                                        {
                                            int localPortInstance = int.Parse(localPortElement.Value, CultureInfo.InvariantCulture);
                                            instanceEndpointInstance.LocalPort = localPortInstance;
                                        }
                                        
                                        XElement nameElement2 = instanceEndpointsElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                        if (nameElement2 != null)
                                        {
                                            string nameInstance2 = nameElement2.Value;
                                            instanceEndpointInstance.Name = nameInstance2;
                                        }
                                        
                                        XElement portElement = instanceEndpointsElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                        if (portElement != null)
                                        {
                                            int portInstance = int.Parse(portElement.Value, CultureInfo.InvariantCulture);
                                            instanceEndpointInstance.Port = portInstance;
                                        }
                                        
                                        XElement protocolElement = instanceEndpointsElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                        if (protocolElement != null)
                                        {
                                            string protocolInstance = protocolElement.Value;
                                            instanceEndpointInstance.Protocol = protocolInstance;
                                        }
                                        
                                        XElement vipElement = instanceEndpointsElement.Element(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                                        if (vipElement != null)
                                        {
                                            string vipInstance = vipElement.Value;
                                            instanceEndpointInstance.VirtualIPAddress = vipInstance;
                                        }
                                    }
                                }
                                
                                XElement powerStateElement = roleInstanceListElement.Element(XName.Get("PowerState", "http://schemas.microsoft.com/windowsazure"));
                                if (powerStateElement != null)
                                {
                                    RoleInstancePowerState powerStateInstance = (RoleInstancePowerState)Enum.Parse(typeof(RoleInstancePowerState), powerStateElement.Value, false);
                                    roleInstanceInstance.PowerState = powerStateInstance;
                                }
                                
                                XElement hostNameElement = roleInstanceListElement.Element(XName.Get("HostName", "http://schemas.microsoft.com/windowsazure"));
                                if (hostNameElement != null)
                                {
                                    string hostNameInstance = hostNameElement.Value;
                                    roleInstanceInstance.HostName = hostNameInstance;
                                }
                                
                                XElement remoteAccessCertificateThumbprintElement = roleInstanceListElement.Element(XName.Get("RemoteAccessCertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                if (remoteAccessCertificateThumbprintElement != null)
                                {
                                    string remoteAccessCertificateThumbprintInstance = remoteAccessCertificateThumbprintElement.Value;
                                    roleInstanceInstance.RemoteAccessCertificateThumbprint = remoteAccessCertificateThumbprintInstance;
                                }
                            }
                        }
                        
                        XElement upgradeStatusElement = deploymentElement.Element(XName.Get("UpgradeStatus", "http://schemas.microsoft.com/windowsazure"));
                        if (upgradeStatusElement != null)
                        {
                            UpgradeStatus upgradeStatusInstance = new UpgradeStatus();
                            result.UpgradeStatus = upgradeStatusInstance;
                            
                            XElement upgradeTypeElement = upgradeStatusElement.Element(XName.Get("UpgradeType", "http://schemas.microsoft.com/windowsazure"));
                            if (upgradeTypeElement != null)
                            {
                                DeploymentUpgradeType upgradeTypeInstance = (DeploymentUpgradeType)Enum.Parse(typeof(DeploymentUpgradeType), upgradeTypeElement.Value, false);
                                upgradeStatusInstance.UpgradeType = upgradeTypeInstance;
                            }
                            
                            XElement currentUpgradeDomainStateElement = upgradeStatusElement.Element(XName.Get("CurrentUpgradeDomainState", "http://schemas.microsoft.com/windowsazure"));
                            if (currentUpgradeDomainStateElement != null)
                            {
                                UpgradeDomainState currentUpgradeDomainStateInstance = (UpgradeDomainState)Enum.Parse(typeof(UpgradeDomainState), currentUpgradeDomainStateElement.Value, false);
                                upgradeStatusInstance.CurrentUpgradeDomainState = currentUpgradeDomainStateInstance;
                            }
                            
                            XElement currentUpgradeDomainElement = upgradeStatusElement.Element(XName.Get("CurrentUpgradeDomain", "http://schemas.microsoft.com/windowsazure"));
                            if (currentUpgradeDomainElement != null)
                            {
                                int currentUpgradeDomainInstance = int.Parse(currentUpgradeDomainElement.Value, CultureInfo.InvariantCulture);
                                upgradeStatusInstance.CurrentUpgradeDomain = currentUpgradeDomainInstance;
                            }
                        }
                        
                        XElement upgradeDomainCountElement = deploymentElement.Element(XName.Get("UpgradeDomainCount", "http://schemas.microsoft.com/windowsazure"));
                        if (upgradeDomainCountElement != null)
                        {
                            int upgradeDomainCountInstance = int.Parse(upgradeDomainCountElement.Value, CultureInfo.InvariantCulture);
                            result.UpgradeDomainCount = upgradeDomainCountInstance;
                        }
                        
                        XElement roleListSequenceElement = deploymentElement.Element(XName.Get("RoleList", "http://schemas.microsoft.com/windowsazure"));
                        if (roleListSequenceElement != null)
                        {
                            foreach (XElement roleListElement in roleListSequenceElement.Elements(XName.Get("Role", "http://schemas.microsoft.com/windowsazure")))
                            {
                                Role roleInstance = new Role();
                                result.Roles.Add(roleInstance);
                                
                                XElement roleNameElement2 = roleListElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                                if (roleNameElement2 != null)
                                {
                                    string roleNameInstance2 = roleNameElement2.Value;
                                    roleInstance.RoleName = roleNameInstance2;
                                }
                                
                                XElement oSVersionElement = roleListElement.Element(XName.Get("OSVersion", "http://schemas.microsoft.com/windowsazure"));
                                if (oSVersionElement != null)
                                {
                                    string oSVersionInstance = oSVersionElement.Value;
                                    roleInstance.OSVersion = oSVersionInstance;
                                }
                                
                                XElement roleTypeElement = roleListElement.Element(XName.Get("RoleType", "http://schemas.microsoft.com/windowsazure"));
                                if (roleTypeElement != null)
                                {
                                    string roleTypeInstance = roleTypeElement.Value;
                                    roleInstance.RoleType = roleTypeInstance;
                                }
                                
                                XElement configurationSetsSequenceElement = roleListElement.Element(XName.Get("ConfigurationSets", "http://schemas.microsoft.com/windowsazure"));
                                if (configurationSetsSequenceElement != null)
                                {
                                    foreach (XElement configurationSetsElement in configurationSetsSequenceElement.Elements(XName.Get("ConfigurationSet", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        ConfigurationSet configurationSetInstance = new ConfigurationSet();
                                        roleInstance.ConfigurationSets.Add(configurationSetInstance);
                                        
                                        XElement configurationSetTypeElement = configurationSetsElement.Element(XName.Get("ConfigurationSetType", "http://schemas.microsoft.com/windowsazure"));
                                        if (configurationSetTypeElement != null)
                                        {
                                            string configurationSetTypeInstance = configurationSetTypeElement.Value;
                                            configurationSetInstance.ConfigurationSetType = configurationSetTypeInstance;
                                        }
                                        
                                        XElement inputEndpointsSequenceElement = configurationSetsElement.Element(XName.Get("InputEndpoints", "http://schemas.microsoft.com/windowsazure"));
                                        if (inputEndpointsSequenceElement != null)
                                        {
                                            foreach (XElement inputEndpointsElement in inputEndpointsSequenceElement.Elements(XName.Get("InputEndpoint", "http://schemas.microsoft.com/windowsazure")))
                                            {
                                                InputEndpoint inputEndpointInstance = new InputEndpoint();
                                                configurationSetInstance.InputEndpoints.Add(inputEndpointInstance);
                                                
                                                XElement loadBalancedEndpointSetNameElement = inputEndpointsElement.Element(XName.Get("LoadBalancedEndpointSetName", "http://schemas.microsoft.com/windowsazure"));
                                                if (loadBalancedEndpointSetNameElement != null)
                                                {
                                                    string loadBalancedEndpointSetNameInstance = loadBalancedEndpointSetNameElement.Value;
                                                    inputEndpointInstance.LoadBalancedEndpointSetName = loadBalancedEndpointSetNameInstance;
                                                }
                                                
                                                XElement localPortElement2 = inputEndpointsElement.Element(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                                                if (localPortElement2 != null && string.IsNullOrEmpty(localPortElement2.Value) == false)
                                                {
                                                    int localPortInstance2 = int.Parse(localPortElement2.Value, CultureInfo.InvariantCulture);
                                                    inputEndpointInstance.LocalPort = localPortInstance2;
                                                }
                                                
                                                XElement nameElement3 = inputEndpointsElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                                if (nameElement3 != null)
                                                {
                                                    string nameInstance3 = nameElement3.Value;
                                                    inputEndpointInstance.Name = nameInstance3;
                                                }
                                                
                                                XElement portElement2 = inputEndpointsElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                                if (portElement2 != null && string.IsNullOrEmpty(portElement2.Value) == false)
                                                {
                                                    int portInstance2 = int.Parse(portElement2.Value, CultureInfo.InvariantCulture);
                                                    inputEndpointInstance.Port = portInstance2;
                                                }
                                                
                                                XElement loadBalancerProbeElement = inputEndpointsElement.Element(XName.Get("LoadBalancerProbe", "http://schemas.microsoft.com/windowsazure"));
                                                if (loadBalancerProbeElement != null)
                                                {
                                                    LoadBalancerProbe loadBalancerProbeInstance = new LoadBalancerProbe();
                                                    inputEndpointInstance.LoadBalancerProbe = loadBalancerProbeInstance;
                                                    
                                                    XElement pathElement = loadBalancerProbeElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                                    if (pathElement != null)
                                                    {
                                                        string pathInstance = pathElement.Value;
                                                        loadBalancerProbeInstance.Path = pathInstance;
                                                    }
                                                    
                                                    XElement portElement3 = loadBalancerProbeElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                                    if (portElement3 != null)
                                                    {
                                                        int portInstance3 = int.Parse(portElement3.Value, CultureInfo.InvariantCulture);
                                                        loadBalancerProbeInstance.Port = portInstance3;
                                                    }
                                                    
                                                    XElement protocolElement2 = loadBalancerProbeElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                                    if (protocolElement2 != null)
                                                    {
                                                        LoadBalancerProbeTransportProtocol protocolInstance2 = ComputeManagementClient.ParseLoadBalancerProbeTransportProtocol(protocolElement2.Value);
                                                        loadBalancerProbeInstance.Protocol = protocolInstance2;
                                                    }
                                                    
                                                    XElement intervalInSecondsElement = loadBalancerProbeElement.Element(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                                    if (intervalInSecondsElement != null && string.IsNullOrEmpty(intervalInSecondsElement.Value) == false)
                                                    {
                                                        int intervalInSecondsInstance = int.Parse(intervalInSecondsElement.Value, CultureInfo.InvariantCulture);
                                                        loadBalancerProbeInstance.IntervalInSeconds = intervalInSecondsInstance;
                                                    }
                                                    
                                                    XElement timeoutInSecondsElement = loadBalancerProbeElement.Element(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                                    if (timeoutInSecondsElement != null && string.IsNullOrEmpty(timeoutInSecondsElement.Value) == false)
                                                    {
                                                        int timeoutInSecondsInstance = int.Parse(timeoutInSecondsElement.Value, CultureInfo.InvariantCulture);
                                                        loadBalancerProbeInstance.TimeoutInSeconds = timeoutInSecondsInstance;
                                                    }
                                                }
                                                
                                                XElement protocolElement3 = inputEndpointsElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                                if (protocolElement3 != null)
                                                {
                                                    string protocolInstance3 = protocolElement3.Value;
                                                    inputEndpointInstance.Protocol = protocolInstance3;
                                                }
                                                
                                                XElement vipElement2 = inputEndpointsElement.Element(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                                                if (vipElement2 != null)
                                                {
                                                    string vipInstance2 = vipElement2.Value;
                                                    inputEndpointInstance.VirtualIPAddress = vipInstance2;
                                                }
                                                
                                                XElement enableDirectServerReturnElement = inputEndpointsElement.Element(XName.Get("EnableDirectServerReturn", "http://schemas.microsoft.com/windowsazure"));
                                                if (enableDirectServerReturnElement != null && string.IsNullOrEmpty(enableDirectServerReturnElement.Value) == false)
                                                {
                                                    bool enableDirectServerReturnInstance = bool.Parse(enableDirectServerReturnElement.Value);
                                                    inputEndpointInstance.EnableDirectServerReturn = enableDirectServerReturnInstance;
                                                }
                                                
                                                XElement accessControlListElement = inputEndpointsElement.Element(XName.Get("AccessControlList", "http://schemas.microsoft.com/windowsazure"));
                                                if (accessControlListElement != null)
                                                {
                                                    AccessControlList accessControlListInstance = new AccessControlList();
                                                    inputEndpointInstance.AccessControlList = accessControlListInstance;
                                                    
                                                    XElement rulesSequenceElement = accessControlListElement.Element(XName.Get("Rules", "http://schemas.microsoft.com/windowsazure"));
                                                    if (rulesSequenceElement != null)
                                                    {
                                                        foreach (XElement rulesElement in rulesSequenceElement.Elements(XName.Get("Rule", "http://schemas.microsoft.com/windowsazure")))
                                                        {
                                                            AccessControlListRule ruleInstance = new AccessControlListRule();
                                                            accessControlListInstance.Rules.Add(ruleInstance);
                                                            
                                                            XElement orderElement = rulesElement.Element(XName.Get("Order", "http://schemas.microsoft.com/windowsazure"));
                                                            if (orderElement != null && string.IsNullOrEmpty(orderElement.Value) == false)
                                                            {
                                                                int orderInstance = int.Parse(orderElement.Value, CultureInfo.InvariantCulture);
                                                                ruleInstance.Order = orderInstance;
                                                            }
                                                            
                                                            XElement actionElement = rulesElement.Element(XName.Get("Action", "http://schemas.microsoft.com/windowsazure"));
                                                            if (actionElement != null)
                                                            {
                                                                string actionInstance = actionElement.Value;
                                                                ruleInstance.Action = actionInstance;
                                                            }
                                                            
                                                            XElement remoteSubnetElement = rulesElement.Element(XName.Get("RemoteSubnet", "http://schemas.microsoft.com/windowsazure"));
                                                            if (remoteSubnetElement != null)
                                                            {
                                                                string remoteSubnetInstance = remoteSubnetElement.Value;
                                                                ruleInstance.RemoteSubnet = remoteSubnetInstance;
                                                            }
                                                            
                                                            XElement descriptionElement = rulesElement.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                                                            if (descriptionElement != null)
                                                            {
                                                                string descriptionInstance = descriptionElement.Value;
                                                                ruleInstance.Description = descriptionInstance;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        
                                        XElement subnetNamesSequenceElement = configurationSetsElement.Element(XName.Get("SubnetNames", "http://schemas.microsoft.com/windowsazure"));
                                        if (subnetNamesSequenceElement != null)
                                        {
                                            foreach (XElement subnetNamesElement in subnetNamesSequenceElement.Elements(XName.Get("SubnetName", "http://schemas.microsoft.com/windowsazure")))
                                            {
                                                configurationSetInstance.SubnetNames.Add(subnetNamesElement.Value);
                                            }
                                        }
                                        
                                        XElement computerNameElement = configurationSetsElement.Element(XName.Get("ComputerName", "http://schemas.microsoft.com/windowsazure"));
                                        if (computerNameElement != null)
                                        {
                                            string computerNameInstance = computerNameElement.Value;
                                            configurationSetInstance.ComputerName = computerNameInstance;
                                        }
                                        
                                        XElement adminPasswordElement = configurationSetsElement.Element(XName.Get("AdminPassword", "http://schemas.microsoft.com/windowsazure"));
                                        if (adminPasswordElement != null)
                                        {
                                            string adminPasswordInstance = adminPasswordElement.Value;
                                            configurationSetInstance.AdminPassword = adminPasswordInstance;
                                        }
                                        
                                        XElement resetPasswordOnFirstLogonElement = configurationSetsElement.Element(XName.Get("ResetPasswordOnFirstLogon", "http://schemas.microsoft.com/windowsazure"));
                                        if (resetPasswordOnFirstLogonElement != null && string.IsNullOrEmpty(resetPasswordOnFirstLogonElement.Value) == false)
                                        {
                                            bool resetPasswordOnFirstLogonInstance = bool.Parse(resetPasswordOnFirstLogonElement.Value);
                                            configurationSetInstance.ResetPasswordOnFirstLogon = resetPasswordOnFirstLogonInstance;
                                        }
                                        
                                        XElement enableAutomaticUpdatesElement = configurationSetsElement.Element(XName.Get("EnableAutomaticUpdates", "http://schemas.microsoft.com/windowsazure"));
                                        if (enableAutomaticUpdatesElement != null && string.IsNullOrEmpty(enableAutomaticUpdatesElement.Value) == false)
                                        {
                                            bool enableAutomaticUpdatesInstance = bool.Parse(enableAutomaticUpdatesElement.Value);
                                            configurationSetInstance.EnableAutomaticUpdates = enableAutomaticUpdatesInstance;
                                        }
                                        
                                        XElement timeZoneElement = configurationSetsElement.Element(XName.Get("TimeZone", "http://schemas.microsoft.com/windowsazure"));
                                        if (timeZoneElement != null)
                                        {
                                            string timeZoneInstance = timeZoneElement.Value;
                                            configurationSetInstance.TimeZone = timeZoneInstance;
                                        }
                                        
                                        XElement domainJoinElement = configurationSetsElement.Element(XName.Get("DomainJoin", "http://schemas.microsoft.com/windowsazure"));
                                        if (domainJoinElement != null)
                                        {
                                            DomainJoinSettings domainJoinInstance = new DomainJoinSettings();
                                            configurationSetInstance.DomainJoin = domainJoinInstance;
                                            
                                            XElement credentialsElement = domainJoinElement.Element(XName.Get("Credentials", "http://schemas.microsoft.com/windowsazure"));
                                            if (credentialsElement != null)
                                            {
                                                DomainJoinCredentials credentialsInstance = new DomainJoinCredentials();
                                                domainJoinInstance.Credentials = credentialsInstance;
                                                
                                                XElement domainElement = credentialsElement.Element(XName.Get("Domain", "http://schemas.microsoft.com/windowsazure"));
                                                if (domainElement != null)
                                                {
                                                    string domainInstance = domainElement.Value;
                                                    credentialsInstance.Domain = domainInstance;
                                                }
                                                
                                                XElement usernameElement = credentialsElement.Element(XName.Get("Username", "http://schemas.microsoft.com/windowsazure"));
                                                if (usernameElement != null)
                                                {
                                                    string usernameInstance = usernameElement.Value;
                                                    credentialsInstance.UserName = usernameInstance;
                                                }
                                                
                                                XElement passwordElement = credentialsElement.Element(XName.Get("Password", "http://schemas.microsoft.com/windowsazure"));
                                                if (passwordElement != null)
                                                {
                                                    string passwordInstance = passwordElement.Value;
                                                    credentialsInstance.Password = passwordInstance;
                                                }
                                            }
                                            
                                            XElement joinDomainElement = domainJoinElement.Element(XName.Get("JoinDomain", "http://schemas.microsoft.com/windowsazure"));
                                            if (joinDomainElement != null)
                                            {
                                                string joinDomainInstance = joinDomainElement.Value;
                                                domainJoinInstance.DomainToJoin = joinDomainInstance;
                                            }
                                            
                                            XElement machineObjectOUElement = domainJoinElement.Element(XName.Get("MachineObjectOU", "http://schemas.microsoft.com/windowsazure"));
                                            if (machineObjectOUElement != null)
                                            {
                                                string machineObjectOUInstance = machineObjectOUElement.Value;
                                                domainJoinInstance.LdapMachineObjectOU = machineObjectOUInstance;
                                            }
                                            
                                            XElement provisioningElement = domainJoinElement.Element(XName.Get("Provisioning", "http://schemas.microsoft.com/windowsazure"));
                                            if (provisioningElement != null)
                                            {
                                                DomainJoinProvisioning provisioningInstance = new DomainJoinProvisioning();
                                                domainJoinInstance.Provisioning = provisioningInstance;
                                                
                                                XElement accountDataElement = provisioningElement.Element(XName.Get("AccountData", "http://schemas.microsoft.com/windowsazure"));
                                                if (accountDataElement != null)
                                                {
                                                    string accountDataInstance = accountDataElement.Value;
                                                    provisioningInstance.AccountData = accountDataInstance;
                                                }
                                            }
                                        }
                                        
                                        XElement storedCertificateSettingsSequenceElement = configurationSetsElement.Element(XName.Get("StoredCertificateSettings", "http://schemas.microsoft.com/windowsazure"));
                                        if (storedCertificateSettingsSequenceElement != null)
                                        {
                                            foreach (XElement storedCertificateSettingsElement in storedCertificateSettingsSequenceElement.Elements(XName.Get("CertificateSetting", "http://schemas.microsoft.com/windowsazure")))
                                            {
                                                StoredCertificateSettings certificateSettingInstance = new StoredCertificateSettings();
                                                configurationSetInstance.StoredCertificateSettings.Add(certificateSettingInstance);
                                                
                                                XElement storeLocationElement = storedCertificateSettingsElement.Element(XName.Get("StoreLocation", "http://schemas.microsoft.com/windowsazure"));
                                                if (storeLocationElement != null)
                                                {
                                                }
                                                
                                                XElement storeNameElement = storedCertificateSettingsElement.Element(XName.Get("StoreName", "http://schemas.microsoft.com/windowsazure"));
                                                if (storeNameElement != null)
                                                {
                                                    string storeNameInstance = storeNameElement.Value;
                                                    certificateSettingInstance.StoreName = storeNameInstance;
                                                }
                                                
                                                XElement thumbprintElement = storedCertificateSettingsElement.Element(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                                                if (thumbprintElement != null)
                                                {
                                                    string thumbprintInstance = thumbprintElement.Value;
                                                    certificateSettingInstance.Thumbprint = thumbprintInstance;
                                                }
                                            }
                                        }
                                        
                                        XElement winRMElement = configurationSetsElement.Element(XName.Get("WinRM", "http://schemas.microsoft.com/windowsazure"));
                                        if (winRMElement != null)
                                        {
                                            WindowsRemoteManagementSettings winRMInstance = new WindowsRemoteManagementSettings();
                                            configurationSetInstance.WindowsRemoteManagement = winRMInstance;
                                            
                                            XElement listenersSequenceElement = winRMElement.Element(XName.Get("Listeners", "http://schemas.microsoft.com/windowsazure"));
                                            if (listenersSequenceElement != null)
                                            {
                                                foreach (XElement listenersElement in listenersSequenceElement.Elements(XName.Get("Listener", "http://schemas.microsoft.com/windowsazure")))
                                                {
                                                    WindowsRemoteManagementListener listenerInstance = new WindowsRemoteManagementListener();
                                                    winRMInstance.Listeners.Add(listenerInstance);
                                                    
                                                    XElement protocolElement4 = listenersElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                                    if (protocolElement4 != null)
                                                    {
                                                        VirtualMachineWindowsRemoteManagementListenerType protocolInstance4 = (VirtualMachineWindowsRemoteManagementListenerType)Enum.Parse(typeof(VirtualMachineWindowsRemoteManagementListenerType), protocolElement4.Value, false);
                                                        listenerInstance.ListenerType = protocolInstance4;
                                                    }
                                                    
                                                    XElement certificateThumbprintElement = listenersElement.Element(XName.Get("CertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                                    if (certificateThumbprintElement != null)
                                                    {
                                                        string certificateThumbprintInstance = certificateThumbprintElement.Value;
                                                        listenerInstance.CertificateThumbprint = certificateThumbprintInstance;
                                                    }
                                                }
                                            }
                                        }
                                        
                                        XElement adminUsernameElement = configurationSetsElement.Element(XName.Get("AdminUsername", "http://schemas.microsoft.com/windowsazure"));
                                        if (adminUsernameElement != null)
                                        {
                                            string adminUsernameInstance = adminUsernameElement.Value;
                                            configurationSetInstance.AdminUserName = adminUsernameInstance;
                                        }
                                        
                                        XElement hostNameElement2 = configurationSetsElement.Element(XName.Get("HostName", "http://schemas.microsoft.com/windowsazure"));
                                        if (hostNameElement2 != null)
                                        {
                                            string hostNameInstance2 = hostNameElement2.Value;
                                            configurationSetInstance.HostName = hostNameInstance2;
                                        }
                                        
                                        XElement userNameElement = configurationSetsElement.Element(XName.Get("UserName", "http://schemas.microsoft.com/windowsazure"));
                                        if (userNameElement != null)
                                        {
                                            string userNameInstance = userNameElement.Value;
                                            configurationSetInstance.UserName = userNameInstance;
                                        }
                                        
                                        XElement userPasswordElement = configurationSetsElement.Element(XName.Get("UserPassword", "http://schemas.microsoft.com/windowsazure"));
                                        if (userPasswordElement != null)
                                        {
                                            string userPasswordInstance = userPasswordElement.Value;
                                            configurationSetInstance.UserPassword = userPasswordInstance;
                                        }
                                        
                                        XElement disableSshPasswordAuthenticationElement = configurationSetsElement.Element(XName.Get("DisableSshPasswordAuthentication", "http://schemas.microsoft.com/windowsazure"));
                                        if (disableSshPasswordAuthenticationElement != null && string.IsNullOrEmpty(disableSshPasswordAuthenticationElement.Value) == false)
                                        {
                                            bool disableSshPasswordAuthenticationInstance = bool.Parse(disableSshPasswordAuthenticationElement.Value);
                                            configurationSetInstance.DisableSshPasswordAuthentication = disableSshPasswordAuthenticationInstance;
                                        }
                                        
                                        XElement sSHElement = configurationSetsElement.Element(XName.Get("SSH", "http://schemas.microsoft.com/windowsazure"));
                                        if (sSHElement != null)
                                        {
                                            SshSettings sSHInstance = new SshSettings();
                                            configurationSetInstance.SshSettings = sSHInstance;
                                            
                                            XElement publicKeysSequenceElement = sSHElement.Element(XName.Get("PublicKeys", "http://schemas.microsoft.com/windowsazure"));
                                            if (publicKeysSequenceElement != null)
                                            {
                                                foreach (XElement publicKeysElement in publicKeysSequenceElement.Elements(XName.Get("PublicKey", "http://schemas.microsoft.com/windowsazure")))
                                                {
                                                    SshSettingPublicKey publicKeyInstance = new SshSettingPublicKey();
                                                    sSHInstance.PublicKeys.Add(publicKeyInstance);
                                                    
                                                    XElement fingerPrintElement = publicKeysElement.Element(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                                    if (fingerPrintElement != null)
                                                    {
                                                        string fingerPrintInstance = fingerPrintElement.Value;
                                                        publicKeyInstance.Fingerprint = fingerPrintInstance;
                                                    }
                                                    
                                                    XElement pathElement2 = publicKeysElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                                    if (pathElement2 != null)
                                                    {
                                                        string pathInstance2 = pathElement2.Value;
                                                        publicKeyInstance.Path = pathInstance2;
                                                    }
                                                }
                                            }
                                            
                                            XElement keyPairsSequenceElement = sSHElement.Element(XName.Get("KeyPairs", "http://schemas.microsoft.com/windowsazure"));
                                            if (keyPairsSequenceElement != null)
                                            {
                                                foreach (XElement keyPairsElement in keyPairsSequenceElement.Elements(XName.Get("KeyPair", "http://schemas.microsoft.com/windowsazure")))
                                                {
                                                    SshSettingKeyPair keyPairInstance = new SshSettingKeyPair();
                                                    sSHInstance.KeyPairs.Add(keyPairInstance);
                                                    
                                                    XElement fingerPrintElement2 = keyPairsElement.Element(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                                    if (fingerPrintElement2 != null)
                                                    {
                                                        string fingerPrintInstance2 = fingerPrintElement2.Value;
                                                        keyPairInstance.Fingerprint = fingerPrintInstance2;
                                                    }
                                                    
                                                    XElement pathElement3 = keyPairsElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                                    if (pathElement3 != null)
                                                    {
                                                        string pathInstance3 = pathElement3.Value;
                                                        keyPairInstance.Path = pathInstance3;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                XElement availabilitySetNameElement = roleListElement.Element(XName.Get("AvailabilitySetName", "http://schemas.microsoft.com/windowsazure"));
                                if (availabilitySetNameElement != null)
                                {
                                    string availabilitySetNameInstance = availabilitySetNameElement.Value;
                                    roleInstance.AvailabilitySetName = availabilitySetNameInstance;
                                }
                                
                                XElement dataVirtualHardDisksSequenceElement = roleListElement.Element(XName.Get("DataVirtualHardDisks", "http://schemas.microsoft.com/windowsazure"));
                                if (dataVirtualHardDisksSequenceElement != null)
                                {
                                    foreach (XElement dataVirtualHardDisksElement in dataVirtualHardDisksSequenceElement.Elements(XName.Get("DataVirtualHardDisk", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        DataVirtualHardDisk dataVirtualHardDiskInstance = new DataVirtualHardDisk();
                                        roleInstance.DataVirtualHardDisks.Add(dataVirtualHardDiskInstance);
                                        
                                        XElement hostCachingElement = dataVirtualHardDisksElement.Element(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                                        if (hostCachingElement != null && string.IsNullOrEmpty(hostCachingElement.Value) == false)
                                        {
                                            VirtualHardDiskHostCaching hostCachingInstance = (VirtualHardDiskHostCaching)Enum.Parse(typeof(VirtualHardDiskHostCaching), hostCachingElement.Value, false);
                                            dataVirtualHardDiskInstance.HostCaching = hostCachingInstance;
                                        }
                                        
                                        XElement diskLabelElement = dataVirtualHardDisksElement.Element(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                                        if (diskLabelElement != null)
                                        {
                                            string diskLabelInstance = diskLabelElement.Value;
                                            dataVirtualHardDiskInstance.DiskLabel = diskLabelInstance;
                                        }
                                        
                                        XElement diskNameElement = dataVirtualHardDisksElement.Element(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                                        if (diskNameElement != null)
                                        {
                                            string diskNameInstance = diskNameElement.Value;
                                            dataVirtualHardDiskInstance.DiskName = diskNameInstance;
                                        }
                                        
                                        XElement lunElement = dataVirtualHardDisksElement.Element(XName.Get("Lun", "http://schemas.microsoft.com/windowsazure"));
                                        if (lunElement != null && string.IsNullOrEmpty(lunElement.Value) == false)
                                        {
                                            int lunInstance = int.Parse(lunElement.Value, CultureInfo.InvariantCulture);
                                            dataVirtualHardDiskInstance.LogicalUnitNumber = lunInstance;
                                        }
                                        
                                        XElement logicalDiskSizeInGBElement = dataVirtualHardDisksElement.Element(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                                        if (logicalDiskSizeInGBElement != null)
                                        {
                                            int logicalDiskSizeInGBInstance = int.Parse(logicalDiskSizeInGBElement.Value, CultureInfo.InvariantCulture);
                                            dataVirtualHardDiskInstance.LogicalDiskSizeInGB = logicalDiskSizeInGBInstance;
                                        }
                                        
                                        XElement mediaLinkElement = dataVirtualHardDisksElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                                        if (mediaLinkElement != null)
                                        {
                                            Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement.Value);
                                            dataVirtualHardDiskInstance.MediaLink = mediaLinkInstance;
                                        }
                                    }
                                }
                                
                                XElement labelElement2 = roleListElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                                if (labelElement2 != null)
                                {
                                    string labelInstance2 = labelElement2.Value;
                                    roleInstance.Label = labelInstance2;
                                }
                                
                                XElement oSVirtualHardDiskElement = roleListElement.Element(XName.Get("OSVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                                if (oSVirtualHardDiskElement != null)
                                {
                                    OSVirtualHardDisk oSVirtualHardDiskInstance = new OSVirtualHardDisk();
                                    roleInstance.OSVirtualHardDisk = oSVirtualHardDiskInstance;
                                    
                                    XElement hostCachingElement2 = oSVirtualHardDiskElement.Element(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                                    if (hostCachingElement2 != null && string.IsNullOrEmpty(hostCachingElement2.Value) == false)
                                    {
                                        VirtualHardDiskHostCaching hostCachingInstance2 = (VirtualHardDiskHostCaching)Enum.Parse(typeof(VirtualHardDiskHostCaching), hostCachingElement2.Value, false);
                                        oSVirtualHardDiskInstance.HostCaching = hostCachingInstance2;
                                    }
                                    
                                    XElement diskLabelElement2 = oSVirtualHardDiskElement.Element(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                                    if (diskLabelElement2 != null)
                                    {
                                        string diskLabelInstance2 = diskLabelElement2.Value;
                                        oSVirtualHardDiskInstance.DiskLabel = diskLabelInstance2;
                                    }
                                    
                                    XElement diskNameElement2 = oSVirtualHardDiskElement.Element(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                                    if (diskNameElement2 != null)
                                    {
                                        string diskNameInstance2 = diskNameElement2.Value;
                                        oSVirtualHardDiskInstance.DiskName = diskNameInstance2;
                                    }
                                    
                                    XElement mediaLinkElement2 = oSVirtualHardDiskElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                                    if (mediaLinkElement2 != null)
                                    {
                                        Uri mediaLinkInstance2 = TypeConversion.TryParseUri(mediaLinkElement2.Value);
                                        oSVirtualHardDiskInstance.MediaLink = mediaLinkInstance2;
                                    }
                                    
                                    XElement sourceImageNameElement = oSVirtualHardDiskElement.Element(XName.Get("SourceImageName", "http://schemas.microsoft.com/windowsazure"));
                                    if (sourceImageNameElement != null)
                                    {
                                        string sourceImageNameInstance = sourceImageNameElement.Value;
                                        oSVirtualHardDiskInstance.SourceImageName = sourceImageNameInstance;
                                    }
                                    
                                    XElement osElement = oSVirtualHardDiskElement.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                                    if (osElement != null)
                                    {
                                        string osInstance = osElement.Value;
                                        oSVirtualHardDiskInstance.OperatingSystem = osInstance;
                                    }
                                }
                                
                                XElement roleSizeElement = roleListElement.Element(XName.Get("RoleSize", "http://schemas.microsoft.com/windowsazure"));
                                if (roleSizeElement != null && string.IsNullOrEmpty(roleSizeElement.Value) == false)
                                {
                                    VirtualMachineRoleSize roleSizeInstance = (VirtualMachineRoleSize)Enum.Parse(typeof(VirtualMachineRoleSize), roleSizeElement.Value, false);
                                    roleInstance.RoleSize = roleSizeInstance;
                                }
                                
                                XElement defaultWinRmCertificateThumbprintElement = roleListElement.Element(XName.Get("DefaultWinRmCertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                if (defaultWinRmCertificateThumbprintElement != null)
                                {
                                    string defaultWinRmCertificateThumbprintInstance = defaultWinRmCertificateThumbprintElement.Value;
                                    roleInstance.DefaultWinRmCertificateThumbprint = defaultWinRmCertificateThumbprintInstance;
                                }
                            }
                        }
                        
                        XElement sdkVersionElement = deploymentElement.Element(XName.Get("SdkVersion", "http://schemas.microsoft.com/windowsazure"));
                        if (sdkVersionElement != null)
                        {
                            string sdkVersionInstance = sdkVersionElement.Value;
                            result.SdkVersion = sdkVersionInstance;
                        }
                        
                        XElement lockedElement = deploymentElement.Element(XName.Get("Locked", "http://schemas.microsoft.com/windowsazure"));
                        if (lockedElement != null)
                        {
                            bool lockedInstance = bool.Parse(lockedElement.Value);
                            result.Locked = lockedInstance;
                        }
                        
                        XElement rollbackAllowedElement = deploymentElement.Element(XName.Get("RollbackAllowed", "http://schemas.microsoft.com/windowsazure"));
                        if (rollbackAllowedElement != null)
                        {
                            string rollbackAllowedInstance = rollbackAllowedElement.Value;
                            result.RollbackAllowed = rollbackAllowedInstance;
                        }
                        
                        XElement createdTimeElement = deploymentElement.Element(XName.Get("CreatedTime", "http://schemas.microsoft.com/windowsazure"));
                        if (createdTimeElement != null)
                        {
                            DateTime createdTimeInstance = DateTime.Parse(createdTimeElement.Value, CultureInfo.InvariantCulture);
                            result.CreatedTime = createdTimeInstance;
                        }
                        
                        XElement lastModifiedTimeElement = deploymentElement.Element(XName.Get("LastModifiedTime", "http://schemas.microsoft.com/windowsazure"));
                        if (lastModifiedTimeElement != null)
                        {
                            DateTime lastModifiedTimeInstance = DateTime.Parse(lastModifiedTimeElement.Value, CultureInfo.InvariantCulture);
                            result.LastModifiedTime = lastModifiedTimeInstance;
                        }
                        
                        XElement virtualNetworkNameElement = deploymentElement.Element(XName.Get("VirtualNetworkName", "http://schemas.microsoft.com/windowsazure"));
                        if (virtualNetworkNameElement != null)
                        {
                            string virtualNetworkNameInstance = virtualNetworkNameElement.Value;
                            result.VirtualNetworkName = virtualNetworkNameInstance;
                        }
                        
                        XElement extendedPropertiesSequenceElement = deploymentElement.Element(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                        if (extendedPropertiesSequenceElement != null)
                        {
                            foreach (XElement extendedPropertiesElement in extendedPropertiesSequenceElement.Elements(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure")))
                            {
                                string extendedPropertiesKey = extendedPropertiesElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure")).Value;
                                string extendedPropertiesValue = extendedPropertiesElement.Element(XName.Get("Value", "http://schemas.microsoft.com/windowsazure")).Value;
                                result.ExtendedProperties.Add(extendedPropertiesKey, extendedPropertiesValue);
                            }
                        }
                        
                        XElement persistentVMDowntimeElement = deploymentElement.Element(XName.Get("PersistentVMDowntime", "http://schemas.microsoft.com/windowsazure"));
                        if (persistentVMDowntimeElement != null)
                        {
                            PersistentVMDowntime persistentVMDowntimeInstance = new PersistentVMDowntime();
                            result.PersistentVMDowntime = persistentVMDowntimeInstance;
                            
                            XElement startTimeElement = persistentVMDowntimeElement.Element(XName.Get("StartTime", "http://schemas.microsoft.com/windowsazure"));
                            if (startTimeElement != null)
                            {
                                DateTime startTimeInstance = DateTime.Parse(startTimeElement.Value, CultureInfo.InvariantCulture);
                                persistentVMDowntimeInstance.StartTime = startTimeInstance;
                            }
                            
                            XElement endTimeElement = persistentVMDowntimeElement.Element(XName.Get("EndTime", "http://schemas.microsoft.com/windowsazure"));
                            if (endTimeElement != null)
                            {
                                DateTime endTimeInstance = DateTime.Parse(endTimeElement.Value, CultureInfo.InvariantCulture);
                                persistentVMDowntimeInstance.EndTime = endTimeInstance;
                            }
                            
                            XElement statusElement2 = persistentVMDowntimeElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                            if (statusElement2 != null)
                            {
                                string statusInstance2 = statusElement2.Value;
                                persistentVMDowntimeInstance.Status = statusInstance2;
                            }
                        }
                        
                        XElement virtualIPsSequenceElement = deploymentElement.Element(XName.Get("VirtualIPs", "http://schemas.microsoft.com/windowsazure"));
                        if (virtualIPsSequenceElement != null)
                        {
                            foreach (XElement virtualIPsElement in virtualIPsSequenceElement.Elements(XName.Get("VirtualIPAddress", "http://schemas.microsoft.com/windowsazure")))
                            {
                                VirtualIPAddress virtualIPAddressInstance = new VirtualIPAddress();
                                result.VirtualIPAddresses.Add(virtualIPAddressInstance);
                                
                                XElement addressElement = virtualIPsElement.Element(XName.Get("Address", "http://schemas.microsoft.com/windowsazure"));
                                if (addressElement != null)
                                {
                                    string addressInstance = addressElement.Value;
                                    virtualIPAddressInstance.Address = addressInstance;
                                }
                            }
                        }
                        
                        XElement dnsElement = deploymentElement.Element(XName.Get("Dns", "http://schemas.microsoft.com/windowsazure"));
                        if (dnsElement != null)
                        {
                            DnsSettings dnsInstance = new DnsSettings();
                            result.DnsSettings = dnsInstance;
                            
                            XElement dnsServersSequenceElement = dnsElement.Element(XName.Get("DnsServers", "http://schemas.microsoft.com/windowsazure"));
                            if (dnsServersSequenceElement != null)
                            {
                                foreach (XElement dnsServersElement in dnsServersSequenceElement.Elements(XName.Get("DnsServer", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    DnsServer dnsServerInstance = new DnsServer();
                                    dnsInstance.DnsServers.Add(dnsServerInstance);
                                    
                                    XElement nameElement4 = dnsServersElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                    if (nameElement4 != null)
                                    {
                                        string nameInstance4 = nameElement4.Value;
                                        dnsServerInstance.Name = nameInstance4;
                                    }
                                    
                                    XElement addressElement2 = dnsServersElement.Element(XName.Get("Address", "http://schemas.microsoft.com/windowsazure"));
                                    if (addressElement2 != null)
                                    {
                                        string addressInstance2 = addressElement2.Value;
                                        dnsServerInstance.Address = addressInstance2;
                                    }
                                }
                            }
                        }
                        
                        XElement extensionConfigurationElement = deploymentElement.Element(XName.Get("ExtensionConfiguration", "http://schemas.microsoft.com/windowsazure"));
                        if (extensionConfigurationElement != null)
                        {
                            ExtensionConfiguration extensionConfigurationInstance = new ExtensionConfiguration();
                            result.ExtensionConfiguration = extensionConfigurationInstance;
                            
                            XElement allRolesSequenceElement = extensionConfigurationElement.Element(XName.Get("AllRoles", "http://schemas.microsoft.com/windowsazure"));
                            if (allRolesSequenceElement != null)
                            {
                                foreach (XElement allRolesElement in allRolesSequenceElement.Elements(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    ExtensionConfiguration.Extension extensionInstance = new ExtensionConfiguration.Extension();
                                    extensionConfigurationInstance.AllRoles.Add(extensionInstance);
                                    
                                    XElement idElement = allRolesElement.Element(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                                    if (idElement != null)
                                    {
                                        string idInstance = idElement.Value;
                                        extensionInstance.Id = idInstance;
                                    }
                                }
                            }
                            
                            XElement namedRolesSequenceElement = extensionConfigurationElement.Element(XName.Get("NamedRoles", "http://schemas.microsoft.com/windowsazure"));
                            if (namedRolesSequenceElement != null)
                            {
                                foreach (XElement namedRolesElement in namedRolesSequenceElement.Elements(XName.Get("Role", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    ExtensionConfiguration.NamedRole roleInstance2 = new ExtensionConfiguration.NamedRole();
                                    extensionConfigurationInstance.NamedRoles.Add(roleInstance2);
                                    
                                    XElement roleNameElement3 = namedRolesElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                                    if (roleNameElement3 != null)
                                    {
                                        string roleNameInstance3 = roleNameElement3.Value;
                                        roleInstance2.RoleName = roleNameInstance3;
                                    }
                                    
                                    XElement extensionsSequenceElement = namedRolesElement.Element(XName.Get("Extensions", "http://schemas.microsoft.com/windowsazure"));
                                    if (extensionsSequenceElement != null)
                                    {
                                        foreach (XElement extensionsElement in extensionsSequenceElement.Elements(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure")))
                                        {
                                            ExtensionConfiguration.Extension extensionInstance2 = new ExtensionConfiguration.Extension();
                                            roleInstance2.Extensions.Add(extensionInstance2);
                                            
                                            XElement idElement2 = extensionsElement.Element(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                                            if (idElement2 != null)
                                            {
                                                string idInstance2 = idElement2.Value;
                                                extensionInstance2.Id = idInstance2;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get Package operation retrieves a cloud service package for a
        /// deployment and stores the package files in Windows Azure Blob
        /// storage.  The following package files are placed in storage:
        /// Service configuration file - The cloud service configuration file
        /// (.cscfg) provides configuration settings for the cloud service and
        /// individual roles, including the number of role instances.
        /// Service package - The service package (.cspkg) contains the
        /// application code and the service definition file.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154121.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Package operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> GetPackageByNameAsync(string serviceName, string deploymentName, DeploymentGetPackageParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.ContainerUri == null)
            {
                throw new ArgumentNullException("parameters.ContainerUri");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "GetPackageByNameAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/package?containerUri=" + parameters.ContainerUri + " +";
            if (parameters.OverwriteExisting != null)
            {
                url = url + "&overwriteExisting=" + Uri.EscapeUriString(parameters.OverwriteExisting.Value.ToString().ToLower());
            }
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get Package operation retrieves a cloud service package for a
        /// deployment and stores the package files in Windows Azure Blob
        /// storage.  The following package files are placed in storage:
        /// Service configuration file - The cloud service configuration file
        /// (.cscfg) provides configuration settings for the cloud service and
        /// individual roles, including the number of role instances.
        /// Service package - The service package (.cspkg) contains the
        /// application code and the service definition file.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154121.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Package operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> GetPackageBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentGetPackageParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.ContainerUri == null)
            {
                throw new ArgumentNullException("parameters.ContainerUri");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "GetPackageBySlotAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deploymentslots/" + deploymentSlot + "/package?containerUri=" + parameters.ContainerUri + " +";
            if (parameters.OverwriteExisting != null)
            {
                url = url + "&overwriteExisting=" + Uri.EscapeUriString(parameters.OverwriteExisting.Value.ToString().ToLower());
            }
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginRebootingRoleInstanceByDeploymentNameAsync(string serviceName, string deploymentName, string roleInstanceName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (roleInstanceName == null)
            {
                throw new ArgumentNullException("roleInstanceName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("roleInstanceName", roleInstanceName);
                Tracing.Enter(invocationId, this, "BeginRebootingRoleInstanceByDeploymentNameAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roleinstances/" + roleInstanceName + "?comp=reboot";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> RebootRoleInstanceByDeploymentNameAsync(string serviceName, string deploymentName, string roleInstanceName, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("roleInstanceName", roleInstanceName);
                Tracing.Enter(invocationId, this, "RebootRoleInstanceByDeploymentNameAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginRebootingRoleInstanceByDeploymentNameAsync(serviceName, deploymentName, roleInstanceName, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginRebootingRoleInstanceByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (roleInstanceName == null)
            {
                throw new ArgumentNullException("roleInstanceName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("roleInstanceName", roleInstanceName);
                Tracing.Enter(invocationId, this, "BeginRebootingRoleInstanceByDeploymentSlotAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deploymentslots/" + deploymentSlot + "/roleinstances/" + roleInstanceName + "?comp=reboot";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Reboot Role Instance operation requests a reboot of a role
        /// instance that is running in a deployment.  The Reboot Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441298.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> RebootRoleInstanceByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("roleInstanceName", roleInstanceName);
                Tracing.Enter(invocationId, this, "RebootRoleInstanceByDeploymentSlotAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginRebootingRoleInstanceByDeploymentSlotAsync(serviceName, deploymentSlot, roleInstanceName, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginReimagingRoleInstanceByDeploymentNameAsync(string serviceName, string deploymentName, string roleInstanceName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (roleInstanceName == null)
            {
                throw new ArgumentNullException("roleInstanceName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("roleInstanceName", roleInstanceName);
                Tracing.Enter(invocationId, this, "BeginReimagingRoleInstanceByDeploymentNameAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roleinstances/" + roleInstanceName + "?comp=reimage";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> ReimageRoleInstanceByDeploymentNameAsync(string serviceName, string deploymentName, string roleInstanceName, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("roleInstanceName", roleInstanceName);
                Tracing.Enter(invocationId, this, "ReimageRoleInstanceByDeploymentNameAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginReimagingRoleInstanceByDeploymentNameAsync(serviceName, deploymentName, roleInstanceName, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginReimagingRoleInstanceByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (roleInstanceName == null)
            {
                throw new ArgumentNullException("roleInstanceName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("roleInstanceName", roleInstanceName);
                Tracing.Enter(invocationId, this, "BeginReimagingRoleInstanceByDeploymentSlotAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deploymentslots/" + deploymentSlot + "/roleinstances/" + roleInstanceName + "?comp=reimage";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Reimage Role Instance operation requests a reimage of a role
        /// instance that is running in a deployment.  The Reimage Role
        /// Instance operation is an asynchronous operation. To determine
        /// whether the Management service has finished processing the
        /// request, call Get Operation Status. For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441292.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='roleInstanceName'>
        /// The name of your role instance.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> ReimageRoleInstanceByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, string roleInstanceName, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("roleInstanceName", roleInstanceName);
                Tracing.Enter(invocationId, this, "ReimageRoleInstanceByDeploymentSlotAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginReimagingRoleInstanceByDeploymentSlotAsync(serviceName, deploymentSlot, roleInstanceName, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Rollback Update Or Upgrade operation cancels an in-progress
        /// configuration update and returns the deployment to its state
        /// before the update was started.  The Rollback Update Or Upgrade
        /// operation can only be called when an update is in progress on the
        /// deployment. The deployment status can be detected by calling the
        /// Get Deployment operation or Get Hosted Service Properties
        /// operation and inspecting the RollbackAllowed element. If the value
        /// returned is true a rollback can be performed.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/hh403977.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Rollback Update Or Upgrade operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> RollbackUpdateOrUpgradeByDeploymentNameAsync(string serviceName, string deploymentName, DeploymentRollbackUpdateOrUpgradeParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "RollbackUpdateOrUpgradeByDeploymentNameAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "?comp=rollback";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement rollbackUpdateOrUpgradeElement = new XElement(XName.Get("RollbackUpdateOrUpgrade", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(rollbackUpdateOrUpgradeElement);
                
                XElement modeElement = new XElement(XName.Get("Mode", "http://schemas.microsoft.com/windowsazure"));
                modeElement.Value = ComputeManagementClient.RollbackUpdateOrUpgradeModeToString(parameters.Mode);
                rollbackUpdateOrUpgradeElement.Add(modeElement);
                
                XElement forceElement = new XElement(XName.Get("Force", "http://schemas.microsoft.com/windowsazure"));
                forceElement.Value = parameters.Force.ToString().ToLower();
                rollbackUpdateOrUpgradeElement.Add(forceElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Rollback Update Or Upgrade operation cancels an in-progress
        /// configuration update and returns the deployment to its state
        /// before the update was started.  The Rollback Update Or Upgrade
        /// operation can only be called when an update is in progress on the
        /// deployment. The deployment status can be detected by calling the
        /// Get Deployment operation or Get Hosted Service Properties
        /// operation and inspecting the RollbackAllowed element. If the value
        /// returned is true a rollback can be performed.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/hh403977.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Rollback Update Or Upgrade operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> RollbackUpdateOrUpgradeByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentRollbackUpdateOrUpgradeParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "RollbackUpdateOrUpgradeByDeploymentSlotAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deploymentslots/" + deploymentSlot + "?comp=rollback";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement rollbackUpdateOrUpgradeElement = new XElement(XName.Get("RollbackUpdateOrUpgrade", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(rollbackUpdateOrUpgradeElement);
                
                XElement modeElement = new XElement(XName.Get("Mode", "http://schemas.microsoft.com/windowsazure"));
                modeElement.Value = ComputeManagementClient.RollbackUpdateOrUpgradeModeToString(parameters.Mode);
                rollbackUpdateOrUpgradeElement.Add(modeElement);
                
                XElement forceElement = new XElement(XName.Get("Force", "http://schemas.microsoft.com/windowsazure"));
                forceElement.Value = parameters.Force.ToString().ToLower();
                rollbackUpdateOrUpgradeElement.Add(forceElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Swap Deployment operation initiates a virtual IP address swap
        /// between the staging and production deployment environments for a
        /// service. If the service is currently running in the staging
        /// environment, it will be swapped to the production environment. If
        /// it is running in the production environment, it will be swapped to
        /// staging. For more information on this type of upgrade, see
        /// Performing Virtual IP Swap Upgrades.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460814.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Swap Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginSwappingAsync(string serviceName, DeploymentSwapParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.SourceDeployment == null)
            {
                throw new ArgumentNullException("parameters.SourceDeployment");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginSwappingAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement swapElement = new XElement(XName.Get("Swap", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(swapElement);
                
                if (parameters.ProductionDeployment != null)
                {
                    XElement productionElement = new XElement(XName.Get("Production", "http://schemas.microsoft.com/windowsazure"));
                    productionElement.Value = parameters.ProductionDeployment;
                    swapElement.Add(productionElement);
                }
                
                XElement sourceDeploymentElement = new XElement(XName.Get("SourceDeployment", "http://schemas.microsoft.com/windowsazure"));
                sourceDeploymentElement.Value = parameters.SourceDeployment;
                swapElement.Add(sourceDeploymentElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Swap Deployment operation initiates a virtual IP address swap
        /// between the staging and production deployment environments for a
        /// service. If the service is currently running in the staging
        /// environment, it will be swapped to the production environment. If
        /// it is running in the production environment, it will be swapped to
        /// staging. For more information on this type of upgrade, see
        /// Performing Virtual IP Swap Upgrades.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460814.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Swap Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> SwapAsync(string serviceName, DeploymentSwapParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "SwapAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginSwappingAsync(serviceName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginUpdatingStatusByDeploymentNameAsync(string serviceName, string deploymentName, DeploymentUpdateStatusParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginUpdatingStatusByDeploymentNameAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/?comp=status";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement updateDeploymentStatusElement = new XElement(XName.Get("UpdateDeploymentStatus", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(updateDeploymentStatusElement);
                
                XElement statusElement = new XElement(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                statusElement.Value = parameters.Status.ToString();
                updateDeploymentStatusElement.Add(statusElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> UpdateStatusByDeploymentNameAsync(string serviceName, string deploymentName, DeploymentUpdateStatusParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "UpdateStatusByDeploymentNameAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginUpdatingStatusByDeploymentNameAsync(serviceName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginUpdatingStatusByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentUpdateStatusParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginUpdatingStatusByDeploymentSlotAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deploymentslots/" + deploymentSlot + "/?comp=status";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement updateDeploymentStatusElement = new XElement(XName.Get("UpdateDeploymentStatus", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(updateDeploymentStatusElement);
                
                XElement statusElement = new XElement(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                statusElement.Value = parameters.Status.ToString();
                updateDeploymentStatusElement.Add(statusElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Update Deployment Status operation initiates a change in the
        /// running status of a deployment. The status of a deployment can be
        /// running or suspended.  The Update Deployment Status operation is
        /// an asynchronous operation. To determine whether the Management
        /// service has finished processing the request, call Get Operation
        /// Status. For more information on asynchronous operations, see
        /// Tracking Asynchronous Service Management Requests.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460808.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to swap deployments for.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Deployment Status operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> UpdateStatusByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentUpdateStatusParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "UpdateStatusByDeploymentSlotAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginUpdatingStatusByDeploymentSlotAsync(serviceName, deploymentSlot, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.  To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginUpgradingBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentUpgradeParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.PackageUri == null)
            {
                throw new ArgumentNullException("parameters.PackageUri");
            }
            if (parameters.Configuration == null)
            {
                throw new ArgumentNullException("parameters.Configuration");
            }
            if (parameters.Label == null)
            {
                throw new ArgumentNullException("parameters.Label");
            }
            if (parameters.Label.Length > 100)
            {
                throw new ArgumentOutOfRangeException("parameters.Label");
            }
            if (parameters.ExtensionConfiguration != null)
            {
                foreach (ExtensionConfiguration.Extension allRolesParameterItem in parameters.ExtensionConfiguration.AllRoles)
                {
                    if (allRolesParameterItem.Id == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.AllRoles.Id");
                    }
                }
                foreach (ExtensionConfiguration.NamedRole namedRolesParameterItem in parameters.ExtensionConfiguration.NamedRoles)
                {
                    if (namedRolesParameterItem.RoleName == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.RoleName");
                    }
                    if (namedRolesParameterItem.Extensions == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.Extensions");
                    }
                    foreach (ExtensionConfiguration.Extension extensionsParameterItem in namedRolesParameterItem.Extensions)
                    {
                        if (extensionsParameterItem.Id == null)
                        {
                            throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.Extensions.Id");
                        }
                    }
                }
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginUpgradingBySlotAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deploymentslots/" + deploymentSlot + "/?comp=upgrade";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement upgradeDeploymentElement = new XElement(XName.Get("UpgradeDeployment", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(upgradeDeploymentElement);
                
                XElement modeElement = new XElement(XName.Get("Mode", "http://schemas.microsoft.com/windowsazure"));
                modeElement.Value = parameters.Mode.ToString();
                upgradeDeploymentElement.Add(modeElement);
                
                XElement packageUrlElement = new XElement(XName.Get("PackageUrl", "http://schemas.microsoft.com/windowsazure"));
                packageUrlElement.Value = parameters.PackageUri.ToString();
                upgradeDeploymentElement.Add(packageUrlElement);
                
                XElement configurationElement = new XElement(XName.Get("Configuration", "http://schemas.microsoft.com/windowsazure"));
                configurationElement.Value = TypeConversion.ToBase64String(parameters.Configuration);
                upgradeDeploymentElement.Add(configurationElement);
                
                XElement labelElement = new XElement(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                labelElement.Value = TypeConversion.ToBase64String(parameters.Label);
                upgradeDeploymentElement.Add(labelElement);
                
                if (parameters.RoleToUpgrade != null)
                {
                    XElement roleToUpgradeElement = new XElement(XName.Get("RoleToUpgrade", "http://schemas.microsoft.com/windowsazure"));
                    roleToUpgradeElement.Value = parameters.RoleToUpgrade;
                    upgradeDeploymentElement.Add(roleToUpgradeElement);
                }
                
                XElement forceElement = new XElement(XName.Get("Force", "http://schemas.microsoft.com/windowsazure"));
                forceElement.Value = parameters.Force.ToString().ToLower();
                upgradeDeploymentElement.Add(forceElement);
                
                if (parameters.ExtendedProperties != null)
                {
                    XElement extendedPropertiesDictionaryElement = new XElement(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                    foreach (KeyValuePair<string, string> pair in parameters.ExtendedProperties)
                    {
                        string extendedPropertiesKey = pair.Key;
                        string extendedPropertiesValue = pair.Value;
                        XElement extendedPropertiesElement = new XElement(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesDictionaryElement.Add(extendedPropertiesElement);
                        
                        XElement extendedPropertiesKeyElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesKeyElement.Value = extendedPropertiesKey;
                        extendedPropertiesElement.Add(extendedPropertiesKeyElement);
                        
                        XElement extendedPropertiesValueElement = new XElement(XName.Get("Value", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesValueElement.Value = extendedPropertiesValue;
                        extendedPropertiesElement.Add(extendedPropertiesValueElement);
                    }
                    upgradeDeploymentElement.Add(extendedPropertiesDictionaryElement);
                }
                
                if (parameters.ExtensionConfiguration != null)
                {
                    XElement extensionConfigurationElement = new XElement(XName.Get("ExtensionConfiguration", "http://schemas.microsoft.com/windowsazure"));
                    upgradeDeploymentElement.Add(extensionConfigurationElement);
                    
                    if (parameters.ExtensionConfiguration.AllRoles != null)
                    {
                        XElement allRolesSequenceElement = new XElement(XName.Get("AllRoles", "http://schemas.microsoft.com/windowsazure"));
                        foreach (ExtensionConfiguration.Extension allRolesItem in parameters.ExtensionConfiguration.AllRoles)
                        {
                            XElement extensionElement = new XElement(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                            allRolesSequenceElement.Add(extensionElement);
                            
                            XElement idElement = new XElement(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                            idElement.Value = allRolesItem.Id;
                            extensionElement.Add(idElement);
                        }
                        extensionConfigurationElement.Add(allRolesSequenceElement);
                    }
                    
                    if (parameters.ExtensionConfiguration.NamedRoles != null)
                    {
                        XElement namedRolesSequenceElement = new XElement(XName.Get("NamedRoles", "http://schemas.microsoft.com/windowsazure"));
                        foreach (ExtensionConfiguration.NamedRole namedRolesItem in parameters.ExtensionConfiguration.NamedRoles)
                        {
                            XElement roleElement = new XElement(XName.Get("Role", "http://schemas.microsoft.com/windowsazure"));
                            namedRolesSequenceElement.Add(roleElement);
                            
                            XElement roleNameElement = new XElement(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                            roleNameElement.Value = namedRolesItem.RoleName;
                            roleElement.Add(roleNameElement);
                            
                            XElement extensionsSequenceElement = new XElement(XName.Get("Extensions", "http://schemas.microsoft.com/windowsazure"));
                            foreach (ExtensionConfiguration.Extension extensionsItem in namedRolesItem.Extensions)
                            {
                                XElement extensionElement2 = new XElement(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                                extensionsSequenceElement.Add(extensionElement2);
                                
                                XElement idElement2 = new XElement(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                                idElement2.Value = extensionsItem.Id;
                                extensionElement2.Add(idElement2);
                            }
                            roleElement.Add(extensionsSequenceElement);
                        }
                        extensionConfigurationElement.Add(namedRolesSequenceElement);
                    }
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The slot to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> UpgradeBySlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentUpgradeParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "UpgradeBySlotAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginUpgradingBySlotAsync(serviceName, deploymentSlot, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginUpgradingByNameAsync(string serviceName, string deploymentName, DeploymentUpgradeParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.PackageUri == null)
            {
                throw new ArgumentNullException("parameters.PackageUri");
            }
            if (parameters.Configuration == null)
            {
                throw new ArgumentNullException("parameters.Configuration");
            }
            if (parameters.Label == null)
            {
                throw new ArgumentNullException("parameters.Label");
            }
            if (parameters.Label.Length > 100)
            {
                throw new ArgumentOutOfRangeException("parameters.Label");
            }
            if (parameters.ExtensionConfiguration != null)
            {
                foreach (ExtensionConfiguration.Extension allRolesParameterItem in parameters.ExtensionConfiguration.AllRoles)
                {
                    if (allRolesParameterItem.Id == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.AllRoles.Id");
                    }
                }
                foreach (ExtensionConfiguration.NamedRole namedRolesParameterItem in parameters.ExtensionConfiguration.NamedRoles)
                {
                    if (namedRolesParameterItem.RoleName == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.RoleName");
                    }
                    if (namedRolesParameterItem.Extensions == null)
                    {
                        throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.Extensions");
                    }
                    foreach (ExtensionConfiguration.Extension extensionsParameterItem in namedRolesParameterItem.Extensions)
                    {
                        if (extensionsParameterItem.Id == null)
                        {
                            throw new ArgumentNullException("parameters.ExtensionConfiguration.NamedRoles.Extensions.Id");
                        }
                    }
                }
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginUpgradingByNameAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/?comp=upgrade";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement upgradeDeploymentElement = new XElement(XName.Get("UpgradeDeployment", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(upgradeDeploymentElement);
                
                XElement modeElement = new XElement(XName.Get("Mode", "http://schemas.microsoft.com/windowsazure"));
                modeElement.Value = parameters.Mode.ToString();
                upgradeDeploymentElement.Add(modeElement);
                
                XElement packageUrlElement = new XElement(XName.Get("PackageUrl", "http://schemas.microsoft.com/windowsazure"));
                packageUrlElement.Value = parameters.PackageUri.ToString();
                upgradeDeploymentElement.Add(packageUrlElement);
                
                XElement configurationElement = new XElement(XName.Get("Configuration", "http://schemas.microsoft.com/windowsazure"));
                configurationElement.Value = TypeConversion.ToBase64String(parameters.Configuration);
                upgradeDeploymentElement.Add(configurationElement);
                
                XElement labelElement = new XElement(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                labelElement.Value = TypeConversion.ToBase64String(parameters.Label);
                upgradeDeploymentElement.Add(labelElement);
                
                if (parameters.RoleToUpgrade != null)
                {
                    XElement roleToUpgradeElement = new XElement(XName.Get("RoleToUpgrade", "http://schemas.microsoft.com/windowsazure"));
                    roleToUpgradeElement.Value = parameters.RoleToUpgrade;
                    upgradeDeploymentElement.Add(roleToUpgradeElement);
                }
                
                XElement forceElement = new XElement(XName.Get("Force", "http://schemas.microsoft.com/windowsazure"));
                forceElement.Value = parameters.Force.ToString().ToLower();
                upgradeDeploymentElement.Add(forceElement);
                
                if (parameters.ExtendedProperties != null)
                {
                    XElement extendedPropertiesDictionaryElement = new XElement(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                    foreach (KeyValuePair<string, string> pair in parameters.ExtendedProperties)
                    {
                        string extendedPropertiesKey = pair.Key;
                        string extendedPropertiesValue = pair.Value;
                        XElement extendedPropertiesElement = new XElement(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesDictionaryElement.Add(extendedPropertiesElement);
                        
                        XElement extendedPropertiesKeyElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesKeyElement.Value = extendedPropertiesKey;
                        extendedPropertiesElement.Add(extendedPropertiesKeyElement);
                        
                        XElement extendedPropertiesValueElement = new XElement(XName.Get("Value", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesValueElement.Value = extendedPropertiesValue;
                        extendedPropertiesElement.Add(extendedPropertiesValueElement);
                    }
                    upgradeDeploymentElement.Add(extendedPropertiesDictionaryElement);
                }
                
                if (parameters.ExtensionConfiguration != null)
                {
                    XElement extensionConfigurationElement = new XElement(XName.Get("ExtensionConfiguration", "http://schemas.microsoft.com/windowsazure"));
                    upgradeDeploymentElement.Add(extensionConfigurationElement);
                    
                    if (parameters.ExtensionConfiguration.AllRoles != null)
                    {
                        XElement allRolesSequenceElement = new XElement(XName.Get("AllRoles", "http://schemas.microsoft.com/windowsazure"));
                        foreach (ExtensionConfiguration.Extension allRolesItem in parameters.ExtensionConfiguration.AllRoles)
                        {
                            XElement extensionElement = new XElement(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                            allRolesSequenceElement.Add(extensionElement);
                            
                            XElement idElement = new XElement(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                            idElement.Value = allRolesItem.Id;
                            extensionElement.Add(idElement);
                        }
                        extensionConfigurationElement.Add(allRolesSequenceElement);
                    }
                    
                    if (parameters.ExtensionConfiguration.NamedRoles != null)
                    {
                        XElement namedRolesSequenceElement = new XElement(XName.Get("NamedRoles", "http://schemas.microsoft.com/windowsazure"));
                        foreach (ExtensionConfiguration.NamedRole namedRolesItem in parameters.ExtensionConfiguration.NamedRoles)
                        {
                            XElement roleElement = new XElement(XName.Get("Role", "http://schemas.microsoft.com/windowsazure"));
                            namedRolesSequenceElement.Add(roleElement);
                            
                            XElement roleNameElement = new XElement(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                            roleNameElement.Value = namedRolesItem.RoleName;
                            roleElement.Add(roleNameElement);
                            
                            XElement extensionsSequenceElement = new XElement(XName.Get("Extensions", "http://schemas.microsoft.com/windowsazure"));
                            foreach (ExtensionConfiguration.Extension extensionsItem in namedRolesItem.Extensions)
                            {
                                XElement extensionElement2 = new XElement(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                                extensionsSequenceElement.Add(extensionElement2);
                                
                                XElement idElement2 = new XElement(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                                idElement2.Value = extensionsItem.Id;
                                extensionElement2.Add(idElement2);
                            }
                            roleElement.Add(extensionsSequenceElement);
                        }
                        extensionConfigurationElement.Add(namedRolesSequenceElement);
                    }
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Upgrade Deployment operation initiates an update of role
        /// instances in a deployment using the package and configuration that
        /// you specify. For more information about updating role instances,
        /// see Update a Windows Azure Service.  The Upgrade Deployment
        /// operation is an asynchronous operation. To determine whether the
        /// request has been processed, call Get Operation Status. For more
        /// information on asynchronous operations, see Tracking Asynchronous
        /// Service Management Requests.To perform an automatic update of a
        /// deployment, call Upgrade Deployment or Change Deployment
        /// Configuration with the Mode element set to automatic. The update
        /// proceeds from that point without a need for further input. You can
        /// call Get Operation Status to determine when the update is
        /// complete.  To perform a manual update, first call Upgrade
        /// Deployment with the Mode element set to manual. Next, call Walk
        /// Upgrade Domain to update each domain within the deployment. You
        /// should make sure that the operation is complete by calling Get
        /// Operation Status before updating the next domain.  Important: An
        /// update that adds or removes role instances will result in a
        /// configuration update to all roles that are deployed in the cloud
        /// service. Existing role instances need to be notified of new role
        /// instances so that all role instances can communicate together in
        /// the cloud service.  By default, a cloud service is deployed with
        /// five update domains, which are updated one at a time during an
        /// in-place update. For information on modifying the number of update
        /// domains in the service definition file, see Windows Azure Service
        /// Definition Schema (.csdef File).  To determine the update domain
        /// in which a particular instance is running in Windows Azure, use
        /// the UpdateDomain property of the RoleInstance class. See the
        /// Windows Azure Managed Library Reference for more information.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/ee460793.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service to upgrade.
        /// </param>
        /// <param name='deploymentName'>
        /// The deployment to upgrade.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Upgrade Deployment operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> UpgradeByNameAsync(string serviceName, string deploymentName, DeploymentUpgradeParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "UpgradeByNameAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginUpgradingByNameAsync(serviceName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginWalkingUpgradeDomainByDeploymentNameAsync(string serviceName, string deploymentName, DeploymentWalkUpgradeDomainParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginWalkingUpgradeDomainByDeploymentNameAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "?comp=walkupgradedomain";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement walkUpgradeDomainElement = new XElement(XName.Get("WalkUpgradeDomain", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(walkUpgradeDomainElement);
                
                XElement upgradeDomainElement = new XElement(XName.Get("UpgradeDomain", "http://schemas.microsoft.com/windowsazure"));
                upgradeDomainElement.Value = parameters.UpgradeDomain.ToString();
                walkUpgradeDomainElement.Add(upgradeDomainElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> WalkUpgradeDomainByDeploymentNameAsync(string serviceName, string deploymentName, DeploymentWalkUpgradeDomainParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "WalkUpgradeDomainByDeploymentNameAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginWalkingUpgradeDomainByDeploymentNameAsync(serviceName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginWalkingUpgradeDomainByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentWalkUpgradeDomainParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginWalkingUpgradeDomainByDeploymentSlotAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deploymentslots/" + deploymentSlot + "/?comp=walkupgradedomain";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement walkUpgradeDomainElement = new XElement(XName.Get("WalkUpgradeDomain", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(walkUpgradeDomainElement);
                
                XElement upgradeDomainElement = new XElement(XName.Get("UpgradeDomain", "http://schemas.microsoft.com/windowsazure"));
                upgradeDomainElement.Value = parameters.UpgradeDomain.ToString();
                walkUpgradeDomainElement.Add(upgradeDomainElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Walk Upgrade Domain operation specifies an update domain in
        /// which a role instance must be updated. For more information about
        /// updating role instances, see Update a Windows Azure Service.  The
        /// Walk Upgrade Domain operation is an asynchronous operation. To
        /// determine whether the Management service has finished processing
        /// the request, call Get Operation Status.  For more information on
        /// asynchronous operations, see Tracking Asynchronous Service
        /// Management Requests.  Prior to calling the Walk Upgrade Domain
        /// operation you must have called Upgrade Deployment, Change
        /// Deployment Configuration, or Rollback Update Or Upgrade.  By
        /// default, a service is deployed with five update domains, which are
        /// updated one at a time during an in-place update. For information
        /// on modifying the number of update domains in the service
        /// definition file, see Windows Azure Service Definition Schema
        /// (.csdef File).  To perform a manual update of your deployment,
        /// proceed in this order:  Call Upgrade Deployment with the Mode
        /// element set to manual.   Call Walk Upgrade Domain to update each
        /// domain within the deployment. Update domains must be updated in
        /// order. For example, begin with domain 0, proceed to domain 1, and
        /// so on.  Important: An update that adds or removes role instances
        /// will result in a configuration update to all roles that are
        /// deployed in the cloud service. Existing role instances need to be
        /// notified of new role instances so that all role instances can
        /// communicate together in the cloud service.  While an update is in
        /// progress, call Get Deployment to determine its status. If the
        /// update is in progress, Get Deployment returns an UpgradeStatus
        /// element that contains information about the update. If the update
        /// is complete, or if no update is in progress, then the
        /// UpgradeStatus element is null.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460800.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='deploymentSlot'>
        /// The deployment slot.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Walk Upgrade Domain operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> WalkUpgradeDomainByDeploymentSlotAsync(string serviceName, DeploymentSlot deploymentSlot, DeploymentWalkUpgradeDomainParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentSlot", deploymentSlot);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "WalkUpgradeDomainByDeploymentSlotAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.Deployments.BeginWalkingUpgradeDomainByDeploymentSlotAsync(serviceName, deploymentSlot, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the hosted
    /// services beneath your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460812.aspx for
    /// more information)
    /// </summary>
    public partial interface IHostedServiceOperations
    {
        /// <summary>
        /// The Add Extension operation adds an available extension to your
        /// cloud service. In Windows Azure, a process can run as an extension
        /// of a cloud service. For example, Remote Desktop Access or the
        /// Windows Azure Diagnostics Agent can run as extensions to the cloud
        /// service. You can find the available extension by using the List
        /// Available Extensions operation.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169558.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Add Extension operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginAddingExtensionAsync(string serviceName, HostedServiceAddExtensionParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Add Extension operation adds an available extension to your
        /// cloud service. In Windows Azure, a process can run as an extension
        /// of a cloud service. For example, Remote Desktop Access or the
        /// Windows Azure Diagnostics Agent can run as extensions to the cloud
        /// service. You can find the available extension by using the List
        /// Available Extensions operation.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169558.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Add Extension operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> AddExtensionAsync(string serviceName, HostedServiceAddExtensionParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Extension operation deletes the specified extension from
        /// a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169560.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginDeletingExtensionAsync(string serviceName, string extensionId, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Extension operation deletes the specified extension from
        /// a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169560.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> DeleteExtensionAsync(string serviceName, string extensionId, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get Extension operation retrieves information about a specified
        /// extension that was added to a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169557.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Extension operation response.
        /// </returns>
        Task<HostedServiceGetExtensionResponse> GetExtensionAsync(string serviceName, string extensionId, CancellationToken cancellationToken);
        
        /// <summary>
        /// The List Available Extensions operation lists the extensions that
        /// are available to add to your cloud service. In Windows Azure, a
        /// process can run as an extension of a cloud service. For example,
        /// Remote Desktop Access or the Windows Azure Diagnostics Agent can
        /// run as extensions to the cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169559.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Available Extensions operation response.
        /// </returns>
        Task<HostedServiceListAvailableExtensionsResponse> ListAvailableExtensionsAsync(CancellationToken cancellationToken);
        
        /// <summary>
        /// The List Extensions operation lists all of the extensions that were
        /// added to a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169561.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Extensions operation response.
        /// </returns>
        Task<HostedServiceListExtensionsResponse> ListExtensionsAsync(string serviceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Check Hosted Service Name Availability operation checks for the
        /// availability of the specified cloud service name.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154116.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service name that you would like to use.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Check Hosted Service Name Availability operation response.
        /// </returns>
        Task<HostedServiceCheckNameAvailabilityResponse> CheckNameAvailabilityAsync(string serviceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Create Hosted Service operation creates a new cloud service in
        /// Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441304.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Hosted Service operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> CreateAsync(HostedServiceCreateParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Hosted Service operation deletes the specified cloud
        /// service from Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441305.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> DeleteAsync(string serviceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get Hosted Service Properties operation retrieves system
        /// properties for the specified cloud service. These properties
        /// include the service name and service type; the name of the
        /// affinity group to which the service belongs, or its location if it
        /// is not part of an affinity group.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460806.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Hosted Service operation response.
        /// </returns>
        Task<HostedServiceGetResponse> GetAsync(string serviceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get Hosted Service Properties operation retrieves system
        /// properties for the specified cloud service. These properties
        /// include the service name and service type; the name of the
        /// affinity group to which the service belongs, or its location if it
        /// is not part of an affinity group; and information on the
        /// deployments of the service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460806.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The detailed Get Hosted Service operation response.
        /// </returns>
        Task<HostedServiceGetDetailedResponse> GetDetailedAsync(string serviceName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The List Hosted Services operation lists the cloud services
        /// available under the current subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460781.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Hosted Service operation response.
        /// </returns>
        Task<HostedServiceListResponse> ListAsync(CancellationToken cancellationToken);
        
        /// <summary>
        /// The Update Hosted Service operation can update the label or
        /// description of a cloud service in Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441303.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Hosted Service operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> UpdateAsync(string serviceName, HostedServiceUpdateParameters parameters, CancellationToken cancellationToken);
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the hosted
    /// services beneath your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460812.aspx for
    /// more information)
    /// </summary>
    public static partial class HostedServiceOperationsExtensions
    {
        /// <summary>
        /// The Add Extension operation adds an available extension to your
        /// cloud service. In Windows Azure, a process can run as an extension
        /// of a cloud service. For example, Remote Desktop Access or the
        /// Windows Azure Diagnostics Agent can run as extensions to the cloud
        /// service. You can find the available extension by using the List
        /// Available Extensions operation.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169558.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Add Extension operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginAddingExtension(this IHostedServiceOperations operations, string serviceName, HostedServiceAddExtensionParameters parameters)
        {
            try
            {
                return operations.BeginAddingExtensionAsync(serviceName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Add Extension operation adds an available extension to your
        /// cloud service. In Windows Azure, a process can run as an extension
        /// of a cloud service. For example, Remote Desktop Access or the
        /// Windows Azure Diagnostics Agent can run as extensions to the cloud
        /// service. You can find the available extension by using the List
        /// Available Extensions operation.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169558.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Add Extension operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginAddingExtensionAsync(this IHostedServiceOperations operations, string serviceName, HostedServiceAddExtensionParameters parameters)
        {
            return operations.BeginAddingExtensionAsync(serviceName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Add Extension operation adds an available extension to your
        /// cloud service. In Windows Azure, a process can run as an extension
        /// of a cloud service. For example, Remote Desktop Access or the
        /// Windows Azure Diagnostics Agent can run as extensions to the cloud
        /// service. You can find the available extension by using the List
        /// Available Extensions operation.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169558.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Add Extension operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse AddExtension(this IHostedServiceOperations operations, string serviceName, HostedServiceAddExtensionParameters parameters)
        {
            try
            {
                return operations.AddExtensionAsync(serviceName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Add Extension operation adds an available extension to your
        /// cloud service. In Windows Azure, a process can run as an extension
        /// of a cloud service. For example, Remote Desktop Access or the
        /// Windows Azure Diagnostics Agent can run as extensions to the cloud
        /// service. You can find the available extension by using the List
        /// Available Extensions operation.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169558.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Add Extension operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> AddExtensionAsync(this IHostedServiceOperations operations, string serviceName, HostedServiceAddExtensionParameters parameters)
        {
            return operations.AddExtensionAsync(serviceName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Extension operation deletes the specified extension from
        /// a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169560.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginDeletingExtension(this IHostedServiceOperations operations, string serviceName, string extensionId)
        {
            try
            {
                return operations.BeginDeletingExtensionAsync(serviceName, extensionId).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Extension operation deletes the specified extension from
        /// a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169560.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginDeletingExtensionAsync(this IHostedServiceOperations operations, string serviceName, string extensionId)
        {
            return operations.BeginDeletingExtensionAsync(serviceName, extensionId, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Extension operation deletes the specified extension from
        /// a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169560.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse DeleteExtension(this IHostedServiceOperations operations, string serviceName, string extensionId)
        {
            try
            {
                return operations.DeleteExtensionAsync(serviceName, extensionId).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Extension operation deletes the specified extension from
        /// a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169560.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> DeleteExtensionAsync(this IHostedServiceOperations operations, string serviceName, string extensionId)
        {
            return operations.DeleteExtensionAsync(serviceName, extensionId, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get Extension operation retrieves information about a specified
        /// extension that was added to a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169557.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <returns>
        /// The Get Extension operation response.
        /// </returns>
        public static HostedServiceGetExtensionResponse GetExtension(this IHostedServiceOperations operations, string serviceName, string extensionId)
        {
            try
            {
                return operations.GetExtensionAsync(serviceName, extensionId).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Extension operation retrieves information about a specified
        /// extension that was added to a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169557.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <returns>
        /// The Get Extension operation response.
        /// </returns>
        public static Task<HostedServiceGetExtensionResponse> GetExtensionAsync(this IHostedServiceOperations operations, string serviceName, string extensionId)
        {
            return operations.GetExtensionAsync(serviceName, extensionId, CancellationToken.None);
        }
        
        /// <summary>
        /// The List Available Extensions operation lists the extensions that
        /// are available to add to your cloud service. In Windows Azure, a
        /// process can run as an extension of a cloud service. For example,
        /// Remote Desktop Access or the Windows Azure Diagnostics Agent can
        /// run as extensions to the cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169559.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <returns>
        /// The List Available Extensions operation response.
        /// </returns>
        public static HostedServiceListAvailableExtensionsResponse ListAvailableExtensions(this IHostedServiceOperations operations)
        {
            try
            {
                return operations.ListAvailableExtensionsAsync().Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The List Available Extensions operation lists the extensions that
        /// are available to add to your cloud service. In Windows Azure, a
        /// process can run as an extension of a cloud service. For example,
        /// Remote Desktop Access or the Windows Azure Diagnostics Agent can
        /// run as extensions to the cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169559.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <returns>
        /// The List Available Extensions operation response.
        /// </returns>
        public static Task<HostedServiceListAvailableExtensionsResponse> ListAvailableExtensionsAsync(this IHostedServiceOperations operations)
        {
            return operations.ListAvailableExtensionsAsync(CancellationToken.None);
        }
        
        /// <summary>
        /// The List Extensions operation lists all of the extensions that were
        /// added to a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169561.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <returns>
        /// The List Extensions operation response.
        /// </returns>
        public static HostedServiceListExtensionsResponse ListExtensions(this IHostedServiceOperations operations, string serviceName)
        {
            try
            {
                return operations.ListExtensionsAsync(serviceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The List Extensions operation lists all of the extensions that were
        /// added to a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169561.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <returns>
        /// The List Extensions operation response.
        /// </returns>
        public static Task<HostedServiceListExtensionsResponse> ListExtensionsAsync(this IHostedServiceOperations operations, string serviceName)
        {
            return operations.ListExtensionsAsync(serviceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Check Hosted Service Name Availability operation checks for the
        /// availability of the specified cloud service name.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154116.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service name that you would like to use.
        /// </param>
        /// <returns>
        /// The Check Hosted Service Name Availability operation response.
        /// </returns>
        public static HostedServiceCheckNameAvailabilityResponse CheckNameAvailability(this IHostedServiceOperations operations, string serviceName)
        {
            try
            {
                return operations.CheckNameAvailabilityAsync(serviceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Check Hosted Service Name Availability operation checks for the
        /// availability of the specified cloud service name.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154116.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The cloud service name that you would like to use.
        /// </param>
        /// <returns>
        /// The Check Hosted Service Name Availability operation response.
        /// </returns>
        public static Task<HostedServiceCheckNameAvailabilityResponse> CheckNameAvailabilityAsync(this IHostedServiceOperations operations, string serviceName)
        {
            return operations.CheckNameAvailabilityAsync(serviceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Create Hosted Service operation creates a new cloud service in
        /// Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441304.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Hosted Service operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse Create(this IHostedServiceOperations operations, HostedServiceCreateParameters parameters)
        {
            try
            {
                return operations.CreateAsync(parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Create Hosted Service operation creates a new cloud service in
        /// Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441304.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Hosted Service operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> CreateAsync(this IHostedServiceOperations operations, HostedServiceCreateParameters parameters)
        {
            return operations.CreateAsync(parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Hosted Service operation deletes the specified cloud
        /// service from Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441305.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse Delete(this IHostedServiceOperations operations, string serviceName)
        {
            try
            {
                return operations.DeleteAsync(serviceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Hosted Service operation deletes the specified cloud
        /// service from Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441305.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> DeleteAsync(this IHostedServiceOperations operations, string serviceName)
        {
            return operations.DeleteAsync(serviceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get Hosted Service Properties operation retrieves system
        /// properties for the specified cloud service. These properties
        /// include the service name and service type; the name of the
        /// affinity group to which the service belongs, or its location if it
        /// is not part of an affinity group.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460806.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <returns>
        /// The Get Hosted Service operation response.
        /// </returns>
        public static HostedServiceGetResponse Get(this IHostedServiceOperations operations, string serviceName)
        {
            try
            {
                return operations.GetAsync(serviceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Hosted Service Properties operation retrieves system
        /// properties for the specified cloud service. These properties
        /// include the service name and service type; the name of the
        /// affinity group to which the service belongs, or its location if it
        /// is not part of an affinity group.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460806.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <returns>
        /// The Get Hosted Service operation response.
        /// </returns>
        public static Task<HostedServiceGetResponse> GetAsync(this IHostedServiceOperations operations, string serviceName)
        {
            return operations.GetAsync(serviceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get Hosted Service Properties operation retrieves system
        /// properties for the specified cloud service. These properties
        /// include the service name and service type; the name of the
        /// affinity group to which the service belongs, or its location if it
        /// is not part of an affinity group; and information on the
        /// deployments of the service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460806.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <returns>
        /// The detailed Get Hosted Service operation response.
        /// </returns>
        public static HostedServiceGetDetailedResponse GetDetailed(this IHostedServiceOperations operations, string serviceName)
        {
            try
            {
                return operations.GetDetailedAsync(serviceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Hosted Service Properties operation retrieves system
        /// properties for the specified cloud service. These properties
        /// include the service name and service type; the name of the
        /// affinity group to which the service belongs, or its location if it
        /// is not part of an affinity group; and information on the
        /// deployments of the service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460806.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <returns>
        /// The detailed Get Hosted Service operation response.
        /// </returns>
        public static Task<HostedServiceGetDetailedResponse> GetDetailedAsync(this IHostedServiceOperations operations, string serviceName)
        {
            return operations.GetDetailedAsync(serviceName, CancellationToken.None);
        }
        
        /// <summary>
        /// The List Hosted Services operation lists the cloud services
        /// available under the current subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460781.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <returns>
        /// The Get Hosted Service operation response.
        /// </returns>
        public static HostedServiceListResponse List(this IHostedServiceOperations operations)
        {
            try
            {
                return operations.ListAsync().Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The List Hosted Services operation lists the cloud services
        /// available under the current subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460781.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <returns>
        /// The Get Hosted Service operation response.
        /// </returns>
        public static Task<HostedServiceListResponse> ListAsync(this IHostedServiceOperations operations)
        {
            return operations.ListAsync(CancellationToken.None);
        }
        
        /// <summary>
        /// The Update Hosted Service operation can update the label or
        /// description of a cloud service in Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441303.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Hosted Service operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse Update(this IHostedServiceOperations operations, string serviceName, HostedServiceUpdateParameters parameters)
        {
            try
            {
                return operations.UpdateAsync(serviceName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Update Hosted Service operation can update the label or
        /// description of a cloud service in Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441303.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IHostedServiceOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Hosted Service operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> UpdateAsync(this IHostedServiceOperations operations, string serviceName, HostedServiceUpdateParameters parameters)
        {
            return operations.UpdateAsync(serviceName, parameters, CancellationToken.None);
        }
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the hosted
    /// services beneath your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460812.aspx for
    /// more information)
    /// </summary>
    internal partial class HostedServiceOperations : IServiceOperations<ComputeManagementClient>, IHostedServiceOperations
    {
        /// <summary>
        /// Initializes a new instance of the HostedServiceOperations class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        internal HostedServiceOperations(ComputeManagementClient client)
        {
            this._client = client;
        }
        
        private ComputeManagementClient _client;
        
        /// <summary>
        /// Gets a reference to the
        /// Microsoft.WindowsAzure.Management.Compute.ComputeManagementClient.
        /// </summary>
        public ComputeManagementClient Client
        {
            get { return this._client; }
        }
        
        /// <summary>
        /// The Add Extension operation adds an available extension to your
        /// cloud service. In Windows Azure, a process can run as an extension
        /// of a cloud service. For example, Remote Desktop Access or the
        /// Windows Azure Diagnostics Agent can run as extensions to the cloud
        /// service. You can find the available extension by using the List
        /// Available Extensions operation.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169558.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Add Extension operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginAddingExtensionAsync(string serviceName, HostedServiceAddExtensionParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.Type == null)
            {
                throw new ArgumentNullException("parameters.Type");
            }
            if (parameters.Id == null)
            {
                throw new ArgumentNullException("parameters.Id");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginAddingExtensionAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/extensions";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement extensionElement = new XElement(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(extensionElement);
                
                if (parameters.ProviderNamespace != null)
                {
                    XElement providerNameSpaceElement = new XElement(XName.Get("ProviderNameSpace", "http://schemas.microsoft.com/windowsazure"));
                    providerNameSpaceElement.Value = parameters.ProviderNamespace;
                    extensionElement.Add(providerNameSpaceElement);
                }
                
                XElement typeElement = new XElement(XName.Get("Type", "http://schemas.microsoft.com/windowsazure"));
                typeElement.Value = parameters.Type;
                extensionElement.Add(typeElement);
                
                XElement idElement = new XElement(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                idElement.Value = parameters.Id;
                extensionElement.Add(idElement);
                
                if (parameters.Thumbprint != null)
                {
                    XElement thumbprintElement = new XElement(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                    thumbprintElement.Value = parameters.Thumbprint;
                    extensionElement.Add(thumbprintElement);
                }
                
                if (parameters.ThumbprintAlgorithm != null)
                {
                    XElement thumbprintAlgorithmElement = new XElement(XName.Get("ThumbprintAlgorithm", "http://schemas.microsoft.com/windowsazure"));
                    thumbprintAlgorithmElement.Value = parameters.ThumbprintAlgorithm;
                    extensionElement.Add(thumbprintAlgorithmElement);
                }
                
                if (parameters.PublicConfiguration != null)
                {
                    XElement publicConfigurationElement = new XElement(XName.Get("PublicConfiguration", "http://schemas.microsoft.com/windowsazure"));
                    publicConfigurationElement.Value = TypeConversion.ToBase64String(parameters.PublicConfiguration);
                    extensionElement.Add(publicConfigurationElement);
                }
                
                if (parameters.PrivateConfiguration != null)
                {
                    XElement privateConfigurationElement = new XElement(XName.Get("PrivateConfiguration", "http://schemas.microsoft.com/windowsazure"));
                    privateConfigurationElement.Value = TypeConversion.ToBase64String(parameters.PrivateConfiguration);
                    extensionElement.Add(privateConfigurationElement);
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Add Extension operation adds an available extension to your
        /// cloud service. In Windows Azure, a process can run as an extension
        /// of a cloud service. For example, Remote Desktop Access or the
        /// Windows Azure Diagnostics Agent can run as extensions to the cloud
        /// service. You can find the available extension by using the List
        /// Available Extensions operation.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169558.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Add Extension operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> AddExtensionAsync(string serviceName, HostedServiceAddExtensionParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "AddExtensionAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.HostedServices.BeginAddingExtensionAsync(serviceName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Extension operation deletes the specified extension from
        /// a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169560.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginDeletingExtensionAsync(string serviceName, string extensionId, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (extensionId == null)
            {
                throw new ArgumentNullException("extensionId");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("extensionId", extensionId);
                Tracing.Enter(invocationId, this, "BeginDeletingExtensionAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/extensions/" + extensionId;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Delete;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK && statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Extension operation deletes the specified extension from
        /// a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169560.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> DeleteExtensionAsync(string serviceName, string extensionId, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("extensionId", extensionId);
                Tracing.Enter(invocationId, this, "DeleteExtensionAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.HostedServices.BeginDeletingExtensionAsync(serviceName, extensionId, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get Extension operation retrieves information about a specified
        /// extension that was added to a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169557.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='extensionId'>
        /// The identifier that was assigned to the extension when it was added
        /// to the cloud service
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Extension operation response.
        /// </returns>
        public async Task<HostedServiceGetExtensionResponse> GetExtensionAsync(string serviceName, string extensionId, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (extensionId == null)
            {
                throw new ArgumentNullException("extensionId");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("extensionId", extensionId);
                Tracing.Enter(invocationId, this, "GetExtensionAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/extensions/" + extensionId;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    HostedServiceGetExtensionResponse result = new HostedServiceGetExtensionResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement extensionElement = responseDoc.Element(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure"));
                    if (extensionElement != null)
                    {
                        XElement providerNameSpaceElement = extensionElement.Element(XName.Get("ProviderNameSpace", "http://schemas.microsoft.com/windowsazure"));
                        if (providerNameSpaceElement != null)
                        {
                            string providerNameSpaceInstance = providerNameSpaceElement.Value;
                            result.ProviderNamespace = providerNameSpaceInstance;
                        }
                        
                        XElement typeElement = extensionElement.Element(XName.Get("Type", "http://schemas.microsoft.com/windowsazure"));
                        if (typeElement != null)
                        {
                            string typeInstance = typeElement.Value;
                            result.Type = typeInstance;
                        }
                        
                        XElement idElement = extensionElement.Element(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                        if (idElement != null)
                        {
                            string idInstance = idElement.Value;
                            result.Id = idInstance;
                        }
                        
                        XElement versionElement = extensionElement.Element(XName.Get("Version", "http://schemas.microsoft.com/windowsazure"));
                        if (versionElement != null)
                        {
                            string versionInstance = versionElement.Value;
                            result.Version = versionInstance;
                        }
                        
                        XElement thumbprintElement = extensionElement.Element(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                        if (thumbprintElement != null)
                        {
                            string thumbprintInstance = thumbprintElement.Value;
                            result.Thumbprint = thumbprintInstance;
                        }
                        
                        XElement thumbprintAlgorithmElement = extensionElement.Element(XName.Get("ThumbprintAlgorithm", "http://schemas.microsoft.com/windowsazure"));
                        if (thumbprintAlgorithmElement != null)
                        {
                            string thumbprintAlgorithmInstance = thumbprintAlgorithmElement.Value;
                            result.ThumbprintAlgorithm = thumbprintAlgorithmInstance;
                        }
                        
                        XElement publicConfigurationElement = extensionElement.Element(XName.Get("PublicConfiguration", "http://schemas.microsoft.com/windowsazure"));
                        if (publicConfigurationElement != null)
                        {
                            string publicConfigurationInstance = TypeConversion.FromBase64String(publicConfigurationElement.Value);
                            result.PublicConfiguration = publicConfigurationInstance;
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The List Available Extensions operation lists the extensions that
        /// are available to add to your cloud service. In Windows Azure, a
        /// process can run as an extension of a cloud service. For example,
        /// Remote Desktop Access or the Windows Azure Diagnostics Agent can
        /// run as extensions to the cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169559.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Available Extensions operation response.
        /// </returns>
        public async Task<HostedServiceListAvailableExtensionsResponse> ListAvailableExtensionsAsync(CancellationToken cancellationToken)
        {
            // Validate
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                Tracing.Enter(invocationId, this, "ListAvailableExtensionsAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/extensions";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    HostedServiceListAvailableExtensionsResponse result = new HostedServiceListAvailableExtensionsResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement extensionImagesSequenceElement = responseDoc.Element(XName.Get("ExtensionImages", "http://schemas.microsoft.com/windowsazure"));
                    if (extensionImagesSequenceElement != null)
                    {
                        foreach (XElement extensionImagesElement in extensionImagesSequenceElement.Elements(XName.Get("ExtensionImage", "http://schemas.microsoft.com/windowsazure")))
                        {
                            HostedServiceListAvailableExtensionsResponse.ExtensionImage extensionImageInstance = new HostedServiceListAvailableExtensionsResponse.ExtensionImage();
                            result.ExtensionImages.Add(extensionImageInstance);
                            
                            XElement providerNameSpaceElement = extensionImagesElement.Element(XName.Get("ProviderNameSpace", "http://schemas.microsoft.com/windowsazure"));
                            if (providerNameSpaceElement != null)
                            {
                                string providerNameSpaceInstance = providerNameSpaceElement.Value;
                                extensionImageInstance.ProviderNamespace = providerNameSpaceInstance;
                            }
                            
                            XElement typeElement = extensionImagesElement.Element(XName.Get("Type", "http://schemas.microsoft.com/windowsazure"));
                            if (typeElement != null)
                            {
                                string typeInstance = typeElement.Value;
                                extensionImageInstance.Type = typeInstance;
                            }
                            
                            XElement labelElement = extensionImagesElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                            if (labelElement != null)
                            {
                                string labelInstance = labelElement.Value;
                                extensionImageInstance.Label = labelInstance;
                            }
                            
                            XElement versionElement = extensionImagesElement.Element(XName.Get("Version", "http://schemas.microsoft.com/windowsazure"));
                            if (versionElement != null)
                            {
                                string versionInstance = versionElement.Value;
                                extensionImageInstance.Version = versionInstance;
                            }
                            
                            XElement descriptionElement = extensionImagesElement.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                            if (descriptionElement != null)
                            {
                                string descriptionInstance = descriptionElement.Value;
                                extensionImageInstance.Description = descriptionInstance;
                            }
                            
                            XElement thumbprintAlgorithmElement = extensionImagesElement.Element(XName.Get("ThumbprintAlgorithm", "http://schemas.microsoft.com/windowsazure"));
                            if (thumbprintAlgorithmElement != null)
                            {
                                string thumbprintAlgorithmInstance = thumbprintAlgorithmElement.Value;
                                extensionImageInstance.ThumbprintAlgorithm = thumbprintAlgorithmInstance;
                            }
                            
                            XElement hostingResourcesElement = extensionImagesElement.Element(XName.Get("HostingResources", "http://schemas.microsoft.com/windowsazure"));
                            if (hostingResourcesElement != null)
                            {
                                HostingResources hostingResourcesInstance = ComputeManagementClient.ParseHostingResources(hostingResourcesElement.Value);
                                extensionImageInstance.HostingResources = hostingResourcesInstance;
                            }
                            
                            XElement publicConfigurationSchemaElement = extensionImagesElement.Element(XName.Get("PublicConfigurationSchema", "http://schemas.microsoft.com/windowsazure"));
                            if (publicConfigurationSchemaElement != null)
                            {
                                string publicConfigurationSchemaInstance = TypeConversion.FromBase64String(publicConfigurationSchemaElement.Value);
                                extensionImageInstance.PublicConfigurationSchema = publicConfigurationSchemaInstance;
                            }
                            
                            XElement privateConfigurationSchemaElement = extensionImagesElement.Element(XName.Get("PrivateConfigurationSchema", "http://schemas.microsoft.com/windowsazure"));
                            if (privateConfigurationSchemaElement != null)
                            {
                                string privateConfigurationSchemaInstance = TypeConversion.FromBase64String(privateConfigurationSchemaElement.Value);
                                extensionImageInstance.PrivateConfigurationSchema = privateConfigurationSchemaInstance;
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The List Extensions operation lists all of the extensions that were
        /// added to a cloud service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/dn169561.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Extensions operation response.
        /// </returns>
        public async Task<HostedServiceListExtensionsResponse> ListExtensionsAsync(string serviceName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                Tracing.Enter(invocationId, this, "ListExtensionsAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/extensions";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    HostedServiceListExtensionsResponse result = new HostedServiceListExtensionsResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement extensionsSequenceElement = responseDoc.Element(XName.Get("Extensions", "http://schemas.microsoft.com/windowsazure"));
                    if (extensionsSequenceElement != null)
                    {
                        foreach (XElement extensionsElement in extensionsSequenceElement.Elements(XName.Get("Extension", "http://schemas.microsoft.com/windowsazure")))
                        {
                            HostedServiceListExtensionsResponse.Extension extensionInstance = new HostedServiceListExtensionsResponse.Extension();
                            result.Extensions.Add(extensionInstance);
                            
                            XElement providerNameSpaceElement = extensionsElement.Element(XName.Get("ProviderNameSpace", "http://schemas.microsoft.com/windowsazure"));
                            if (providerNameSpaceElement != null)
                            {
                                string providerNameSpaceInstance = providerNameSpaceElement.Value;
                                extensionInstance.ProviderNamespace = providerNameSpaceInstance;
                            }
                            
                            XElement typeElement = extensionsElement.Element(XName.Get("Type", "http://schemas.microsoft.com/windowsazure"));
                            if (typeElement != null)
                            {
                                string typeInstance = typeElement.Value;
                                extensionInstance.Type = typeInstance;
                            }
                            
                            XElement idElement = extensionsElement.Element(XName.Get("Id", "http://schemas.microsoft.com/windowsazure"));
                            if (idElement != null)
                            {
                                string idInstance = idElement.Value;
                                extensionInstance.Id = idInstance;
                            }
                            
                            XElement versionElement = extensionsElement.Element(XName.Get("Version", "http://schemas.microsoft.com/windowsazure"));
                            if (versionElement != null)
                            {
                                string versionInstance = versionElement.Value;
                                extensionInstance.Version = versionInstance;
                            }
                            
                            XElement thumbprintElement = extensionsElement.Element(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                            if (thumbprintElement != null)
                            {
                                string thumbprintInstance = thumbprintElement.Value;
                                extensionInstance.Thumbprint = thumbprintInstance;
                            }
                            
                            XElement thumbprintAlgorithmElement = extensionsElement.Element(XName.Get("ThumbprintAlgorithm", "http://schemas.microsoft.com/windowsazure"));
                            if (thumbprintAlgorithmElement != null)
                            {
                                string thumbprintAlgorithmInstance = thumbprintAlgorithmElement.Value;
                                extensionInstance.ThumbprintAlgorithm = thumbprintAlgorithmInstance;
                            }
                            
                            XElement publicConfigurationElement = extensionsElement.Element(XName.Get("PublicConfiguration", "http://schemas.microsoft.com/windowsazure"));
                            if (publicConfigurationElement != null)
                            {
                                string publicConfigurationInstance = TypeConversion.FromBase64String(publicConfigurationElement.Value);
                                extensionInstance.PublicConfiguration = publicConfigurationInstance;
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Check Hosted Service Name Availability operation checks for the
        /// availability of the specified cloud service name.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154116.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The cloud service name that you would like to use.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Check Hosted Service Name Availability operation response.
        /// </returns>
        public async Task<HostedServiceCheckNameAvailabilityResponse> CheckNameAvailabilityAsync(string serviceName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                Tracing.Enter(invocationId, this, "CheckNameAvailabilityAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/operations/isavailable/" + serviceName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    HostedServiceCheckNameAvailabilityResponse result = new HostedServiceCheckNameAvailabilityResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement availabilityResponseElement = responseDoc.Element(XName.Get("AvailabilityResponse", "http://schemas.microsoft.com/windowsazure"));
                    if (availabilityResponseElement != null)
                    {
                        XElement resultElement = availabilityResponseElement.Element(XName.Get("Result", "http://schemas.microsoft.com/windowsazure"));
                        if (resultElement != null)
                        {
                            bool resultInstance = bool.Parse(resultElement.Value);
                            result.IsAvailable = resultInstance;
                        }
                        
                        XElement reasonElement = availabilityResponseElement.Element(XName.Get("Reason", "http://schemas.microsoft.com/windowsazure"));
                        if (reasonElement != null)
                        {
                            string reasonInstance = reasonElement.Value;
                            result.Reason = reasonInstance;
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Create Hosted Service operation creates a new cloud service in
        /// Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441304.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Hosted Service operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> CreateAsync(HostedServiceCreateParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.ServiceName == null)
            {
                throw new ArgumentNullException("parameters.ServiceName");
            }
            // TODO: Validate parameters.ServiceName is a valid DNS name.
            if (parameters.Label == null)
            {
                throw new ArgumentNullException("parameters.Label");
            }
            if (parameters.Description != null && parameters.Description.Length > 1024)
            {
                throw new ArgumentOutOfRangeException("parameters.Description");
            }
            int locationCount = (parameters.Location != null ? 1 : 0) + (parameters.AffinityGroup != null ? 1 : 0);
            if (locationCount != 1)
            {
                throw new ArgumentException("Only one of parameters.Location, parameters.AffinityGroup may be provided.");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "CreateAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement createHostedServiceElement = new XElement(XName.Get("CreateHostedService", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(createHostedServiceElement);
                
                XElement serviceNameElement = new XElement(XName.Get("ServiceName", "http://schemas.microsoft.com/windowsazure"));
                serviceNameElement.Value = parameters.ServiceName;
                createHostedServiceElement.Add(serviceNameElement);
                
                XElement labelElement = new XElement(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                labelElement.Value = TypeConversion.ToBase64String(parameters.Label);
                createHostedServiceElement.Add(labelElement);
                
                if (parameters.Description != null)
                {
                    XElement descriptionElement = new XElement(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                    descriptionElement.Value = parameters.Description;
                    createHostedServiceElement.Add(descriptionElement);
                }
                
                if (parameters.Location != null)
                {
                    XElement locationElement = new XElement(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                    locationElement.Value = parameters.Location;
                    createHostedServiceElement.Add(locationElement);
                }
                
                if (parameters.AffinityGroup != null)
                {
                    XElement affinityGroupElement = new XElement(XName.Get("AffinityGroup", "http://schemas.microsoft.com/windowsazure"));
                    affinityGroupElement.Value = parameters.AffinityGroup;
                    createHostedServiceElement.Add(affinityGroupElement);
                }
                
                if (parameters.ExtendedProperties != null)
                {
                    XElement extendedPropertiesDictionaryElement = new XElement(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                    foreach (KeyValuePair<string, string> pair in parameters.ExtendedProperties)
                    {
                        string extendedPropertiesKey = pair.Key;
                        string extendedPropertiesValue = pair.Value;
                        XElement extendedPropertiesElement = new XElement(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesDictionaryElement.Add(extendedPropertiesElement);
                        
                        XElement extendedPropertiesKeyElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesKeyElement.Value = extendedPropertiesKey;
                        extendedPropertiesElement.Add(extendedPropertiesKeyElement);
                        
                        XElement extendedPropertiesValueElement = new XElement(XName.Get("Value", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesValueElement.Value = extendedPropertiesValue;
                        extendedPropertiesElement.Add(extendedPropertiesValueElement);
                    }
                    createHostedServiceElement.Add(extendedPropertiesDictionaryElement);
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Created)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Hosted Service operation deletes the specified cloud
        /// service from Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441305.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> DeleteAsync(string serviceName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                Tracing.Enter(invocationId, this, "DeleteAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Delete;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get Hosted Service Properties operation retrieves system
        /// properties for the specified cloud service. These properties
        /// include the service name and service type; the name of the
        /// affinity group to which the service belongs, or its location if it
        /// is not part of an affinity group.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460806.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Hosted Service operation response.
        /// </returns>
        public async Task<HostedServiceGetResponse> GetAsync(string serviceName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                Tracing.Enter(invocationId, this, "GetAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    HostedServiceGetResponse result = new HostedServiceGetResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement hostedServiceElement = responseDoc.Element(XName.Get("HostedService", "http://schemas.microsoft.com/windowsazure"));
                    if (hostedServiceElement != null)
                    {
                        XElement urlElement = hostedServiceElement.Element(XName.Get("Url", "http://schemas.microsoft.com/windowsazure"));
                        if (urlElement != null)
                        {
                            Uri urlInstance = TypeConversion.TryParseUri(urlElement.Value);
                            result.Uri = urlInstance;
                        }
                        
                        XElement serviceNameElement = hostedServiceElement.Element(XName.Get("ServiceName", "http://schemas.microsoft.com/windowsazure"));
                        if (serviceNameElement != null)
                        {
                            string serviceNameInstance = serviceNameElement.Value;
                            result.ServiceName = serviceNameInstance;
                        }
                        
                        XElement hostedServicePropertiesElement = hostedServiceElement.Element(XName.Get("HostedServiceProperties", "http://schemas.microsoft.com/windowsazure"));
                        if (hostedServicePropertiesElement != null)
                        {
                            HostedServiceProperties hostedServicePropertiesInstance = new HostedServiceProperties();
                            result.Properties = hostedServicePropertiesInstance;
                            
                            XElement descriptionElement = hostedServicePropertiesElement.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                            if (descriptionElement != null)
                            {
                                string descriptionInstance = descriptionElement.Value;
                                hostedServicePropertiesInstance.Description = descriptionInstance;
                            }
                            
                            XElement affinityGroupElement = hostedServicePropertiesElement.Element(XName.Get("AffinityGroup", "http://schemas.microsoft.com/windowsazure"));
                            if (affinityGroupElement != null)
                            {
                                string affinityGroupInstance = affinityGroupElement.Value;
                                hostedServicePropertiesInstance.AffinityGroup = affinityGroupInstance;
                            }
                            
                            XElement locationElement = hostedServicePropertiesElement.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                            if (locationElement != null)
                            {
                                string locationInstance = locationElement.Value;
                                hostedServicePropertiesInstance.Location = locationInstance;
                            }
                            
                            XElement labelElement = hostedServicePropertiesElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                            if (labelElement != null)
                            {
                                string labelInstance = TypeConversion.FromBase64String(labelElement.Value);
                                hostedServicePropertiesInstance.Label = labelInstance;
                            }
                            
                            XElement statusElement = hostedServicePropertiesElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                            if (statusElement != null)
                            {
                                HostedServiceStatus statusInstance = (HostedServiceStatus)Enum.Parse(typeof(HostedServiceStatus), statusElement.Value, false);
                                hostedServicePropertiesInstance.Status = statusInstance;
                            }
                            
                            XElement dateCreatedElement = hostedServicePropertiesElement.Element(XName.Get("DateCreated", "http://schemas.microsoft.com/windowsazure"));
                            if (dateCreatedElement != null)
                            {
                                DateTime dateCreatedInstance = DateTime.Parse(dateCreatedElement.Value, CultureInfo.InvariantCulture);
                                hostedServicePropertiesInstance.DateCreated = dateCreatedInstance;
                            }
                            
                            XElement dateLastModifiedElement = hostedServicePropertiesElement.Element(XName.Get("DateLastModified", "http://schemas.microsoft.com/windowsazure"));
                            if (dateLastModifiedElement != null)
                            {
                                DateTime dateLastModifiedInstance = DateTime.Parse(dateLastModifiedElement.Value, CultureInfo.InvariantCulture);
                                hostedServicePropertiesInstance.DateLastModified = dateLastModifiedInstance;
                            }
                            
                            XElement extendedPropertiesSequenceElement = hostedServicePropertiesElement.Element(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                            if (extendedPropertiesSequenceElement != null)
                            {
                                foreach (XElement extendedPropertiesElement in extendedPropertiesSequenceElement.Elements(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    string extendedPropertiesKey = extendedPropertiesElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure")).Value;
                                    string extendedPropertiesValue = extendedPropertiesElement.Element(XName.Get("Value", "http://schemas.microsoft.com/windowsazure")).Value;
                                    hostedServicePropertiesInstance.ExtendedProperties.Add(extendedPropertiesKey, extendedPropertiesValue);
                                }
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get Hosted Service Properties operation retrieves system
        /// properties for the specified cloud service. These properties
        /// include the service name and service type; the name of the
        /// affinity group to which the service belongs, or its location if it
        /// is not part of an affinity group; and information on the
        /// deployments of the service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460806.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The detailed Get Hosted Service operation response.
        /// </returns>
        public async Task<HostedServiceGetDetailedResponse> GetDetailedAsync(string serviceName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                Tracing.Enter(invocationId, this, "GetDetailedAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "?embed-detail=true";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    HostedServiceGetDetailedResponse result = new HostedServiceGetDetailedResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement hostedServiceElement = responseDoc.Element(XName.Get("HostedService", "http://schemas.microsoft.com/windowsazure"));
                    if (hostedServiceElement != null)
                    {
                        XElement deploymentsSequenceElement = hostedServiceElement.Element(XName.Get("Deployments", "http://schemas.microsoft.com/windowsazure"));
                        if (deploymentsSequenceElement != null)
                        {
                            foreach (XElement deploymentsElement in deploymentsSequenceElement.Elements(XName.Get("Deployment", "http://schemas.microsoft.com/windowsazure")))
                            {
                                HostedServiceGetDetailedResponse.Deployment deploymentInstance = new HostedServiceGetDetailedResponse.Deployment();
                                result.Deployments.Add(deploymentInstance);
                                
                                XElement nameElement = deploymentsElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                if (nameElement != null)
                                {
                                    string nameInstance = nameElement.Value;
                                    deploymentInstance.Name = nameInstance;
                                }
                                
                                XElement deploymentSlotElement = deploymentsElement.Element(XName.Get("DeploymentSlot", "http://schemas.microsoft.com/windowsazure"));
                                if (deploymentSlotElement != null)
                                {
                                    DeploymentSlot deploymentSlotInstance = (DeploymentSlot)Enum.Parse(typeof(DeploymentSlot), deploymentSlotElement.Value, false);
                                    deploymentInstance.DeploymentSlot = deploymentSlotInstance;
                                }
                                
                                XElement privateIDElement = deploymentsElement.Element(XName.Get("PrivateID", "http://schemas.microsoft.com/windowsazure"));
                                if (privateIDElement != null)
                                {
                                    string privateIDInstance = privateIDElement.Value;
                                    deploymentInstance.PrivateId = privateIDInstance;
                                }
                                
                                XElement statusElement = deploymentsElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                                if (statusElement != null)
                                {
                                    DeploymentStatus statusInstance = (DeploymentStatus)Enum.Parse(typeof(DeploymentStatus), statusElement.Value, false);
                                    deploymentInstance.Status = statusInstance;
                                }
                                
                                XElement labelElement = deploymentsElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                                if (labelElement != null)
                                {
                                    string labelInstance = TypeConversion.FromBase64String(labelElement.Value);
                                    deploymentInstance.Label = labelInstance;
                                }
                                
                                XElement urlElement = deploymentsElement.Element(XName.Get("Url", "http://schemas.microsoft.com/windowsazure"));
                                if (urlElement != null)
                                {
                                    Uri urlInstance = TypeConversion.TryParseUri(urlElement.Value);
                                    deploymentInstance.Uri = urlInstance;
                                }
                                
                                XElement configurationElement = deploymentsElement.Element(XName.Get("Configuration", "http://schemas.microsoft.com/windowsazure"));
                                if (configurationElement != null)
                                {
                                    string configurationInstance = TypeConversion.FromBase64String(configurationElement.Value);
                                    deploymentInstance.Configuration = configurationInstance;
                                }
                                
                                XElement roleInstanceListSequenceElement = deploymentsElement.Element(XName.Get("RoleInstanceList", "http://schemas.microsoft.com/windowsazure"));
                                if (roleInstanceListSequenceElement != null)
                                {
                                    foreach (XElement roleInstanceListElement in roleInstanceListSequenceElement.Elements(XName.Get("RoleInstance", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        RoleInstance roleInstanceInstance = new RoleInstance();
                                        deploymentInstance.RoleInstances.Add(roleInstanceInstance);
                                        
                                        XElement roleNameElement = roleInstanceListElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                                        if (roleNameElement != null)
                                        {
                                            string roleNameInstance = roleNameElement.Value;
                                            roleInstanceInstance.RoleName = roleNameInstance;
                                        }
                                        
                                        XElement instanceNameElement = roleInstanceListElement.Element(XName.Get("InstanceName", "http://schemas.microsoft.com/windowsazure"));
                                        if (instanceNameElement != null)
                                        {
                                            string instanceNameInstance = instanceNameElement.Value;
                                            roleInstanceInstance.InstanceName = instanceNameInstance;
                                        }
                                        
                                        XElement instanceStatusElement = roleInstanceListElement.Element(XName.Get("InstanceStatus", "http://schemas.microsoft.com/windowsazure"));
                                        if (instanceStatusElement != null)
                                        {
                                            string instanceStatusInstance = instanceStatusElement.Value;
                                            roleInstanceInstance.InstanceStatus = instanceStatusInstance;
                                        }
                                        
                                        XElement instanceUpgradeDomainElement = roleInstanceListElement.Element(XName.Get("InstanceUpgradeDomain", "http://schemas.microsoft.com/windowsazure"));
                                        if (instanceUpgradeDomainElement != null && string.IsNullOrEmpty(instanceUpgradeDomainElement.Value) == false)
                                        {
                                            int instanceUpgradeDomainInstance = int.Parse(instanceUpgradeDomainElement.Value, CultureInfo.InvariantCulture);
                                            roleInstanceInstance.InstanceUpgradeDomain = instanceUpgradeDomainInstance;
                                        }
                                        
                                        XElement instanceFaultDomainElement = roleInstanceListElement.Element(XName.Get("InstanceFaultDomain", "http://schemas.microsoft.com/windowsazure"));
                                        if (instanceFaultDomainElement != null && string.IsNullOrEmpty(instanceFaultDomainElement.Value) == false)
                                        {
                                            int instanceFaultDomainInstance = int.Parse(instanceFaultDomainElement.Value, CultureInfo.InvariantCulture);
                                            roleInstanceInstance.InstanceFaultDomain = instanceFaultDomainInstance;
                                        }
                                        
                                        XElement instanceSizeElement = roleInstanceListElement.Element(XName.Get("InstanceSize", "http://schemas.microsoft.com/windowsazure"));
                                        if (instanceSizeElement != null && string.IsNullOrEmpty(instanceSizeElement.Value) == false)
                                        {
                                            VirtualMachineRoleSize instanceSizeInstance = (VirtualMachineRoleSize)Enum.Parse(typeof(VirtualMachineRoleSize), instanceSizeElement.Value, false);
                                            roleInstanceInstance.InstanceSize = instanceSizeInstance;
                                        }
                                        
                                        XElement instanceStateDetailsElement = roleInstanceListElement.Element(XName.Get("InstanceStateDetails", "http://schemas.microsoft.com/windowsazure"));
                                        if (instanceStateDetailsElement != null)
                                        {
                                            string instanceStateDetailsInstance = instanceStateDetailsElement.Value;
                                            roleInstanceInstance.InstanceStateDetails = instanceStateDetailsInstance;
                                        }
                                        
                                        XElement instanceErrorCodeElement = roleInstanceListElement.Element(XName.Get("InstanceErrorCode", "http://schemas.microsoft.com/windowsazure"));
                                        if (instanceErrorCodeElement != null)
                                        {
                                            string instanceErrorCodeInstance = instanceErrorCodeElement.Value;
                                            roleInstanceInstance.InstanceErrorCode = instanceErrorCodeInstance;
                                        }
                                        
                                        XElement ipAddressElement = roleInstanceListElement.Element(XName.Get("IpAddress", "http://schemas.microsoft.com/windowsazure"));
                                        if (ipAddressElement != null)
                                        {
                                            string ipAddressInstance = ipAddressElement.Value;
                                            roleInstanceInstance.IPAddress = ipAddressInstance;
                                        }
                                        
                                        XElement instanceEndpointsSequenceElement = roleInstanceListElement.Element(XName.Get("InstanceEndpoints", "http://schemas.microsoft.com/windowsazure"));
                                        if (instanceEndpointsSequenceElement != null)
                                        {
                                            foreach (XElement instanceEndpointsElement in instanceEndpointsSequenceElement.Elements(XName.Get("InstanceEndpoint", "http://schemas.microsoft.com/windowsazure")))
                                            {
                                                InstanceEndpoint instanceEndpointInstance = new InstanceEndpoint();
                                                roleInstanceInstance.InstanceEndpoints.Add(instanceEndpointInstance);
                                                
                                                XElement localPortElement = instanceEndpointsElement.Element(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                                                if (localPortElement != null && string.IsNullOrEmpty(localPortElement.Value) == false)
                                                {
                                                    int localPortInstance = int.Parse(localPortElement.Value, CultureInfo.InvariantCulture);
                                                    instanceEndpointInstance.LocalPort = localPortInstance;
                                                }
                                                
                                                XElement nameElement2 = instanceEndpointsElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                                if (nameElement2 != null)
                                                {
                                                    string nameInstance2 = nameElement2.Value;
                                                    instanceEndpointInstance.Name = nameInstance2;
                                                }
                                                
                                                XElement portElement = instanceEndpointsElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                                if (portElement != null)
                                                {
                                                    int portInstance = int.Parse(portElement.Value, CultureInfo.InvariantCulture);
                                                    instanceEndpointInstance.Port = portInstance;
                                                }
                                                
                                                XElement protocolElement = instanceEndpointsElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                                if (protocolElement != null)
                                                {
                                                    string protocolInstance = protocolElement.Value;
                                                    instanceEndpointInstance.Protocol = protocolInstance;
                                                }
                                                
                                                XElement vipElement = instanceEndpointsElement.Element(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                                                if (vipElement != null)
                                                {
                                                    string vipInstance = vipElement.Value;
                                                    instanceEndpointInstance.VirtualIPAddress = vipInstance;
                                                }
                                            }
                                        }
                                        
                                        XElement powerStateElement = roleInstanceListElement.Element(XName.Get("PowerState", "http://schemas.microsoft.com/windowsazure"));
                                        if (powerStateElement != null)
                                        {
                                            RoleInstancePowerState powerStateInstance = (RoleInstancePowerState)Enum.Parse(typeof(RoleInstancePowerState), powerStateElement.Value, false);
                                            roleInstanceInstance.PowerState = powerStateInstance;
                                        }
                                        
                                        XElement hostNameElement = roleInstanceListElement.Element(XName.Get("HostName", "http://schemas.microsoft.com/windowsazure"));
                                        if (hostNameElement != null)
                                        {
                                            string hostNameInstance = hostNameElement.Value;
                                            roleInstanceInstance.HostName = hostNameInstance;
                                        }
                                        
                                        XElement remoteAccessCertificateThumbprintElement = roleInstanceListElement.Element(XName.Get("RemoteAccessCertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                        if (remoteAccessCertificateThumbprintElement != null)
                                        {
                                            string remoteAccessCertificateThumbprintInstance = remoteAccessCertificateThumbprintElement.Value;
                                            roleInstanceInstance.RemoteAccessCertificateThumbprint = remoteAccessCertificateThumbprintInstance;
                                        }
                                    }
                                }
                                
                                XElement upgradeStatusElement = deploymentsElement.Element(XName.Get("UpgradeStatus", "http://schemas.microsoft.com/windowsazure"));
                                if (upgradeStatusElement != null)
                                {
                                    UpgradeStatus upgradeStatusInstance = new UpgradeStatus();
                                    deploymentInstance.UpgradeStatus = upgradeStatusInstance;
                                    
                                    XElement upgradeTypeElement = upgradeStatusElement.Element(XName.Get("UpgradeType", "http://schemas.microsoft.com/windowsazure"));
                                    if (upgradeTypeElement != null)
                                    {
                                        DeploymentUpgradeType upgradeTypeInstance = (DeploymentUpgradeType)Enum.Parse(typeof(DeploymentUpgradeType), upgradeTypeElement.Value, false);
                                        upgradeStatusInstance.UpgradeType = upgradeTypeInstance;
                                    }
                                    
                                    XElement currentUpgradeDomainStateElement = upgradeStatusElement.Element(XName.Get("CurrentUpgradeDomainState", "http://schemas.microsoft.com/windowsazure"));
                                    if (currentUpgradeDomainStateElement != null)
                                    {
                                        UpgradeDomainState currentUpgradeDomainStateInstance = (UpgradeDomainState)Enum.Parse(typeof(UpgradeDomainState), currentUpgradeDomainStateElement.Value, false);
                                        upgradeStatusInstance.CurrentUpgradeDomainState = currentUpgradeDomainStateInstance;
                                    }
                                    
                                    XElement currentUpgradeDomainElement = upgradeStatusElement.Element(XName.Get("CurrentUpgradeDomain", "http://schemas.microsoft.com/windowsazure"));
                                    if (currentUpgradeDomainElement != null)
                                    {
                                        int currentUpgradeDomainInstance = int.Parse(currentUpgradeDomainElement.Value, CultureInfo.InvariantCulture);
                                        upgradeStatusInstance.CurrentUpgradeDomain = currentUpgradeDomainInstance;
                                    }
                                }
                                
                                XElement upgradeDomainCountElement = deploymentsElement.Element(XName.Get("UpgradeDomainCount", "http://schemas.microsoft.com/windowsazure"));
                                if (upgradeDomainCountElement != null)
                                {
                                    int upgradeDomainCountInstance = int.Parse(upgradeDomainCountElement.Value, CultureInfo.InvariantCulture);
                                    deploymentInstance.UpgradeDomainCount = upgradeDomainCountInstance;
                                }
                                
                                XElement roleListSequenceElement = deploymentsElement.Element(XName.Get("RoleList", "http://schemas.microsoft.com/windowsazure"));
                                if (roleListSequenceElement != null)
                                {
                                    foreach (XElement roleListElement in roleListSequenceElement.Elements(XName.Get("Role", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        Role roleInstance = new Role();
                                        deploymentInstance.Roles.Add(roleInstance);
                                        
                                        XElement roleNameElement2 = roleListElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                                        if (roleNameElement2 != null)
                                        {
                                            string roleNameInstance2 = roleNameElement2.Value;
                                            roleInstance.RoleName = roleNameInstance2;
                                        }
                                        
                                        XElement oSVersionElement = roleListElement.Element(XName.Get("OSVersion", "http://schemas.microsoft.com/windowsazure"));
                                        if (oSVersionElement != null)
                                        {
                                            string oSVersionInstance = oSVersionElement.Value;
                                            roleInstance.OSVersion = oSVersionInstance;
                                        }
                                        
                                        XElement roleTypeElement = roleListElement.Element(XName.Get("RoleType", "http://schemas.microsoft.com/windowsazure"));
                                        if (roleTypeElement != null)
                                        {
                                            string roleTypeInstance = roleTypeElement.Value;
                                            roleInstance.RoleType = roleTypeInstance;
                                        }
                                        
                                        XElement configurationSetsSequenceElement = roleListElement.Element(XName.Get("ConfigurationSets", "http://schemas.microsoft.com/windowsazure"));
                                        if (configurationSetsSequenceElement != null)
                                        {
                                            foreach (XElement configurationSetsElement in configurationSetsSequenceElement.Elements(XName.Get("ConfigurationSet", "http://schemas.microsoft.com/windowsazure")))
                                            {
                                                ConfigurationSet configurationSetInstance = new ConfigurationSet();
                                                roleInstance.ConfigurationSets.Add(configurationSetInstance);
                                                
                                                XElement configurationSetTypeElement = configurationSetsElement.Element(XName.Get("ConfigurationSetType", "http://schemas.microsoft.com/windowsazure"));
                                                if (configurationSetTypeElement != null)
                                                {
                                                    string configurationSetTypeInstance = configurationSetTypeElement.Value;
                                                    configurationSetInstance.ConfigurationSetType = configurationSetTypeInstance;
                                                }
                                                
                                                XElement inputEndpointsSequenceElement = configurationSetsElement.Element(XName.Get("InputEndpoints", "http://schemas.microsoft.com/windowsazure"));
                                                if (inputEndpointsSequenceElement != null)
                                                {
                                                    foreach (XElement inputEndpointsElement in inputEndpointsSequenceElement.Elements(XName.Get("InputEndpoint", "http://schemas.microsoft.com/windowsazure")))
                                                    {
                                                        InputEndpoint inputEndpointInstance = new InputEndpoint();
                                                        configurationSetInstance.InputEndpoints.Add(inputEndpointInstance);
                                                        
                                                        XElement loadBalancedEndpointSetNameElement = inputEndpointsElement.Element(XName.Get("LoadBalancedEndpointSetName", "http://schemas.microsoft.com/windowsazure"));
                                                        if (loadBalancedEndpointSetNameElement != null)
                                                        {
                                                            string loadBalancedEndpointSetNameInstance = loadBalancedEndpointSetNameElement.Value;
                                                            inputEndpointInstance.LoadBalancedEndpointSetName = loadBalancedEndpointSetNameInstance;
                                                        }
                                                        
                                                        XElement localPortElement2 = inputEndpointsElement.Element(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                                                        if (localPortElement2 != null && string.IsNullOrEmpty(localPortElement2.Value) == false)
                                                        {
                                                            int localPortInstance2 = int.Parse(localPortElement2.Value, CultureInfo.InvariantCulture);
                                                            inputEndpointInstance.LocalPort = localPortInstance2;
                                                        }
                                                        
                                                        XElement nameElement3 = inputEndpointsElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                                        if (nameElement3 != null)
                                                        {
                                                            string nameInstance3 = nameElement3.Value;
                                                            inputEndpointInstance.Name = nameInstance3;
                                                        }
                                                        
                                                        XElement portElement2 = inputEndpointsElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                                        if (portElement2 != null && string.IsNullOrEmpty(portElement2.Value) == false)
                                                        {
                                                            int portInstance2 = int.Parse(portElement2.Value, CultureInfo.InvariantCulture);
                                                            inputEndpointInstance.Port = portInstance2;
                                                        }
                                                        
                                                        XElement loadBalancerProbeElement = inputEndpointsElement.Element(XName.Get("LoadBalancerProbe", "http://schemas.microsoft.com/windowsazure"));
                                                        if (loadBalancerProbeElement != null)
                                                        {
                                                            LoadBalancerProbe loadBalancerProbeInstance = new LoadBalancerProbe();
                                                            inputEndpointInstance.LoadBalancerProbe = loadBalancerProbeInstance;
                                                            
                                                            XElement pathElement = loadBalancerProbeElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                                            if (pathElement != null)
                                                            {
                                                                string pathInstance = pathElement.Value;
                                                                loadBalancerProbeInstance.Path = pathInstance;
                                                            }
                                                            
                                                            XElement portElement3 = loadBalancerProbeElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                                            if (portElement3 != null)
                                                            {
                                                                int portInstance3 = int.Parse(portElement3.Value, CultureInfo.InvariantCulture);
                                                                loadBalancerProbeInstance.Port = portInstance3;
                                                            }
                                                            
                                                            XElement protocolElement2 = loadBalancerProbeElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                                            if (protocolElement2 != null)
                                                            {
                                                                LoadBalancerProbeTransportProtocol protocolInstance2 = ComputeManagementClient.ParseLoadBalancerProbeTransportProtocol(protocolElement2.Value);
                                                                loadBalancerProbeInstance.Protocol = protocolInstance2;
                                                            }
                                                            
                                                            XElement intervalInSecondsElement = loadBalancerProbeElement.Element(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                                            if (intervalInSecondsElement != null && string.IsNullOrEmpty(intervalInSecondsElement.Value) == false)
                                                            {
                                                                int intervalInSecondsInstance = int.Parse(intervalInSecondsElement.Value, CultureInfo.InvariantCulture);
                                                                loadBalancerProbeInstance.IntervalInSeconds = intervalInSecondsInstance;
                                                            }
                                                            
                                                            XElement timeoutInSecondsElement = loadBalancerProbeElement.Element(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                                            if (timeoutInSecondsElement != null && string.IsNullOrEmpty(timeoutInSecondsElement.Value) == false)
                                                            {
                                                                int timeoutInSecondsInstance = int.Parse(timeoutInSecondsElement.Value, CultureInfo.InvariantCulture);
                                                                loadBalancerProbeInstance.TimeoutInSeconds = timeoutInSecondsInstance;
                                                            }
                                                        }
                                                        
                                                        XElement protocolElement3 = inputEndpointsElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                                        if (protocolElement3 != null)
                                                        {
                                                            string protocolInstance3 = protocolElement3.Value;
                                                            inputEndpointInstance.Protocol = protocolInstance3;
                                                        }
                                                        
                                                        XElement vipElement2 = inputEndpointsElement.Element(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                                                        if (vipElement2 != null)
                                                        {
                                                            string vipInstance2 = vipElement2.Value;
                                                            inputEndpointInstance.VirtualIPAddress = vipInstance2;
                                                        }
                                                        
                                                        XElement enableDirectServerReturnElement = inputEndpointsElement.Element(XName.Get("EnableDirectServerReturn", "http://schemas.microsoft.com/windowsazure"));
                                                        if (enableDirectServerReturnElement != null && string.IsNullOrEmpty(enableDirectServerReturnElement.Value) == false)
                                                        {
                                                            bool enableDirectServerReturnInstance = bool.Parse(enableDirectServerReturnElement.Value);
                                                            inputEndpointInstance.EnableDirectServerReturn = enableDirectServerReturnInstance;
                                                        }
                                                        
                                                        XElement accessControlListElement = inputEndpointsElement.Element(XName.Get("AccessControlList", "http://schemas.microsoft.com/windowsazure"));
                                                        if (accessControlListElement != null)
                                                        {
                                                            AccessControlList accessControlListInstance = new AccessControlList();
                                                            inputEndpointInstance.AccessControlList = accessControlListInstance;
                                                            
                                                            XElement rulesSequenceElement = accessControlListElement.Element(XName.Get("Rules", "http://schemas.microsoft.com/windowsazure"));
                                                            if (rulesSequenceElement != null)
                                                            {
                                                                foreach (XElement rulesElement in rulesSequenceElement.Elements(XName.Get("Rule", "http://schemas.microsoft.com/windowsazure")))
                                                                {
                                                                    AccessControlListRule ruleInstance = new AccessControlListRule();
                                                                    accessControlListInstance.Rules.Add(ruleInstance);
                                                                    
                                                                    XElement orderElement = rulesElement.Element(XName.Get("Order", "http://schemas.microsoft.com/windowsazure"));
                                                                    if (orderElement != null && string.IsNullOrEmpty(orderElement.Value) == false)
                                                                    {
                                                                        int orderInstance = int.Parse(orderElement.Value, CultureInfo.InvariantCulture);
                                                                        ruleInstance.Order = orderInstance;
                                                                    }
                                                                    
                                                                    XElement actionElement = rulesElement.Element(XName.Get("Action", "http://schemas.microsoft.com/windowsazure"));
                                                                    if (actionElement != null)
                                                                    {
                                                                        string actionInstance = actionElement.Value;
                                                                        ruleInstance.Action = actionInstance;
                                                                    }
                                                                    
                                                                    XElement remoteSubnetElement = rulesElement.Element(XName.Get("RemoteSubnet", "http://schemas.microsoft.com/windowsazure"));
                                                                    if (remoteSubnetElement != null)
                                                                    {
                                                                        string remoteSubnetInstance = remoteSubnetElement.Value;
                                                                        ruleInstance.RemoteSubnet = remoteSubnetInstance;
                                                                    }
                                                                    
                                                                    XElement descriptionElement = rulesElement.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                                                                    if (descriptionElement != null)
                                                                    {
                                                                        string descriptionInstance = descriptionElement.Value;
                                                                        ruleInstance.Description = descriptionInstance;
                                                                    }
                                                                }
                                                            }
                                                        }
                                                    }
                                                }
                                                
                                                XElement subnetNamesSequenceElement = configurationSetsElement.Element(XName.Get("SubnetNames", "http://schemas.microsoft.com/windowsazure"));
                                                if (subnetNamesSequenceElement != null)
                                                {
                                                    foreach (XElement subnetNamesElement in subnetNamesSequenceElement.Elements(XName.Get("SubnetName", "http://schemas.microsoft.com/windowsazure")))
                                                    {
                                                        configurationSetInstance.SubnetNames.Add(subnetNamesElement.Value);
                                                    }
                                                }
                                                
                                                XElement computerNameElement = configurationSetsElement.Element(XName.Get("ComputerName", "http://schemas.microsoft.com/windowsazure"));
                                                if (computerNameElement != null)
                                                {
                                                    string computerNameInstance = computerNameElement.Value;
                                                    configurationSetInstance.ComputerName = computerNameInstance;
                                                }
                                                
                                                XElement adminPasswordElement = configurationSetsElement.Element(XName.Get("AdminPassword", "http://schemas.microsoft.com/windowsazure"));
                                                if (adminPasswordElement != null)
                                                {
                                                    string adminPasswordInstance = adminPasswordElement.Value;
                                                    configurationSetInstance.AdminPassword = adminPasswordInstance;
                                                }
                                                
                                                XElement resetPasswordOnFirstLogonElement = configurationSetsElement.Element(XName.Get("ResetPasswordOnFirstLogon", "http://schemas.microsoft.com/windowsazure"));
                                                if (resetPasswordOnFirstLogonElement != null && string.IsNullOrEmpty(resetPasswordOnFirstLogonElement.Value) == false)
                                                {
                                                    bool resetPasswordOnFirstLogonInstance = bool.Parse(resetPasswordOnFirstLogonElement.Value);
                                                    configurationSetInstance.ResetPasswordOnFirstLogon = resetPasswordOnFirstLogonInstance;
                                                }
                                                
                                                XElement enableAutomaticUpdatesElement = configurationSetsElement.Element(XName.Get("EnableAutomaticUpdates", "http://schemas.microsoft.com/windowsazure"));
                                                if (enableAutomaticUpdatesElement != null && string.IsNullOrEmpty(enableAutomaticUpdatesElement.Value) == false)
                                                {
                                                    bool enableAutomaticUpdatesInstance = bool.Parse(enableAutomaticUpdatesElement.Value);
                                                    configurationSetInstance.EnableAutomaticUpdates = enableAutomaticUpdatesInstance;
                                                }
                                                
                                                XElement timeZoneElement = configurationSetsElement.Element(XName.Get("TimeZone", "http://schemas.microsoft.com/windowsazure"));
                                                if (timeZoneElement != null)
                                                {
                                                    string timeZoneInstance = timeZoneElement.Value;
                                                    configurationSetInstance.TimeZone = timeZoneInstance;
                                                }
                                                
                                                XElement domainJoinElement = configurationSetsElement.Element(XName.Get("DomainJoin", "http://schemas.microsoft.com/windowsazure"));
                                                if (domainJoinElement != null)
                                                {
                                                    DomainJoinSettings domainJoinInstance = new DomainJoinSettings();
                                                    configurationSetInstance.DomainJoin = domainJoinInstance;
                                                    
                                                    XElement credentialsElement = domainJoinElement.Element(XName.Get("Credentials", "http://schemas.microsoft.com/windowsazure"));
                                                    if (credentialsElement != null)
                                                    {
                                                        DomainJoinCredentials credentialsInstance = new DomainJoinCredentials();
                                                        domainJoinInstance.Credentials = credentialsInstance;
                                                        
                                                        XElement domainElement = credentialsElement.Element(XName.Get("Domain", "http://schemas.microsoft.com/windowsazure"));
                                                        if (domainElement != null)
                                                        {
                                                            string domainInstance = domainElement.Value;
                                                            credentialsInstance.Domain = domainInstance;
                                                        }
                                                        
                                                        XElement usernameElement = credentialsElement.Element(XName.Get("Username", "http://schemas.microsoft.com/windowsazure"));
                                                        if (usernameElement != null)
                                                        {
                                                            string usernameInstance = usernameElement.Value;
                                                            credentialsInstance.UserName = usernameInstance;
                                                        }
                                                        
                                                        XElement passwordElement = credentialsElement.Element(XName.Get("Password", "http://schemas.microsoft.com/windowsazure"));
                                                        if (passwordElement != null)
                                                        {
                                                            string passwordInstance = passwordElement.Value;
                                                            credentialsInstance.Password = passwordInstance;
                                                        }
                                                    }
                                                    
                                                    XElement joinDomainElement = domainJoinElement.Element(XName.Get("JoinDomain", "http://schemas.microsoft.com/windowsazure"));
                                                    if (joinDomainElement != null)
                                                    {
                                                        string joinDomainInstance = joinDomainElement.Value;
                                                        domainJoinInstance.DomainToJoin = joinDomainInstance;
                                                    }
                                                    
                                                    XElement machineObjectOUElement = domainJoinElement.Element(XName.Get("MachineObjectOU", "http://schemas.microsoft.com/windowsazure"));
                                                    if (machineObjectOUElement != null)
                                                    {
                                                        string machineObjectOUInstance = machineObjectOUElement.Value;
                                                        domainJoinInstance.LdapMachineObjectOU = machineObjectOUInstance;
                                                    }
                                                    
                                                    XElement provisioningElement = domainJoinElement.Element(XName.Get("Provisioning", "http://schemas.microsoft.com/windowsazure"));
                                                    if (provisioningElement != null)
                                                    {
                                                        DomainJoinProvisioning provisioningInstance = new DomainJoinProvisioning();
                                                        domainJoinInstance.Provisioning = provisioningInstance;
                                                        
                                                        XElement accountDataElement = provisioningElement.Element(XName.Get("AccountData", "http://schemas.microsoft.com/windowsazure"));
                                                        if (accountDataElement != null)
                                                        {
                                                            string accountDataInstance = accountDataElement.Value;
                                                            provisioningInstance.AccountData = accountDataInstance;
                                                        }
                                                    }
                                                }
                                                
                                                XElement storedCertificateSettingsSequenceElement = configurationSetsElement.Element(XName.Get("StoredCertificateSettings", "http://schemas.microsoft.com/windowsazure"));
                                                if (storedCertificateSettingsSequenceElement != null)
                                                {
                                                    foreach (XElement storedCertificateSettingsElement in storedCertificateSettingsSequenceElement.Elements(XName.Get("CertificateSetting", "http://schemas.microsoft.com/windowsazure")))
                                                    {
                                                        StoredCertificateSettings certificateSettingInstance = new StoredCertificateSettings();
                                                        configurationSetInstance.StoredCertificateSettings.Add(certificateSettingInstance);
                                                        
                                                        XElement storeLocationElement = storedCertificateSettingsElement.Element(XName.Get("StoreLocation", "http://schemas.microsoft.com/windowsazure"));
                                                        if (storeLocationElement != null)
                                                        {
                                                        }
                                                        
                                                        XElement storeNameElement = storedCertificateSettingsElement.Element(XName.Get("StoreName", "http://schemas.microsoft.com/windowsazure"));
                                                        if (storeNameElement != null)
                                                        {
                                                            string storeNameInstance = storeNameElement.Value;
                                                            certificateSettingInstance.StoreName = storeNameInstance;
                                                        }
                                                        
                                                        XElement thumbprintElement = storedCertificateSettingsElement.Element(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                                                        if (thumbprintElement != null)
                                                        {
                                                            string thumbprintInstance = thumbprintElement.Value;
                                                            certificateSettingInstance.Thumbprint = thumbprintInstance;
                                                        }
                                                    }
                                                }
                                                
                                                XElement winRMElement = configurationSetsElement.Element(XName.Get("WinRM", "http://schemas.microsoft.com/windowsazure"));
                                                if (winRMElement != null)
                                                {
                                                    WindowsRemoteManagementSettings winRMInstance = new WindowsRemoteManagementSettings();
                                                    configurationSetInstance.WindowsRemoteManagement = winRMInstance;
                                                    
                                                    XElement listenersSequenceElement = winRMElement.Element(XName.Get("Listeners", "http://schemas.microsoft.com/windowsazure"));
                                                    if (listenersSequenceElement != null)
                                                    {
                                                        foreach (XElement listenersElement in listenersSequenceElement.Elements(XName.Get("Listener", "http://schemas.microsoft.com/windowsazure")))
                                                        {
                                                            WindowsRemoteManagementListener listenerInstance = new WindowsRemoteManagementListener();
                                                            winRMInstance.Listeners.Add(listenerInstance);
                                                            
                                                            XElement protocolElement4 = listenersElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                                            if (protocolElement4 != null)
                                                            {
                                                                VirtualMachineWindowsRemoteManagementListenerType protocolInstance4 = (VirtualMachineWindowsRemoteManagementListenerType)Enum.Parse(typeof(VirtualMachineWindowsRemoteManagementListenerType), protocolElement4.Value, false);
                                                                listenerInstance.ListenerType = protocolInstance4;
                                                            }
                                                            
                                                            XElement certificateThumbprintElement = listenersElement.Element(XName.Get("CertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                                            if (certificateThumbprintElement != null)
                                                            {
                                                                string certificateThumbprintInstance = certificateThumbprintElement.Value;
                                                                listenerInstance.CertificateThumbprint = certificateThumbprintInstance;
                                                            }
                                                        }
                                                    }
                                                }
                                                
                                                XElement adminUsernameElement = configurationSetsElement.Element(XName.Get("AdminUsername", "http://schemas.microsoft.com/windowsazure"));
                                                if (adminUsernameElement != null)
                                                {
                                                    string adminUsernameInstance = adminUsernameElement.Value;
                                                    configurationSetInstance.AdminUserName = adminUsernameInstance;
                                                }
                                                
                                                XElement hostNameElement2 = configurationSetsElement.Element(XName.Get("HostName", "http://schemas.microsoft.com/windowsazure"));
                                                if (hostNameElement2 != null)
                                                {
                                                    string hostNameInstance2 = hostNameElement2.Value;
                                                    configurationSetInstance.HostName = hostNameInstance2;
                                                }
                                                
                                                XElement userNameElement = configurationSetsElement.Element(XName.Get("UserName", "http://schemas.microsoft.com/windowsazure"));
                                                if (userNameElement != null)
                                                {
                                                    string userNameInstance = userNameElement.Value;
                                                    configurationSetInstance.UserName = userNameInstance;
                                                }
                                                
                                                XElement userPasswordElement = configurationSetsElement.Element(XName.Get("UserPassword", "http://schemas.microsoft.com/windowsazure"));
                                                if (userPasswordElement != null)
                                                {
                                                    string userPasswordInstance = userPasswordElement.Value;
                                                    configurationSetInstance.UserPassword = userPasswordInstance;
                                                }
                                                
                                                XElement disableSshPasswordAuthenticationElement = configurationSetsElement.Element(XName.Get("DisableSshPasswordAuthentication", "http://schemas.microsoft.com/windowsazure"));
                                                if (disableSshPasswordAuthenticationElement != null && string.IsNullOrEmpty(disableSshPasswordAuthenticationElement.Value) == false)
                                                {
                                                    bool disableSshPasswordAuthenticationInstance = bool.Parse(disableSshPasswordAuthenticationElement.Value);
                                                    configurationSetInstance.DisableSshPasswordAuthentication = disableSshPasswordAuthenticationInstance;
                                                }
                                                
                                                XElement sSHElement = configurationSetsElement.Element(XName.Get("SSH", "http://schemas.microsoft.com/windowsazure"));
                                                if (sSHElement != null)
                                                {
                                                    SshSettings sSHInstance = new SshSettings();
                                                    configurationSetInstance.SshSettings = sSHInstance;
                                                    
                                                    XElement publicKeysSequenceElement = sSHElement.Element(XName.Get("PublicKeys", "http://schemas.microsoft.com/windowsazure"));
                                                    if (publicKeysSequenceElement != null)
                                                    {
                                                        foreach (XElement publicKeysElement in publicKeysSequenceElement.Elements(XName.Get("PublicKey", "http://schemas.microsoft.com/windowsazure")))
                                                        {
                                                            SshSettingPublicKey publicKeyInstance = new SshSettingPublicKey();
                                                            sSHInstance.PublicKeys.Add(publicKeyInstance);
                                                            
                                                            XElement fingerPrintElement = publicKeysElement.Element(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                                            if (fingerPrintElement != null)
                                                            {
                                                                string fingerPrintInstance = fingerPrintElement.Value;
                                                                publicKeyInstance.Fingerprint = fingerPrintInstance;
                                                            }
                                                            
                                                            XElement pathElement2 = publicKeysElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                                            if (pathElement2 != null)
                                                            {
                                                                string pathInstance2 = pathElement2.Value;
                                                                publicKeyInstance.Path = pathInstance2;
                                                            }
                                                        }
                                                    }
                                                    
                                                    XElement keyPairsSequenceElement = sSHElement.Element(XName.Get("KeyPairs", "http://schemas.microsoft.com/windowsazure"));
                                                    if (keyPairsSequenceElement != null)
                                                    {
                                                        foreach (XElement keyPairsElement in keyPairsSequenceElement.Elements(XName.Get("KeyPair", "http://schemas.microsoft.com/windowsazure")))
                                                        {
                                                            SshSettingKeyPair keyPairInstance = new SshSettingKeyPair();
                                                            sSHInstance.KeyPairs.Add(keyPairInstance);
                                                            
                                                            XElement fingerPrintElement2 = keyPairsElement.Element(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                                            if (fingerPrintElement2 != null)
                                                            {
                                                                string fingerPrintInstance2 = fingerPrintElement2.Value;
                                                                keyPairInstance.Fingerprint = fingerPrintInstance2;
                                                            }
                                                            
                                                            XElement pathElement3 = keyPairsElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                                            if (pathElement3 != null)
                                                            {
                                                                string pathInstance3 = pathElement3.Value;
                                                                keyPairInstance.Path = pathInstance3;
                                                            }
                                                        }
                                                    }
                                                }
                                            }
                                        }
                                        
                                        XElement availabilitySetNameElement = roleListElement.Element(XName.Get("AvailabilitySetName", "http://schemas.microsoft.com/windowsazure"));
                                        if (availabilitySetNameElement != null)
                                        {
                                            string availabilitySetNameInstance = availabilitySetNameElement.Value;
                                            roleInstance.AvailabilitySetName = availabilitySetNameInstance;
                                        }
                                        
                                        XElement dataVirtualHardDisksSequenceElement = roleListElement.Element(XName.Get("DataVirtualHardDisks", "http://schemas.microsoft.com/windowsazure"));
                                        if (dataVirtualHardDisksSequenceElement != null)
                                        {
                                            foreach (XElement dataVirtualHardDisksElement in dataVirtualHardDisksSequenceElement.Elements(XName.Get("DataVirtualHardDisk", "http://schemas.microsoft.com/windowsazure")))
                                            {
                                                DataVirtualHardDisk dataVirtualHardDiskInstance = new DataVirtualHardDisk();
                                                roleInstance.DataVirtualHardDisks.Add(dataVirtualHardDiskInstance);
                                                
                                                XElement hostCachingElement = dataVirtualHardDisksElement.Element(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                                                if (hostCachingElement != null && string.IsNullOrEmpty(hostCachingElement.Value) == false)
                                                {
                                                    VirtualHardDiskHostCaching hostCachingInstance = (VirtualHardDiskHostCaching)Enum.Parse(typeof(VirtualHardDiskHostCaching), hostCachingElement.Value, false);
                                                    dataVirtualHardDiskInstance.HostCaching = hostCachingInstance;
                                                }
                                                
                                                XElement diskLabelElement = dataVirtualHardDisksElement.Element(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                                                if (diskLabelElement != null)
                                                {
                                                    string diskLabelInstance = diskLabelElement.Value;
                                                    dataVirtualHardDiskInstance.DiskLabel = diskLabelInstance;
                                                }
                                                
                                                XElement diskNameElement = dataVirtualHardDisksElement.Element(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                                                if (diskNameElement != null)
                                                {
                                                    string diskNameInstance = diskNameElement.Value;
                                                    dataVirtualHardDiskInstance.DiskName = diskNameInstance;
                                                }
                                                
                                                XElement lunElement = dataVirtualHardDisksElement.Element(XName.Get("Lun", "http://schemas.microsoft.com/windowsazure"));
                                                if (lunElement != null && string.IsNullOrEmpty(lunElement.Value) == false)
                                                {
                                                    int lunInstance = int.Parse(lunElement.Value, CultureInfo.InvariantCulture);
                                                    dataVirtualHardDiskInstance.LogicalUnitNumber = lunInstance;
                                                }
                                                
                                                XElement logicalDiskSizeInGBElement = dataVirtualHardDisksElement.Element(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                                                if (logicalDiskSizeInGBElement != null)
                                                {
                                                    int logicalDiskSizeInGBInstance = int.Parse(logicalDiskSizeInGBElement.Value, CultureInfo.InvariantCulture);
                                                    dataVirtualHardDiskInstance.LogicalDiskSizeInGB = logicalDiskSizeInGBInstance;
                                                }
                                                
                                                XElement mediaLinkElement = dataVirtualHardDisksElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                                                if (mediaLinkElement != null)
                                                {
                                                    Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement.Value);
                                                    dataVirtualHardDiskInstance.MediaLink = mediaLinkInstance;
                                                }
                                            }
                                        }
                                        
                                        XElement labelElement2 = roleListElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                                        if (labelElement2 != null)
                                        {
                                            string labelInstance2 = labelElement2.Value;
                                            roleInstance.Label = labelInstance2;
                                        }
                                        
                                        XElement oSVirtualHardDiskElement = roleListElement.Element(XName.Get("OSVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                                        if (oSVirtualHardDiskElement != null)
                                        {
                                            OSVirtualHardDisk oSVirtualHardDiskInstance = new OSVirtualHardDisk();
                                            roleInstance.OSVirtualHardDisk = oSVirtualHardDiskInstance;
                                            
                                            XElement hostCachingElement2 = oSVirtualHardDiskElement.Element(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                                            if (hostCachingElement2 != null && string.IsNullOrEmpty(hostCachingElement2.Value) == false)
                                            {
                                                VirtualHardDiskHostCaching hostCachingInstance2 = (VirtualHardDiskHostCaching)Enum.Parse(typeof(VirtualHardDiskHostCaching), hostCachingElement2.Value, false);
                                                oSVirtualHardDiskInstance.HostCaching = hostCachingInstance2;
                                            }
                                            
                                            XElement diskLabelElement2 = oSVirtualHardDiskElement.Element(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                                            if (diskLabelElement2 != null)
                                            {
                                                string diskLabelInstance2 = diskLabelElement2.Value;
                                                oSVirtualHardDiskInstance.DiskLabel = diskLabelInstance2;
                                            }
                                            
                                            XElement diskNameElement2 = oSVirtualHardDiskElement.Element(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                                            if (diskNameElement2 != null)
                                            {
                                                string diskNameInstance2 = diskNameElement2.Value;
                                                oSVirtualHardDiskInstance.DiskName = diskNameInstance2;
                                            }
                                            
                                            XElement mediaLinkElement2 = oSVirtualHardDiskElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                                            if (mediaLinkElement2 != null)
                                            {
                                                Uri mediaLinkInstance2 = TypeConversion.TryParseUri(mediaLinkElement2.Value);
                                                oSVirtualHardDiskInstance.MediaLink = mediaLinkInstance2;
                                            }
                                            
                                            XElement sourceImageNameElement = oSVirtualHardDiskElement.Element(XName.Get("SourceImageName", "http://schemas.microsoft.com/windowsazure"));
                                            if (sourceImageNameElement != null)
                                            {
                                                string sourceImageNameInstance = sourceImageNameElement.Value;
                                                oSVirtualHardDiskInstance.SourceImageName = sourceImageNameInstance;
                                            }
                                            
                                            XElement osElement = oSVirtualHardDiskElement.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                                            if (osElement != null)
                                            {
                                                string osInstance = osElement.Value;
                                                oSVirtualHardDiskInstance.OperatingSystem = osInstance;
                                            }
                                        }
                                        
                                        XElement roleSizeElement = roleListElement.Element(XName.Get("RoleSize", "http://schemas.microsoft.com/windowsazure"));
                                        if (roleSizeElement != null && string.IsNullOrEmpty(roleSizeElement.Value) == false)
                                        {
                                            VirtualMachineRoleSize roleSizeInstance = (VirtualMachineRoleSize)Enum.Parse(typeof(VirtualMachineRoleSize), roleSizeElement.Value, false);
                                            roleInstance.RoleSize = roleSizeInstance;
                                        }
                                        
                                        XElement defaultWinRmCertificateThumbprintElement = roleListElement.Element(XName.Get("DefaultWinRmCertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                        if (defaultWinRmCertificateThumbprintElement != null)
                                        {
                                            string defaultWinRmCertificateThumbprintInstance = defaultWinRmCertificateThumbprintElement.Value;
                                            roleInstance.DefaultWinRmCertificateThumbprint = defaultWinRmCertificateThumbprintInstance;
                                        }
                                    }
                                }
                                
                                XElement sdkVersionElement = deploymentsElement.Element(XName.Get("SdkVersion", "http://schemas.microsoft.com/windowsazure"));
                                if (sdkVersionElement != null)
                                {
                                    string sdkVersionInstance = sdkVersionElement.Value;
                                    deploymentInstance.SdkVersion = sdkVersionInstance;
                                }
                                
                                XElement lockedElement = deploymentsElement.Element(XName.Get("Locked", "http://schemas.microsoft.com/windowsazure"));
                                if (lockedElement != null)
                                {
                                    bool lockedInstance = bool.Parse(lockedElement.Value);
                                    deploymentInstance.Locked = lockedInstance;
                                }
                                
                                XElement rollbackAllowedElement = deploymentsElement.Element(XName.Get("RollbackAllowed", "http://schemas.microsoft.com/windowsazure"));
                                if (rollbackAllowedElement != null)
                                {
                                    string rollbackAllowedInstance = rollbackAllowedElement.Value;
                                    deploymentInstance.RollbackAllowed = rollbackAllowedInstance;
                                }
                                
                                XElement createdTimeElement = deploymentsElement.Element(XName.Get("CreatedTime", "http://schemas.microsoft.com/windowsazure"));
                                if (createdTimeElement != null)
                                {
                                    DateTime createdTimeInstance = DateTime.Parse(createdTimeElement.Value, CultureInfo.InvariantCulture);
                                    deploymentInstance.CreatedTime = createdTimeInstance;
                                }
                                
                                XElement lastModifiedTimeElement = deploymentsElement.Element(XName.Get("LastModifiedTime", "http://schemas.microsoft.com/windowsazure"));
                                if (lastModifiedTimeElement != null)
                                {
                                    string lastModifiedTimeInstance = lastModifiedTimeElement.Value;
                                    deploymentInstance.LastModifiedTime = lastModifiedTimeInstance;
                                }
                                
                                XElement virtualNetworkNameElement = deploymentsElement.Element(XName.Get("VirtualNetworkName", "http://schemas.microsoft.com/windowsazure"));
                                if (virtualNetworkNameElement != null)
                                {
                                    string virtualNetworkNameInstance = virtualNetworkNameElement.Value;
                                    deploymentInstance.VirtualNetworkName = virtualNetworkNameInstance;
                                }
                                
                                XElement extendedPropertiesSequenceElement = deploymentsElement.Element(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                                if (extendedPropertiesSequenceElement != null)
                                {
                                    foreach (XElement extendedPropertiesElement in extendedPropertiesSequenceElement.Elements(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        string extendedPropertiesKey = extendedPropertiesElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure")).Value;
                                        string extendedPropertiesValue = extendedPropertiesElement.Element(XName.Get("Value", "http://schemas.microsoft.com/windowsazure")).Value;
                                        deploymentInstance.ExtendedProperties.Add(extendedPropertiesKey, extendedPropertiesValue);
                                    }
                                }
                                
                                XElement persistentVMDowntimeElement = deploymentsElement.Element(XName.Get("PersistentVMDowntime", "http://schemas.microsoft.com/windowsazure"));
                                if (persistentVMDowntimeElement != null)
                                {
                                    PersistentVMDowntime persistentVMDowntimeInstance = new PersistentVMDowntime();
                                    deploymentInstance.PersistentVMDowntime = persistentVMDowntimeInstance;
                                    
                                    XElement startTimeElement = persistentVMDowntimeElement.Element(XName.Get("StartTime", "http://schemas.microsoft.com/windowsazure"));
                                    if (startTimeElement != null)
                                    {
                                        DateTime startTimeInstance = DateTime.Parse(startTimeElement.Value, CultureInfo.InvariantCulture);
                                        persistentVMDowntimeInstance.StartTime = startTimeInstance;
                                    }
                                    
                                    XElement endTimeElement = persistentVMDowntimeElement.Element(XName.Get("EndTime", "http://schemas.microsoft.com/windowsazure"));
                                    if (endTimeElement != null)
                                    {
                                        DateTime endTimeInstance = DateTime.Parse(endTimeElement.Value, CultureInfo.InvariantCulture);
                                        persistentVMDowntimeInstance.EndTime = endTimeInstance;
                                    }
                                    
                                    XElement statusElement2 = persistentVMDowntimeElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                                    if (statusElement2 != null)
                                    {
                                        string statusInstance2 = statusElement2.Value;
                                        persistentVMDowntimeInstance.Status = statusInstance2;
                                    }
                                }
                                
                                XElement virtualIPsSequenceElement = deploymentsElement.Element(XName.Get("VirtualIPs", "http://schemas.microsoft.com/windowsazure"));
                                if (virtualIPsSequenceElement != null)
                                {
                                    foreach (XElement virtualIPsElement in virtualIPsSequenceElement.Elements(XName.Get("VirtualIPAddress", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        VirtualIPAddress virtualIPAddressInstance = new VirtualIPAddress();
                                        deploymentInstance.VirtualIPAddresses.Add(virtualIPAddressInstance);
                                        
                                        XElement addressElement = virtualIPsElement.Element(XName.Get("Address", "http://schemas.microsoft.com/windowsazure"));
                                        if (addressElement != null)
                                        {
                                            string addressInstance = addressElement.Value;
                                            virtualIPAddressInstance.Address = addressInstance;
                                        }
                                    }
                                }
                                
                                XElement dnsElement = deploymentsElement.Element(XName.Get("Dns", "http://schemas.microsoft.com/windowsazure"));
                                if (dnsElement != null)
                                {
                                    DnsSettings dnsInstance = new DnsSettings();
                                    deploymentInstance.DnsSettings = dnsInstance;
                                    
                                    XElement dnsServersSequenceElement = dnsElement.Element(XName.Get("DnsServers", "http://schemas.microsoft.com/windowsazure"));
                                    if (dnsServersSequenceElement != null)
                                    {
                                        foreach (XElement dnsServersElement in dnsServersSequenceElement.Elements(XName.Get("DnsServer", "http://schemas.microsoft.com/windowsazure")))
                                        {
                                            DnsServer dnsServerInstance = new DnsServer();
                                            dnsInstance.DnsServers.Add(dnsServerInstance);
                                            
                                            XElement nameElement4 = dnsServersElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                            if (nameElement4 != null)
                                            {
                                                string nameInstance4 = nameElement4.Value;
                                                dnsServerInstance.Name = nameInstance4;
                                            }
                                            
                                            XElement addressElement2 = dnsServersElement.Element(XName.Get("Address", "http://schemas.microsoft.com/windowsazure"));
                                            if (addressElement2 != null)
                                            {
                                                string addressInstance2 = addressElement2.Value;
                                                dnsServerInstance.Address = addressInstance2;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        XElement urlElement2 = hostedServiceElement.Element(XName.Get("Url", "http://schemas.microsoft.com/windowsazure"));
                        if (urlElement2 != null)
                        {
                            Uri urlInstance2 = TypeConversion.TryParseUri(urlElement2.Value);
                            result.Uri = urlInstance2;
                        }
                        
                        XElement serviceNameElement = hostedServiceElement.Element(XName.Get("ServiceName", "http://schemas.microsoft.com/windowsazure"));
                        if (serviceNameElement != null)
                        {
                            string serviceNameInstance = serviceNameElement.Value;
                            result.ServiceName = serviceNameInstance;
                        }
                        
                        XElement hostedServicePropertiesElement = hostedServiceElement.Element(XName.Get("HostedServiceProperties", "http://schemas.microsoft.com/windowsazure"));
                        if (hostedServicePropertiesElement != null)
                        {
                            HostedServiceProperties hostedServicePropertiesInstance = new HostedServiceProperties();
                            result.Properties = hostedServicePropertiesInstance;
                            
                            XElement descriptionElement2 = hostedServicePropertiesElement.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                            if (descriptionElement2 != null)
                            {
                                string descriptionInstance2 = descriptionElement2.Value;
                                hostedServicePropertiesInstance.Description = descriptionInstance2;
                            }
                            
                            XElement affinityGroupElement = hostedServicePropertiesElement.Element(XName.Get("AffinityGroup", "http://schemas.microsoft.com/windowsazure"));
                            if (affinityGroupElement != null)
                            {
                                string affinityGroupInstance = affinityGroupElement.Value;
                                hostedServicePropertiesInstance.AffinityGroup = affinityGroupInstance;
                            }
                            
                            XElement locationElement = hostedServicePropertiesElement.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                            if (locationElement != null)
                            {
                                string locationInstance = locationElement.Value;
                                hostedServicePropertiesInstance.Location = locationInstance;
                            }
                            
                            XElement labelElement3 = hostedServicePropertiesElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                            if (labelElement3 != null)
                            {
                                string labelInstance3 = TypeConversion.FromBase64String(labelElement3.Value);
                                hostedServicePropertiesInstance.Label = labelInstance3;
                            }
                            
                            XElement statusElement3 = hostedServicePropertiesElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                            if (statusElement3 != null)
                            {
                                HostedServiceStatus statusInstance3 = (HostedServiceStatus)Enum.Parse(typeof(HostedServiceStatus), statusElement3.Value, false);
                                hostedServicePropertiesInstance.Status = statusInstance3;
                            }
                            
                            XElement dateCreatedElement = hostedServicePropertiesElement.Element(XName.Get("DateCreated", "http://schemas.microsoft.com/windowsazure"));
                            if (dateCreatedElement != null)
                            {
                                DateTime dateCreatedInstance = DateTime.Parse(dateCreatedElement.Value, CultureInfo.InvariantCulture);
                                hostedServicePropertiesInstance.DateCreated = dateCreatedInstance;
                            }
                            
                            XElement dateLastModifiedElement = hostedServicePropertiesElement.Element(XName.Get("DateLastModified", "http://schemas.microsoft.com/windowsazure"));
                            if (dateLastModifiedElement != null)
                            {
                                DateTime dateLastModifiedInstance = DateTime.Parse(dateLastModifiedElement.Value, CultureInfo.InvariantCulture);
                                hostedServicePropertiesInstance.DateLastModified = dateLastModifiedInstance;
                            }
                            
                            XElement extendedPropertiesSequenceElement2 = hostedServicePropertiesElement.Element(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                            if (extendedPropertiesSequenceElement2 != null)
                            {
                                foreach (XElement extendedPropertiesElement2 in extendedPropertiesSequenceElement2.Elements(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    string extendedPropertiesKey2 = extendedPropertiesElement2.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure")).Value;
                                    string extendedPropertiesValue2 = extendedPropertiesElement2.Element(XName.Get("Value", "http://schemas.microsoft.com/windowsazure")).Value;
                                    hostedServicePropertiesInstance.ExtendedProperties.Add(extendedPropertiesKey2, extendedPropertiesValue2);
                                }
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The List Hosted Services operation lists the cloud services
        /// available under the current subscription.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460781.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Hosted Service operation response.
        /// </returns>
        public async Task<HostedServiceListResponse> ListAsync(CancellationToken cancellationToken)
        {
            // Validate
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                Tracing.Enter(invocationId, this, "ListAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    HostedServiceListResponse result = new HostedServiceListResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement hostedServicesSequenceElement = responseDoc.Element(XName.Get("HostedServices", "http://schemas.microsoft.com/windowsazure"));
                    if (hostedServicesSequenceElement != null)
                    {
                        foreach (XElement hostedServicesElement in hostedServicesSequenceElement.Elements(XName.Get("HostedService", "http://schemas.microsoft.com/windowsazure")))
                        {
                            HostedServiceListResponse.HostedService hostedServiceInstance = new HostedServiceListResponse.HostedService();
                            result.HostedServices.Add(hostedServiceInstance);
                            
                            XElement urlElement = hostedServicesElement.Element(XName.Get("Url", "http://schemas.microsoft.com/windowsazure"));
                            if (urlElement != null)
                            {
                                Uri urlInstance = TypeConversion.TryParseUri(urlElement.Value);
                                hostedServiceInstance.Uri = urlInstance;
                            }
                            
                            XElement serviceNameElement = hostedServicesElement.Element(XName.Get("ServiceName", "http://schemas.microsoft.com/windowsazure"));
                            if (serviceNameElement != null)
                            {
                                string serviceNameInstance = serviceNameElement.Value;
                                hostedServiceInstance.ServiceName = serviceNameInstance;
                            }
                            
                            XElement hostedServicePropertiesElement = hostedServicesElement.Element(XName.Get("HostedServiceProperties", "http://schemas.microsoft.com/windowsazure"));
                            if (hostedServicePropertiesElement != null)
                            {
                                HostedServiceProperties hostedServicePropertiesInstance = new HostedServiceProperties();
                                hostedServiceInstance.Properties = hostedServicePropertiesInstance;
                                
                                XElement descriptionElement = hostedServicePropertiesElement.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                                if (descriptionElement != null)
                                {
                                    string descriptionInstance = descriptionElement.Value;
                                    hostedServicePropertiesInstance.Description = descriptionInstance;
                                }
                                
                                XElement affinityGroupElement = hostedServicePropertiesElement.Element(XName.Get("AffinityGroup", "http://schemas.microsoft.com/windowsazure"));
                                if (affinityGroupElement != null)
                                {
                                    string affinityGroupInstance = affinityGroupElement.Value;
                                    hostedServicePropertiesInstance.AffinityGroup = affinityGroupInstance;
                                }
                                
                                XElement locationElement = hostedServicePropertiesElement.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                                if (locationElement != null)
                                {
                                    string locationInstance = locationElement.Value;
                                    hostedServicePropertiesInstance.Location = locationInstance;
                                }
                                
                                XElement labelElement = hostedServicePropertiesElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                                if (labelElement != null)
                                {
                                    string labelInstance = TypeConversion.FromBase64String(labelElement.Value);
                                    hostedServicePropertiesInstance.Label = labelInstance;
                                }
                                
                                XElement statusElement = hostedServicePropertiesElement.Element(XName.Get("Status", "http://schemas.microsoft.com/windowsazure"));
                                if (statusElement != null)
                                {
                                    HostedServiceStatus statusInstance = (HostedServiceStatus)Enum.Parse(typeof(HostedServiceStatus), statusElement.Value, false);
                                    hostedServicePropertiesInstance.Status = statusInstance;
                                }
                                
                                XElement dateCreatedElement = hostedServicePropertiesElement.Element(XName.Get("DateCreated", "http://schemas.microsoft.com/windowsazure"));
                                if (dateCreatedElement != null)
                                {
                                    DateTime dateCreatedInstance = DateTime.Parse(dateCreatedElement.Value, CultureInfo.InvariantCulture);
                                    hostedServicePropertiesInstance.DateCreated = dateCreatedInstance;
                                }
                                
                                XElement dateLastModifiedElement = hostedServicePropertiesElement.Element(XName.Get("DateLastModified", "http://schemas.microsoft.com/windowsazure"));
                                if (dateLastModifiedElement != null)
                                {
                                    DateTime dateLastModifiedInstance = DateTime.Parse(dateLastModifiedElement.Value, CultureInfo.InvariantCulture);
                                    hostedServicePropertiesInstance.DateLastModified = dateLastModifiedInstance;
                                }
                                
                                XElement extendedPropertiesSequenceElement = hostedServicePropertiesElement.Element(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                                if (extendedPropertiesSequenceElement != null)
                                {
                                    foreach (XElement extendedPropertiesElement in extendedPropertiesSequenceElement.Elements(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        string extendedPropertiesKey = extendedPropertiesElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure")).Value;
                                        string extendedPropertiesValue = extendedPropertiesElement.Element(XName.Get("Value", "http://schemas.microsoft.com/windowsazure")).Value;
                                        hostedServicePropertiesInstance.ExtendedProperties.Add(extendedPropertiesKey, extendedPropertiesValue);
                                    }
                                }
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Update Hosted Service operation can update the label or
        /// description of a cloud service in Windows Azure.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441303.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of the cloud service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Hosted Service operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> UpdateAsync(string serviceName, HostedServiceUpdateParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.Description != null && parameters.Description.Length > 1024)
            {
                throw new ArgumentOutOfRangeException("parameters.Description");
            }
            int labelCount = (parameters.Label != null ? 1 : 0) + (parameters.Description != null ? 1 : 0);
            if (labelCount < 1)
            {
                throw new ArgumentException("Expected at least one of parameters.Label, parameters.Description to be provided.");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "UpdateAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Put;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement updateHostedServiceElement = new XElement(XName.Get("UpdateHostedService", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(updateHostedServiceElement);
                
                if (parameters.Label != null)
                {
                    XElement labelElement = new XElement(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                    labelElement.Value = TypeConversion.ToBase64String(parameters.Label);
                    updateHostedServiceElement.Add(labelElement);
                }
                
                if (parameters.Description != null)
                {
                    XElement descriptionElement = new XElement(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                    descriptionElement.Value = parameters.Description;
                    updateHostedServiceElement.Add(descriptionElement);
                }
                
                if (parameters.ExtendedProperties != null)
                {
                    XElement extendedPropertiesDictionaryElement = new XElement(XName.Get("ExtendedProperties", "http://schemas.microsoft.com/windowsazure"));
                    foreach (KeyValuePair<string, string> pair in parameters.ExtendedProperties)
                    {
                        string extendedPropertiesKey = pair.Key;
                        string extendedPropertiesValue = pair.Value;
                        XElement extendedPropertiesElement = new XElement(XName.Get("ExtendedProperty", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesDictionaryElement.Add(extendedPropertiesElement);
                        
                        XElement extendedPropertiesKeyElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesKeyElement.Value = extendedPropertiesKey;
                        extendedPropertiesElement.Add(extendedPropertiesKeyElement);
                        
                        XElement extendedPropertiesValueElement = new XElement(XName.Get("Value", "http://schemas.microsoft.com/windowsazure"));
                        extendedPropertiesValueElement.Value = extendedPropertiesValue;
                        extendedPropertiesElement.Add(extendedPropertiesValueElement);
                    }
                    updateHostedServiceElement.Add(extendedPropertiesDictionaryElement);
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
    }
    
    /// <summary>
    /// Operations for determining the version of the Windows Azure Guest
    /// Operating System on which your service is running.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ff684169.aspx for
    /// more information)
    /// </summary>
    public partial interface IOperatingSystemOperations
    {
        /// <summary>
        /// The List Operating Systems operation lists the versions of the
        /// guest operating system that are currently available in Windows
        /// Azure. The 2010-10-28 version of List Operating Systems also
        /// indicates what family an operating system version belongs to.
        /// Currently Windows Azure supports two operating system families:
        /// the Windows Azure guest operating system that is substantially
        /// compatible with Windows Server 2008 SP2, and the Windows Azure
        /// guest operating system that is substantially compatible with
        /// Windows Server 2008 R2.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ff684168.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Operating Systems operation response.
        /// </returns>
        Task<OperatingSystemListResponse> ListAsync(CancellationToken cancellationToken);
        
        /// <summary>
        /// The List OS Families operation lists the guest operating system
        /// families available in Windows Azure, and also lists the operating
        /// system versions available for each family. Currently Windows Azure
        /// supports two operating system families: the Windows Azure guest
        /// operating system that is substantially compatible with Windows
        /// Server 2008 SP2, and the Windows Azure guest operating system that
        /// is substantially compatible with Windows Server 2008 R2.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441291.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Operating System Families operation response.
        /// </returns>
        Task<OperatingSystemListFamiliesResponse> ListFamiliesAsync(CancellationToken cancellationToken);
    }
    
    /// <summary>
    /// Operations for determining the version of the Windows Azure Guest
    /// Operating System on which your service is running.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ff684169.aspx for
    /// more information)
    /// </summary>
    public static partial class OperatingSystemOperationsExtensions
    {
        /// <summary>
        /// The List Operating Systems operation lists the versions of the
        /// guest operating system that are currently available in Windows
        /// Azure. The 2010-10-28 version of List Operating Systems also
        /// indicates what family an operating system version belongs to.
        /// Currently Windows Azure supports two operating system families:
        /// the Windows Azure guest operating system that is substantially
        /// compatible with Windows Server 2008 SP2, and the Windows Azure
        /// guest operating system that is substantially compatible with
        /// Windows Server 2008 R2.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ff684168.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IOperatingSystemOperations.
        /// </param>
        /// <returns>
        /// The List Operating Systems operation response.
        /// </returns>
        public static OperatingSystemListResponse List(this IOperatingSystemOperations operations)
        {
            try
            {
                return operations.ListAsync().Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The List Operating Systems operation lists the versions of the
        /// guest operating system that are currently available in Windows
        /// Azure. The 2010-10-28 version of List Operating Systems also
        /// indicates what family an operating system version belongs to.
        /// Currently Windows Azure supports two operating system families:
        /// the Windows Azure guest operating system that is substantially
        /// compatible with Windows Server 2008 SP2, and the Windows Azure
        /// guest operating system that is substantially compatible with
        /// Windows Server 2008 R2.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ff684168.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IOperatingSystemOperations.
        /// </param>
        /// <returns>
        /// The List Operating Systems operation response.
        /// </returns>
        public static Task<OperatingSystemListResponse> ListAsync(this IOperatingSystemOperations operations)
        {
            return operations.ListAsync(CancellationToken.None);
        }
        
        /// <summary>
        /// The List OS Families operation lists the guest operating system
        /// families available in Windows Azure, and also lists the operating
        /// system versions available for each family. Currently Windows Azure
        /// supports two operating system families: the Windows Azure guest
        /// operating system that is substantially compatible with Windows
        /// Server 2008 SP2, and the Windows Azure guest operating system that
        /// is substantially compatible with Windows Server 2008 R2.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441291.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IOperatingSystemOperations.
        /// </param>
        /// <returns>
        /// The List Operating System Families operation response.
        /// </returns>
        public static OperatingSystemListFamiliesResponse ListFamilies(this IOperatingSystemOperations operations)
        {
            try
            {
                return operations.ListFamiliesAsync().Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The List OS Families operation lists the guest operating system
        /// families available in Windows Azure, and also lists the operating
        /// system versions available for each family. Currently Windows Azure
        /// supports two operating system families: the Windows Azure guest
        /// operating system that is substantially compatible with Windows
        /// Server 2008 SP2, and the Windows Azure guest operating system that
        /// is substantially compatible with Windows Server 2008 R2.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441291.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IOperatingSystemOperations.
        /// </param>
        /// <returns>
        /// The List Operating System Families operation response.
        /// </returns>
        public static Task<OperatingSystemListFamiliesResponse> ListFamiliesAsync(this IOperatingSystemOperations operations)
        {
            return operations.ListFamiliesAsync(CancellationToken.None);
        }
    }
    
    /// <summary>
    /// Operations for determining the version of the Windows Azure Guest
    /// Operating System on which your service is running.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ff684169.aspx for
    /// more information)
    /// </summary>
    internal partial class OperatingSystemOperations : IServiceOperations<ComputeManagementClient>, IOperatingSystemOperations
    {
        /// <summary>
        /// Initializes a new instance of the OperatingSystemOperations class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        internal OperatingSystemOperations(ComputeManagementClient client)
        {
            this._client = client;
        }
        
        private ComputeManagementClient _client;
        
        /// <summary>
        /// Gets a reference to the
        /// Microsoft.WindowsAzure.Management.Compute.ComputeManagementClient.
        /// </summary>
        public ComputeManagementClient Client
        {
            get { return this._client; }
        }
        
        /// <summary>
        /// The List Operating Systems operation lists the versions of the
        /// guest operating system that are currently available in Windows
        /// Azure. The 2010-10-28 version of List Operating Systems also
        /// indicates what family an operating system version belongs to.
        /// Currently Windows Azure supports two operating system families:
        /// the Windows Azure guest operating system that is substantially
        /// compatible with Windows Server 2008 SP2, and the Windows Azure
        /// guest operating system that is substantially compatible with
        /// Windows Server 2008 R2.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ff684168.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Operating Systems operation response.
        /// </returns>
        public async Task<OperatingSystemListResponse> ListAsync(CancellationToken cancellationToken)
        {
            // Validate
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                Tracing.Enter(invocationId, this, "ListAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/operatingsystems";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperatingSystemListResponse result = new OperatingSystemListResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement operatingSystemsSequenceElement = responseDoc.Element(XName.Get("OperatingSystems", "http://schemas.microsoft.com/windowsazure"));
                    if (operatingSystemsSequenceElement != null)
                    {
                        foreach (XElement operatingSystemsElement in operatingSystemsSequenceElement.Elements(XName.Get("OperatingSystem", "http://schemas.microsoft.com/windowsazure")))
                        {
                            OperatingSystemListResponse.OperatingSystem operatingSystemInstance = new OperatingSystemListResponse.OperatingSystem();
                            result.OperatingSystems.Add(operatingSystemInstance);
                            
                            XElement versionElement = operatingSystemsElement.Element(XName.Get("Version", "http://schemas.microsoft.com/windowsazure"));
                            if (versionElement != null)
                            {
                                string versionInstance = versionElement.Value;
                                operatingSystemInstance.Version = versionInstance;
                            }
                            
                            XElement labelElement = operatingSystemsElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                            if (labelElement != null)
                            {
                                string labelInstance = TypeConversion.FromBase64String(labelElement.Value);
                                operatingSystemInstance.Label = labelInstance;
                            }
                            
                            XElement isDefaultElement = operatingSystemsElement.Element(XName.Get("IsDefault", "http://schemas.microsoft.com/windowsazure"));
                            if (isDefaultElement != null)
                            {
                                bool isDefaultInstance = bool.Parse(isDefaultElement.Value);
                                operatingSystemInstance.IsDefault = isDefaultInstance;
                            }
                            
                            XElement isActiveElement = operatingSystemsElement.Element(XName.Get("IsActive", "http://schemas.microsoft.com/windowsazure"));
                            if (isActiveElement != null)
                            {
                                bool isActiveInstance = bool.Parse(isActiveElement.Value);
                                operatingSystemInstance.IsActive = isActiveInstance;
                            }
                            
                            XElement familyElement = operatingSystemsElement.Element(XName.Get("Family", "http://schemas.microsoft.com/windowsazure"));
                            if (familyElement != null)
                            {
                                int familyInstance = int.Parse(familyElement.Value, CultureInfo.InvariantCulture);
                                operatingSystemInstance.Family = familyInstance;
                            }
                            
                            XElement familyLabelElement = operatingSystemsElement.Element(XName.Get("FamilyLabel", "http://schemas.microsoft.com/windowsazure"));
                            if (familyLabelElement != null)
                            {
                                string familyLabelInstance = TypeConversion.FromBase64String(familyLabelElement.Value);
                                operatingSystemInstance.FamilyLabel = familyLabelInstance;
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The List OS Families operation lists the guest operating system
        /// families available in Windows Azure, and also lists the operating
        /// system versions available for each family. Currently Windows Azure
        /// supports two operating system families: the Windows Azure guest
        /// operating system that is substantially compatible with Windows
        /// Server 2008 SP2, and the Windows Azure guest operating system that
        /// is substantially compatible with Windows Server 2008 R2.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/gg441291.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Operating System Families operation response.
        /// </returns>
        public async Task<OperatingSystemListFamiliesResponse> ListFamiliesAsync(CancellationToken cancellationToken)
        {
            // Validate
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                Tracing.Enter(invocationId, this, "ListFamiliesAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/operatingsystemfamilies";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperatingSystemListFamiliesResponse result = new OperatingSystemListFamiliesResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement operatingSystemFamiliesSequenceElement = responseDoc.Element(XName.Get("OperatingSystemFamilies", "http://schemas.microsoft.com/windowsazure"));
                    if (operatingSystemFamiliesSequenceElement != null)
                    {
                        foreach (XElement operatingSystemFamiliesElement in operatingSystemFamiliesSequenceElement.Elements(XName.Get("OperatingSystemFamily", "http://schemas.microsoft.com/windowsazure")))
                        {
                            OperatingSystemListFamiliesResponse.OperatingSystemFamily operatingSystemFamilyInstance = new OperatingSystemListFamiliesResponse.OperatingSystemFamily();
                            result.OperatingSystemFamilies.Add(operatingSystemFamilyInstance);
                            
                            XElement nameElement = operatingSystemFamiliesElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                            if (nameElement != null)
                            {
                                int nameInstance = int.Parse(nameElement.Value, CultureInfo.InvariantCulture);
                                operatingSystemFamilyInstance.Name = nameInstance;
                            }
                            
                            XElement labelElement = operatingSystemFamiliesElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                            if (labelElement != null)
                            {
                                string labelInstance = TypeConversion.FromBase64String(labelElement.Value);
                                operatingSystemFamilyInstance.Label = labelInstance;
                            }
                            
                            XElement operatingSystemsSequenceElement = operatingSystemFamiliesElement.Element(XName.Get("OperatingSystems", "http://schemas.microsoft.com/windowsazure"));
                            if (operatingSystemsSequenceElement != null)
                            {
                                foreach (XElement operatingSystemsElement in operatingSystemsSequenceElement.Elements(XName.Get("OperatingSystem", "http://schemas.microsoft.com/windowsazure")))
                                {
                                    OperatingSystemListFamiliesResponse.OperatingSystem operatingSystemInstance = new OperatingSystemListFamiliesResponse.OperatingSystem();
                                    operatingSystemFamilyInstance.OperatingSystems.Add(operatingSystemInstance);
                                    
                                    XElement versionElement = operatingSystemsElement.Element(XName.Get("Version", "http://schemas.microsoft.com/windowsazure"));
                                    if (versionElement != null)
                                    {
                                        string versionInstance = versionElement.Value;
                                        operatingSystemInstance.Version = versionInstance;
                                    }
                                    
                                    XElement labelElement2 = operatingSystemsElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                                    if (labelElement2 != null)
                                    {
                                        string labelInstance2 = TypeConversion.FromBase64String(labelElement2.Value);
                                        operatingSystemInstance.Label = labelInstance2;
                                    }
                                    
                                    XElement isDefaultElement = operatingSystemsElement.Element(XName.Get("IsDefault", "http://schemas.microsoft.com/windowsazure"));
                                    if (isDefaultElement != null)
                                    {
                                        bool isDefaultInstance = bool.Parse(isDefaultElement.Value);
                                        operatingSystemInstance.IsDefault = isDefaultInstance;
                                    }
                                    
                                    XElement isActiveElement = operatingSystemsElement.Element(XName.Get("IsActive", "http://schemas.microsoft.com/windowsazure"));
                                    if (isActiveElement != null)
                                    {
                                        bool isActiveInstance = bool.Parse(isActiveElement.Value);
                                        operatingSystemInstance.IsActive = isActiveInstance;
                                    }
                                }
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
    }
    
    /// <summary>
    /// Operations for managing service certificates for your subscription.
    /// (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee795178.aspx for
    /// more information)
    /// </summary>
    public partial interface IServiceCertificateOperations
    {
        /// <summary>
        /// The Add Service Certificate operation adds a certificate to a
        /// hosted service.  The Add Service Certificate operation is an
        /// asynchronous operation. To determine whether the management
        /// service has finished processing the request, call Get Operation
        /// Status.   (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460817.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The DNS prefix name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Service Certificate operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginCreatingAsync(string serviceName, ServiceCertificateCreateParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Add Service Certificate operation adds a certificate to a
        /// hosted service.  The Add Service Certificate operation is an
        /// asynchronous operation. To determine whether the management
        /// service has finished processing the request, call Get Operation
        /// Status.  This overload will   (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460817.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The DNS prefix name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Service Certificate operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> CreateAsync(string serviceName, ServiceCertificateCreateParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Service Certificate operation deletes a service
        /// certificate from the certificate store of a hosted service.  The
        /// Delete Service Certificate operation is an asynchronous operation.
        /// To determine whether the management service has finished
        /// processing the request, call Get Operation Status.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460803.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Delete Service Certificate operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginDeletingAsync(ServiceCertificateDeleteParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Service Certificate operation deletes a service
        /// certificate from the certificate store of a hosted service.  The
        /// Delete Service Certificate operation is an asynchronous operation.
        /// To determine whether the management service has finished
        /// processing the request, call Get Operation Status.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460803.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Delete Service Certificate operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> DeleteAsync(ServiceCertificateDeleteParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get Service Certificate operation returns the public data for
        /// the specified X.509 certificate associated with a hosted service.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460792.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Service Certificate operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Service Certificate operation response.
        /// </returns>
        Task<ServiceCertificateGetResponse> GetAsync(ServiceCertificateGetParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The List Service Certificates operation lists all of the service
        /// certificates associated with the specified hosted service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154105.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The DNS prefix name of your hosted service.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Service Certificates operation response.
        /// </returns>
        Task<ServiceCertificateListResponse> ListAsync(string serviceName, CancellationToken cancellationToken);
    }
    
    /// <summary>
    /// Operations for managing service certificates for your subscription.
    /// (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee795178.aspx for
    /// more information)
    /// </summary>
    public static partial class ServiceCertificateOperationsExtensions
    {
        /// <summary>
        /// The Add Service Certificate operation adds a certificate to a
        /// hosted service.  The Add Service Certificate operation is an
        /// asynchronous operation. To determine whether the management
        /// service has finished processing the request, call Get Operation
        /// Status.   (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460817.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The DNS prefix name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Service Certificate operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginCreating(this IServiceCertificateOperations operations, string serviceName, ServiceCertificateCreateParameters parameters)
        {
            try
            {
                return operations.BeginCreatingAsync(serviceName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Add Service Certificate operation adds a certificate to a
        /// hosted service.  The Add Service Certificate operation is an
        /// asynchronous operation. To determine whether the management
        /// service has finished processing the request, call Get Operation
        /// Status.   (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460817.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The DNS prefix name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Service Certificate operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginCreatingAsync(this IServiceCertificateOperations operations, string serviceName, ServiceCertificateCreateParameters parameters)
        {
            return operations.BeginCreatingAsync(serviceName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Add Service Certificate operation adds a certificate to a
        /// hosted service.  The Add Service Certificate operation is an
        /// asynchronous operation. To determine whether the management
        /// service has finished processing the request, call Get Operation
        /// Status.  This overload will   (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460817.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The DNS prefix name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Service Certificate operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse Create(this IServiceCertificateOperations operations, string serviceName, ServiceCertificateCreateParameters parameters)
        {
            try
            {
                return operations.CreateAsync(serviceName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Add Service Certificate operation adds a certificate to a
        /// hosted service.  The Add Service Certificate operation is an
        /// asynchronous operation. To determine whether the management
        /// service has finished processing the request, call Get Operation
        /// Status.  This overload will   (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460817.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The DNS prefix name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Service Certificate operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> CreateAsync(this IServiceCertificateOperations operations, string serviceName, ServiceCertificateCreateParameters parameters)
        {
            return operations.CreateAsync(serviceName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Service Certificate operation deletes a service
        /// certificate from the certificate store of a hosted service.  The
        /// Delete Service Certificate operation is an asynchronous operation.
        /// To determine whether the management service has finished
        /// processing the request, call Get Operation Status.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460803.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Delete Service Certificate operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginDeleting(this IServiceCertificateOperations operations, ServiceCertificateDeleteParameters parameters)
        {
            try
            {
                return operations.BeginDeletingAsync(parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Service Certificate operation deletes a service
        /// certificate from the certificate store of a hosted service.  The
        /// Delete Service Certificate operation is an asynchronous operation.
        /// To determine whether the management service has finished
        /// processing the request, call Get Operation Status.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460803.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Delete Service Certificate operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginDeletingAsync(this IServiceCertificateOperations operations, ServiceCertificateDeleteParameters parameters)
        {
            return operations.BeginDeletingAsync(parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Service Certificate operation deletes a service
        /// certificate from the certificate store of a hosted service.  The
        /// Delete Service Certificate operation is an asynchronous operation.
        /// To determine whether the management service has finished
        /// processing the request, call Get Operation Status.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460803.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Delete Service Certificate operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse Delete(this IServiceCertificateOperations operations, ServiceCertificateDeleteParameters parameters)
        {
            try
            {
                return operations.DeleteAsync(parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Service Certificate operation deletes a service
        /// certificate from the certificate store of a hosted service.  The
        /// Delete Service Certificate operation is an asynchronous operation.
        /// To determine whether the management service has finished
        /// processing the request, call Get Operation Status.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460803.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Delete Service Certificate operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> DeleteAsync(this IServiceCertificateOperations operations, ServiceCertificateDeleteParameters parameters)
        {
            return operations.DeleteAsync(parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get Service Certificate operation returns the public data for
        /// the specified X.509 certificate associated with a hosted service.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460792.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Service Certificate operation.
        /// </param>
        /// <returns>
        /// The Get Service Certificate operation response.
        /// </returns>
        public static ServiceCertificateGetResponse Get(this IServiceCertificateOperations operations, ServiceCertificateGetParameters parameters)
        {
            try
            {
                return operations.GetAsync(parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Service Certificate operation returns the public data for
        /// the specified X.509 certificate associated with a hosted service.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460792.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Service Certificate operation.
        /// </param>
        /// <returns>
        /// The Get Service Certificate operation response.
        /// </returns>
        public static Task<ServiceCertificateGetResponse> GetAsync(this IServiceCertificateOperations operations, ServiceCertificateGetParameters parameters)
        {
            return operations.GetAsync(parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The List Service Certificates operation lists all of the service
        /// certificates associated with the specified hosted service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154105.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The DNS prefix name of your hosted service.
        /// </param>
        /// <returns>
        /// The List Service Certificates operation response.
        /// </returns>
        public static ServiceCertificateListResponse List(this IServiceCertificateOperations operations, string serviceName)
        {
            try
            {
                return operations.ListAsync(serviceName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The List Service Certificates operation lists all of the service
        /// certificates associated with the specified hosted service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154105.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IServiceCertificateOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The DNS prefix name of your hosted service.
        /// </param>
        /// <returns>
        /// The List Service Certificates operation response.
        /// </returns>
        public static Task<ServiceCertificateListResponse> ListAsync(this IServiceCertificateOperations operations, string serviceName)
        {
            return operations.ListAsync(serviceName, CancellationToken.None);
        }
    }
    
    /// <summary>
    /// Operations for managing service certificates for your subscription.
    /// (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/ee795178.aspx for
    /// more information)
    /// </summary>
    internal partial class ServiceCertificateOperations : IServiceOperations<ComputeManagementClient>, IServiceCertificateOperations
    {
        /// <summary>
        /// Initializes a new instance of the ServiceCertificateOperations
        /// class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        internal ServiceCertificateOperations(ComputeManagementClient client)
        {
            this._client = client;
        }
        
        private ComputeManagementClient _client;
        
        /// <summary>
        /// Gets a reference to the
        /// Microsoft.WindowsAzure.Management.Compute.ComputeManagementClient.
        /// </summary>
        public ComputeManagementClient Client
        {
            get { return this._client; }
        }
        
        /// <summary>
        /// The Add Service Certificate operation adds a certificate to a
        /// hosted service.  The Add Service Certificate operation is an
        /// asynchronous operation. To determine whether the management
        /// service has finished processing the request, call Get Operation
        /// Status.   (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460817.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The DNS prefix name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Service Certificate operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginCreatingAsync(string serviceName, ServiceCertificateCreateParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.Data == null)
            {
                throw new ArgumentNullException("parameters.Data");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginCreatingAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/certificates";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement certificateFileElement = new XElement(XName.Get("CertificateFile", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(certificateFileElement);
                
                XElement dataElement = new XElement(XName.Get("Data", "http://schemas.microsoft.com/windowsazure"));
                dataElement.Value = Convert.ToBase64String(parameters.Data);
                certificateFileElement.Add(dataElement);
                
                XElement certificateFormatElement = new XElement(XName.Get("CertificateFormat", "http://schemas.microsoft.com/windowsazure"));
                certificateFormatElement.Value = ComputeManagementClient.CertificateFormatToString(parameters.CertificateFormat);
                certificateFileElement.Add(certificateFormatElement);
                
                if (parameters.Password != null)
                {
                    XElement passwordElement = new XElement(XName.Get("Password", "http://schemas.microsoft.com/windowsazure"));
                    passwordElement.Value = parameters.Password;
                    certificateFileElement.Add(passwordElement);
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Add Service Certificate operation adds a certificate to a
        /// hosted service.  The Add Service Certificate operation is an
        /// asynchronous operation. To determine whether the management
        /// service has finished processing the request, call Get Operation
        /// Status.  This overload will   (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460817.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The DNS prefix name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Service Certificate operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> CreateAsync(string serviceName, ServiceCertificateCreateParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "CreateAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.ServiceCertificates.BeginCreatingAsync(serviceName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Service Certificate operation deletes a service
        /// certificate from the certificate store of a hosted service.  The
        /// Delete Service Certificate operation is an asynchronous operation.
        /// To determine whether the management service has finished
        /// processing the request, call Get Operation Status.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460803.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Delete Service Certificate operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginDeletingAsync(ServiceCertificateDeleteParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.ServiceName == null)
            {
                throw new ArgumentNullException("parameters.ServiceName");
            }
            // TODO: Validate parameters.ServiceName is a valid DNS name.
            if (parameters.ThumbprintAlgorithm == null)
            {
                throw new ArgumentNullException("parameters.ThumbprintAlgorithm");
            }
            if (parameters.Thumbprint == null)
            {
                throw new ArgumentNullException("parameters.Thumbprint");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginDeletingAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + parameters.ServiceName + "/certificates/" + parameters.ThumbprintAlgorithm + "-" + parameters.Thumbprint;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Delete;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Service Certificate operation deletes a service
        /// certificate from the certificate store of a hosted service.  The
        /// Delete Service Certificate operation is an asynchronous operation.
        /// To determine whether the management service has finished
        /// processing the request, call Get Operation Status.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460803.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Delete Service Certificate operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> DeleteAsync(ServiceCertificateDeleteParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "DeleteAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.ServiceCertificates.BeginDeletingAsync(parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get Service Certificate operation returns the public data for
        /// the specified X.509 certificate associated with a hosted service.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/ee460792.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Get Service Certificate operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Service Certificate operation response.
        /// </returns>
        public async Task<ServiceCertificateGetResponse> GetAsync(ServiceCertificateGetParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.ServiceName == null)
            {
                throw new ArgumentNullException("parameters.ServiceName");
            }
            // TODO: Validate parameters.ServiceName is a valid DNS name.
            if (parameters.ThumbprintAlgorithm == null)
            {
                throw new ArgumentNullException("parameters.ThumbprintAlgorithm");
            }
            if (parameters.Thumbprint == null)
            {
                throw new ArgumentNullException("parameters.Thumbprint");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "GetAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + parameters.ServiceName + "/certificates/" + parameters.ThumbprintAlgorithm + "-" + parameters.Thumbprint;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    ServiceCertificateGetResponse result = new ServiceCertificateGetResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement certificateElement = responseDoc.Element(XName.Get("Certificate", "http://schemas.microsoft.com/windowsazure"));
                    if (certificateElement != null)
                    {
                        XElement dataElement = certificateElement.Element(XName.Get("Data", "http://schemas.microsoft.com/windowsazure"));
                        if (dataElement != null)
                        {
                            byte[] dataInstance = Convert.FromBase64String(dataElement.Value);
                            result.Data = dataInstance;
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The List Service Certificates operation lists all of the service
        /// certificates associated with the specified hosted service.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj154105.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The DNS prefix name of your hosted service.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Service Certificates operation response.
        /// </returns>
        public async Task<ServiceCertificateListResponse> ListAsync(string serviceName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            // TODO: Validate serviceName is a valid DNS name.
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                Tracing.Enter(invocationId, this, "ListAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/certificates";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    ServiceCertificateListResponse result = new ServiceCertificateListResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement certificatesSequenceElement = responseDoc.Element(XName.Get("Certificates", "http://schemas.microsoft.com/windowsazure"));
                    if (certificatesSequenceElement != null)
                    {
                        foreach (XElement certificatesElement in certificatesSequenceElement.Elements(XName.Get("Certificate", "http://schemas.microsoft.com/windowsazure")))
                        {
                            ServiceCertificateListResponse.Certificate certificateInstance = new ServiceCertificateListResponse.Certificate();
                            result.Certificates.Add(certificateInstance);
                            
                            XElement certificateUrlElement = certificatesElement.Element(XName.Get("CertificateUrl", "http://schemas.microsoft.com/windowsazure"));
                            if (certificateUrlElement != null)
                            {
                                Uri certificateUrlInstance = TypeConversion.TryParseUri(certificateUrlElement.Value);
                                certificateInstance.CertificateUri = certificateUrlInstance;
                            }
                            
                            XElement thumbprintElement = certificatesElement.Element(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                            if (thumbprintElement != null)
                            {
                                string thumbprintInstance = thumbprintElement.Value;
                                certificateInstance.Thumbprint = thumbprintInstance;
                            }
                            
                            XElement thumbprintAlgorithmElement = certificatesElement.Element(XName.Get("ThumbprintAlgorithm", "http://schemas.microsoft.com/windowsazure"));
                            if (thumbprintAlgorithmElement != null)
                            {
                                string thumbprintAlgorithmInstance = thumbprintAlgorithmElement.Value;
                                certificateInstance.ThumbprintAlgorithm = thumbprintAlgorithmInstance;
                            }
                            
                            XElement dataElement = certificatesElement.Element(XName.Get("Data", "http://schemas.microsoft.com/windowsazure"));
                            if (dataElement != null)
                            {
                                byte[] dataInstance = Convert.FromBase64String(dataElement.Value);
                                certificateInstance.Data = dataInstance;
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the disks
    /// in your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157188.aspx for
    /// more information)
    /// </summary>
    public partial interface IVirtualMachineDiskOperations
    {
        /// <summary>
        /// The Add Data Disk operation adds a data disk to a virtual machine.
        /// There are three ways to create the data disk using the Add Data
        /// Disk operation.  Option 1  Attach an empty data disk to the role
        /// by specifying the disk label and location of the disk image.  Do
        /// not include the DiskName and SourceMediaLink elements in the
        /// request body.  Include the MediaLink element and reference a blob
        /// that is in the same geographical region as the role.  You can also
        /// omit the MediaLink element. In this usage, Windows Azure will
        /// create the data disk in the storage account configured as default
        /// for the role.   Option 2  Attach an existing data disk that is in
        /// the image repository.  Do not include the DiskName and
        /// SourceMediaLink elements in the request body.  Specify the data
        /// disk to use by including the DiskName element.  Note: If included
        /// the in the response body, the MediaLink and LogicalDiskSizeInGB
        /// elements are ignored.  Option 3 - Specify the location of a blob
        /// in your storage account that contain a disk image to use.  Include
        /// the SourceMediaLink element. Note: If the MediaLink element
        /// isincluded, it is ignored.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157199.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to add the data disk to.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Data Disk
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> CreateDataDiskAsync(string serviceName, string deploymentName, string roleName, VirtualMachineDiskCreateDataDiskParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Add Disk operation adds a disk to the user image repository.
        /// The disk can be an operating system disk or a data disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Disk operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        Task<VirtualMachineDiskCreateDiskResponse> CreateDiskAsync(VirtualMachineDiskCreateDiskParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Data Disk operation removes the specified data disk from
        /// a virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157179.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to delete the data disk from.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> DeleteDataDiskAsync(string serviceName, string deploymentName, string roleName, int logicalUnitNumber, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Disk operation deletes the specified data or operating
        /// system disk from your image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157200.aspx
        /// for more information)
        /// </summary>
        /// <param name='diskName'>
        /// The name of the disk to delete.
        /// </param>
        /// <param name='deleteFromStorage'>
        /// Optional. Specifies that the source blob for the disk should also
        /// be deleted from storage.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> DeleteDiskAsync(string diskName, bool deleteFromStorage, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get Data Disk operation retrieves the specified data disk from
        /// a virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157180.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Data Disk operation response.
        /// </returns>
        Task<VirtualMachineDiskGetDataDiskResponse> GetDataDiskAsync(string serviceName, string deploymentName, string roleName, int logicalUnitNumber, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get Disk operation retrieves a disk from the user image
        /// repository. The disk can be an operating system disk or a data
        /// disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='diskName'>
        /// The name of the disk.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        Task<VirtualMachineDiskGetDiskResponse> GetDiskAsync(string diskName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The List Disks operation retrieves a list of the disks in your
        /// image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157176.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Disks operation response.
        /// </returns>
        Task<VirtualMachineDiskListResponse> ListDisksAsync(CancellationToken cancellationToken);
        
        /// <summary>
        /// The Update Data Disk operation updates the specified data disk
        /// attached to the specified virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157190.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to add the data disk to.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Data Disk
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> UpdateDataDiskAsync(string serviceName, string deploymentName, string roleName, int logicalUnitNumber, VirtualMachineDiskUpdateDataDiskParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Add Disk operation adds a disk to the user image repository.
        /// The disk can be an operating system disk or a data disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='diskName'>
        /// The name of the disk being updated.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Disk operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        Task<VirtualMachineDiskUpdateDiskResponse> UpdateDiskAsync(string diskName, VirtualMachineDiskUpdateDiskParameters parameters, CancellationToken cancellationToken);
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the disks
    /// in your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157188.aspx for
    /// more information)
    /// </summary>
    public static partial class VirtualMachineDiskOperationsExtensions
    {
        /// <summary>
        /// The Add Data Disk operation adds a data disk to a virtual machine.
        /// There are three ways to create the data disk using the Add Data
        /// Disk operation.  Option 1  Attach an empty data disk to the role
        /// by specifying the disk label and location of the disk image.  Do
        /// not include the DiskName and SourceMediaLink elements in the
        /// request body.  Include the MediaLink element and reference a blob
        /// that is in the same geographical region as the role.  You can also
        /// omit the MediaLink element. In this usage, Windows Azure will
        /// create the data disk in the storage account configured as default
        /// for the role.   Option 2  Attach an existing data disk that is in
        /// the image repository.  Do not include the DiskName and
        /// SourceMediaLink elements in the request body.  Specify the data
        /// disk to use by including the DiskName element.  Note: If included
        /// the in the response body, the MediaLink and LogicalDiskSizeInGB
        /// elements are ignored.  Option 3 - Specify the location of a blob
        /// in your storage account that contain a disk image to use.  Include
        /// the SourceMediaLink element. Note: If the MediaLink element
        /// isincluded, it is ignored.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157199.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to add the data disk to.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Data Disk
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse CreateDataDisk(this IVirtualMachineDiskOperations operations, string serviceName, string deploymentName, string roleName, VirtualMachineDiskCreateDataDiskParameters parameters)
        {
            try
            {
                return operations.CreateDataDiskAsync(serviceName, deploymentName, roleName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Add Data Disk operation adds a data disk to a virtual machine.
        /// There are three ways to create the data disk using the Add Data
        /// Disk operation.  Option 1  Attach an empty data disk to the role
        /// by specifying the disk label and location of the disk image.  Do
        /// not include the DiskName and SourceMediaLink elements in the
        /// request body.  Include the MediaLink element and reference a blob
        /// that is in the same geographical region as the role.  You can also
        /// omit the MediaLink element. In this usage, Windows Azure will
        /// create the data disk in the storage account configured as default
        /// for the role.   Option 2  Attach an existing data disk that is in
        /// the image repository.  Do not include the DiskName and
        /// SourceMediaLink elements in the request body.  Specify the data
        /// disk to use by including the DiskName element.  Note: If included
        /// the in the response body, the MediaLink and LogicalDiskSizeInGB
        /// elements are ignored.  Option 3 - Specify the location of a blob
        /// in your storage account that contain a disk image to use.  Include
        /// the SourceMediaLink element. Note: If the MediaLink element
        /// isincluded, it is ignored.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157199.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to add the data disk to.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Data Disk
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> CreateDataDiskAsync(this IVirtualMachineDiskOperations operations, string serviceName, string deploymentName, string roleName, VirtualMachineDiskCreateDataDiskParameters parameters)
        {
            return operations.CreateDataDiskAsync(serviceName, deploymentName, roleName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Add Disk operation adds a disk to the user image repository.
        /// The disk can be an operating system disk or a data disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Disk operation.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        public static VirtualMachineDiskCreateDiskResponse CreateDisk(this IVirtualMachineDiskOperations operations, VirtualMachineDiskCreateDiskParameters parameters)
        {
            try
            {
                return operations.CreateDiskAsync(parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Add Disk operation adds a disk to the user image repository.
        /// The disk can be an operating system disk or a data disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Disk operation.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        public static Task<VirtualMachineDiskCreateDiskResponse> CreateDiskAsync(this IVirtualMachineDiskOperations operations, VirtualMachineDiskCreateDiskParameters parameters)
        {
            return operations.CreateDiskAsync(parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Data Disk operation removes the specified data disk from
        /// a virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157179.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to delete the data disk from.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse DeleteDataDisk(this IVirtualMachineDiskOperations operations, string serviceName, string deploymentName, string roleName, int logicalUnitNumber)
        {
            try
            {
                return operations.DeleteDataDiskAsync(serviceName, deploymentName, roleName, logicalUnitNumber).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Data Disk operation removes the specified data disk from
        /// a virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157179.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to delete the data disk from.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> DeleteDataDiskAsync(this IVirtualMachineDiskOperations operations, string serviceName, string deploymentName, string roleName, int logicalUnitNumber)
        {
            return operations.DeleteDataDiskAsync(serviceName, deploymentName, roleName, logicalUnitNumber, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Disk operation deletes the specified data or operating
        /// system disk from your image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157200.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='diskName'>
        /// The name of the disk to delete.
        /// </param>
        /// <param name='deleteFromStorage'>
        /// Optional. Specifies that the source blob for the disk should also
        /// be deleted from storage.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse DeleteDisk(this IVirtualMachineDiskOperations operations, string diskName, bool deleteFromStorage)
        {
            try
            {
                return operations.DeleteDiskAsync(diskName, deleteFromStorage).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Disk operation deletes the specified data or operating
        /// system disk from your image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157200.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='diskName'>
        /// The name of the disk to delete.
        /// </param>
        /// <param name='deleteFromStorage'>
        /// Optional. Specifies that the source blob for the disk should also
        /// be deleted from storage.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> DeleteDiskAsync(this IVirtualMachineDiskOperations operations, string diskName, bool deleteFromStorage)
        {
            return operations.DeleteDiskAsync(diskName, deleteFromStorage, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get Data Disk operation retrieves the specified data disk from
        /// a virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157180.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <returns>
        /// The Get Data Disk operation response.
        /// </returns>
        public static VirtualMachineDiskGetDataDiskResponse GetDataDisk(this IVirtualMachineDiskOperations operations, string serviceName, string deploymentName, string roleName, int logicalUnitNumber)
        {
            try
            {
                return operations.GetDataDiskAsync(serviceName, deploymentName, roleName, logicalUnitNumber).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Data Disk operation retrieves the specified data disk from
        /// a virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157180.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <returns>
        /// The Get Data Disk operation response.
        /// </returns>
        public static Task<VirtualMachineDiskGetDataDiskResponse> GetDataDiskAsync(this IVirtualMachineDiskOperations operations, string serviceName, string deploymentName, string roleName, int logicalUnitNumber)
        {
            return operations.GetDataDiskAsync(serviceName, deploymentName, roleName, logicalUnitNumber, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get Disk operation retrieves a disk from the user image
        /// repository. The disk can be an operating system disk or a data
        /// disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='diskName'>
        /// The name of the disk.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        public static VirtualMachineDiskGetDiskResponse GetDisk(this IVirtualMachineDiskOperations operations, string diskName)
        {
            try
            {
                return operations.GetDiskAsync(diskName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Disk operation retrieves a disk from the user image
        /// repository. The disk can be an operating system disk or a data
        /// disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='diskName'>
        /// The name of the disk.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        public static Task<VirtualMachineDiskGetDiskResponse> GetDiskAsync(this IVirtualMachineDiskOperations operations, string diskName)
        {
            return operations.GetDiskAsync(diskName, CancellationToken.None);
        }
        
        /// <summary>
        /// The List Disks operation retrieves a list of the disks in your
        /// image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157176.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <returns>
        /// The List Disks operation response.
        /// </returns>
        public static VirtualMachineDiskListResponse ListDisks(this IVirtualMachineDiskOperations operations)
        {
            try
            {
                return operations.ListDisksAsync().Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The List Disks operation retrieves a list of the disks in your
        /// image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157176.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <returns>
        /// The List Disks operation response.
        /// </returns>
        public static Task<VirtualMachineDiskListResponse> ListDisksAsync(this IVirtualMachineDiskOperations operations)
        {
            return operations.ListDisksAsync(CancellationToken.None);
        }
        
        /// <summary>
        /// The Update Data Disk operation updates the specified data disk
        /// attached to the specified virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157190.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to add the data disk to.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Data Disk
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse UpdateDataDisk(this IVirtualMachineDiskOperations operations, string serviceName, string deploymentName, string roleName, int logicalUnitNumber, VirtualMachineDiskUpdateDataDiskParameters parameters)
        {
            try
            {
                return operations.UpdateDataDiskAsync(serviceName, deploymentName, roleName, logicalUnitNumber, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Update Data Disk operation updates the specified data disk
        /// attached to the specified virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157190.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to add the data disk to.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Data Disk
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> UpdateDataDiskAsync(this IVirtualMachineDiskOperations operations, string serviceName, string deploymentName, string roleName, int logicalUnitNumber, VirtualMachineDiskUpdateDataDiskParameters parameters)
        {
            return operations.UpdateDataDiskAsync(serviceName, deploymentName, roleName, logicalUnitNumber, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Add Disk operation adds a disk to the user image repository.
        /// The disk can be an operating system disk or a data disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='diskName'>
        /// The name of the disk being updated.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Disk operation.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        public static VirtualMachineDiskUpdateDiskResponse UpdateDisk(this IVirtualMachineDiskOperations operations, string diskName, VirtualMachineDiskUpdateDiskParameters parameters)
        {
            try
            {
                return operations.UpdateDiskAsync(diskName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Add Disk operation adds a disk to the user image repository.
        /// The disk can be an operating system disk or a data disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineDiskOperations.
        /// </param>
        /// <param name='diskName'>
        /// The name of the disk being updated.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Disk operation.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        public static Task<VirtualMachineDiskUpdateDiskResponse> UpdateDiskAsync(this IVirtualMachineDiskOperations operations, string diskName, VirtualMachineDiskUpdateDiskParameters parameters)
        {
            return operations.UpdateDiskAsync(diskName, parameters, CancellationToken.None);
        }
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the disks
    /// in your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157188.aspx for
    /// more information)
    /// </summary>
    internal partial class VirtualMachineDiskOperations : IServiceOperations<ComputeManagementClient>, IVirtualMachineDiskOperations
    {
        /// <summary>
        /// Initializes a new instance of the VirtualMachineDiskOperations
        /// class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        internal VirtualMachineDiskOperations(ComputeManagementClient client)
        {
            this._client = client;
        }
        
        private ComputeManagementClient _client;
        
        /// <summary>
        /// Gets a reference to the
        /// Microsoft.WindowsAzure.Management.Compute.ComputeManagementClient.
        /// </summary>
        public ComputeManagementClient Client
        {
            get { return this._client; }
        }
        
        /// <summary>
        /// The Add Data Disk operation adds a data disk to a virtual machine.
        /// There are three ways to create the data disk using the Add Data
        /// Disk operation.  Option 1  Attach an empty data disk to the role
        /// by specifying the disk label and location of the disk image.  Do
        /// not include the DiskName and SourceMediaLink elements in the
        /// request body.  Include the MediaLink element and reference a blob
        /// that is in the same geographical region as the role.  You can also
        /// omit the MediaLink element. In this usage, Windows Azure will
        /// create the data disk in the storage account configured as default
        /// for the role.   Option 2  Attach an existing data disk that is in
        /// the image repository.  Do not include the DiskName and
        /// SourceMediaLink elements in the request body.  Specify the data
        /// disk to use by including the DiskName element.  Note: If included
        /// the in the response body, the MediaLink and LogicalDiskSizeInGB
        /// elements are ignored.  Option 3 - Specify the location of a blob
        /// in your storage account that contain a disk image to use.  Include
        /// the SourceMediaLink element. Note: If the MediaLink element
        /// isincluded, it is ignored.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157199.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to add the data disk to.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Data Disk
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> CreateDataDiskAsync(string serviceName, string deploymentName, string roleName, VirtualMachineDiskCreateDataDiskParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (roleName == null)
            {
                throw new ArgumentNullException("roleName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.MediaLinkUri == null)
            {
                throw new ArgumentNullException("parameters.MediaLinkUri");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("roleName", roleName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "CreateDataDiskAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roles/" + roleName + "/DataDisks";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement dataVirtualHardDiskElement = new XElement(XName.Get("DataVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(dataVirtualHardDiskElement);
                
                XElement hostCachingElement = new XElement(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                hostCachingElement.Value = parameters.HostCaching.ToString();
                dataVirtualHardDiskElement.Add(hostCachingElement);
                
                if (parameters.DiskLabel != null)
                {
                    XElement diskLabelElement = new XElement(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                    diskLabelElement.Value = parameters.DiskLabel;
                    dataVirtualHardDiskElement.Add(diskLabelElement);
                }
                
                if (parameters.DiskName != null)
                {
                    XElement diskNameElement = new XElement(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                    diskNameElement.Value = parameters.DiskName;
                    dataVirtualHardDiskElement.Add(diskNameElement);
                }
                
                if (parameters.LogicalUnitNumber != null)
                {
                    XElement lunElement = new XElement(XName.Get("Lun", "http://schemas.microsoft.com/windowsazure"));
                    lunElement.Value = parameters.LogicalUnitNumber.ToString();
                    dataVirtualHardDiskElement.Add(lunElement);
                }
                
                XElement logicalDiskSizeInGBElement = new XElement(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                logicalDiskSizeInGBElement.Value = parameters.LogicalDiskSizeInGB.ToString();
                dataVirtualHardDiskElement.Add(logicalDiskSizeInGBElement);
                
                XElement mediaLinkElement = new XElement(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                mediaLinkElement.Value = parameters.MediaLinkUri.ToString();
                dataVirtualHardDiskElement.Add(mediaLinkElement);
                
                if (parameters.SourceMediaLinkUri != null)
                {
                    XElement sourceMediaLinkElement = new XElement(XName.Get("SourceMediaLink", "http://schemas.microsoft.com/windowsazure"));
                    sourceMediaLinkElement.Value = parameters.SourceMediaLinkUri.ToString();
                    dataVirtualHardDiskElement.Add(sourceMediaLinkElement);
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Created)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Add Disk operation adds a disk to the user image repository.
        /// The disk can be an operating system disk or a data disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Disk operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        public async Task<VirtualMachineDiskCreateDiskResponse> CreateDiskAsync(VirtualMachineDiskCreateDiskParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.Label == null)
            {
                throw new ArgumentNullException("parameters.Label");
            }
            if (parameters.MediaLinkUri == null)
            {
                throw new ArgumentNullException("parameters.MediaLinkUri");
            }
            if (parameters.Name == null)
            {
                throw new ArgumentNullException("parameters.Name");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "CreateDiskAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/disks";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement diskElement = new XElement(XName.Get("Disk", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(diskElement);
                
                if (parameters.OperatingSystemType != null)
                {
                    XElement osElement = new XElement(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                    osElement.Value = parameters.OperatingSystemType;
                    diskElement.Add(osElement);
                }
                
                XElement labelElement = new XElement(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                labelElement.Value = parameters.Label;
                diskElement.Add(labelElement);
                
                XElement mediaLinkElement = new XElement(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                mediaLinkElement.Value = parameters.MediaLinkUri.ToString();
                diskElement.Add(mediaLinkElement);
                
                XElement nameElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                nameElement.Value = parameters.Name;
                diskElement.Add(nameElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    VirtualMachineDiskCreateDiskResponse result = new VirtualMachineDiskCreateDiskResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement diskElement2 = responseDoc.Element(XName.Get("Disk", "http://schemas.microsoft.com/windowsazure"));
                    if (diskElement2 != null)
                    {
                        XElement osElement2 = diskElement2.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                        if (osElement2 != null)
                        {
                            string osInstance = osElement2.Value;
                            result.OperatingSystem = osInstance;
                        }
                        
                        XElement labelElement2 = diskElement2.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                        if (labelElement2 != null)
                        {
                            string labelInstance = labelElement2.Value;
                            result.Label = labelInstance;
                        }
                        
                        XElement affinityGroupElement = diskElement2.Element(XName.Get("AffinityGroup", "http://schemas.microsoft.com/windowsazure"));
                        if (affinityGroupElement != null)
                        {
                            string affinityGroupInstance = affinityGroupElement.Value;
                            result.AffinityGroup = affinityGroupInstance;
                        }
                        
                        XElement locationElement = diskElement2.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                        if (locationElement != null)
                        {
                            string locationInstance = locationElement.Value;
                            result.Location = locationInstance;
                        }
                        
                        XElement logicalDiskSizeInGBElement = diskElement2.Element(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                        if (logicalDiskSizeInGBElement != null)
                        {
                            double logicalDiskSizeInGBInstance = double.Parse(logicalDiskSizeInGBElement.Value, CultureInfo.InvariantCulture);
                            result.LogicalSizeInGB = logicalDiskSizeInGBInstance;
                        }
                        
                        XElement mediaLinkElement2 = diskElement2.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                        if (mediaLinkElement2 != null)
                        {
                            Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement2.Value);
                            result.MediaLinkUri = mediaLinkInstance;
                        }
                        
                        XElement nameElement2 = diskElement2.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        if (nameElement2 != null)
                        {
                            string nameInstance = nameElement2.Value;
                            result.Name = nameInstance;
                        }
                        
                        XElement sourceImageNameElement = diskElement2.Element(XName.Get("SourceImageName", "http://schemas.microsoft.com/windowsazure"));
                        if (sourceImageNameElement != null)
                        {
                            string sourceImageNameInstance = sourceImageNameElement.Value;
                            result.SourceImageName = sourceImageNameInstance;
                        }
                        
                        XElement attachedToElement = diskElement2.Element(XName.Get("AttachedTo", "http://schemas.microsoft.com/windowsazure"));
                        if (attachedToElement != null)
                        {
                            VirtualMachineDiskCreateDiskResponse.VirtualMachineDiskUsageDetails attachedToInstance = new VirtualMachineDiskCreateDiskResponse.VirtualMachineDiskUsageDetails();
                            result.UsageDetails = attachedToInstance;
                            
                            XElement hostedServiceNameElement = attachedToElement.Element(XName.Get("HostedServiceName", "http://schemas.microsoft.com/windowsazure"));
                            if (hostedServiceNameElement != null)
                            {
                                string hostedServiceNameInstance = hostedServiceNameElement.Value;
                                attachedToInstance.HostedServiceName = hostedServiceNameInstance;
                            }
                            
                            XElement deploymentNameElement = attachedToElement.Element(XName.Get("DeploymentName", "http://schemas.microsoft.com/windowsazure"));
                            if (deploymentNameElement != null)
                            {
                                string deploymentNameInstance = deploymentNameElement.Value;
                                attachedToInstance.DeploymentName = deploymentNameInstance;
                            }
                            
                            XElement roleNameElement = attachedToElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                            if (roleNameElement != null)
                            {
                                string roleNameInstance = roleNameElement.Value;
                                attachedToInstance.RoleName = roleNameInstance;
                            }
                        }
                        
                        XElement isPremiumElement = diskElement2.Element(XName.Get("IsPremium", "http://schemas.microsoft.com/windowsazure"));
                        if (isPremiumElement != null && string.IsNullOrEmpty(isPremiumElement.Value) == false)
                        {
                            bool isPremiumInstance = bool.Parse(isPremiumElement.Value);
                            result.IsPremium = isPremiumInstance;
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Data Disk operation removes the specified data disk from
        /// a virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157179.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to delete the data disk from.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> DeleteDataDiskAsync(string serviceName, string deploymentName, string roleName, int logicalUnitNumber, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (roleName == null)
            {
                throw new ArgumentNullException("roleName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("roleName", roleName);
                tracingParameters.Add("logicalUnitNumber", logicalUnitNumber);
                Tracing.Enter(invocationId, this, "DeleteDataDiskAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roles/" + roleName + "/DataDisks/" + logicalUnitNumber;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Delete;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Disk operation deletes the specified data or operating
        /// system disk from your image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157200.aspx
        /// for more information)
        /// </summary>
        /// <param name='diskName'>
        /// The name of the disk to delete.
        /// </param>
        /// <param name='deleteFromStorage'>
        /// Optional. Specifies that the source blob for the disk should also
        /// be deleted from storage.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> DeleteDiskAsync(string diskName, bool deleteFromStorage, CancellationToken cancellationToken)
        {
            // Validate
            if (diskName == null)
            {
                throw new ArgumentNullException("diskName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("diskName", diskName);
                tracingParameters.Add("deleteFromStorage", deleteFromStorage);
                Tracing.Enter(invocationId, this, "DeleteDiskAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/disks/" + diskName + "?";
            if (deleteFromStorage == true)
            {
                url = url + "&comp=" + Uri.EscapeUriString("media");
            }
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Delete;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get Data Disk operation retrieves the specified data disk from
        /// a virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157180.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Data Disk operation response.
        /// </returns>
        public async Task<VirtualMachineDiskGetDataDiskResponse> GetDataDiskAsync(string serviceName, string deploymentName, string roleName, int logicalUnitNumber, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (roleName == null)
            {
                throw new ArgumentNullException("roleName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("roleName", roleName);
                tracingParameters.Add("logicalUnitNumber", logicalUnitNumber);
                Tracing.Enter(invocationId, this, "GetDataDiskAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roles/" + roleName + "/DataDisks/" + logicalUnitNumber;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    VirtualMachineDiskGetDataDiskResponse result = new VirtualMachineDiskGetDataDiskResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement dataVirtualHardDiskElement = responseDoc.Element(XName.Get("DataVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                    if (dataVirtualHardDiskElement != null)
                    {
                        XElement hostCachingElement = dataVirtualHardDiskElement.Element(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                        if (hostCachingElement != null)
                        {
                            VirtualHardDiskHostCaching hostCachingInstance = (VirtualHardDiskHostCaching)Enum.Parse(typeof(VirtualHardDiskHostCaching), hostCachingElement.Value, false);
                            result.HostCaching = hostCachingInstance;
                        }
                        
                        XElement diskLabelElement = dataVirtualHardDiskElement.Element(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                        if (diskLabelElement != null)
                        {
                            string diskLabelInstance = diskLabelElement.Value;
                            result.DiskLabel = diskLabelInstance;
                        }
                        
                        XElement diskNameElement = dataVirtualHardDiskElement.Element(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                        if (diskNameElement != null)
                        {
                            string diskNameInstance = diskNameElement.Value;
                            result.DiskName = diskNameInstance;
                        }
                        
                        XElement lunElement = dataVirtualHardDiskElement.Element(XName.Get("Lun", "http://schemas.microsoft.com/windowsazure"));
                        if (lunElement != null && string.IsNullOrEmpty(lunElement.Value) == false)
                        {
                            int lunInstance = int.Parse(lunElement.Value, CultureInfo.InvariantCulture);
                            result.LogicalUnitNumber = lunInstance;
                        }
                        
                        XElement logicalDiskSizeInGBElement = dataVirtualHardDiskElement.Element(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                        if (logicalDiskSizeInGBElement != null)
                        {
                            double logicalDiskSizeInGBInstance = double.Parse(logicalDiskSizeInGBElement.Value, CultureInfo.InvariantCulture);
                            result.LogicalDiskSizeInGB = logicalDiskSizeInGBInstance;
                        }
                        
                        XElement mediaLinkElement = dataVirtualHardDiskElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                        if (mediaLinkElement != null)
                        {
                            Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement.Value);
                            result.MediaLinkUri = mediaLinkInstance;
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get Disk operation retrieves a disk from the user image
        /// repository. The disk can be an operating system disk or a data
        /// disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='diskName'>
        /// The name of the disk.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        public async Task<VirtualMachineDiskGetDiskResponse> GetDiskAsync(string diskName, CancellationToken cancellationToken)
        {
            // Validate
            if (diskName == null)
            {
                throw new ArgumentNullException("diskName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("diskName", diskName);
                Tracing.Enter(invocationId, this, "GetDiskAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/disks/" + diskName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    VirtualMachineDiskGetDiskResponse result = new VirtualMachineDiskGetDiskResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement diskElement = responseDoc.Element(XName.Get("Disk", "http://schemas.microsoft.com/windowsazure"));
                    if (diskElement != null)
                    {
                        XElement affinityGroupElement = diskElement.Element(XName.Get("AffinityGroup", "http://schemas.microsoft.com/windowsazure"));
                        if (affinityGroupElement != null)
                        {
                            string affinityGroupInstance = affinityGroupElement.Value;
                            result.AffinityGroup = affinityGroupInstance;
                        }
                        
                        XElement locationElement = diskElement.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                        if (locationElement != null)
                        {
                            string locationInstance = locationElement.Value;
                            result.Location = locationInstance;
                        }
                        
                        XElement labelElement = diskElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                        if (labelElement != null)
                        {
                            string labelInstance = labelElement.Value;
                            result.Label = labelInstance;
                        }
                        
                        XElement logicalDiskSizeInGBElement = diskElement.Element(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                        if (logicalDiskSizeInGBElement != null)
                        {
                            double logicalDiskSizeInGBInstance = double.Parse(logicalDiskSizeInGBElement.Value, CultureInfo.InvariantCulture);
                            result.LogicalSizeInGB = logicalDiskSizeInGBInstance;
                        }
                        
                        XElement mediaLinkElement = diskElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                        if (mediaLinkElement != null)
                        {
                            Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement.Value);
                            result.MediaLinkUri = mediaLinkInstance;
                        }
                        
                        XElement nameElement = diskElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        if (nameElement != null)
                        {
                            string nameInstance = nameElement.Value;
                            result.Name = nameInstance;
                        }
                        
                        XElement osElement = diskElement.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                        if (osElement != null)
                        {
                            string osInstance = osElement.Value;
                            result.OperatingSystemType = osInstance;
                        }
                        
                        XElement sourceImageNameElement = diskElement.Element(XName.Get("SourceImageName", "http://schemas.microsoft.com/windowsazure"));
                        if (sourceImageNameElement != null)
                        {
                            string sourceImageNameInstance = sourceImageNameElement.Value;
                            result.SourceImageName = sourceImageNameInstance;
                        }
                        
                        XElement attachedToElement = diskElement.Element(XName.Get("AttachedTo", "http://schemas.microsoft.com/windowsazure"));
                        if (attachedToElement != null)
                        {
                            VirtualMachineDiskGetDiskResponse.VirtualMachineDiskUsageDetails attachedToInstance = new VirtualMachineDiskGetDiskResponse.VirtualMachineDiskUsageDetails();
                            result.UsageDetails = attachedToInstance;
                            
                            XElement hostedServiceNameElement = attachedToElement.Element(XName.Get("HostedServiceName", "http://schemas.microsoft.com/windowsazure"));
                            if (hostedServiceNameElement != null)
                            {
                                string hostedServiceNameInstance = hostedServiceNameElement.Value;
                                attachedToInstance.HostedServiceName = hostedServiceNameInstance;
                            }
                            
                            XElement deploymentNameElement = attachedToElement.Element(XName.Get("DeploymentName", "http://schemas.microsoft.com/windowsazure"));
                            if (deploymentNameElement != null)
                            {
                                string deploymentNameInstance = deploymentNameElement.Value;
                                attachedToInstance.DeploymentName = deploymentNameInstance;
                            }
                            
                            XElement roleNameElement = attachedToElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                            if (roleNameElement != null)
                            {
                                string roleNameInstance = roleNameElement.Value;
                                attachedToInstance.RoleName = roleNameInstance;
                            }
                        }
                        
                        XElement isCorruptedElement = diskElement.Element(XName.Get("IsCorrupted", "http://schemas.microsoft.com/windowsazure"));
                        if (isCorruptedElement != null && string.IsNullOrEmpty(isCorruptedElement.Value) == false)
                        {
                            bool isCorruptedInstance = bool.Parse(isCorruptedElement.Value);
                            result.IsCorrupted = isCorruptedInstance;
                        }
                        
                        XElement isPremiumElement = diskElement.Element(XName.Get("IsPremium", "http://schemas.microsoft.com/windowsazure"));
                        if (isPremiumElement != null && string.IsNullOrEmpty(isPremiumElement.Value) == false)
                        {
                            bool isPremiumInstance = bool.Parse(isPremiumElement.Value);
                            result.IsPremium = isPremiumInstance;
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The List Disks operation retrieves a list of the disks in your
        /// image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157176.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List Disks operation response.
        /// </returns>
        public async Task<VirtualMachineDiskListResponse> ListDisksAsync(CancellationToken cancellationToken)
        {
            // Validate
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                Tracing.Enter(invocationId, this, "ListDisksAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/disks";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    VirtualMachineDiskListResponse result = new VirtualMachineDiskListResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement disksSequenceElement = responseDoc.Element(XName.Get("Disks", "http://schemas.microsoft.com/windowsazure"));
                    if (disksSequenceElement != null)
                    {
                        foreach (XElement disksElement in disksSequenceElement.Elements(XName.Get("Disk", "http://schemas.microsoft.com/windowsazure")))
                        {
                            VirtualMachineDiskListResponse.VirtualMachineDisk diskInstance = new VirtualMachineDiskListResponse.VirtualMachineDisk();
                            result.Disks.Add(diskInstance);
                            
                            XElement affinityGroupElement = disksElement.Element(XName.Get("AffinityGroup", "http://schemas.microsoft.com/windowsazure"));
                            if (affinityGroupElement != null)
                            {
                                string affinityGroupInstance = affinityGroupElement.Value;
                                diskInstance.AffinityGroup = affinityGroupInstance;
                            }
                            
                            XElement locationElement = disksElement.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                            if (locationElement != null)
                            {
                                string locationInstance = locationElement.Value;
                                diskInstance.Location = locationInstance;
                            }
                            
                            XElement labelElement = disksElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                            if (labelElement != null)
                            {
                                string labelInstance = labelElement.Value;
                                diskInstance.Label = labelInstance;
                            }
                            
                            XElement logicalDiskSizeInGBElement = disksElement.Element(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                            if (logicalDiskSizeInGBElement != null)
                            {
                                double logicalDiskSizeInGBInstance = double.Parse(logicalDiskSizeInGBElement.Value, CultureInfo.InvariantCulture);
                                diskInstance.LogicalSizeInGB = logicalDiskSizeInGBInstance;
                            }
                            
                            XElement mediaLinkElement = disksElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                            if (mediaLinkElement != null)
                            {
                                Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement.Value);
                                diskInstance.MediaLinkUri = mediaLinkInstance;
                            }
                            
                            XElement nameElement = disksElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                            if (nameElement != null)
                            {
                                string nameInstance = nameElement.Value;
                                diskInstance.Name = nameInstance;
                            }
                            
                            XElement osElement = disksElement.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                            if (osElement != null)
                            {
                                string osInstance = osElement.Value;
                                diskInstance.OperatingSystemType = osInstance;
                            }
                            
                            XElement sourceImageNameElement = disksElement.Element(XName.Get("SourceImageName", "http://schemas.microsoft.com/windowsazure"));
                            if (sourceImageNameElement != null)
                            {
                                string sourceImageNameInstance = sourceImageNameElement.Value;
                                diskInstance.SourceImageName = sourceImageNameInstance;
                            }
                            
                            XElement attachedToElement = disksElement.Element(XName.Get("AttachedTo", "http://schemas.microsoft.com/windowsazure"));
                            if (attachedToElement != null)
                            {
                                VirtualMachineDiskListResponse.VirtualMachineDiskUsageDetails attachedToInstance = new VirtualMachineDiskListResponse.VirtualMachineDiskUsageDetails();
                                diskInstance.UsageDetails = attachedToInstance;
                                
                                XElement hostedServiceNameElement = attachedToElement.Element(XName.Get("HostedServiceName", "http://schemas.microsoft.com/windowsazure"));
                                if (hostedServiceNameElement != null)
                                {
                                    string hostedServiceNameInstance = hostedServiceNameElement.Value;
                                    attachedToInstance.HostedServiceName = hostedServiceNameInstance;
                                }
                                
                                XElement deploymentNameElement = attachedToElement.Element(XName.Get("DeploymentName", "http://schemas.microsoft.com/windowsazure"));
                                if (deploymentNameElement != null)
                                {
                                    string deploymentNameInstance = deploymentNameElement.Value;
                                    attachedToInstance.DeploymentName = deploymentNameInstance;
                                }
                                
                                XElement roleNameElement = attachedToElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                                if (roleNameElement != null)
                                {
                                    string roleNameInstance = roleNameElement.Value;
                                    attachedToInstance.RoleName = roleNameInstance;
                                }
                            }
                            
                            XElement isCorruptedElement = disksElement.Element(XName.Get("IsCorrupted", "http://schemas.microsoft.com/windowsazure"));
                            if (isCorruptedElement != null && string.IsNullOrEmpty(isCorruptedElement.Value) == false)
                            {
                                bool isCorruptedInstance = bool.Parse(isCorruptedElement.Value);
                                diskInstance.IsCorrupted = isCorruptedInstance;
                            }
                            
                            XElement isPremiumElement = disksElement.Element(XName.Get("IsPremium", "http://schemas.microsoft.com/windowsazure"));
                            if (isPremiumElement != null && string.IsNullOrEmpty(isPremiumElement.Value) == false)
                            {
                                bool isPremiumInstance = bool.Parse(isPremiumElement.Value);
                                diskInstance.IsPremium = isPremiumInstance;
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Update Data Disk operation updates the specified data disk
        /// attached to the specified virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157190.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of the deployment.
        /// </param>
        /// <param name='roleName'>
        /// The name of the role to add the data disk to.
        /// </param>
        /// <param name='logicalUnitNumber'>
        /// The logical unit number of the disk.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Data Disk
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> UpdateDataDiskAsync(string serviceName, string deploymentName, string roleName, int logicalUnitNumber, VirtualMachineDiskUpdateDataDiskParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (roleName == null)
            {
                throw new ArgumentNullException("roleName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.MediaLinkUri == null)
            {
                throw new ArgumentNullException("parameters.MediaLinkUri");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("roleName", roleName);
                tracingParameters.Add("logicalUnitNumber", logicalUnitNumber);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "UpdateDataDiskAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roles/" + roleName + "/DataDisks/" + logicalUnitNumber;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Put;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement dataVirtualHardDiskElement = new XElement(XName.Get("DataVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(dataVirtualHardDiskElement);
                
                XElement hostCachingElement = new XElement(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                hostCachingElement.Value = parameters.HostCaching.ToString();
                dataVirtualHardDiskElement.Add(hostCachingElement);
                
                if (parameters.DiskLabel != null)
                {
                    XElement diskLabelElement = new XElement(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                    diskLabelElement.Value = parameters.DiskLabel;
                    dataVirtualHardDiskElement.Add(diskLabelElement);
                }
                
                if (parameters.DiskName != null)
                {
                    XElement diskNameElement = new XElement(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                    diskNameElement.Value = parameters.DiskName;
                    dataVirtualHardDiskElement.Add(diskNameElement);
                }
                
                if (parameters.LogicalUnitNumber != null)
                {
                    XElement lunElement = new XElement(XName.Get("Lun", "http://schemas.microsoft.com/windowsazure"));
                    lunElement.Value = parameters.LogicalUnitNumber.ToString();
                    dataVirtualHardDiskElement.Add(lunElement);
                }
                
                XElement logicalDiskSizeInGBElement = new XElement(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                logicalDiskSizeInGBElement.Value = parameters.LogicalDiskSizeInGB.ToString();
                dataVirtualHardDiskElement.Add(logicalDiskSizeInGBElement);
                
                XElement mediaLinkElement = new XElement(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                mediaLinkElement.Value = parameters.MediaLinkUri.ToString();
                dataVirtualHardDiskElement.Add(mediaLinkElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Add Disk operation adds a disk to the user image repository.
        /// The disk can be an operating system disk or a data disk.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157178.aspx
        /// for more information)
        /// </summary>
        /// <param name='diskName'>
        /// The name of the disk being updated.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Disk operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A virtual machine disk associated with your subscription.
        /// </returns>
        public async Task<VirtualMachineDiskUpdateDiskResponse> UpdateDiskAsync(string diskName, VirtualMachineDiskUpdateDiskParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (diskName == null)
            {
                throw new ArgumentNullException("diskName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.Label == null)
            {
                throw new ArgumentNullException("parameters.Label");
            }
            if (parameters.Name == null)
            {
                throw new ArgumentNullException("parameters.Name");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("diskName", diskName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "UpdateDiskAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/disks/" + diskName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Put;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement diskElement = new XElement(XName.Get("Disk", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(diskElement);
                
                if (parameters.HasOperatingSystem != null)
                {
                    XElement hasOperatingSystemElement = new XElement(XName.Get("HasOperatingSystem", "http://schemas.microsoft.com/windowsazure"));
                    hasOperatingSystemElement.Value = parameters.HasOperatingSystem.ToString().ToLower();
                    diskElement.Add(hasOperatingSystemElement);
                }
                
                if (parameters.OperatingSystemType != null)
                {
                    XElement osElement = new XElement(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                    osElement.Value = parameters.OperatingSystemType;
                    diskElement.Add(osElement);
                }
                
                XElement labelElement = new XElement(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                labelElement.Value = parameters.Label;
                diskElement.Add(labelElement);
                
                if (parameters.MediaLinkUri != null)
                {
                    XElement mediaLinkElement = new XElement(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                    mediaLinkElement.Value = parameters.MediaLinkUri.ToString();
                    diskElement.Add(mediaLinkElement);
                }
                
                XElement nameElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                nameElement.Value = parameters.Name;
                diskElement.Add(nameElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    VirtualMachineDiskUpdateDiskResponse result = new VirtualMachineDiskUpdateDiskResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement diskElement2 = responseDoc.Element(XName.Get("Disk", "http://schemas.microsoft.com/windowsazure"));
                    if (diskElement2 != null)
                    {
                        XElement osElement2 = diskElement2.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                        if (osElement2 != null)
                        {
                            string osInstance = osElement2.Value;
                            result.OperatingSystem = osInstance;
                        }
                        
                        XElement labelElement2 = diskElement2.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                        if (labelElement2 != null)
                        {
                            string labelInstance = labelElement2.Value;
                            result.Label = labelInstance;
                        }
                        
                        XElement affinityGroupElement = diskElement2.Element(XName.Get("AffinityGroup", "http://schemas.microsoft.com/windowsazure"));
                        if (affinityGroupElement != null)
                        {
                            string affinityGroupInstance = affinityGroupElement.Value;
                            result.AffinityGroup = affinityGroupInstance;
                        }
                        
                        XElement locationElement = diskElement2.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                        if (locationElement != null)
                        {
                            string locationInstance = locationElement.Value;
                            result.Location = locationInstance;
                        }
                        
                        XElement logicalDiskSizeInGBElement = diskElement2.Element(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                        if (logicalDiskSizeInGBElement != null)
                        {
                            double logicalDiskSizeInGBInstance = double.Parse(logicalDiskSizeInGBElement.Value, CultureInfo.InvariantCulture);
                            result.LogicalSizeInGB = logicalDiskSizeInGBInstance;
                        }
                        
                        XElement mediaLinkElement2 = diskElement2.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                        if (mediaLinkElement2 != null)
                        {
                            Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement2.Value);
                            result.MediaLinkUri = mediaLinkInstance;
                        }
                        
                        XElement nameElement2 = diskElement2.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        if (nameElement2 != null)
                        {
                            string nameInstance = nameElement2.Value;
                            result.Name = nameInstance;
                        }
                        
                        XElement isPremiumElement = diskElement2.Element(XName.Get("IsPremium", "http://schemas.microsoft.com/windowsazure"));
                        if (isPremiumElement != null && string.IsNullOrEmpty(isPremiumElement.Value) == false)
                        {
                            bool isPremiumInstance = bool.Parse(isPremiumElement.Value);
                            result.IsPremium = isPremiumInstance;
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the OS
    /// images in your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157175.aspx for
    /// more information)
    /// </summary>
    public partial interface IVirtualMachineImageOperations
    {
        /// <summary>
        /// The Add OS Image operation adds an operating system image that is
        /// stored in a storage account and is available from the image
        /// repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157192.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Image operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// Parameters returned from the Create Virtual Machine Image operation.
        /// </returns>
        Task<VirtualMachineImageCreateResponse> CreateAsync(VirtualMachineImageCreateParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete OS Image operation deletes the specified OS image from
        /// your image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157203.aspx
        /// for more information)
        /// </summary>
        /// <param name='imageName'>
        /// The name of the image to delete.
        /// </param>
        /// <param name='deleteFromStorage'>
        /// Optional. Specifies that the source blob for the image should also
        /// be deleted from storage.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> DeleteAsync(string imageName, bool deleteFromStorage, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get OS Image operation retrieves the details for an operating
        /// system image from the image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157191.aspx
        /// for more information)
        /// </summary>
        /// <param name='imageName'>
        /// The name of the OS image to retrieve
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A virtual machine image associated with your subscription.
        /// </returns>
        Task<VirtualMachineImageGetResponse> GetAsync(string imageName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The List OS Images operation retrieves a list of the operating
        /// system images from the image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157191.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List OS Images operation response.
        /// </returns>
        Task<VirtualMachineImageListResponse> ListAsync(CancellationToken cancellationToken);
        
        /// <summary>
        /// The Update OS Image operation updates an OS image that in your
        /// image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157198.aspx
        /// for more information)
        /// </summary>
        /// <param name='imageName'>
        /// The name of the virtual machine image to be updated.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Image operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// Parameters returned from the Create Virtual Machine Image operation.
        /// </returns>
        Task<VirtualMachineImageUpdateResponse> UpdateAsync(string imageName, VirtualMachineImageUpdateParameters parameters, CancellationToken cancellationToken);
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the OS
    /// images in your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157175.aspx for
    /// more information)
    /// </summary>
    public static partial class VirtualMachineImageOperationsExtensions
    {
        /// <summary>
        /// The Add OS Image operation adds an operating system image that is
        /// stored in a storage account and is available from the image
        /// repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157192.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineImageOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Image operation.
        /// </param>
        /// <returns>
        /// Parameters returned from the Create Virtual Machine Image operation.
        /// </returns>
        public static VirtualMachineImageCreateResponse Create(this IVirtualMachineImageOperations operations, VirtualMachineImageCreateParameters parameters)
        {
            try
            {
                return operations.CreateAsync(parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Add OS Image operation adds an operating system image that is
        /// stored in a storage account and is available from the image
        /// repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157192.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineImageOperations.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Image operation.
        /// </param>
        /// <returns>
        /// Parameters returned from the Create Virtual Machine Image operation.
        /// </returns>
        public static Task<VirtualMachineImageCreateResponse> CreateAsync(this IVirtualMachineImageOperations operations, VirtualMachineImageCreateParameters parameters)
        {
            return operations.CreateAsync(parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete OS Image operation deletes the specified OS image from
        /// your image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157203.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineImageOperations.
        /// </param>
        /// <param name='imageName'>
        /// The name of the image to delete.
        /// </param>
        /// <param name='deleteFromStorage'>
        /// Optional. Specifies that the source blob for the image should also
        /// be deleted from storage.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse Delete(this IVirtualMachineImageOperations operations, string imageName, bool deleteFromStorage)
        {
            try
            {
                return operations.DeleteAsync(imageName, deleteFromStorage).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete OS Image operation deletes the specified OS image from
        /// your image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157203.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineImageOperations.
        /// </param>
        /// <param name='imageName'>
        /// The name of the image to delete.
        /// </param>
        /// <param name='deleteFromStorage'>
        /// Optional. Specifies that the source blob for the image should also
        /// be deleted from storage.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> DeleteAsync(this IVirtualMachineImageOperations operations, string imageName, bool deleteFromStorage)
        {
            return operations.DeleteAsync(imageName, deleteFromStorage, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get OS Image operation retrieves the details for an operating
        /// system image from the image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157191.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineImageOperations.
        /// </param>
        /// <param name='imageName'>
        /// The name of the OS image to retrieve
        /// </param>
        /// <returns>
        /// A virtual machine image associated with your subscription.
        /// </returns>
        public static VirtualMachineImageGetResponse Get(this IVirtualMachineImageOperations operations, string imageName)
        {
            try
            {
                return operations.GetAsync(imageName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get OS Image operation retrieves the details for an operating
        /// system image from the image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157191.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineImageOperations.
        /// </param>
        /// <param name='imageName'>
        /// The name of the OS image to retrieve
        /// </param>
        /// <returns>
        /// A virtual machine image associated with your subscription.
        /// </returns>
        public static Task<VirtualMachineImageGetResponse> GetAsync(this IVirtualMachineImageOperations operations, string imageName)
        {
            return operations.GetAsync(imageName, CancellationToken.None);
        }
        
        /// <summary>
        /// The List OS Images operation retrieves a list of the operating
        /// system images from the image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157191.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineImageOperations.
        /// </param>
        /// <returns>
        /// The List OS Images operation response.
        /// </returns>
        public static VirtualMachineImageListResponse List(this IVirtualMachineImageOperations operations)
        {
            try
            {
                return operations.ListAsync().Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The List OS Images operation retrieves a list of the operating
        /// system images from the image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157191.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineImageOperations.
        /// </param>
        /// <returns>
        /// The List OS Images operation response.
        /// </returns>
        public static Task<VirtualMachineImageListResponse> ListAsync(this IVirtualMachineImageOperations operations)
        {
            return operations.ListAsync(CancellationToken.None);
        }
        
        /// <summary>
        /// The Update OS Image operation updates an OS image that in your
        /// image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157198.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineImageOperations.
        /// </param>
        /// <param name='imageName'>
        /// The name of the virtual machine image to be updated.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Image operation.
        /// </param>
        /// <returns>
        /// Parameters returned from the Create Virtual Machine Image operation.
        /// </returns>
        public static VirtualMachineImageUpdateResponse Update(this IVirtualMachineImageOperations operations, string imageName, VirtualMachineImageUpdateParameters parameters)
        {
            try
            {
                return operations.UpdateAsync(imageName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Update OS Image operation updates an OS image that in your
        /// image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157198.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineImageOperations.
        /// </param>
        /// <param name='imageName'>
        /// The name of the virtual machine image to be updated.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Image operation.
        /// </param>
        /// <returns>
        /// Parameters returned from the Create Virtual Machine Image operation.
        /// </returns>
        public static Task<VirtualMachineImageUpdateResponse> UpdateAsync(this IVirtualMachineImageOperations operations, string imageName, VirtualMachineImageUpdateParameters parameters)
        {
            return operations.UpdateAsync(imageName, parameters, CancellationToken.None);
        }
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the OS
    /// images in your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157175.aspx for
    /// more information)
    /// </summary>
    internal partial class VirtualMachineImageOperations : IServiceOperations<ComputeManagementClient>, IVirtualMachineImageOperations
    {
        /// <summary>
        /// Initializes a new instance of the VirtualMachineImageOperations
        /// class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        internal VirtualMachineImageOperations(ComputeManagementClient client)
        {
            this._client = client;
        }
        
        private ComputeManagementClient _client;
        
        /// <summary>
        /// Gets a reference to the
        /// Microsoft.WindowsAzure.Management.Compute.ComputeManagementClient.
        /// </summary>
        public ComputeManagementClient Client
        {
            get { return this._client; }
        }
        
        /// <summary>
        /// The Add OS Image operation adds an operating system image that is
        /// stored in a storage account and is available from the image
        /// repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157192.aspx
        /// for more information)
        /// </summary>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Image operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// Parameters returned from the Create Virtual Machine Image operation.
        /// </returns>
        public async Task<VirtualMachineImageCreateResponse> CreateAsync(VirtualMachineImageCreateParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.Label == null)
            {
                throw new ArgumentNullException("parameters.Label");
            }
            if (parameters.MediaLinkUri == null)
            {
                throw new ArgumentNullException("parameters.MediaLinkUri");
            }
            if (parameters.Name == null)
            {
                throw new ArgumentNullException("parameters.Name");
            }
            if (parameters.OperatingSystemType == null)
            {
                throw new ArgumentNullException("parameters.OperatingSystemType");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "CreateAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/images";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement oSImageElement = new XElement(XName.Get("OSImage", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(oSImageElement);
                
                XElement labelElement = new XElement(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                labelElement.Value = parameters.Label;
                oSImageElement.Add(labelElement);
                
                XElement mediaLinkElement = new XElement(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                mediaLinkElement.Value = parameters.MediaLinkUri.ToString();
                oSImageElement.Add(mediaLinkElement);
                
                XElement nameElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                nameElement.Value = parameters.Name;
                oSImageElement.Add(nameElement);
                
                XElement osElement = new XElement(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                osElement.Value = parameters.OperatingSystemType;
                oSImageElement.Add(osElement);
                
                if (parameters.Eula != null)
                {
                    XElement eulaElement = new XElement(XName.Get("Eula", "http://schemas.microsoft.com/windowsazure"));
                    eulaElement.Value = parameters.Eula;
                    oSImageElement.Add(eulaElement);
                }
                
                if (parameters.Description != null)
                {
                    XElement descriptionElement = new XElement(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                    descriptionElement.Value = parameters.Description;
                    oSImageElement.Add(descriptionElement);
                }
                
                if (parameters.ImageFamily != null)
                {
                    XElement imageFamilyElement = new XElement(XName.Get("ImageFamily", "http://schemas.microsoft.com/windowsazure"));
                    imageFamilyElement.Value = parameters.ImageFamily;
                    oSImageElement.Add(imageFamilyElement);
                }
                
                if (parameters.PublishedDate != null)
                {
                    XElement publishedDateElement = new XElement(XName.Get("PublishedDate", "http://schemas.microsoft.com/windowsazure"));
                    publishedDateElement.Value = parameters.PublishedDate.ToString();
                    oSImageElement.Add(publishedDateElement);
                }
                
                XElement isPremiumElement = new XElement(XName.Get("IsPremium", "http://schemas.microsoft.com/windowsazure"));
                isPremiumElement.Value = parameters.IsPremium.ToString().ToLower();
                oSImageElement.Add(isPremiumElement);
                
                XElement showInGuiElement = new XElement(XName.Get("ShowInGui", "http://schemas.microsoft.com/windowsazure"));
                showInGuiElement.Value = parameters.ShowInGui.ToString().ToLower();
                oSImageElement.Add(showInGuiElement);
                
                if (parameters.PrivacyUri != null)
                {
                    XElement privacyUriElement = new XElement(XName.Get("PrivacyUri", "http://schemas.microsoft.com/windowsazure"));
                    privacyUriElement.Value = parameters.PrivacyUri.ToString();
                    oSImageElement.Add(privacyUriElement);
                }
                
                if (parameters.IconUri != null)
                {
                    XElement iconUriElement = new XElement(XName.Get("IconUri", "http://schemas.microsoft.com/windowsazure"));
                    iconUriElement.Value = parameters.IconUri.ToString();
                    oSImageElement.Add(iconUriElement);
                }
                
                if (parameters.RecommendedVMSize != null)
                {
                    XElement recommendedVMSizeElement = new XElement(XName.Get("RecommendedVMSize", "http://schemas.microsoft.com/windowsazure"));
                    recommendedVMSizeElement.Value = parameters.RecommendedVMSize.ToString();
                    oSImageElement.Add(recommendedVMSizeElement);
                }
                
                if (parameters.SmallIconUri != null)
                {
                    XElement smallIconUriElement = new XElement(XName.Get("SmallIconUri", "http://schemas.microsoft.com/windowsazure"));
                    smallIconUriElement.Value = parameters.SmallIconUri.ToString();
                    oSImageElement.Add(smallIconUriElement);
                }
                
                if (parameters.Language != null)
                {
                    XElement languageElement = new XElement(XName.Get("Language", "http://schemas.microsoft.com/windowsazure"));
                    languageElement.Value = parameters.Language;
                    oSImageElement.Add(languageElement);
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    VirtualMachineImageCreateResponse result = new VirtualMachineImageCreateResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement oSImageElement2 = responseDoc.Element(XName.Get("OSImage", "http://schemas.microsoft.com/windowsazure"));
                    if (oSImageElement2 != null)
                    {
                        XElement locationElement = oSImageElement2.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                        if (locationElement != null)
                        {
                            string locationInstance = locationElement.Value;
                            result.Location = locationInstance;
                        }
                        
                        XElement categoryElement = oSImageElement2.Element(XName.Get("Category", "http://schemas.microsoft.com/windowsazure"));
                        if (categoryElement != null)
                        {
                            string categoryInstance = categoryElement.Value;
                            result.Category = categoryInstance;
                        }
                        
                        XElement labelElement2 = oSImageElement2.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                        if (labelElement2 != null)
                        {
                            string labelInstance = labelElement2.Value;
                            result.Label = labelInstance;
                        }
                        
                        XElement logicalSizeInGBElement = oSImageElement2.Element(XName.Get("LogicalSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                        if (logicalSizeInGBElement != null)
                        {
                            double logicalSizeInGBInstance = double.Parse(logicalSizeInGBElement.Value, CultureInfo.InvariantCulture);
                            result.LogicalSizeInGB = logicalSizeInGBInstance;
                        }
                        
                        XElement mediaLinkElement2 = oSImageElement2.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                        if (mediaLinkElement2 != null)
                        {
                            Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement2.Value);
                            result.MediaLinkUri = mediaLinkInstance;
                        }
                        
                        XElement nameElement2 = oSImageElement2.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        if (nameElement2 != null)
                        {
                            string nameInstance = nameElement2.Value;
                            result.Name = nameInstance;
                        }
                        
                        XElement osElement2 = oSImageElement2.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                        if (osElement2 != null)
                        {
                            string osInstance = osElement2.Value;
                            result.OperatingSystemType = osInstance;
                        }
                        
                        XElement eulaElement2 = oSImageElement2.Element(XName.Get("Eula", "http://schemas.microsoft.com/windowsazure"));
                        if (eulaElement2 != null)
                        {
                            string eulaInstance = eulaElement2.Value;
                            result.Eula = eulaInstance;
                        }
                        
                        XElement descriptionElement2 = oSImageElement2.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                        if (descriptionElement2 != null)
                        {
                            string descriptionInstance = descriptionElement2.Value;
                            result.Description = descriptionInstance;
                        }
                        
                        XElement imageFamilyElement2 = oSImageElement2.Element(XName.Get("ImageFamily", "http://schemas.microsoft.com/windowsazure"));
                        if (imageFamilyElement2 != null)
                        {
                            string imageFamilyInstance = imageFamilyElement2.Value;
                            result.ImageFamily = imageFamilyInstance;
                        }
                        
                        XElement publishedDateElement2 = oSImageElement2.Element(XName.Get("PublishedDate", "http://schemas.microsoft.com/windowsazure"));
                        if (publishedDateElement2 != null && string.IsNullOrEmpty(publishedDateElement2.Value) == false)
                        {
                            DateTime publishedDateInstance = DateTime.Parse(publishedDateElement2.Value, CultureInfo.InvariantCulture);
                            result.PublishedDate = publishedDateInstance;
                        }
                        
                        XElement publisherNameElement = oSImageElement2.Element(XName.Get("PublisherName", "http://schemas.microsoft.com/windowsazure"));
                        if (publisherNameElement != null)
                        {
                            string publisherNameInstance = publisherNameElement.Value;
                            result.PublisherName = publisherNameInstance;
                        }
                        
                        XElement isPremiumElement2 = oSImageElement2.Element(XName.Get("IsPremium", "http://schemas.microsoft.com/windowsazure"));
                        if (isPremiumElement2 != null && string.IsNullOrEmpty(isPremiumElement2.Value) == false)
                        {
                            bool isPremiumInstance = bool.Parse(isPremiumElement2.Value);
                            result.IsPremium = isPremiumInstance;
                        }
                        
                        XElement showInGuiElement2 = oSImageElement2.Element(XName.Get("ShowInGui", "http://schemas.microsoft.com/windowsazure"));
                        if (showInGuiElement2 != null && string.IsNullOrEmpty(showInGuiElement2.Value) == false)
                        {
                            bool showInGuiInstance = bool.Parse(showInGuiElement2.Value);
                            result.ShowInGui = showInGuiInstance;
                        }
                        
                        XElement privacyUriElement2 = oSImageElement2.Element(XName.Get("PrivacyUri", "http://schemas.microsoft.com/windowsazure"));
                        if (privacyUriElement2 != null)
                        {
                            Uri privacyUriInstance = TypeConversion.TryParseUri(privacyUriElement2.Value);
                            result.PrivacyUri = privacyUriInstance;
                        }
                        
                        XElement iconUriElement2 = oSImageElement2.Element(XName.Get("IconUri", "http://schemas.microsoft.com/windowsazure"));
                        if (iconUriElement2 != null)
                        {
                            Uri iconUriInstance = TypeConversion.TryParseUri(iconUriElement2.Value);
                            result.IconUri = iconUriInstance;
                        }
                        
                        XElement recommendedVMSizeElement2 = oSImageElement2.Element(XName.Get("RecommendedVMSize", "http://schemas.microsoft.com/windowsazure"));
                        if (recommendedVMSizeElement2 != null)
                        {
                            VirtualMachineRoleSize recommendedVMSizeInstance = (VirtualMachineRoleSize)Enum.Parse(typeof(VirtualMachineRoleSize), recommendedVMSizeElement2.Value, false);
                            result.RecommendedVMSize = recommendedVMSizeInstance;
                        }
                        
                        XElement smallIconUriElement2 = oSImageElement2.Element(XName.Get("SmallIconUri", "http://schemas.microsoft.com/windowsazure"));
                        if (smallIconUriElement2 != null)
                        {
                            Uri smallIconUriInstance = TypeConversion.TryParseUri(smallIconUriElement2.Value);
                            result.SmallIconUri = smallIconUriInstance;
                        }
                        
                        XElement languageElement2 = oSImageElement2.Element(XName.Get("Language", "http://schemas.microsoft.com/windowsazure"));
                        if (languageElement2 != null)
                        {
                            string languageInstance = languageElement2.Value;
                            result.Language = languageInstance;
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete OS Image operation deletes the specified OS image from
        /// your image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157203.aspx
        /// for more information)
        /// </summary>
        /// <param name='imageName'>
        /// The name of the image to delete.
        /// </param>
        /// <param name='deleteFromStorage'>
        /// Optional. Specifies that the source blob for the image should also
        /// be deleted from storage.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> DeleteAsync(string imageName, bool deleteFromStorage, CancellationToken cancellationToken)
        {
            // Validate
            if (imageName == null)
            {
                throw new ArgumentNullException("imageName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("imageName", imageName);
                tracingParameters.Add("deleteFromStorage", deleteFromStorage);
                Tracing.Enter(invocationId, this, "DeleteAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/images/" + imageName + "?";
            if (deleteFromStorage == true)
            {
                url = url + "&comp=" + Uri.EscapeUriString("media");
            }
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Delete;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get OS Image operation retrieves the details for an operating
        /// system image from the image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157191.aspx
        /// for more information)
        /// </summary>
        /// <param name='imageName'>
        /// The name of the OS image to retrieve
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A virtual machine image associated with your subscription.
        /// </returns>
        public async Task<VirtualMachineImageGetResponse> GetAsync(string imageName, CancellationToken cancellationToken)
        {
            // Validate
            if (imageName == null)
            {
                throw new ArgumentNullException("imageName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("imageName", imageName);
                Tracing.Enter(invocationId, this, "GetAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/images/" + imageName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    VirtualMachineImageGetResponse result = new VirtualMachineImageGetResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement oSImageElement = responseDoc.Element(XName.Get("OSImage", "http://schemas.microsoft.com/windowsazure"));
                    if (oSImageElement != null)
                    {
                        XElement affinityGroupElement = oSImageElement.Element(XName.Get("AffinityGroup", "http://schemas.microsoft.com/windowsazure"));
                        if (affinityGroupElement != null)
                        {
                            string affinityGroupInstance = affinityGroupElement.Value;
                            result.AffinityGroup = affinityGroupInstance;
                        }
                        
                        XElement categoryElement = oSImageElement.Element(XName.Get("Category", "http://schemas.microsoft.com/windowsazure"));
                        if (categoryElement != null)
                        {
                            string categoryInstance = categoryElement.Value;
                            result.Category = categoryInstance;
                        }
                        
                        XElement labelElement = oSImageElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                        if (labelElement != null)
                        {
                            string labelInstance = labelElement.Value;
                            result.Label = labelInstance;
                        }
                        
                        XElement locationElement = oSImageElement.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                        if (locationElement != null)
                        {
                            string locationInstance = locationElement.Value;
                            result.Location = locationInstance;
                        }
                        
                        XElement logicalSizeInGBElement = oSImageElement.Element(XName.Get("LogicalSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                        if (logicalSizeInGBElement != null)
                        {
                            double logicalSizeInGBInstance = double.Parse(logicalSizeInGBElement.Value, CultureInfo.InvariantCulture);
                            result.LogicalSizeInGB = logicalSizeInGBInstance;
                        }
                        
                        XElement mediaLinkElement = oSImageElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                        if (mediaLinkElement != null)
                        {
                            Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement.Value);
                            result.MediaLinkUri = mediaLinkInstance;
                        }
                        
                        XElement nameElement = oSImageElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        if (nameElement != null)
                        {
                            string nameInstance = nameElement.Value;
                            result.Name = nameInstance;
                        }
                        
                        XElement osElement = oSImageElement.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                        if (osElement != null)
                        {
                            string osInstance = osElement.Value;
                            result.OperatingSystemType = osInstance;
                        }
                        
                        XElement eulaElement = oSImageElement.Element(XName.Get("Eula", "http://schemas.microsoft.com/windowsazure"));
                        if (eulaElement != null)
                        {
                            string eulaInstance = eulaElement.Value;
                            result.Eula = eulaInstance;
                        }
                        
                        XElement descriptionElement = oSImageElement.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                        if (descriptionElement != null)
                        {
                            string descriptionInstance = descriptionElement.Value;
                            result.Description = descriptionInstance;
                        }
                        
                        XElement imageFamilyElement = oSImageElement.Element(XName.Get("ImageFamily", "http://schemas.microsoft.com/windowsazure"));
                        if (imageFamilyElement != null)
                        {
                            string imageFamilyInstance = imageFamilyElement.Value;
                            result.ImageFamily = imageFamilyInstance;
                        }
                        
                        XElement showInGuiElement = oSImageElement.Element(XName.Get("ShowInGui", "http://schemas.microsoft.com/windowsazure"));
                        if (showInGuiElement != null && string.IsNullOrEmpty(showInGuiElement.Value) == false)
                        {
                            bool showInGuiInstance = bool.Parse(showInGuiElement.Value);
                            result.ShowInGui = showInGuiInstance;
                        }
                        
                        XElement publishedDateElement = oSImageElement.Element(XName.Get("PublishedDate", "http://schemas.microsoft.com/windowsazure"));
                        if (publishedDateElement != null)
                        {
                            DateTime publishedDateInstance = DateTime.Parse(publishedDateElement.Value, CultureInfo.InvariantCulture);
                            result.PublishedDate = publishedDateInstance;
                        }
                        
                        XElement isPremiumElement = oSImageElement.Element(XName.Get("IsPremium", "http://schemas.microsoft.com/windowsazure"));
                        if (isPremiumElement != null && string.IsNullOrEmpty(isPremiumElement.Value) == false)
                        {
                            bool isPremiumInstance = bool.Parse(isPremiumElement.Value);
                            result.IsPremium = isPremiumInstance;
                        }
                        
                        XElement iconUriElement = oSImageElement.Element(XName.Get("IconUri", "http://schemas.microsoft.com/windowsazure"));
                        if (iconUriElement != null)
                        {
                            Uri iconUriInstance = TypeConversion.TryParseUri(iconUriElement.Value);
                            result.IconUri = iconUriInstance;
                        }
                        
                        XElement privacyUriElement = oSImageElement.Element(XName.Get("PrivacyUri", "http://schemas.microsoft.com/windowsazure"));
                        if (privacyUriElement != null)
                        {
                            Uri privacyUriInstance = TypeConversion.TryParseUri(privacyUriElement.Value);
                            result.PrivacyUri = privacyUriInstance;
                        }
                        
                        XElement recommendedVMSizeElement = oSImageElement.Element(XName.Get("RecommendedVMSize", "http://schemas.microsoft.com/windowsazure"));
                        if (recommendedVMSizeElement != null)
                        {
                            VirtualMachineRoleSize recommendedVMSizeInstance = (VirtualMachineRoleSize)Enum.Parse(typeof(VirtualMachineRoleSize), recommendedVMSizeElement.Value, false);
                            result.RecommendedVMSize = recommendedVMSizeInstance;
                        }
                        
                        XElement publisherNameElement = oSImageElement.Element(XName.Get("PublisherName", "http://schemas.microsoft.com/windowsazure"));
                        if (publisherNameElement != null)
                        {
                            string publisherNameInstance = publisherNameElement.Value;
                            result.PublisherName = publisherNameInstance;
                        }
                        
                        XElement smallIconUriElement = oSImageElement.Element(XName.Get("SmallIconUri", "http://schemas.microsoft.com/windowsazure"));
                        if (smallIconUriElement != null)
                        {
                            Uri smallIconUriInstance = TypeConversion.TryParseUri(smallIconUriElement.Value);
                            result.SmallIconUri = smallIconUriInstance;
                        }
                        
                        XElement languageElement = oSImageElement.Element(XName.Get("Language", "http://schemas.microsoft.com/windowsazure"));
                        if (languageElement != null)
                        {
                            string languageInstance = languageElement.Value;
                            result.Language = languageInstance;
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The List OS Images operation retrieves a list of the operating
        /// system images from the image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157191.aspx
        /// for more information)
        /// </summary>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The List OS Images operation response.
        /// </returns>
        public async Task<VirtualMachineImageListResponse> ListAsync(CancellationToken cancellationToken)
        {
            // Validate
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                Tracing.Enter(invocationId, this, "ListAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/images";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    VirtualMachineImageListResponse result = new VirtualMachineImageListResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement imagesSequenceElement = responseDoc.Element(XName.Get("Images", "http://schemas.microsoft.com/windowsazure"));
                    if (imagesSequenceElement != null)
                    {
                        foreach (XElement imagesElement in imagesSequenceElement.Elements(XName.Get("OSImage", "http://schemas.microsoft.com/windowsazure")))
                        {
                            VirtualMachineImageListResponse.VirtualMachineImage oSImageInstance = new VirtualMachineImageListResponse.VirtualMachineImage();
                            result.Images.Add(oSImageInstance);
                            
                            XElement affinityGroupElement = imagesElement.Element(XName.Get("AffinityGroup", "http://schemas.microsoft.com/windowsazure"));
                            if (affinityGroupElement != null)
                            {
                                string affinityGroupInstance = affinityGroupElement.Value;
                                oSImageInstance.AffinityGroup = affinityGroupInstance;
                            }
                            
                            XElement categoryElement = imagesElement.Element(XName.Get("Category", "http://schemas.microsoft.com/windowsazure"));
                            if (categoryElement != null)
                            {
                                string categoryInstance = categoryElement.Value;
                                oSImageInstance.Category = categoryInstance;
                            }
                            
                            XElement labelElement = imagesElement.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                            if (labelElement != null)
                            {
                                string labelInstance = labelElement.Value;
                                oSImageInstance.Label = labelInstance;
                            }
                            
                            XElement locationElement = imagesElement.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                            if (locationElement != null)
                            {
                                string locationInstance = locationElement.Value;
                                oSImageInstance.Location = locationInstance;
                            }
                            
                            XElement logicalSizeInGBElement = imagesElement.Element(XName.Get("LogicalSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                            if (logicalSizeInGBElement != null)
                            {
                                double logicalSizeInGBInstance = double.Parse(logicalSizeInGBElement.Value, CultureInfo.InvariantCulture);
                                oSImageInstance.LogicalSizeInGB = logicalSizeInGBInstance;
                            }
                            
                            XElement mediaLinkElement = imagesElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                            if (mediaLinkElement != null)
                            {
                                Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement.Value);
                                oSImageInstance.MediaLinkUri = mediaLinkInstance;
                            }
                            
                            XElement nameElement = imagesElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                            if (nameElement != null)
                            {
                                string nameInstance = nameElement.Value;
                                oSImageInstance.Name = nameInstance;
                            }
                            
                            XElement osElement = imagesElement.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                            if (osElement != null)
                            {
                                string osInstance = osElement.Value;
                                oSImageInstance.OperatingSystemType = osInstance;
                            }
                            
                            XElement eulaElement = imagesElement.Element(XName.Get("Eula", "http://schemas.microsoft.com/windowsazure"));
                            if (eulaElement != null)
                            {
                                string eulaInstance = eulaElement.Value;
                                oSImageInstance.Eula = eulaInstance;
                            }
                            
                            XElement descriptionElement = imagesElement.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                            if (descriptionElement != null)
                            {
                                string descriptionInstance = descriptionElement.Value;
                                oSImageInstance.Description = descriptionInstance;
                            }
                            
                            XElement imageFamilyElement = imagesElement.Element(XName.Get("ImageFamily", "http://schemas.microsoft.com/windowsazure"));
                            if (imageFamilyElement != null)
                            {
                                string imageFamilyInstance = imageFamilyElement.Value;
                                oSImageInstance.ImageFamily = imageFamilyInstance;
                            }
                            
                            XElement publishedDateElement = imagesElement.Element(XName.Get("PublishedDate", "http://schemas.microsoft.com/windowsazure"));
                            if (publishedDateElement != null)
                            {
                                DateTime publishedDateInstance = DateTime.Parse(publishedDateElement.Value, CultureInfo.InvariantCulture);
                                oSImageInstance.PublishedDate = publishedDateInstance;
                            }
                            
                            XElement isPremiumElement = imagesElement.Element(XName.Get("IsPremium", "http://schemas.microsoft.com/windowsazure"));
                            if (isPremiumElement != null && string.IsNullOrEmpty(isPremiumElement.Value) == false)
                            {
                                bool isPremiumInstance = bool.Parse(isPremiumElement.Value);
                                oSImageInstance.IsPremium = isPremiumInstance;
                            }
                            
                            XElement privacyUriElement = imagesElement.Element(XName.Get("PrivacyUri", "http://schemas.microsoft.com/windowsazure"));
                            if (privacyUriElement != null)
                            {
                                Uri privacyUriInstance = TypeConversion.TryParseUri(privacyUriElement.Value);
                                oSImageInstance.PrivacyUri = privacyUriInstance;
                            }
                            
                            XElement recommendedVMSizeElement = imagesElement.Element(XName.Get("RecommendedVMSize", "http://schemas.microsoft.com/windowsazure"));
                            if (recommendedVMSizeElement != null)
                            {
                                VirtualMachineRoleSize recommendedVMSizeInstance = (VirtualMachineRoleSize)Enum.Parse(typeof(VirtualMachineRoleSize), recommendedVMSizeElement.Value, false);
                                oSImageInstance.RecommendedVMSize = recommendedVMSizeInstance;
                            }
                            
                            XElement publisherNameElement = imagesElement.Element(XName.Get("PublisherName", "http://schemas.microsoft.com/windowsazure"));
                            if (publisherNameElement != null)
                            {
                                string publisherNameInstance = publisherNameElement.Value;
                                oSImageInstance.PublisherName = publisherNameInstance;
                            }
                            
                            XElement pricingDetailLinkElement = imagesElement.Element(XName.Get("PricingDetailLink", "http://schemas.microsoft.com/windowsazure"));
                            if (pricingDetailLinkElement != null)
                            {
                                Uri pricingDetailLinkInstance = TypeConversion.TryParseUri(pricingDetailLinkElement.Value);
                                oSImageInstance.PricingDetailUri = pricingDetailLinkInstance;
                            }
                            
                            XElement smallIconUriElement = imagesElement.Element(XName.Get("SmallIconUri", "http://schemas.microsoft.com/windowsazure"));
                            if (smallIconUriElement != null)
                            {
                                Uri smallIconUriInstance = TypeConversion.TryParseUri(smallIconUriElement.Value);
                                oSImageInstance.SmallIconUri = smallIconUriInstance;
                            }
                            
                            XElement languageElement = imagesElement.Element(XName.Get("Language", "http://schemas.microsoft.com/windowsazure"));
                            if (languageElement != null)
                            {
                                string languageInstance = languageElement.Value;
                                oSImageInstance.Language = languageInstance;
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Update OS Image operation updates an OS image that in your
        /// image repository.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157198.aspx
        /// for more information)
        /// </summary>
        /// <param name='imageName'>
        /// The name of the virtual machine image to be updated.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine Image operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// Parameters returned from the Create Virtual Machine Image operation.
        /// </returns>
        public async Task<VirtualMachineImageUpdateResponse> UpdateAsync(string imageName, VirtualMachineImageUpdateParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (imageName == null)
            {
                throw new ArgumentNullException("imageName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.Label == null)
            {
                throw new ArgumentNullException("parameters.Label");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("imageName", imageName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "UpdateAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/images/" + imageName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Put;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement oSImageElement = new XElement(XName.Get("OSImage", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(oSImageElement);
                
                XElement labelElement = new XElement(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                labelElement.Value = parameters.Label;
                oSImageElement.Add(labelElement);
                
                if (parameters.Eula != null)
                {
                    XElement eulaElement = new XElement(XName.Get("Eula", "http://schemas.microsoft.com/windowsazure"));
                    eulaElement.Value = parameters.Eula;
                    oSImageElement.Add(eulaElement);
                }
                
                if (parameters.Description != null)
                {
                    XElement descriptionElement = new XElement(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                    descriptionElement.Value = parameters.Description;
                    oSImageElement.Add(descriptionElement);
                }
                
                if (parameters.ImageFamily != null)
                {
                    XElement imageFamilyElement = new XElement(XName.Get("ImageFamily", "http://schemas.microsoft.com/windowsazure"));
                    imageFamilyElement.Value = parameters.ImageFamily;
                    oSImageElement.Add(imageFamilyElement);
                }
                
                if (parameters.PublishedDate != null)
                {
                    XElement publishedDateElement = new XElement(XName.Get("PublishedDate", "http://schemas.microsoft.com/windowsazure"));
                    publishedDateElement.Value = parameters.PublishedDate.ToString();
                    oSImageElement.Add(publishedDateElement);
                }
                
                XElement isPremiumElement = new XElement(XName.Get("IsPremium", "http://schemas.microsoft.com/windowsazure"));
                isPremiumElement.Value = parameters.IsPremium.ToString().ToLower();
                oSImageElement.Add(isPremiumElement);
                
                if (parameters.PrivacyUri != null)
                {
                    XElement privacyUriElement = new XElement(XName.Get("PrivacyUri", "http://schemas.microsoft.com/windowsazure"));
                    privacyUriElement.Value = parameters.PrivacyUri.ToString();
                    oSImageElement.Add(privacyUriElement);
                }
                
                if (parameters.IconUri != null)
                {
                    XElement iconUriElement = new XElement(XName.Get("IconUri", "http://schemas.microsoft.com/windowsazure"));
                    iconUriElement.Value = parameters.IconUri.ToString();
                    oSImageElement.Add(iconUriElement);
                }
                
                if (parameters.RecommendedVMSize != null)
                {
                    XElement recommendedVMSizeElement = new XElement(XName.Get("RecommendedVMSize", "http://schemas.microsoft.com/windowsazure"));
                    recommendedVMSizeElement.Value = parameters.RecommendedVMSize.ToString();
                    oSImageElement.Add(recommendedVMSizeElement);
                }
                
                if (parameters.SmallIconUri != null)
                {
                    XElement smallIconUriElement = new XElement(XName.Get("SmallIconUri", "http://schemas.microsoft.com/windowsazure"));
                    smallIconUriElement.Value = parameters.SmallIconUri.ToString();
                    oSImageElement.Add(smallIconUriElement);
                }
                
                if (parameters.Language != null)
                {
                    XElement languageElement = new XElement(XName.Get("Language", "http://schemas.microsoft.com/windowsazure"));
                    languageElement.Value = parameters.Language;
                    oSImageElement.Add(languageElement);
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    VirtualMachineImageUpdateResponse result = new VirtualMachineImageUpdateResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement oSImageElement2 = responseDoc.Element(XName.Get("OSImage", "http://schemas.microsoft.com/windowsazure"));
                    if (oSImageElement2 != null)
                    {
                        XElement locationElement = oSImageElement2.Element(XName.Get("Location", "http://schemas.microsoft.com/windowsazure"));
                        if (locationElement != null)
                        {
                            string locationInstance = locationElement.Value;
                            result.Location = locationInstance;
                        }
                        
                        XElement categoryElement = oSImageElement2.Element(XName.Get("Category", "http://schemas.microsoft.com/windowsazure"));
                        if (categoryElement != null)
                        {
                            string categoryInstance = categoryElement.Value;
                            result.Category = categoryInstance;
                        }
                        
                        XElement labelElement2 = oSImageElement2.Element(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                        if (labelElement2 != null)
                        {
                            string labelInstance = labelElement2.Value;
                            result.Label = labelInstance;
                        }
                        
                        XElement logicalSizeInGBElement = oSImageElement2.Element(XName.Get("LogicalSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                        if (logicalSizeInGBElement != null)
                        {
                            double logicalSizeInGBInstance = double.Parse(logicalSizeInGBElement.Value, CultureInfo.InvariantCulture);
                            result.LogicalSizeInGB = logicalSizeInGBInstance;
                        }
                        
                        XElement mediaLinkElement = oSImageElement2.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                        if (mediaLinkElement != null)
                        {
                            Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement.Value);
                            result.MediaLinkUri = mediaLinkInstance;
                        }
                        
                        XElement nameElement = oSImageElement2.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        if (nameElement != null)
                        {
                            string nameInstance = nameElement.Value;
                            result.Name = nameInstance;
                        }
                        
                        XElement osElement = oSImageElement2.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                        if (osElement != null)
                        {
                            string osInstance = osElement.Value;
                            result.OperatingSystemType = osInstance;
                        }
                        
                        XElement eulaElement2 = oSImageElement2.Element(XName.Get("Eula", "http://schemas.microsoft.com/windowsazure"));
                        if (eulaElement2 != null)
                        {
                            string eulaInstance = eulaElement2.Value;
                            result.Eula = eulaInstance;
                        }
                        
                        XElement descriptionElement2 = oSImageElement2.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                        if (descriptionElement2 != null)
                        {
                            string descriptionInstance = descriptionElement2.Value;
                            result.Description = descriptionInstance;
                        }
                        
                        XElement imageFamilyElement2 = oSImageElement2.Element(XName.Get("ImageFamily", "http://schemas.microsoft.com/windowsazure"));
                        if (imageFamilyElement2 != null)
                        {
                            string imageFamilyInstance = imageFamilyElement2.Value;
                            result.ImageFamily = imageFamilyInstance;
                        }
                        
                        XElement publishedDateElement2 = oSImageElement2.Element(XName.Get("PublishedDate", "http://schemas.microsoft.com/windowsazure"));
                        if (publishedDateElement2 != null && string.IsNullOrEmpty(publishedDateElement2.Value) == false)
                        {
                            DateTime publishedDateInstance = DateTime.Parse(publishedDateElement2.Value, CultureInfo.InvariantCulture);
                            result.PublishedDate = publishedDateInstance;
                        }
                        
                        XElement publisherNameElement = oSImageElement2.Element(XName.Get("PublisherName", "http://schemas.microsoft.com/windowsazure"));
                        if (publisherNameElement != null)
                        {
                            string publisherNameInstance = publisherNameElement.Value;
                            result.PublisherName = publisherNameInstance;
                        }
                        
                        XElement isPremiumElement2 = oSImageElement2.Element(XName.Get("IsPremium", "http://schemas.microsoft.com/windowsazure"));
                        if (isPremiumElement2 != null && string.IsNullOrEmpty(isPremiumElement2.Value) == false)
                        {
                            bool isPremiumInstance = bool.Parse(isPremiumElement2.Value);
                            result.IsPremium = isPremiumInstance;
                        }
                        
                        XElement showInGuiElement = oSImageElement2.Element(XName.Get("ShowInGui", "http://schemas.microsoft.com/windowsazure"));
                        if (showInGuiElement != null && string.IsNullOrEmpty(showInGuiElement.Value) == false)
                        {
                            bool showInGuiInstance = bool.Parse(showInGuiElement.Value);
                            result.ShowInGui = showInGuiInstance;
                        }
                        
                        XElement privacyUriElement2 = oSImageElement2.Element(XName.Get("PrivacyUri", "http://schemas.microsoft.com/windowsazure"));
                        if (privacyUriElement2 != null)
                        {
                            Uri privacyUriInstance = TypeConversion.TryParseUri(privacyUriElement2.Value);
                            result.PrivacyUri = privacyUriInstance;
                        }
                        
                        XElement iconUriElement2 = oSImageElement2.Element(XName.Get("IconUri", "http://schemas.microsoft.com/windowsazure"));
                        if (iconUriElement2 != null)
                        {
                            Uri iconUriInstance = TypeConversion.TryParseUri(iconUriElement2.Value);
                            result.IconUri = iconUriInstance;
                        }
                        
                        XElement recommendedVMSizeElement2 = oSImageElement2.Element(XName.Get("RecommendedVMSize", "http://schemas.microsoft.com/windowsazure"));
                        if (recommendedVMSizeElement2 != null)
                        {
                            VirtualMachineRoleSize recommendedVMSizeInstance = (VirtualMachineRoleSize)Enum.Parse(typeof(VirtualMachineRoleSize), recommendedVMSizeElement2.Value, false);
                            result.RecommendedVMSize = recommendedVMSizeInstance;
                        }
                        
                        XElement smallIconUriElement2 = oSImageElement2.Element(XName.Get("SmallIconUri", "http://schemas.microsoft.com/windowsazure"));
                        if (smallIconUriElement2 != null)
                        {
                            Uri smallIconUriInstance = TypeConversion.TryParseUri(smallIconUriElement2.Value);
                            result.SmallIconUri = smallIconUriInstance;
                        }
                        
                        XElement languageElement2 = oSImageElement2.Element(XName.Get("Language", "http://schemas.microsoft.com/windowsazure"));
                        if (languageElement2 != null)
                        {
                            string languageInstance = languageElement2.Value;
                            result.Language = languageInstance;
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the virtual
    /// machines in your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157206.aspx for
    /// more information)
    /// </summary>
    public partial interface IVirtualMachineOperations
    {
        /// <summary>
        /// The Capture Role operation creates a copy of the operating system
        /// virtual hard disk (VHD) that is deployed in the virtual machine,
        /// saves the VHD copy in the same storage location as the operating
        /// system VHD, and registers the copy as an image in your image
        /// gallery. From the captured image, you can create additional
        /// customized virtual machines. For more information about images and
        /// disks, see Manage Disks and Images. For more information about
        /// capturing images, see How to Capture an Image of a Virtual Machine
        /// Running Windows Server 2008 R2 or How to Capture an Image of a
        /// Virtual Machine Running Linux.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157201.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Capture Virtual Machine operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> CaptureAsync(string serviceName, string deploymentName, string virtualMachineName, VirtualMachineCaptureParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Add Role operation adds a virtual machine to an existing
        /// deployment.  You can refer to the OSDisk in the Add Role operation
        /// in the following ways.  Platform/User Image  Set the
        /// SourceImageName to a platform or user image. You can optionally
        /// specify the DiskName and MediaLink values as part the operation to
        /// control the name and location of target disk.  When DiskName and
        /// MediaLink are specified in this mode, they must not already exist
        /// in the system, otherwise a conflict fault is returned.  UserDisk 
        /// Set DiskName to a user supplied image in image repository.
        /// SourceImageName must be set to NULL. All other properties are
        /// ignored.  Blob in a Storage Account  Set MediaLink to a blob
        /// containing the image. SourceImageName and DiskName are set to
        /// NULL.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157186.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginCreatingAsync(string serviceName, string deploymentName, VirtualMachineCreateParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Add Role operation adds a virtual machine to an existing
        /// deployment.  You can refer to the OSDisk in the Add Role operation
        /// in the following ways.  Platform/User Image  Set the
        /// SourceImageName to a platform or user image. You can optionally
        /// specify the DiskName and MediaLink values as part the operation to
        /// control the name and location of target disk.  When DiskName and
        /// MediaLink are specified in this mode, they must not already exist
        /// in the system, otherwise a conflict fault is returned.  UserDisk 
        /// Set DiskName to a user supplied image in image repository.
        /// SourceImageName must be set to NULL. All other properties are
        /// ignored.  Blob in a Storage Account  Set MediaLink to a blob
        /// containing the image. SourceImageName and DiskName are set to
        /// NULL.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157186.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> CreateAsync(string serviceName, string deploymentName, VirtualMachineCreateParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Create Virtual Machine Deployment operation provisions a
        /// virtual machine based on the supplied configuration.  When you
        /// create a deployment of a virtual machine, you should make sure
        /// that the cloud service and the disk or image that you use are
        /// located in the same region. For example, if the cloud service was
        /// created in the West US region, the disk or image that you use
        /// should also be located in a stor4age account in the West US
        /// region.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157194.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginCreatingDeploymentAsync(string serviceName, VirtualMachineCreateDeploymentParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Create Virtual Machine Deployment operation provisions a
        /// virtual machine based on the supplied configuration.  When you
        /// create a deployment of a virtual machine, you should make sure
        /// that the cloud service and the disk or image that you use are
        /// located in the same region. For example, if the cloud service was
        /// created in the West US region, the disk or image that you use
        /// should also be located in a stor4age account in the West US
        /// region.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157194.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> CreateDeploymentAsync(string serviceName, VirtualMachineCreateDeploymentParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Role operation deletes the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157184.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to delete.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginDeletingAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Delete Role operation deletes the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157184.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to delete.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> DeleteAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Download RDP file operation retrieves the Remote Desktop
        /// Protocol configuration file from the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157183.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Download RDP file operation response.
        /// </returns>
        Task<VirtualMachineGetRemoteDesktopFileResponse> GetRemoteDesktopFileAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Get Role operation retrieves information about the specified
        /// virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157193.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Virtual Machine operation response.
        /// </returns>
        Task<VirtualMachineGetResponse> GetAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Restart role operation restarts the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157197.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginRestartingAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Restart role operation restarts the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157197.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> RestartAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Shutdown Role operation shuts down the specified virtual
        /// machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157195.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to shutdown.
        /// </param>
        /// <param name='parameters'>
        /// The parameters for the shutdown vm operation
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginShutdownAsync(string serviceName, string deploymentName, string virtualMachineName, VirtualMachineShutdownParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Shutdown Role operation shuts down the specified virtual
        /// machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157195.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to shutdown.
        /// </param>
        /// <param name='parameters'>
        /// The parameters for the shutdown vm operation
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> ShutdownAsync(string serviceName, string deploymentName, string virtualMachineName, VirtualMachineShutdownParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Shutdown Roles operation stops the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to shutdown and their post
        /// shutdown state.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginShuttingDownRolesAsync(string serviceName, string deploymentName, VirtualMachineShutdownRolesParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Shutdown Roles operation stops the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to shutdown and their post
        /// shutdown state.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> ShutdownRolesAsync(string serviceName, string deploymentName, VirtualMachineShutdownRolesParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Start Role operation starts the specified virtual machine.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/jj157189.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to start.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginStartingAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Start Role operation starts the specified virtual machine.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/jj157189.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to start.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> StartAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Start Roles operation starts the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to start.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginStartingRolesAsync(string serviceName, string deploymentName, VirtualMachineStartRolesParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Start Roles operation starts the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to start.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> StartRolesAsync(string serviceName, string deploymentName, VirtualMachineStartRolesParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Update Role operation adds a virtual machine to an existing
        /// deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157187.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of your virtual machine.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginUpdatingAsync(string serviceName, string deploymentName, string virtualMachineName, VirtualMachineUpdateParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The Update Role operation adds a virtual machine to an existing
        /// deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157187.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of your virtual machine.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> UpdateAsync(string serviceName, string deploymentName, string virtualMachineName, VirtualMachineUpdateParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The UpdateLoadBalancedEndpointSet operation changes the specified
        /// load-balanced InputEndpoints on all the roles of an Infrastructure
        /// as a Service deployment. Non load-balanced endpoints must be
        /// changed using UpdateRole.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Load Balanced Endpoint Set
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        Task<OperationResponse> BeginUpdatingLoadBalancedEndpointSetAsync(string serviceName, string deploymentName, VirtualMachineUpdateLoadBalancedSetParameters parameters, CancellationToken cancellationToken);
        
        /// <summary>
        /// The UpdateLoadBalancedEndpointSet operation changes the specified
        /// load-balanced InputEndpoints on all the roles of an Infrastructure
        /// as a Service deployment. Non load-balanced endpoints must be
        /// changed using UpdateRole.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Load Balanced Endpoint Set
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        Task<ComputeOperationStatusResponse> UpdateLoadBalancedEndpointSetAsync(string serviceName, string deploymentName, VirtualMachineUpdateLoadBalancedSetParameters parameters, CancellationToken cancellationToken);
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the virtual
    /// machines in your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157206.aspx for
    /// more information)
    /// </summary>
    public static partial class VirtualMachineOperationsExtensions
    {
        /// <summary>
        /// The Capture Role operation creates a copy of the operating system
        /// virtual hard disk (VHD) that is deployed in the virtual machine,
        /// saves the VHD copy in the same storage location as the operating
        /// system VHD, and registers the copy as an image in your image
        /// gallery. From the captured image, you can create additional
        /// customized virtual machines. For more information about images and
        /// disks, see Manage Disks and Images. For more information about
        /// capturing images, see How to Capture an Image of a Virtual Machine
        /// Running Windows Server 2008 R2 or How to Capture an Image of a
        /// Virtual Machine Running Linux.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157201.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Capture Virtual Machine operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse Capture(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName, VirtualMachineCaptureParameters parameters)
        {
            try
            {
                return operations.CaptureAsync(serviceName, deploymentName, virtualMachineName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Capture Role operation creates a copy of the operating system
        /// virtual hard disk (VHD) that is deployed in the virtual machine,
        /// saves the VHD copy in the same storage location as the operating
        /// system VHD, and registers the copy as an image in your image
        /// gallery. From the captured image, you can create additional
        /// customized virtual machines. For more information about images and
        /// disks, see Manage Disks and Images. For more information about
        /// capturing images, see How to Capture an Image of a Virtual Machine
        /// Running Windows Server 2008 R2 or How to Capture an Image of a
        /// Virtual Machine Running Linux.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157201.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Capture Virtual Machine operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> CaptureAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName, VirtualMachineCaptureParameters parameters)
        {
            return operations.CaptureAsync(serviceName, deploymentName, virtualMachineName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Add Role operation adds a virtual machine to an existing
        /// deployment.  You can refer to the OSDisk in the Add Role operation
        /// in the following ways.  Platform/User Image  Set the
        /// SourceImageName to a platform or user image. You can optionally
        /// specify the DiskName and MediaLink values as part the operation to
        /// control the name and location of target disk.  When DiskName and
        /// MediaLink are specified in this mode, they must not already exist
        /// in the system, otherwise a conflict fault is returned.  UserDisk 
        /// Set DiskName to a user supplied image in image repository.
        /// SourceImageName must be set to NULL. All other properties are
        /// ignored.  Blob in a Storage Account  Set MediaLink to a blob
        /// containing the image. SourceImageName and DiskName are set to
        /// NULL.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157186.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginCreating(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineCreateParameters parameters)
        {
            try
            {
                return operations.BeginCreatingAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Add Role operation adds a virtual machine to an existing
        /// deployment.  You can refer to the OSDisk in the Add Role operation
        /// in the following ways.  Platform/User Image  Set the
        /// SourceImageName to a platform or user image. You can optionally
        /// specify the DiskName and MediaLink values as part the operation to
        /// control the name and location of target disk.  When DiskName and
        /// MediaLink are specified in this mode, they must not already exist
        /// in the system, otherwise a conflict fault is returned.  UserDisk 
        /// Set DiskName to a user supplied image in image repository.
        /// SourceImageName must be set to NULL. All other properties are
        /// ignored.  Blob in a Storage Account  Set MediaLink to a blob
        /// containing the image. SourceImageName and DiskName are set to
        /// NULL.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157186.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginCreatingAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineCreateParameters parameters)
        {
            return operations.BeginCreatingAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Add Role operation adds a virtual machine to an existing
        /// deployment.  You can refer to the OSDisk in the Add Role operation
        /// in the following ways.  Platform/User Image  Set the
        /// SourceImageName to a platform or user image. You can optionally
        /// specify the DiskName and MediaLink values as part the operation to
        /// control the name and location of target disk.  When DiskName and
        /// MediaLink are specified in this mode, they must not already exist
        /// in the system, otherwise a conflict fault is returned.  UserDisk 
        /// Set DiskName to a user supplied image in image repository.
        /// SourceImageName must be set to NULL. All other properties are
        /// ignored.  Blob in a Storage Account  Set MediaLink to a blob
        /// containing the image. SourceImageName and DiskName are set to
        /// NULL.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157186.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse Create(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineCreateParameters parameters)
        {
            try
            {
                return operations.CreateAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Add Role operation adds a virtual machine to an existing
        /// deployment.  You can refer to the OSDisk in the Add Role operation
        /// in the following ways.  Platform/User Image  Set the
        /// SourceImageName to a platform or user image. You can optionally
        /// specify the DiskName and MediaLink values as part the operation to
        /// control the name and location of target disk.  When DiskName and
        /// MediaLink are specified in this mode, they must not already exist
        /// in the system, otherwise a conflict fault is returned.  UserDisk 
        /// Set DiskName to a user supplied image in image repository.
        /// SourceImageName must be set to NULL. All other properties are
        /// ignored.  Blob in a Storage Account  Set MediaLink to a blob
        /// containing the image. SourceImageName and DiskName are set to
        /// NULL.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157186.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> CreateAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineCreateParameters parameters)
        {
            return operations.CreateAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Create Virtual Machine Deployment operation provisions a
        /// virtual machine based on the supplied configuration.  When you
        /// create a deployment of a virtual machine, you should make sure
        /// that the cloud service and the disk or image that you use are
        /// located in the same region. For example, if the cloud service was
        /// created in the West US region, the disk or image that you use
        /// should also be located in a stor4age account in the West US
        /// region.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157194.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginCreatingDeployment(this IVirtualMachineOperations operations, string serviceName, VirtualMachineCreateDeploymentParameters parameters)
        {
            try
            {
                return operations.BeginCreatingDeploymentAsync(serviceName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Create Virtual Machine Deployment operation provisions a
        /// virtual machine based on the supplied configuration.  When you
        /// create a deployment of a virtual machine, you should make sure
        /// that the cloud service and the disk or image that you use are
        /// located in the same region. For example, if the cloud service was
        /// created in the West US region, the disk or image that you use
        /// should also be located in a stor4age account in the West US
        /// region.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157194.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginCreatingDeploymentAsync(this IVirtualMachineOperations operations, string serviceName, VirtualMachineCreateDeploymentParameters parameters)
        {
            return operations.BeginCreatingDeploymentAsync(serviceName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Create Virtual Machine Deployment operation provisions a
        /// virtual machine based on the supplied configuration.  When you
        /// create a deployment of a virtual machine, you should make sure
        /// that the cloud service and the disk or image that you use are
        /// located in the same region. For example, if the cloud service was
        /// created in the West US region, the disk or image that you use
        /// should also be located in a stor4age account in the West US
        /// region.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157194.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse CreateDeployment(this IVirtualMachineOperations operations, string serviceName, VirtualMachineCreateDeploymentParameters parameters)
        {
            try
            {
                return operations.CreateDeploymentAsync(serviceName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Create Virtual Machine Deployment operation provisions a
        /// virtual machine based on the supplied configuration.  When you
        /// create a deployment of a virtual machine, you should make sure
        /// that the cloud service and the disk or image that you use are
        /// located in the same region. For example, if the cloud service was
        /// created in the West US region, the disk or image that you use
        /// should also be located in a stor4age account in the West US
        /// region.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157194.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Deployment
        /// operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> CreateDeploymentAsync(this IVirtualMachineOperations operations, string serviceName, VirtualMachineCreateDeploymentParameters parameters)
        {
            return operations.CreateDeploymentAsync(serviceName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Role operation deletes the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157184.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to delete.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginDeleting(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            try
            {
                return operations.BeginDeletingAsync(serviceName, deploymentName, virtualMachineName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Role operation deletes the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157184.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to delete.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginDeletingAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            return operations.BeginDeletingAsync(serviceName, deploymentName, virtualMachineName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Delete Role operation deletes the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157184.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to delete.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse Delete(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            try
            {
                return operations.DeleteAsync(serviceName, deploymentName, virtualMachineName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Delete Role operation deletes the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157184.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to delete.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> DeleteAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            return operations.DeleteAsync(serviceName, deploymentName, virtualMachineName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Download RDP file operation retrieves the Remote Desktop
        /// Protocol configuration file from the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157183.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine.
        /// </param>
        /// <returns>
        /// The Download RDP file operation response.
        /// </returns>
        public static VirtualMachineGetRemoteDesktopFileResponse GetRemoteDesktopFile(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            try
            {
                return operations.GetRemoteDesktopFileAsync(serviceName, deploymentName, virtualMachineName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Download RDP file operation retrieves the Remote Desktop
        /// Protocol configuration file from the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157183.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine.
        /// </param>
        /// <returns>
        /// The Download RDP file operation response.
        /// </returns>
        public static Task<VirtualMachineGetRemoteDesktopFileResponse> GetRemoteDesktopFileAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            return operations.GetRemoteDesktopFileAsync(serviceName, deploymentName, virtualMachineName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Get Role operation retrieves information about the specified
        /// virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157193.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine.
        /// </param>
        /// <returns>
        /// The Get Virtual Machine operation response.
        /// </returns>
        public static VirtualMachineGetResponse Get(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            try
            {
                return operations.GetAsync(serviceName, deploymentName, virtualMachineName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Get Role operation retrieves information about the specified
        /// virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157193.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine.
        /// </param>
        /// <returns>
        /// The Get Virtual Machine operation response.
        /// </returns>
        public static Task<VirtualMachineGetResponse> GetAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            return operations.GetAsync(serviceName, deploymentName, virtualMachineName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Restart role operation restarts the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157197.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginRestarting(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            try
            {
                return operations.BeginRestartingAsync(serviceName, deploymentName, virtualMachineName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Restart role operation restarts the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157197.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginRestartingAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            return operations.BeginRestartingAsync(serviceName, deploymentName, virtualMachineName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Restart role operation restarts the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157197.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse Restart(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            try
            {
                return operations.RestartAsync(serviceName, deploymentName, virtualMachineName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Restart role operation restarts the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157197.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> RestartAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            return operations.RestartAsync(serviceName, deploymentName, virtualMachineName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Shutdown Role operation shuts down the specified virtual
        /// machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157195.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to shutdown.
        /// </param>
        /// <param name='parameters'>
        /// The parameters for the shutdown vm operation
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginShutdown(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName, VirtualMachineShutdownParameters parameters)
        {
            try
            {
                return operations.BeginShutdownAsync(serviceName, deploymentName, virtualMachineName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Shutdown Role operation shuts down the specified virtual
        /// machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157195.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to shutdown.
        /// </param>
        /// <param name='parameters'>
        /// The parameters for the shutdown vm operation
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginShutdownAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName, VirtualMachineShutdownParameters parameters)
        {
            return operations.BeginShutdownAsync(serviceName, deploymentName, virtualMachineName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Shutdown Role operation shuts down the specified virtual
        /// machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157195.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to shutdown.
        /// </param>
        /// <param name='parameters'>
        /// The parameters for the shutdown vm operation
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse Shutdown(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName, VirtualMachineShutdownParameters parameters)
        {
            try
            {
                return operations.ShutdownAsync(serviceName, deploymentName, virtualMachineName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Shutdown Role operation shuts down the specified virtual
        /// machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157195.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to shutdown.
        /// </param>
        /// <param name='parameters'>
        /// The parameters for the shutdown vm operation
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> ShutdownAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName, VirtualMachineShutdownParameters parameters)
        {
            return operations.ShutdownAsync(serviceName, deploymentName, virtualMachineName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Shutdown Roles operation stops the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to shutdown and their post
        /// shutdown state.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginShuttingDownRoles(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineShutdownRolesParameters parameters)
        {
            try
            {
                return operations.BeginShuttingDownRolesAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Shutdown Roles operation stops the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to shutdown and their post
        /// shutdown state.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginShuttingDownRolesAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineShutdownRolesParameters parameters)
        {
            return operations.BeginShuttingDownRolesAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Shutdown Roles operation stops the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to shutdown and their post
        /// shutdown state.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse ShutdownRoles(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineShutdownRolesParameters parameters)
        {
            try
            {
                return operations.ShutdownRolesAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Shutdown Roles operation stops the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to shutdown and their post
        /// shutdown state.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> ShutdownRolesAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineShutdownRolesParameters parameters)
        {
            return operations.ShutdownRolesAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Start Role operation starts the specified virtual machine.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/jj157189.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to start.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginStarting(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            try
            {
                return operations.BeginStartingAsync(serviceName, deploymentName, virtualMachineName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Start Role operation starts the specified virtual machine.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/jj157189.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to start.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginStartingAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            return operations.BeginStartingAsync(serviceName, deploymentName, virtualMachineName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Start Role operation starts the specified virtual machine.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/jj157189.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to start.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse Start(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            try
            {
                return operations.StartAsync(serviceName, deploymentName, virtualMachineName).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Start Role operation starts the specified virtual machine.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/jj157189.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to start.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> StartAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName)
        {
            return operations.StartAsync(serviceName, deploymentName, virtualMachineName, CancellationToken.None);
        }
        
        /// <summary>
        /// The Start Roles operation starts the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to start.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginStartingRoles(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineStartRolesParameters parameters)
        {
            try
            {
                return operations.BeginStartingRolesAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Start Roles operation starts the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to start.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginStartingRolesAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineStartRolesParameters parameters)
        {
            return operations.BeginStartingRolesAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Start Roles operation starts the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to start.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse StartRoles(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineStartRolesParameters parameters)
        {
            try
            {
                return operations.StartRolesAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Start Roles operation starts the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to start.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> StartRolesAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineStartRolesParameters parameters)
        {
            return operations.StartRolesAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Update Role operation adds a virtual machine to an existing
        /// deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157187.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of your virtual machine.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginUpdating(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName, VirtualMachineUpdateParameters parameters)
        {
            try
            {
                return operations.BeginUpdatingAsync(serviceName, deploymentName, virtualMachineName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Update Role operation adds a virtual machine to an existing
        /// deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157187.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of your virtual machine.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginUpdatingAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName, VirtualMachineUpdateParameters parameters)
        {
            return operations.BeginUpdatingAsync(serviceName, deploymentName, virtualMachineName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The Update Role operation adds a virtual machine to an existing
        /// deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157187.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of your virtual machine.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse Update(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName, VirtualMachineUpdateParameters parameters)
        {
            try
            {
                return operations.UpdateAsync(serviceName, deploymentName, virtualMachineName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The Update Role operation adds a virtual machine to an existing
        /// deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157187.aspx
        /// for more information)
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of your virtual machine.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> UpdateAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, string virtualMachineName, VirtualMachineUpdateParameters parameters)
        {
            return operations.UpdateAsync(serviceName, deploymentName, virtualMachineName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The UpdateLoadBalancedEndpointSet operation changes the specified
        /// load-balanced InputEndpoints on all the roles of an Infrastructure
        /// as a Service deployment. Non load-balanced endpoints must be
        /// changed using UpdateRole.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Load Balanced Endpoint Set
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static OperationResponse BeginUpdatingLoadBalancedEndpointSet(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineUpdateLoadBalancedSetParameters parameters)
        {
            try
            {
                return operations.BeginUpdatingLoadBalancedEndpointSetAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The UpdateLoadBalancedEndpointSet operation changes the specified
        /// load-balanced InputEndpoints on all the roles of an Infrastructure
        /// as a Service deployment. Non load-balanced endpoints must be
        /// changed using UpdateRole.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Load Balanced Endpoint Set
        /// operation.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public static Task<OperationResponse> BeginUpdatingLoadBalancedEndpointSetAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineUpdateLoadBalancedSetParameters parameters)
        {
            return operations.BeginUpdatingLoadBalancedEndpointSetAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
        
        /// <summary>
        /// The UpdateLoadBalancedEndpointSet operation changes the specified
        /// load-balanced InputEndpoints on all the roles of an Infrastructure
        /// as a Service deployment. Non load-balanced endpoints must be
        /// changed using UpdateRole.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Load Balanced Endpoint Set
        /// operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static ComputeOperationStatusResponse UpdateLoadBalancedEndpointSet(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineUpdateLoadBalancedSetParameters parameters)
        {
            try
            {
                return operations.UpdateLoadBalancedEndpointSetAsync(serviceName, deploymentName, parameters).Result;
            }
            catch (AggregateException ex)
            {
                if (ex.InnerExceptions.Count > 1)
                {
                    throw;
                }
                else
                {
                    throw ex.InnerException;
                }
            }
        }
        
        /// <summary>
        /// The UpdateLoadBalancedEndpointSet operation changes the specified
        /// load-balanced InputEndpoints on all the roles of an Infrastructure
        /// as a Service deployment. Non load-balanced endpoints must be
        /// changed using UpdateRole.
        /// </summary>
        /// <param name='operations'>
        /// Reference to the
        /// Microsoft.WindowsAzure.Management.Compute.IVirtualMachineOperations.
        /// </param>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Load Balanced Endpoint Set
        /// operation.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public static Task<ComputeOperationStatusResponse> UpdateLoadBalancedEndpointSetAsync(this IVirtualMachineOperations operations, string serviceName, string deploymentName, VirtualMachineUpdateLoadBalancedSetParameters parameters)
        {
            return operations.UpdateLoadBalancedEndpointSetAsync(serviceName, deploymentName, parameters, CancellationToken.None);
        }
    }
    
    /// <summary>
    /// The Service Management API includes operations for managing the virtual
    /// machines in your subscription.  (see
    /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157206.aspx for
    /// more information)
    /// </summary>
    internal partial class VirtualMachineOperations : IServiceOperations<ComputeManagementClient>, IVirtualMachineOperations
    {
        /// <summary>
        /// Initializes a new instance of the VirtualMachineOperations class.
        /// </summary>
        /// <param name='client'>
        /// Reference to the service client.
        /// </param>
        internal VirtualMachineOperations(ComputeManagementClient client)
        {
            this._client = client;
        }
        
        private ComputeManagementClient _client;
        
        /// <summary>
        /// Gets a reference to the
        /// Microsoft.WindowsAzure.Management.Compute.ComputeManagementClient.
        /// </summary>
        public ComputeManagementClient Client
        {
            get { return this._client; }
        }
        
        /// <summary>
        /// The Capture Role operation creates a copy of the operating system
        /// virtual hard disk (VHD) that is deployed in the virtual machine,
        /// saves the VHD copy in the same storage location as the operating
        /// system VHD, and registers the copy as an image in your image
        /// gallery. From the captured image, you can create additional
        /// customized virtual machines. For more information about images and
        /// disks, see Manage Disks and Images. For more information about
        /// capturing images, see How to Capture an Image of a Virtual Machine
        /// Running Windows Server 2008 R2 or How to Capture an Image of a
        /// Virtual Machine Running Linux.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157201.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Capture Virtual Machine operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> CaptureAsync(string serviceName, string deploymentName, string virtualMachineName, VirtualMachineCaptureParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (virtualMachineName == null)
            {
                throw new ArgumentNullException("virtualMachineName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.ProvisioningConfiguration != null)
            {
                if (parameters.ProvisioningConfiguration.DomainJoin != null)
                {
                    if (parameters.ProvisioningConfiguration.DomainJoin.Credentials != null)
                    {
                        if (parameters.ProvisioningConfiguration.DomainJoin.Credentials.UserName == null)
                        {
                            throw new ArgumentNullException("parameters.ProvisioningConfiguration.DomainJoin.Credentials.UserName");
                        }
                        if (parameters.ProvisioningConfiguration.DomainJoin.Credentials.Password == null)
                        {
                            throw new ArgumentNullException("parameters.ProvisioningConfiguration.DomainJoin.Credentials.Password");
                        }
                    }
                }
                foreach (StoredCertificateSettings storedCertificateSettingsParameterItem in parameters.ProvisioningConfiguration.StoredCertificateSettings)
                {
                    if (storedCertificateSettingsParameterItem.StoreName == null)
                    {
                        throw new ArgumentNullException("parameters.ProvisioningConfiguration.StoredCertificateSettings.StoreName");
                    }
                    if (storedCertificateSettingsParameterItem.Thumbprint == null)
                    {
                        throw new ArgumentNullException("parameters.ProvisioningConfiguration.StoredCertificateSettings.Thumbprint");
                    }
                }
                if (parameters.ProvisioningConfiguration.HostName != null && parameters.ProvisioningConfiguration.HostName.Length < 1)
                {
                    throw new ArgumentOutOfRangeException("parameters.ProvisioningConfiguration.HostName");
                }
                if (parameters.ProvisioningConfiguration.HostName != null && parameters.ProvisioningConfiguration.HostName.Length > 64)
                {
                    throw new ArgumentOutOfRangeException("parameters.ProvisioningConfiguration.HostName");
                }
                if (parameters.ProvisioningConfiguration.UserName != null && parameters.ProvisioningConfiguration.UserName.Length < 1)
                {
                    throw new ArgumentOutOfRangeException("parameters.ProvisioningConfiguration.UserName");
                }
                if (parameters.ProvisioningConfiguration.UserName != null && parameters.ProvisioningConfiguration.UserName.Length > 32)
                {
                    throw new ArgumentOutOfRangeException("parameters.ProvisioningConfiguration.UserName");
                }
                if (parameters.ProvisioningConfiguration.UserPassword != null && parameters.ProvisioningConfiguration.UserPassword.Length < 6 && (parameters.ProvisioningConfiguration.DisableSshPasswordAuthentication == false || parameters.ProvisioningConfiguration.UserPassword.Length != 0))
                {
                    throw new ArgumentOutOfRangeException("parameters.ProvisioningConfiguration.UserPassword");
                }
                if (parameters.ProvisioningConfiguration.UserPassword != null && parameters.ProvisioningConfiguration.UserPassword.Length > 72)
                {
                    throw new ArgumentOutOfRangeException("parameters.ProvisioningConfiguration.UserPassword");
                }
                if (parameters.ProvisioningConfiguration.SshSettings != null)
                {
                    foreach (SshSettingPublicKey publicKeysParameterItem in parameters.ProvisioningConfiguration.SshSettings.PublicKeys)
                    {
                        if (publicKeysParameterItem.Fingerprint == null)
                        {
                            throw new ArgumentNullException("parameters.ProvisioningConfiguration.SshSettings.PublicKeys.Fingerprint");
                        }
                        if (publicKeysParameterItem.Path == null)
                        {
                            throw new ArgumentNullException("parameters.ProvisioningConfiguration.SshSettings.PublicKeys.Path");
                        }
                    }
                    foreach (SshSettingKeyPair keyPairsParameterItem in parameters.ProvisioningConfiguration.SshSettings.KeyPairs)
                    {
                        if (keyPairsParameterItem.Fingerprint == null)
                        {
                            throw new ArgumentNullException("parameters.ProvisioningConfiguration.SshSettings.KeyPairs.Fingerprint");
                        }
                        if (keyPairsParameterItem.Path == null)
                        {
                            throw new ArgumentNullException("parameters.ProvisioningConfiguration.SshSettings.KeyPairs.Path");
                        }
                    }
                }
            }
            if (parameters.TargetImageLabel == null)
            {
                throw new ArgumentNullException("parameters.TargetImageLabel");
            }
            if (parameters.TargetImageName == null)
            {
                throw new ArgumentNullException("parameters.TargetImageName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "CaptureAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roleinstances/" + virtualMachineName + "/Operations";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement captureRoleOperationElement = new XElement(XName.Get("CaptureRoleOperation", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(captureRoleOperationElement);
                
                XElement operationTypeElement = new XElement(XName.Get("OperationType", "http://schemas.microsoft.com/windowsazure"));
                operationTypeElement.Value = "CaptureRoleOperation";
                captureRoleOperationElement.Add(operationTypeElement);
                
                XElement postCaptureActionElement = new XElement(XName.Get("PostCaptureAction", "http://schemas.microsoft.com/windowsazure"));
                postCaptureActionElement.Value = parameters.PostCaptureAction.ToString();
                captureRoleOperationElement.Add(postCaptureActionElement);
                
                if (parameters.ProvisioningConfiguration != null)
                {
                    XElement provisioningConfigurationElement = new XElement(XName.Get("ProvisioningConfiguration", "http://schemas.microsoft.com/windowsazure"));
                    captureRoleOperationElement.Add(provisioningConfigurationElement);
                    
                    if (parameters.ProvisioningConfiguration.ConfigurationSetType != null)
                    {
                        XElement configurationSetTypeElement = new XElement(XName.Get("ConfigurationSetType", "http://schemas.microsoft.com/windowsazure"));
                        configurationSetTypeElement.Value = parameters.ProvisioningConfiguration.ConfigurationSetType;
                        provisioningConfigurationElement.Add(configurationSetTypeElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.InputEndpoints != null)
                    {
                        XElement inputEndpointsSequenceElement = new XElement(XName.Get("InputEndpoints", "http://schemas.microsoft.com/windowsazure"));
                        foreach (InputEndpoint inputEndpointsItem in parameters.ProvisioningConfiguration.InputEndpoints)
                        {
                            XElement inputEndpointElement = new XElement(XName.Get("InputEndpoint", "http://schemas.microsoft.com/windowsazure"));
                            inputEndpointsSequenceElement.Add(inputEndpointElement);
                            
                            if (inputEndpointsItem.LoadBalancedEndpointSetName != null)
                            {
                                XElement loadBalancedEndpointSetNameElement = new XElement(XName.Get("LoadBalancedEndpointSetName", "http://schemas.microsoft.com/windowsazure"));
                                loadBalancedEndpointSetNameElement.Value = inputEndpointsItem.LoadBalancedEndpointSetName;
                                inputEndpointElement.Add(loadBalancedEndpointSetNameElement);
                            }
                            
                            if (inputEndpointsItem.LocalPort != null)
                            {
                                XElement localPortElement = new XElement(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                                localPortElement.Value = inputEndpointsItem.LocalPort.ToString();
                                inputEndpointElement.Add(localPortElement);
                            }
                            
                            if (inputEndpointsItem.Name != null)
                            {
                                XElement nameElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                nameElement.Value = inputEndpointsItem.Name;
                                inputEndpointElement.Add(nameElement);
                            }
                            
                            if (inputEndpointsItem.Port != null)
                            {
                                XElement portElement = new XElement(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                portElement.Value = inputEndpointsItem.Port.ToString();
                                inputEndpointElement.Add(portElement);
                            }
                            
                            if (inputEndpointsItem.LoadBalancerProbe != null)
                            {
                                XElement loadBalancerProbeElement = new XElement(XName.Get("LoadBalancerProbe", "http://schemas.microsoft.com/windowsazure"));
                                inputEndpointElement.Add(loadBalancerProbeElement);
                                
                                if (inputEndpointsItem.LoadBalancerProbe.Path != null)
                                {
                                    XElement pathElement = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                    pathElement.Value = inputEndpointsItem.LoadBalancerProbe.Path;
                                    loadBalancerProbeElement.Add(pathElement);
                                }
                                
                                XElement portElement2 = new XElement(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                portElement2.Value = inputEndpointsItem.LoadBalancerProbe.Port.ToString();
                                loadBalancerProbeElement.Add(portElement2);
                                
                                XElement protocolElement = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                protocolElement.Value = ComputeManagementClient.LoadBalancerProbeTransportProtocolToString(inputEndpointsItem.LoadBalancerProbe.Protocol);
                                loadBalancerProbeElement.Add(protocolElement);
                                
                                if (inputEndpointsItem.LoadBalancerProbe.IntervalInSeconds != null)
                                {
                                    XElement intervalInSecondsElement = new XElement(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                    intervalInSecondsElement.Value = inputEndpointsItem.LoadBalancerProbe.IntervalInSeconds.ToString();
                                    loadBalancerProbeElement.Add(intervalInSecondsElement);
                                }
                                
                                if (inputEndpointsItem.LoadBalancerProbe.TimeoutInSeconds != null)
                                {
                                    XElement timeoutInSecondsElement = new XElement(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                    timeoutInSecondsElement.Value = inputEndpointsItem.LoadBalancerProbe.TimeoutInSeconds.ToString();
                                    loadBalancerProbeElement.Add(timeoutInSecondsElement);
                                }
                            }
                            
                            if (inputEndpointsItem.Protocol != null)
                            {
                                XElement protocolElement2 = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                protocolElement2.Value = inputEndpointsItem.Protocol;
                                inputEndpointElement.Add(protocolElement2);
                            }
                            
                            if (inputEndpointsItem.VirtualIPAddress != null)
                            {
                                XElement vipElement = new XElement(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                                vipElement.Value = inputEndpointsItem.VirtualIPAddress;
                                inputEndpointElement.Add(vipElement);
                            }
                            
                            if (inputEndpointsItem.EnableDirectServerReturn != null)
                            {
                                XElement enableDirectServerReturnElement = new XElement(XName.Get("EnableDirectServerReturn", "http://schemas.microsoft.com/windowsazure"));
                                enableDirectServerReturnElement.Value = inputEndpointsItem.EnableDirectServerReturn.ToString().ToLower();
                                inputEndpointElement.Add(enableDirectServerReturnElement);
                            }
                            
                            if (inputEndpointsItem.AccessControlList != null)
                            {
                                XElement accessControlListElement = new XElement(XName.Get("AccessControlList", "http://schemas.microsoft.com/windowsazure"));
                                inputEndpointElement.Add(accessControlListElement);
                                
                                if (inputEndpointsItem.AccessControlList.Rules != null)
                                {
                                    XElement rulesSequenceElement = new XElement(XName.Get("Rules", "http://schemas.microsoft.com/windowsazure"));
                                    foreach (AccessControlListRule rulesItem in inputEndpointsItem.AccessControlList.Rules)
                                    {
                                        XElement ruleElement = new XElement(XName.Get("Rule", "http://schemas.microsoft.com/windowsazure"));
                                        rulesSequenceElement.Add(ruleElement);
                                        
                                        if (rulesItem.Order != null)
                                        {
                                            XElement orderElement = new XElement(XName.Get("Order", "http://schemas.microsoft.com/windowsazure"));
                                            orderElement.Value = rulesItem.Order.ToString();
                                            ruleElement.Add(orderElement);
                                        }
                                        
                                        if (rulesItem.Action != null)
                                        {
                                            XElement actionElement = new XElement(XName.Get("Action", "http://schemas.microsoft.com/windowsazure"));
                                            actionElement.Value = rulesItem.Action;
                                            ruleElement.Add(actionElement);
                                        }
                                        
                                        if (rulesItem.RemoteSubnet != null)
                                        {
                                            XElement remoteSubnetElement = new XElement(XName.Get("RemoteSubnet", "http://schemas.microsoft.com/windowsazure"));
                                            remoteSubnetElement.Value = rulesItem.RemoteSubnet;
                                            ruleElement.Add(remoteSubnetElement);
                                        }
                                        
                                        if (rulesItem.Description != null)
                                        {
                                            XElement descriptionElement = new XElement(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                                            descriptionElement.Value = rulesItem.Description;
                                            ruleElement.Add(descriptionElement);
                                        }
                                    }
                                    accessControlListElement.Add(rulesSequenceElement);
                                }
                            }
                        }
                        provisioningConfigurationElement.Add(inputEndpointsSequenceElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.SubnetNames != null)
                    {
                        XElement subnetNamesSequenceElement = new XElement(XName.Get("SubnetNames", "http://schemas.microsoft.com/windowsazure"));
                        foreach (string subnetNamesItem in parameters.ProvisioningConfiguration.SubnetNames)
                        {
                            XElement subnetNamesItemElement = new XElement(XName.Get("SubnetName", "http://schemas.microsoft.com/windowsazure"));
                            subnetNamesItemElement.Value = subnetNamesItem;
                            subnetNamesSequenceElement.Add(subnetNamesItemElement);
                        }
                        provisioningConfigurationElement.Add(subnetNamesSequenceElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.ComputerName != null)
                    {
                        XElement computerNameElement = new XElement(XName.Get("ComputerName", "http://schemas.microsoft.com/windowsazure"));
                        computerNameElement.Value = parameters.ProvisioningConfiguration.ComputerName;
                        provisioningConfigurationElement.Add(computerNameElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.AdminPassword != null)
                    {
                        XElement adminPasswordElement = new XElement(XName.Get("AdminPassword", "http://schemas.microsoft.com/windowsazure"));
                        adminPasswordElement.Value = parameters.ProvisioningConfiguration.AdminPassword;
                        provisioningConfigurationElement.Add(adminPasswordElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.ResetPasswordOnFirstLogon != null)
                    {
                        XElement resetPasswordOnFirstLogonElement = new XElement(XName.Get("ResetPasswordOnFirstLogon", "http://schemas.microsoft.com/windowsazure"));
                        resetPasswordOnFirstLogonElement.Value = parameters.ProvisioningConfiguration.ResetPasswordOnFirstLogon.ToString().ToLower();
                        provisioningConfigurationElement.Add(resetPasswordOnFirstLogonElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.EnableAutomaticUpdates != null)
                    {
                        XElement enableAutomaticUpdatesElement = new XElement(XName.Get("EnableAutomaticUpdates", "http://schemas.microsoft.com/windowsazure"));
                        enableAutomaticUpdatesElement.Value = parameters.ProvisioningConfiguration.EnableAutomaticUpdates.ToString().ToLower();
                        provisioningConfigurationElement.Add(enableAutomaticUpdatesElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.TimeZone != null)
                    {
                        XElement timeZoneElement = new XElement(XName.Get("TimeZone", "http://schemas.microsoft.com/windowsazure"));
                        timeZoneElement.Value = parameters.ProvisioningConfiguration.TimeZone;
                        provisioningConfigurationElement.Add(timeZoneElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.DomainJoin != null)
                    {
                        XElement domainJoinElement = new XElement(XName.Get("DomainJoin", "http://schemas.microsoft.com/windowsazure"));
                        provisioningConfigurationElement.Add(domainJoinElement);
                        
                        if (parameters.ProvisioningConfiguration.DomainJoin.Credentials != null)
                        {
                            XElement credentialsElement = new XElement(XName.Get("Credentials", "http://schemas.microsoft.com/windowsazure"));
                            domainJoinElement.Add(credentialsElement);
                            
                            if (parameters.ProvisioningConfiguration.DomainJoin.Credentials.Domain != null)
                            {
                                XElement domainElement = new XElement(XName.Get("Domain", "http://schemas.microsoft.com/windowsazure"));
                                domainElement.Value = parameters.ProvisioningConfiguration.DomainJoin.Credentials.Domain;
                                credentialsElement.Add(domainElement);
                            }
                            
                            XElement usernameElement = new XElement(XName.Get("Username", "http://schemas.microsoft.com/windowsazure"));
                            usernameElement.Value = parameters.ProvisioningConfiguration.DomainJoin.Credentials.UserName;
                            credentialsElement.Add(usernameElement);
                            
                            XElement passwordElement = new XElement(XName.Get("Password", "http://schemas.microsoft.com/windowsazure"));
                            passwordElement.Value = parameters.ProvisioningConfiguration.DomainJoin.Credentials.Password;
                            credentialsElement.Add(passwordElement);
                        }
                        
                        if (parameters.ProvisioningConfiguration.DomainJoin.DomainToJoin != null)
                        {
                            XElement joinDomainElement = new XElement(XName.Get("JoinDomain", "http://schemas.microsoft.com/windowsazure"));
                            joinDomainElement.Value = parameters.ProvisioningConfiguration.DomainJoin.DomainToJoin;
                            domainJoinElement.Add(joinDomainElement);
                        }
                        
                        if (parameters.ProvisioningConfiguration.DomainJoin.LdapMachineObjectOU != null)
                        {
                            XElement machineObjectOUElement = new XElement(XName.Get("MachineObjectOU", "http://schemas.microsoft.com/windowsazure"));
                            machineObjectOUElement.Value = parameters.ProvisioningConfiguration.DomainJoin.LdapMachineObjectOU;
                            domainJoinElement.Add(machineObjectOUElement);
                        }
                        
                        if (parameters.ProvisioningConfiguration.DomainJoin.Provisioning != null)
                        {
                            XElement provisioningElement = new XElement(XName.Get("Provisioning", "http://schemas.microsoft.com/windowsazure"));
                            domainJoinElement.Add(provisioningElement);
                            
                            if (parameters.ProvisioningConfiguration.DomainJoin.Provisioning.AccountData != null)
                            {
                                XElement accountDataElement = new XElement(XName.Get("AccountData", "http://schemas.microsoft.com/windowsazure"));
                                accountDataElement.Value = parameters.ProvisioningConfiguration.DomainJoin.Provisioning.AccountData;
                                provisioningElement.Add(accountDataElement);
                            }
                        }
                    }
                    
                    if (parameters.ProvisioningConfiguration.StoredCertificateSettings != null)
                    {
                        XElement storedCertificateSettingsSequenceElement = new XElement(XName.Get("StoredCertificateSettings", "http://schemas.microsoft.com/windowsazure"));
                        foreach (StoredCertificateSettings storedCertificateSettingsItem in parameters.ProvisioningConfiguration.StoredCertificateSettings)
                        {
                            XElement certificateSettingElement = new XElement(XName.Get("CertificateSetting", "http://schemas.microsoft.com/windowsazure"));
                            storedCertificateSettingsSequenceElement.Add(certificateSettingElement);
                            
                            XElement storeLocationElement = new XElement(XName.Get("StoreLocation", "http://schemas.microsoft.com/windowsazure"));
                            storeLocationElement.Value = "LocalMachine";
                            certificateSettingElement.Add(storeLocationElement);
                            
                            XElement storeNameElement = new XElement(XName.Get("StoreName", "http://schemas.microsoft.com/windowsazure"));
                            storeNameElement.Value = storedCertificateSettingsItem.StoreName;
                            certificateSettingElement.Add(storeNameElement);
                            
                            XElement thumbprintElement = new XElement(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                            thumbprintElement.Value = storedCertificateSettingsItem.Thumbprint;
                            certificateSettingElement.Add(thumbprintElement);
                        }
                        provisioningConfigurationElement.Add(storedCertificateSettingsSequenceElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.WindowsRemoteManagement != null)
                    {
                        XElement winRMElement = new XElement(XName.Get("WinRM", "http://schemas.microsoft.com/windowsazure"));
                        provisioningConfigurationElement.Add(winRMElement);
                        
                        if (parameters.ProvisioningConfiguration.WindowsRemoteManagement.Listeners != null)
                        {
                            XElement listenersSequenceElement = new XElement(XName.Get("Listeners", "http://schemas.microsoft.com/windowsazure"));
                            foreach (WindowsRemoteManagementListener listenersItem in parameters.ProvisioningConfiguration.WindowsRemoteManagement.Listeners)
                            {
                                XElement listenerElement = new XElement(XName.Get("Listener", "http://schemas.microsoft.com/windowsazure"));
                                listenersSequenceElement.Add(listenerElement);
                                
                                XElement protocolElement3 = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                protocolElement3.Value = listenersItem.ListenerType.ToString();
                                listenerElement.Add(protocolElement3);
                                
                                if (listenersItem.CertificateThumbprint != null)
                                {
                                    XElement certificateThumbprintElement = new XElement(XName.Get("CertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                    certificateThumbprintElement.Value = listenersItem.CertificateThumbprint;
                                    listenerElement.Add(certificateThumbprintElement);
                                }
                            }
                            winRMElement.Add(listenersSequenceElement);
                        }
                    }
                    
                    if (parameters.ProvisioningConfiguration.AdminUserName != null)
                    {
                        XElement adminUsernameElement = new XElement(XName.Get("AdminUsername", "http://schemas.microsoft.com/windowsazure"));
                        adminUsernameElement.Value = parameters.ProvisioningConfiguration.AdminUserName;
                        provisioningConfigurationElement.Add(adminUsernameElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.HostName != null)
                    {
                        XElement hostNameElement = new XElement(XName.Get("HostName", "http://schemas.microsoft.com/windowsazure"));
                        hostNameElement.Value = parameters.ProvisioningConfiguration.HostName;
                        provisioningConfigurationElement.Add(hostNameElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.UserName != null)
                    {
                        XElement userNameElement = new XElement(XName.Get("UserName", "http://schemas.microsoft.com/windowsazure"));
                        userNameElement.Value = parameters.ProvisioningConfiguration.UserName;
                        provisioningConfigurationElement.Add(userNameElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.UserPassword != null)
                    {
                        XElement userPasswordElement = new XElement(XName.Get("UserPassword", "http://schemas.microsoft.com/windowsazure"));
                        userPasswordElement.Value = parameters.ProvisioningConfiguration.UserPassword;
                        provisioningConfigurationElement.Add(userPasswordElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.DisableSshPasswordAuthentication != null)
                    {
                        XElement disableSshPasswordAuthenticationElement = new XElement(XName.Get("DisableSshPasswordAuthentication", "http://schemas.microsoft.com/windowsazure"));
                        disableSshPasswordAuthenticationElement.Value = parameters.ProvisioningConfiguration.DisableSshPasswordAuthentication.ToString().ToLower();
                        provisioningConfigurationElement.Add(disableSshPasswordAuthenticationElement);
                    }
                    
                    if (parameters.ProvisioningConfiguration.SshSettings != null)
                    {
                        XElement sSHElement = new XElement(XName.Get("SSH", "http://schemas.microsoft.com/windowsazure"));
                        provisioningConfigurationElement.Add(sSHElement);
                        
                        if (parameters.ProvisioningConfiguration.SshSettings.PublicKeys != null)
                        {
                            XElement publicKeysSequenceElement = new XElement(XName.Get("PublicKeys", "http://schemas.microsoft.com/windowsazure"));
                            foreach (SshSettingPublicKey publicKeysItem in parameters.ProvisioningConfiguration.SshSettings.PublicKeys)
                            {
                                XElement publicKeyElement = new XElement(XName.Get("PublicKey", "http://schemas.microsoft.com/windowsazure"));
                                publicKeysSequenceElement.Add(publicKeyElement);
                                
                                XElement fingerPrintElement = new XElement(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                fingerPrintElement.Value = publicKeysItem.Fingerprint;
                                publicKeyElement.Add(fingerPrintElement);
                                
                                XElement pathElement2 = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                pathElement2.Value = publicKeysItem.Path;
                                publicKeyElement.Add(pathElement2);
                            }
                            sSHElement.Add(publicKeysSequenceElement);
                        }
                        
                        if (parameters.ProvisioningConfiguration.SshSettings.KeyPairs != null)
                        {
                            XElement keyPairsSequenceElement = new XElement(XName.Get("KeyPairs", "http://schemas.microsoft.com/windowsazure"));
                            foreach (SshSettingKeyPair keyPairsItem in parameters.ProvisioningConfiguration.SshSettings.KeyPairs)
                            {
                                XElement keyPairElement = new XElement(XName.Get("KeyPair", "http://schemas.microsoft.com/windowsazure"));
                                keyPairsSequenceElement.Add(keyPairElement);
                                
                                XElement fingerPrintElement2 = new XElement(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                fingerPrintElement2.Value = keyPairsItem.Fingerprint;
                                keyPairElement.Add(fingerPrintElement2);
                                
                                XElement pathElement3 = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                pathElement3.Value = keyPairsItem.Path;
                                keyPairElement.Add(pathElement3);
                            }
                            sSHElement.Add(keyPairsSequenceElement);
                        }
                    }
                }
                
                XElement targetImageLabelElement = new XElement(XName.Get("TargetImageLabel", "http://schemas.microsoft.com/windowsazure"));
                targetImageLabelElement.Value = parameters.TargetImageLabel;
                captureRoleOperationElement.Add(targetImageLabelElement);
                
                XElement targetImageNameElement = new XElement(XName.Get("TargetImageName", "http://schemas.microsoft.com/windowsazure"));
                targetImageNameElement.Value = parameters.TargetImageName;
                captureRoleOperationElement.Add(targetImageNameElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Created)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Add Role operation adds a virtual machine to an existing
        /// deployment.  You can refer to the OSDisk in the Add Role operation
        /// in the following ways.  Platform/User Image  Set the
        /// SourceImageName to a platform or user image. You can optionally
        /// specify the DiskName and MediaLink values as part the operation to
        /// control the name and location of target disk.  When DiskName and
        /// MediaLink are specified in this mode, they must not already exist
        /// in the system, otherwise a conflict fault is returned.  UserDisk 
        /// Set DiskName to a user supplied image in image repository.
        /// SourceImageName must be set to NULL. All other properties are
        /// ignored.  Blob in a Storage Account  Set MediaLink to a blob
        /// containing the image. SourceImageName and DiskName are set to
        /// NULL.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157186.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginCreatingAsync(string serviceName, string deploymentName, VirtualMachineCreateParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.RoleName == null)
            {
                throw new ArgumentNullException("parameters.RoleName");
            }
            foreach (ConfigurationSet configurationSetsParameterItem in parameters.ConfigurationSets)
            {
                if (configurationSetsParameterItem.DomainJoin != null)
                {
                    if (configurationSetsParameterItem.DomainJoin.Credentials != null)
                    {
                        if (configurationSetsParameterItem.DomainJoin.Credentials.UserName == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.DomainJoin.Credentials.UserName");
                        }
                        if (configurationSetsParameterItem.DomainJoin.Credentials.Password == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.DomainJoin.Credentials.Password");
                        }
                    }
                }
                foreach (StoredCertificateSettings storedCertificateSettingsParameterItem in configurationSetsParameterItem.StoredCertificateSettings)
                {
                    if (storedCertificateSettingsParameterItem.StoreName == null)
                    {
                        throw new ArgumentNullException("parameters.ConfigurationSets.StoredCertificateSettings.StoreName");
                    }
                    if (storedCertificateSettingsParameterItem.Thumbprint == null)
                    {
                        throw new ArgumentNullException("parameters.ConfigurationSets.StoredCertificateSettings.Thumbprint");
                    }
                }
                if (configurationSetsParameterItem.HostName != null && configurationSetsParameterItem.HostName.Length < 1)
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.HostName");
                }
                if (configurationSetsParameterItem.HostName != null && configurationSetsParameterItem.HostName.Length > 64)
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.HostName");
                }
                if (configurationSetsParameterItem.UserName != null && configurationSetsParameterItem.UserName.Length < 1)
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.UserName");
                }
                if (configurationSetsParameterItem.UserName != null && configurationSetsParameterItem.UserName.Length > 32)
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.UserName");
                }
                if (configurationSetsParameterItem.UserPassword != null && configurationSetsParameterItem.UserPassword.Length < 6 && (configurationSetsParameterItem.DisableSshPasswordAuthentication == false || configurationSetsParameterItem.UserPassword.Length != 0))
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.UserPassword");
                }
                if (configurationSetsParameterItem.UserPassword != null && configurationSetsParameterItem.UserPassword.Length > 72)
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.UserPassword");
                }
                if (configurationSetsParameterItem.SshSettings != null)
                {
                    foreach (SshSettingPublicKey publicKeysParameterItem in configurationSetsParameterItem.SshSettings.PublicKeys)
                    {
                        if (publicKeysParameterItem.Fingerprint == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.SshSettings.PublicKeys.Fingerprint");
                        }
                        if (publicKeysParameterItem.Path == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.SshSettings.PublicKeys.Path");
                        }
                    }
                    foreach (SshSettingKeyPair keyPairsParameterItem in configurationSetsParameterItem.SshSettings.KeyPairs)
                    {
                        if (keyPairsParameterItem.Fingerprint == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.SshSettings.KeyPairs.Fingerprint");
                        }
                        if (keyPairsParameterItem.Path == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.SshSettings.KeyPairs.Path");
                        }
                    }
                }
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginCreatingAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roles";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement persistentVMRoleElement = new XElement(XName.Get("PersistentVMRole", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(persistentVMRoleElement);
                
                XElement roleNameElement = new XElement(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                roleNameElement.Value = parameters.RoleName;
                persistentVMRoleElement.Add(roleNameElement);
                
                XElement roleTypeElement = new XElement(XName.Get("RoleType", "http://schemas.microsoft.com/windowsazure"));
                roleTypeElement.Value = "PersistentVMRole";
                persistentVMRoleElement.Add(roleTypeElement);
                
                if (parameters.ConfigurationSets != null)
                {
                    XElement configurationSetsSequenceElement = new XElement(XName.Get("ConfigurationSets", "http://schemas.microsoft.com/windowsazure"));
                    foreach (ConfigurationSet configurationSetsItem in parameters.ConfigurationSets)
                    {
                        XElement configurationSetElement = new XElement(XName.Get("ConfigurationSet", "http://schemas.microsoft.com/windowsazure"));
                        configurationSetsSequenceElement.Add(configurationSetElement);
                        
                        if (configurationSetsItem.ConfigurationSetType != null)
                        {
                            XElement configurationSetTypeElement = new XElement(XName.Get("ConfigurationSetType", "http://schemas.microsoft.com/windowsazure"));
                            configurationSetTypeElement.Value = configurationSetsItem.ConfigurationSetType;
                            configurationSetElement.Add(configurationSetTypeElement);
                        }
                        
                        if (configurationSetsItem.InputEndpoints != null)
                        {
                            XElement inputEndpointsSequenceElement = new XElement(XName.Get("InputEndpoints", "http://schemas.microsoft.com/windowsazure"));
                            foreach (InputEndpoint inputEndpointsItem in configurationSetsItem.InputEndpoints)
                            {
                                XElement inputEndpointElement = new XElement(XName.Get("InputEndpoint", "http://schemas.microsoft.com/windowsazure"));
                                inputEndpointsSequenceElement.Add(inputEndpointElement);
                                
                                if (inputEndpointsItem.LoadBalancedEndpointSetName != null)
                                {
                                    XElement loadBalancedEndpointSetNameElement = new XElement(XName.Get("LoadBalancedEndpointSetName", "http://schemas.microsoft.com/windowsazure"));
                                    loadBalancedEndpointSetNameElement.Value = inputEndpointsItem.LoadBalancedEndpointSetName;
                                    inputEndpointElement.Add(loadBalancedEndpointSetNameElement);
                                }
                                
                                if (inputEndpointsItem.LocalPort != null)
                                {
                                    XElement localPortElement = new XElement(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                                    localPortElement.Value = inputEndpointsItem.LocalPort.ToString();
                                    inputEndpointElement.Add(localPortElement);
                                }
                                
                                if (inputEndpointsItem.Name != null)
                                {
                                    XElement nameElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                    nameElement.Value = inputEndpointsItem.Name;
                                    inputEndpointElement.Add(nameElement);
                                }
                                
                                if (inputEndpointsItem.Port != null)
                                {
                                    XElement portElement = new XElement(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                    portElement.Value = inputEndpointsItem.Port.ToString();
                                    inputEndpointElement.Add(portElement);
                                }
                                
                                if (inputEndpointsItem.LoadBalancerProbe != null)
                                {
                                    XElement loadBalancerProbeElement = new XElement(XName.Get("LoadBalancerProbe", "http://schemas.microsoft.com/windowsazure"));
                                    inputEndpointElement.Add(loadBalancerProbeElement);
                                    
                                    if (inputEndpointsItem.LoadBalancerProbe.Path != null)
                                    {
                                        XElement pathElement = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                        pathElement.Value = inputEndpointsItem.LoadBalancerProbe.Path;
                                        loadBalancerProbeElement.Add(pathElement);
                                    }
                                    
                                    XElement portElement2 = new XElement(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                    portElement2.Value = inputEndpointsItem.LoadBalancerProbe.Port.ToString();
                                    loadBalancerProbeElement.Add(portElement2);
                                    
                                    XElement protocolElement = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                    protocolElement.Value = ComputeManagementClient.LoadBalancerProbeTransportProtocolToString(inputEndpointsItem.LoadBalancerProbe.Protocol);
                                    loadBalancerProbeElement.Add(protocolElement);
                                    
                                    if (inputEndpointsItem.LoadBalancerProbe.IntervalInSeconds != null)
                                    {
                                        XElement intervalInSecondsElement = new XElement(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                        intervalInSecondsElement.Value = inputEndpointsItem.LoadBalancerProbe.IntervalInSeconds.ToString();
                                        loadBalancerProbeElement.Add(intervalInSecondsElement);
                                    }
                                    
                                    if (inputEndpointsItem.LoadBalancerProbe.TimeoutInSeconds != null)
                                    {
                                        XElement timeoutInSecondsElement = new XElement(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                        timeoutInSecondsElement.Value = inputEndpointsItem.LoadBalancerProbe.TimeoutInSeconds.ToString();
                                        loadBalancerProbeElement.Add(timeoutInSecondsElement);
                                    }
                                }
                                
                                if (inputEndpointsItem.Protocol != null)
                                {
                                    XElement protocolElement2 = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                    protocolElement2.Value = inputEndpointsItem.Protocol;
                                    inputEndpointElement.Add(protocolElement2);
                                }
                                
                                if (inputEndpointsItem.VirtualIPAddress != null)
                                {
                                    XElement vipElement = new XElement(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                                    vipElement.Value = inputEndpointsItem.VirtualIPAddress;
                                    inputEndpointElement.Add(vipElement);
                                }
                                
                                if (inputEndpointsItem.EnableDirectServerReturn != null)
                                {
                                    XElement enableDirectServerReturnElement = new XElement(XName.Get("EnableDirectServerReturn", "http://schemas.microsoft.com/windowsazure"));
                                    enableDirectServerReturnElement.Value = inputEndpointsItem.EnableDirectServerReturn.ToString().ToLower();
                                    inputEndpointElement.Add(enableDirectServerReturnElement);
                                }
                                
                                if (inputEndpointsItem.AccessControlList != null)
                                {
                                    XElement accessControlListElement = new XElement(XName.Get("AccessControlList", "http://schemas.microsoft.com/windowsazure"));
                                    inputEndpointElement.Add(accessControlListElement);
                                    
                                    if (inputEndpointsItem.AccessControlList.Rules != null)
                                    {
                                        XElement rulesSequenceElement = new XElement(XName.Get("Rules", "http://schemas.microsoft.com/windowsazure"));
                                        foreach (AccessControlListRule rulesItem in inputEndpointsItem.AccessControlList.Rules)
                                        {
                                            XElement ruleElement = new XElement(XName.Get("Rule", "http://schemas.microsoft.com/windowsazure"));
                                            rulesSequenceElement.Add(ruleElement);
                                            
                                            if (rulesItem.Order != null)
                                            {
                                                XElement orderElement = new XElement(XName.Get("Order", "http://schemas.microsoft.com/windowsazure"));
                                                orderElement.Value = rulesItem.Order.ToString();
                                                ruleElement.Add(orderElement);
                                            }
                                            
                                            if (rulesItem.Action != null)
                                            {
                                                XElement actionElement = new XElement(XName.Get("Action", "http://schemas.microsoft.com/windowsazure"));
                                                actionElement.Value = rulesItem.Action;
                                                ruleElement.Add(actionElement);
                                            }
                                            
                                            if (rulesItem.RemoteSubnet != null)
                                            {
                                                XElement remoteSubnetElement = new XElement(XName.Get("RemoteSubnet", "http://schemas.microsoft.com/windowsazure"));
                                                remoteSubnetElement.Value = rulesItem.RemoteSubnet;
                                                ruleElement.Add(remoteSubnetElement);
                                            }
                                            
                                            if (rulesItem.Description != null)
                                            {
                                                XElement descriptionElement = new XElement(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                                                descriptionElement.Value = rulesItem.Description;
                                                ruleElement.Add(descriptionElement);
                                            }
                                        }
                                        accessControlListElement.Add(rulesSequenceElement);
                                    }
                                }
                            }
                            configurationSetElement.Add(inputEndpointsSequenceElement);
                        }
                        
                        if (configurationSetsItem.SubnetNames != null)
                        {
                            XElement subnetNamesSequenceElement = new XElement(XName.Get("SubnetNames", "http://schemas.microsoft.com/windowsazure"));
                            foreach (string subnetNamesItem in configurationSetsItem.SubnetNames)
                            {
                                XElement subnetNamesItemElement = new XElement(XName.Get("SubnetName", "http://schemas.microsoft.com/windowsazure"));
                                subnetNamesItemElement.Value = subnetNamesItem;
                                subnetNamesSequenceElement.Add(subnetNamesItemElement);
                            }
                            configurationSetElement.Add(subnetNamesSequenceElement);
                        }
                        
                        if (configurationSetsItem.ComputerName != null)
                        {
                            XElement computerNameElement = new XElement(XName.Get("ComputerName", "http://schemas.microsoft.com/windowsazure"));
                            computerNameElement.Value = configurationSetsItem.ComputerName;
                            configurationSetElement.Add(computerNameElement);
                        }
                        
                        if (configurationSetsItem.AdminPassword != null)
                        {
                            XElement adminPasswordElement = new XElement(XName.Get("AdminPassword", "http://schemas.microsoft.com/windowsazure"));
                            adminPasswordElement.Value = configurationSetsItem.AdminPassword;
                            configurationSetElement.Add(adminPasswordElement);
                        }
                        
                        if (configurationSetsItem.ResetPasswordOnFirstLogon != null)
                        {
                            XElement resetPasswordOnFirstLogonElement = new XElement(XName.Get("ResetPasswordOnFirstLogon", "http://schemas.microsoft.com/windowsazure"));
                            resetPasswordOnFirstLogonElement.Value = configurationSetsItem.ResetPasswordOnFirstLogon.ToString().ToLower();
                            configurationSetElement.Add(resetPasswordOnFirstLogonElement);
                        }
                        
                        if (configurationSetsItem.EnableAutomaticUpdates != null)
                        {
                            XElement enableAutomaticUpdatesElement = new XElement(XName.Get("EnableAutomaticUpdates", "http://schemas.microsoft.com/windowsazure"));
                            enableAutomaticUpdatesElement.Value = configurationSetsItem.EnableAutomaticUpdates.ToString().ToLower();
                            configurationSetElement.Add(enableAutomaticUpdatesElement);
                        }
                        
                        if (configurationSetsItem.TimeZone != null)
                        {
                            XElement timeZoneElement = new XElement(XName.Get("TimeZone", "http://schemas.microsoft.com/windowsazure"));
                            timeZoneElement.Value = configurationSetsItem.TimeZone;
                            configurationSetElement.Add(timeZoneElement);
                        }
                        
                        if (configurationSetsItem.DomainJoin != null)
                        {
                            XElement domainJoinElement = new XElement(XName.Get("DomainJoin", "http://schemas.microsoft.com/windowsazure"));
                            configurationSetElement.Add(domainJoinElement);
                            
                            if (configurationSetsItem.DomainJoin.Credentials != null)
                            {
                                XElement credentialsElement = new XElement(XName.Get("Credentials", "http://schemas.microsoft.com/windowsazure"));
                                domainJoinElement.Add(credentialsElement);
                                
                                if (configurationSetsItem.DomainJoin.Credentials.Domain != null)
                                {
                                    XElement domainElement = new XElement(XName.Get("Domain", "http://schemas.microsoft.com/windowsazure"));
                                    domainElement.Value = configurationSetsItem.DomainJoin.Credentials.Domain;
                                    credentialsElement.Add(domainElement);
                                }
                                
                                XElement usernameElement = new XElement(XName.Get("Username", "http://schemas.microsoft.com/windowsazure"));
                                usernameElement.Value = configurationSetsItem.DomainJoin.Credentials.UserName;
                                credentialsElement.Add(usernameElement);
                                
                                XElement passwordElement = new XElement(XName.Get("Password", "http://schemas.microsoft.com/windowsazure"));
                                passwordElement.Value = configurationSetsItem.DomainJoin.Credentials.Password;
                                credentialsElement.Add(passwordElement);
                            }
                            
                            if (configurationSetsItem.DomainJoin.DomainToJoin != null)
                            {
                                XElement joinDomainElement = new XElement(XName.Get("JoinDomain", "http://schemas.microsoft.com/windowsazure"));
                                joinDomainElement.Value = configurationSetsItem.DomainJoin.DomainToJoin;
                                domainJoinElement.Add(joinDomainElement);
                            }
                            
                            if (configurationSetsItem.DomainJoin.LdapMachineObjectOU != null)
                            {
                                XElement machineObjectOUElement = new XElement(XName.Get("MachineObjectOU", "http://schemas.microsoft.com/windowsazure"));
                                machineObjectOUElement.Value = configurationSetsItem.DomainJoin.LdapMachineObjectOU;
                                domainJoinElement.Add(machineObjectOUElement);
                            }
                            
                            if (configurationSetsItem.DomainJoin.Provisioning != null)
                            {
                                XElement provisioningElement = new XElement(XName.Get("Provisioning", "http://schemas.microsoft.com/windowsazure"));
                                domainJoinElement.Add(provisioningElement);
                                
                                if (configurationSetsItem.DomainJoin.Provisioning.AccountData != null)
                                {
                                    XElement accountDataElement = new XElement(XName.Get("AccountData", "http://schemas.microsoft.com/windowsazure"));
                                    accountDataElement.Value = configurationSetsItem.DomainJoin.Provisioning.AccountData;
                                    provisioningElement.Add(accountDataElement);
                                }
                            }
                        }
                        
                        if (configurationSetsItem.StoredCertificateSettings != null)
                        {
                            XElement storedCertificateSettingsSequenceElement = new XElement(XName.Get("StoredCertificateSettings", "http://schemas.microsoft.com/windowsazure"));
                            foreach (StoredCertificateSettings storedCertificateSettingsItem in configurationSetsItem.StoredCertificateSettings)
                            {
                                XElement certificateSettingElement = new XElement(XName.Get("CertificateSetting", "http://schemas.microsoft.com/windowsazure"));
                                storedCertificateSettingsSequenceElement.Add(certificateSettingElement);
                                
                                XElement storeLocationElement = new XElement(XName.Get("StoreLocation", "http://schemas.microsoft.com/windowsazure"));
                                storeLocationElement.Value = "LocalMachine";
                                certificateSettingElement.Add(storeLocationElement);
                                
                                XElement storeNameElement = new XElement(XName.Get("StoreName", "http://schemas.microsoft.com/windowsazure"));
                                storeNameElement.Value = storedCertificateSettingsItem.StoreName;
                                certificateSettingElement.Add(storeNameElement);
                                
                                XElement thumbprintElement = new XElement(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                                thumbprintElement.Value = storedCertificateSettingsItem.Thumbprint;
                                certificateSettingElement.Add(thumbprintElement);
                            }
                            configurationSetElement.Add(storedCertificateSettingsSequenceElement);
                        }
                        
                        if (configurationSetsItem.WindowsRemoteManagement != null)
                        {
                            XElement winRMElement = new XElement(XName.Get("WinRM", "http://schemas.microsoft.com/windowsazure"));
                            configurationSetElement.Add(winRMElement);
                            
                            if (configurationSetsItem.WindowsRemoteManagement.Listeners != null)
                            {
                                XElement listenersSequenceElement = new XElement(XName.Get("Listeners", "http://schemas.microsoft.com/windowsazure"));
                                foreach (WindowsRemoteManagementListener listenersItem in configurationSetsItem.WindowsRemoteManagement.Listeners)
                                {
                                    XElement listenerElement = new XElement(XName.Get("Listener", "http://schemas.microsoft.com/windowsazure"));
                                    listenersSequenceElement.Add(listenerElement);
                                    
                                    XElement protocolElement3 = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                    protocolElement3.Value = listenersItem.ListenerType.ToString();
                                    listenerElement.Add(protocolElement3);
                                    
                                    if (listenersItem.CertificateThumbprint != null)
                                    {
                                        XElement certificateThumbprintElement = new XElement(XName.Get("CertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                        certificateThumbprintElement.Value = listenersItem.CertificateThumbprint;
                                        listenerElement.Add(certificateThumbprintElement);
                                    }
                                }
                                winRMElement.Add(listenersSequenceElement);
                            }
                        }
                        
                        if (configurationSetsItem.AdminUserName != null)
                        {
                            XElement adminUsernameElement = new XElement(XName.Get("AdminUsername", "http://schemas.microsoft.com/windowsazure"));
                            adminUsernameElement.Value = configurationSetsItem.AdminUserName;
                            configurationSetElement.Add(adminUsernameElement);
                        }
                        
                        if (configurationSetsItem.HostName != null)
                        {
                            XElement hostNameElement = new XElement(XName.Get("HostName", "http://schemas.microsoft.com/windowsazure"));
                            hostNameElement.Value = configurationSetsItem.HostName;
                            configurationSetElement.Add(hostNameElement);
                        }
                        
                        if (configurationSetsItem.UserName != null)
                        {
                            XElement userNameElement = new XElement(XName.Get("UserName", "http://schemas.microsoft.com/windowsazure"));
                            userNameElement.Value = configurationSetsItem.UserName;
                            configurationSetElement.Add(userNameElement);
                        }
                        
                        if (configurationSetsItem.UserPassword != null)
                        {
                            XElement userPasswordElement = new XElement(XName.Get("UserPassword", "http://schemas.microsoft.com/windowsazure"));
                            userPasswordElement.Value = configurationSetsItem.UserPassword;
                            configurationSetElement.Add(userPasswordElement);
                        }
                        
                        if (configurationSetsItem.DisableSshPasswordAuthentication != null)
                        {
                            XElement disableSshPasswordAuthenticationElement = new XElement(XName.Get("DisableSshPasswordAuthentication", "http://schemas.microsoft.com/windowsazure"));
                            disableSshPasswordAuthenticationElement.Value = configurationSetsItem.DisableSshPasswordAuthentication.ToString().ToLower();
                            configurationSetElement.Add(disableSshPasswordAuthenticationElement);
                        }
                        
                        if (configurationSetsItem.SshSettings != null)
                        {
                            XElement sSHElement = new XElement(XName.Get("SSH", "http://schemas.microsoft.com/windowsazure"));
                            configurationSetElement.Add(sSHElement);
                            
                            if (configurationSetsItem.SshSettings.PublicKeys != null)
                            {
                                XElement publicKeysSequenceElement = new XElement(XName.Get("PublicKeys", "http://schemas.microsoft.com/windowsazure"));
                                foreach (SshSettingPublicKey publicKeysItem in configurationSetsItem.SshSettings.PublicKeys)
                                {
                                    XElement publicKeyElement = new XElement(XName.Get("PublicKey", "http://schemas.microsoft.com/windowsazure"));
                                    publicKeysSequenceElement.Add(publicKeyElement);
                                    
                                    XElement fingerPrintElement = new XElement(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                    fingerPrintElement.Value = publicKeysItem.Fingerprint;
                                    publicKeyElement.Add(fingerPrintElement);
                                    
                                    XElement pathElement2 = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                    pathElement2.Value = publicKeysItem.Path;
                                    publicKeyElement.Add(pathElement2);
                                }
                                sSHElement.Add(publicKeysSequenceElement);
                            }
                            
                            if (configurationSetsItem.SshSettings.KeyPairs != null)
                            {
                                XElement keyPairsSequenceElement = new XElement(XName.Get("KeyPairs", "http://schemas.microsoft.com/windowsazure"));
                                foreach (SshSettingKeyPair keyPairsItem in configurationSetsItem.SshSettings.KeyPairs)
                                {
                                    XElement keyPairElement = new XElement(XName.Get("KeyPair", "http://schemas.microsoft.com/windowsazure"));
                                    keyPairsSequenceElement.Add(keyPairElement);
                                    
                                    XElement fingerPrintElement2 = new XElement(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                    fingerPrintElement2.Value = keyPairsItem.Fingerprint;
                                    keyPairElement.Add(fingerPrintElement2);
                                    
                                    XElement pathElement3 = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                    pathElement3.Value = keyPairsItem.Path;
                                    keyPairElement.Add(pathElement3);
                                }
                                sSHElement.Add(keyPairsSequenceElement);
                            }
                        }
                    }
                    persistentVMRoleElement.Add(configurationSetsSequenceElement);
                }
                
                if (parameters.AvailabilitySetName != null)
                {
                    XElement availabilitySetNameElement = new XElement(XName.Get("AvailabilitySetName", "http://schemas.microsoft.com/windowsazure"));
                    availabilitySetNameElement.Value = parameters.AvailabilitySetName;
                    persistentVMRoleElement.Add(availabilitySetNameElement);
                }
                
                if (parameters.DataVirtualHardDisks != null)
                {
                    XElement dataVirtualHardDisksSequenceElement = new XElement(XName.Get("DataVirtualHardDisks", "http://schemas.microsoft.com/windowsazure"));
                    foreach (DataVirtualHardDisk dataVirtualHardDisksItem in parameters.DataVirtualHardDisks)
                    {
                        XElement dataVirtualHardDiskElement = new XElement(XName.Get("DataVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                        dataVirtualHardDisksSequenceElement.Add(dataVirtualHardDiskElement);
                        
                        if (dataVirtualHardDisksItem.HostCaching != null)
                        {
                            XElement hostCachingElement = new XElement(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                            hostCachingElement.Value = dataVirtualHardDisksItem.HostCaching.ToString();
                            dataVirtualHardDiskElement.Add(hostCachingElement);
                        }
                        
                        if (dataVirtualHardDisksItem.DiskLabel != null)
                        {
                            XElement diskLabelElement = new XElement(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                            diskLabelElement.Value = dataVirtualHardDisksItem.DiskLabel;
                            dataVirtualHardDiskElement.Add(diskLabelElement);
                        }
                        
                        if (dataVirtualHardDisksItem.DiskName != null)
                        {
                            XElement diskNameElement = new XElement(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                            diskNameElement.Value = dataVirtualHardDisksItem.DiskName;
                            dataVirtualHardDiskElement.Add(diskNameElement);
                        }
                        
                        if (dataVirtualHardDisksItem.LogicalUnitNumber != null)
                        {
                            XElement lunElement = new XElement(XName.Get("Lun", "http://schemas.microsoft.com/windowsazure"));
                            lunElement.Value = dataVirtualHardDisksItem.LogicalUnitNumber.ToString();
                            dataVirtualHardDiskElement.Add(lunElement);
                        }
                        
                        XElement logicalDiskSizeInGBElement = new XElement(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                        logicalDiskSizeInGBElement.Value = dataVirtualHardDisksItem.LogicalDiskSizeInGB.ToString();
                        dataVirtualHardDiskElement.Add(logicalDiskSizeInGBElement);
                        
                        if (dataVirtualHardDisksItem.MediaLink != null)
                        {
                            XElement mediaLinkElement = new XElement(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                            mediaLinkElement.Value = dataVirtualHardDisksItem.MediaLink.ToString();
                            dataVirtualHardDiskElement.Add(mediaLinkElement);
                        }
                    }
                    persistentVMRoleElement.Add(dataVirtualHardDisksSequenceElement);
                }
                
                if (parameters.OSVirtualHardDisk != null)
                {
                    XElement oSVirtualHardDiskElement = new XElement(XName.Get("OSVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                    persistentVMRoleElement.Add(oSVirtualHardDiskElement);
                    
                    if (parameters.OSVirtualHardDisk.HostCaching != null)
                    {
                        XElement hostCachingElement2 = new XElement(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                        hostCachingElement2.Value = parameters.OSVirtualHardDisk.HostCaching.ToString();
                        oSVirtualHardDiskElement.Add(hostCachingElement2);
                    }
                    
                    if (parameters.OSVirtualHardDisk.DiskLabel != null)
                    {
                        XElement diskLabelElement2 = new XElement(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                        diskLabelElement2.Value = parameters.OSVirtualHardDisk.DiskLabel;
                        oSVirtualHardDiskElement.Add(diskLabelElement2);
                    }
                    
                    if (parameters.OSVirtualHardDisk.DiskName != null)
                    {
                        XElement diskNameElement2 = new XElement(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                        diskNameElement2.Value = parameters.OSVirtualHardDisk.DiskName;
                        oSVirtualHardDiskElement.Add(diskNameElement2);
                    }
                    
                    if (parameters.OSVirtualHardDisk.MediaLink != null)
                    {
                        XElement mediaLinkElement2 = new XElement(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                        mediaLinkElement2.Value = parameters.OSVirtualHardDisk.MediaLink.ToString();
                        oSVirtualHardDiskElement.Add(mediaLinkElement2);
                    }
                    
                    if (parameters.OSVirtualHardDisk.SourceImageName != null)
                    {
                        XElement sourceImageNameElement = new XElement(XName.Get("SourceImageName", "http://schemas.microsoft.com/windowsazure"));
                        sourceImageNameElement.Value = parameters.OSVirtualHardDisk.SourceImageName;
                        oSVirtualHardDiskElement.Add(sourceImageNameElement);
                    }
                    
                    if (parameters.OSVirtualHardDisk.OperatingSystem != null)
                    {
                        XElement osElement = new XElement(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                        osElement.Value = parameters.OSVirtualHardDisk.OperatingSystem;
                        oSVirtualHardDiskElement.Add(osElement);
                    }
                }
                
                if (parameters.RoleSize != null)
                {
                    XElement roleSizeElement = new XElement(XName.Get("RoleSize", "http://schemas.microsoft.com/windowsazure"));
                    roleSizeElement.Value = parameters.RoleSize.ToString();
                    persistentVMRoleElement.Add(roleSizeElement);
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Add Role operation adds a virtual machine to an existing
        /// deployment.  You can refer to the OSDisk in the Add Role operation
        /// in the following ways.  Platform/User Image  Set the
        /// SourceImageName to a platform or user image. You can optionally
        /// specify the DiskName and MediaLink values as part the operation to
        /// control the name and location of target disk.  When DiskName and
        /// MediaLink are specified in this mode, they must not already exist
        /// in the system, otherwise a conflict fault is returned.  UserDisk 
        /// Set DiskName to a user supplied image in image repository.
        /// SourceImageName must be set to NULL. All other properties are
        /// ignored.  Blob in a Storage Account  Set MediaLink to a blob
        /// containing the image. SourceImageName and DiskName are set to
        /// NULL.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157186.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> CreateAsync(string serviceName, string deploymentName, VirtualMachineCreateParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "CreateAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.VirtualMachines.BeginCreatingAsync(serviceName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Create Virtual Machine Deployment operation provisions a
        /// virtual machine based on the supplied configuration.  When you
        /// create a deployment of a virtual machine, you should make sure
        /// that the cloud service and the disk or image that you use are
        /// located in the same region. For example, if the cloud service was
        /// created in the West US region, the disk or image that you use
        /// should also be located in a stor4age account in the West US
        /// region.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157194.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginCreatingDeploymentAsync(string serviceName, VirtualMachineCreateDeploymentParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.Name == null)
            {
                throw new ArgumentNullException("parameters.Name");
            }
            if (parameters.Label == null)
            {
                throw new ArgumentNullException("parameters.Label");
            }
            if (parameters.Label.Length > 100)
            {
                throw new ArgumentOutOfRangeException("parameters.Label");
            }
            if (parameters.Roles == null)
            {
                throw new ArgumentNullException("parameters.Roles");
            }
            foreach (Role rolesParameterItem in parameters.Roles)
            {
                foreach (ConfigurationSet configurationSetsParameterItem in rolesParameterItem.ConfigurationSets)
                {
                    if (configurationSetsParameterItem.DomainJoin != null)
                    {
                        if (configurationSetsParameterItem.DomainJoin.Credentials != null)
                        {
                            if (configurationSetsParameterItem.DomainJoin.Credentials.UserName == null)
                            {
                                throw new ArgumentNullException("parameters.Roles.ConfigurationSets.DomainJoin.Credentials.UserName");
                            }
                            if (configurationSetsParameterItem.DomainJoin.Credentials.Password == null)
                            {
                                throw new ArgumentNullException("parameters.Roles.ConfigurationSets.DomainJoin.Credentials.Password");
                            }
                        }
                    }
                    foreach (StoredCertificateSettings storedCertificateSettingsParameterItem in configurationSetsParameterItem.StoredCertificateSettings)
                    {
                        if (storedCertificateSettingsParameterItem.StoreName == null)
                        {
                            throw new ArgumentNullException("parameters.Roles.ConfigurationSets.StoredCertificateSettings.StoreName");
                        }
                        if (storedCertificateSettingsParameterItem.Thumbprint == null)
                        {
                            throw new ArgumentNullException("parameters.Roles.ConfigurationSets.StoredCertificateSettings.Thumbprint");
                        }
                    }
                    if (configurationSetsParameterItem.HostName != null && configurationSetsParameterItem.HostName.Length < 1)
                    {
                        throw new ArgumentOutOfRangeException("parameters.Roles.ConfigurationSets.HostName");
                    }
                    if (configurationSetsParameterItem.HostName != null && configurationSetsParameterItem.HostName.Length > 64)
                    {
                        throw new ArgumentOutOfRangeException("parameters.Roles.ConfigurationSets.HostName");
                    }
                    if (configurationSetsParameterItem.UserName != null && configurationSetsParameterItem.UserName.Length < 1)
                    {
                        throw new ArgumentOutOfRangeException("parameters.Roles.ConfigurationSets.UserName");
                    }
                    if (configurationSetsParameterItem.UserName != null && configurationSetsParameterItem.UserName.Length > 32)
                    {
                        throw new ArgumentOutOfRangeException("parameters.Roles.ConfigurationSets.UserName");
                    }
                    if (configurationSetsParameterItem.UserPassword != null && configurationSetsParameterItem.UserPassword.Length < 6 && (configurationSetsParameterItem.DisableSshPasswordAuthentication == false || configurationSetsParameterItem.UserPassword.Length != 0))
                    {
                        throw new ArgumentOutOfRangeException("parameters.Roles.ConfigurationSets.UserPassword");
                    }
                    if (configurationSetsParameterItem.UserPassword != null && configurationSetsParameterItem.UserPassword.Length > 72)
                    {
                        throw new ArgumentOutOfRangeException("parameters.Roles.ConfigurationSets.UserPassword");
                    }
                    if (configurationSetsParameterItem.SshSettings != null)
                    {
                        foreach (SshSettingPublicKey publicKeysParameterItem in configurationSetsParameterItem.SshSettings.PublicKeys)
                        {
                            if (publicKeysParameterItem.Fingerprint == null)
                            {
                                throw new ArgumentNullException("parameters.Roles.ConfigurationSets.SshSettings.PublicKeys.Fingerprint");
                            }
                            if (publicKeysParameterItem.Path == null)
                            {
                                throw new ArgumentNullException("parameters.Roles.ConfigurationSets.SshSettings.PublicKeys.Path");
                            }
                        }
                        foreach (SshSettingKeyPair keyPairsParameterItem in configurationSetsParameterItem.SshSettings.KeyPairs)
                        {
                            if (keyPairsParameterItem.Fingerprint == null)
                            {
                                throw new ArgumentNullException("parameters.Roles.ConfigurationSets.SshSettings.KeyPairs.Fingerprint");
                            }
                            if (keyPairsParameterItem.Path == null)
                            {
                                throw new ArgumentNullException("parameters.Roles.ConfigurationSets.SshSettings.KeyPairs.Path");
                            }
                        }
                    }
                }
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginCreatingDeploymentAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement deploymentElement = new XElement(XName.Get("Deployment", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(deploymentElement);
                
                XElement nameElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                nameElement.Value = parameters.Name;
                deploymentElement.Add(nameElement);
                
                XElement deploymentSlotElement = new XElement(XName.Get("DeploymentSlot", "http://schemas.microsoft.com/windowsazure"));
                deploymentSlotElement.Value = parameters.DeploymentSlot.ToString();
                deploymentElement.Add(deploymentSlotElement);
                
                XElement labelElement = new XElement(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                labelElement.Value = TypeConversion.ToBase64String(parameters.Label);
                deploymentElement.Add(labelElement);
                
                XElement roleListSequenceElement = new XElement(XName.Get("RoleList", "http://schemas.microsoft.com/windowsazure"));
                foreach (Role roleListItem in parameters.Roles)
                {
                    XElement roleElement = new XElement(XName.Get("Role", "http://schemas.microsoft.com/windowsazure"));
                    roleListSequenceElement.Add(roleElement);
                    
                    if (roleListItem.RoleName != null)
                    {
                        XElement roleNameElement = new XElement(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                        roleNameElement.Value = roleListItem.RoleName;
                        roleElement.Add(roleNameElement);
                    }
                    
                    if (roleListItem.OSVersion != null)
                    {
                        XElement oSVersionElement = new XElement(XName.Get("OSVersion", "http://schemas.microsoft.com/windowsazure"));
                        oSVersionElement.Value = roleListItem.OSVersion;
                        roleElement.Add(oSVersionElement);
                    }
                    
                    if (roleListItem.RoleType != null)
                    {
                        XElement roleTypeElement = new XElement(XName.Get("RoleType", "http://schemas.microsoft.com/windowsazure"));
                        roleTypeElement.Value = roleListItem.RoleType;
                        roleElement.Add(roleTypeElement);
                    }
                    
                    if (roleListItem.ConfigurationSets != null)
                    {
                        XElement configurationSetsSequenceElement = new XElement(XName.Get("ConfigurationSets", "http://schemas.microsoft.com/windowsazure"));
                        foreach (ConfigurationSet configurationSetsItem in roleListItem.ConfigurationSets)
                        {
                            XElement configurationSetElement = new XElement(XName.Get("ConfigurationSet", "http://schemas.microsoft.com/windowsazure"));
                            configurationSetsSequenceElement.Add(configurationSetElement);
                            
                            if (configurationSetsItem.ConfigurationSetType != null)
                            {
                                XElement configurationSetTypeElement = new XElement(XName.Get("ConfigurationSetType", "http://schemas.microsoft.com/windowsazure"));
                                configurationSetTypeElement.Value = configurationSetsItem.ConfigurationSetType;
                                configurationSetElement.Add(configurationSetTypeElement);
                            }
                            
                            if (configurationSetsItem.InputEndpoints != null)
                            {
                                XElement inputEndpointsSequenceElement = new XElement(XName.Get("InputEndpoints", "http://schemas.microsoft.com/windowsazure"));
                                foreach (InputEndpoint inputEndpointsItem in configurationSetsItem.InputEndpoints)
                                {
                                    XElement inputEndpointElement = new XElement(XName.Get("InputEndpoint", "http://schemas.microsoft.com/windowsazure"));
                                    inputEndpointsSequenceElement.Add(inputEndpointElement);
                                    
                                    if (inputEndpointsItem.LoadBalancedEndpointSetName != null)
                                    {
                                        XElement loadBalancedEndpointSetNameElement = new XElement(XName.Get("LoadBalancedEndpointSetName", "http://schemas.microsoft.com/windowsazure"));
                                        loadBalancedEndpointSetNameElement.Value = inputEndpointsItem.LoadBalancedEndpointSetName;
                                        inputEndpointElement.Add(loadBalancedEndpointSetNameElement);
                                    }
                                    
                                    if (inputEndpointsItem.LocalPort != null)
                                    {
                                        XElement localPortElement = new XElement(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                                        localPortElement.Value = inputEndpointsItem.LocalPort.ToString();
                                        inputEndpointElement.Add(localPortElement);
                                    }
                                    
                                    if (inputEndpointsItem.Name != null)
                                    {
                                        XElement nameElement2 = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                        nameElement2.Value = inputEndpointsItem.Name;
                                        inputEndpointElement.Add(nameElement2);
                                    }
                                    
                                    if (inputEndpointsItem.Port != null)
                                    {
                                        XElement portElement = new XElement(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                        portElement.Value = inputEndpointsItem.Port.ToString();
                                        inputEndpointElement.Add(portElement);
                                    }
                                    
                                    if (inputEndpointsItem.LoadBalancerProbe != null)
                                    {
                                        XElement loadBalancerProbeElement = new XElement(XName.Get("LoadBalancerProbe", "http://schemas.microsoft.com/windowsazure"));
                                        inputEndpointElement.Add(loadBalancerProbeElement);
                                        
                                        if (inputEndpointsItem.LoadBalancerProbe.Path != null)
                                        {
                                            XElement pathElement = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                            pathElement.Value = inputEndpointsItem.LoadBalancerProbe.Path;
                                            loadBalancerProbeElement.Add(pathElement);
                                        }
                                        
                                        XElement portElement2 = new XElement(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                        portElement2.Value = inputEndpointsItem.LoadBalancerProbe.Port.ToString();
                                        loadBalancerProbeElement.Add(portElement2);
                                        
                                        XElement protocolElement = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                        protocolElement.Value = ComputeManagementClient.LoadBalancerProbeTransportProtocolToString(inputEndpointsItem.LoadBalancerProbe.Protocol);
                                        loadBalancerProbeElement.Add(protocolElement);
                                        
                                        if (inputEndpointsItem.LoadBalancerProbe.IntervalInSeconds != null)
                                        {
                                            XElement intervalInSecondsElement = new XElement(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                            intervalInSecondsElement.Value = inputEndpointsItem.LoadBalancerProbe.IntervalInSeconds.ToString();
                                            loadBalancerProbeElement.Add(intervalInSecondsElement);
                                        }
                                        
                                        if (inputEndpointsItem.LoadBalancerProbe.TimeoutInSeconds != null)
                                        {
                                            XElement timeoutInSecondsElement = new XElement(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                            timeoutInSecondsElement.Value = inputEndpointsItem.LoadBalancerProbe.TimeoutInSeconds.ToString();
                                            loadBalancerProbeElement.Add(timeoutInSecondsElement);
                                        }
                                    }
                                    
                                    if (inputEndpointsItem.Protocol != null)
                                    {
                                        XElement protocolElement2 = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                        protocolElement2.Value = inputEndpointsItem.Protocol;
                                        inputEndpointElement.Add(protocolElement2);
                                    }
                                    
                                    if (inputEndpointsItem.VirtualIPAddress != null)
                                    {
                                        XElement vipElement = new XElement(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                                        vipElement.Value = inputEndpointsItem.VirtualIPAddress;
                                        inputEndpointElement.Add(vipElement);
                                    }
                                    
                                    if (inputEndpointsItem.EnableDirectServerReturn != null)
                                    {
                                        XElement enableDirectServerReturnElement = new XElement(XName.Get("EnableDirectServerReturn", "http://schemas.microsoft.com/windowsazure"));
                                        enableDirectServerReturnElement.Value = inputEndpointsItem.EnableDirectServerReturn.ToString().ToLower();
                                        inputEndpointElement.Add(enableDirectServerReturnElement);
                                    }
                                    
                                    if (inputEndpointsItem.AccessControlList != null)
                                    {
                                        XElement accessControlListElement = new XElement(XName.Get("AccessControlList", "http://schemas.microsoft.com/windowsazure"));
                                        inputEndpointElement.Add(accessControlListElement);
                                        
                                        if (inputEndpointsItem.AccessControlList.Rules != null)
                                        {
                                            XElement rulesSequenceElement = new XElement(XName.Get("Rules", "http://schemas.microsoft.com/windowsazure"));
                                            foreach (AccessControlListRule rulesItem in inputEndpointsItem.AccessControlList.Rules)
                                            {
                                                XElement ruleElement = new XElement(XName.Get("Rule", "http://schemas.microsoft.com/windowsazure"));
                                                rulesSequenceElement.Add(ruleElement);
                                                
                                                if (rulesItem.Order != null)
                                                {
                                                    XElement orderElement = new XElement(XName.Get("Order", "http://schemas.microsoft.com/windowsazure"));
                                                    orderElement.Value = rulesItem.Order.ToString();
                                                    ruleElement.Add(orderElement);
                                                }
                                                
                                                if (rulesItem.Action != null)
                                                {
                                                    XElement actionElement = new XElement(XName.Get("Action", "http://schemas.microsoft.com/windowsazure"));
                                                    actionElement.Value = rulesItem.Action;
                                                    ruleElement.Add(actionElement);
                                                }
                                                
                                                if (rulesItem.RemoteSubnet != null)
                                                {
                                                    XElement remoteSubnetElement = new XElement(XName.Get("RemoteSubnet", "http://schemas.microsoft.com/windowsazure"));
                                                    remoteSubnetElement.Value = rulesItem.RemoteSubnet;
                                                    ruleElement.Add(remoteSubnetElement);
                                                }
                                                
                                                if (rulesItem.Description != null)
                                                {
                                                    XElement descriptionElement = new XElement(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                                                    descriptionElement.Value = rulesItem.Description;
                                                    ruleElement.Add(descriptionElement);
                                                }
                                            }
                                            accessControlListElement.Add(rulesSequenceElement);
                                        }
                                    }
                                }
                                configurationSetElement.Add(inputEndpointsSequenceElement);
                            }
                            
                            if (configurationSetsItem.SubnetNames != null)
                            {
                                XElement subnetNamesSequenceElement = new XElement(XName.Get("SubnetNames", "http://schemas.microsoft.com/windowsazure"));
                                foreach (string subnetNamesItem in configurationSetsItem.SubnetNames)
                                {
                                    XElement subnetNamesItemElement = new XElement(XName.Get("SubnetName", "http://schemas.microsoft.com/windowsazure"));
                                    subnetNamesItemElement.Value = subnetNamesItem;
                                    subnetNamesSequenceElement.Add(subnetNamesItemElement);
                                }
                                configurationSetElement.Add(subnetNamesSequenceElement);
                            }
                            
                            if (configurationSetsItem.ComputerName != null)
                            {
                                XElement computerNameElement = new XElement(XName.Get("ComputerName", "http://schemas.microsoft.com/windowsazure"));
                                computerNameElement.Value = configurationSetsItem.ComputerName;
                                configurationSetElement.Add(computerNameElement);
                            }
                            
                            if (configurationSetsItem.AdminPassword != null)
                            {
                                XElement adminPasswordElement = new XElement(XName.Get("AdminPassword", "http://schemas.microsoft.com/windowsazure"));
                                adminPasswordElement.Value = configurationSetsItem.AdminPassword;
                                configurationSetElement.Add(adminPasswordElement);
                            }
                            
                            if (configurationSetsItem.ResetPasswordOnFirstLogon != null)
                            {
                                XElement resetPasswordOnFirstLogonElement = new XElement(XName.Get("ResetPasswordOnFirstLogon", "http://schemas.microsoft.com/windowsazure"));
                                resetPasswordOnFirstLogonElement.Value = configurationSetsItem.ResetPasswordOnFirstLogon.ToString().ToLower();
                                configurationSetElement.Add(resetPasswordOnFirstLogonElement);
                            }
                            
                            if (configurationSetsItem.EnableAutomaticUpdates != null)
                            {
                                XElement enableAutomaticUpdatesElement = new XElement(XName.Get("EnableAutomaticUpdates", "http://schemas.microsoft.com/windowsazure"));
                                enableAutomaticUpdatesElement.Value = configurationSetsItem.EnableAutomaticUpdates.ToString().ToLower();
                                configurationSetElement.Add(enableAutomaticUpdatesElement);
                            }
                            
                            if (configurationSetsItem.TimeZone != null)
                            {
                                XElement timeZoneElement = new XElement(XName.Get("TimeZone", "http://schemas.microsoft.com/windowsazure"));
                                timeZoneElement.Value = configurationSetsItem.TimeZone;
                                configurationSetElement.Add(timeZoneElement);
                            }
                            
                            if (configurationSetsItem.DomainJoin != null)
                            {
                                XElement domainJoinElement = new XElement(XName.Get("DomainJoin", "http://schemas.microsoft.com/windowsazure"));
                                configurationSetElement.Add(domainJoinElement);
                                
                                if (configurationSetsItem.DomainJoin.Credentials != null)
                                {
                                    XElement credentialsElement = new XElement(XName.Get("Credentials", "http://schemas.microsoft.com/windowsazure"));
                                    domainJoinElement.Add(credentialsElement);
                                    
                                    if (configurationSetsItem.DomainJoin.Credentials.Domain != null)
                                    {
                                        XElement domainElement = new XElement(XName.Get("Domain", "http://schemas.microsoft.com/windowsazure"));
                                        domainElement.Value = configurationSetsItem.DomainJoin.Credentials.Domain;
                                        credentialsElement.Add(domainElement);
                                    }
                                    
                                    XElement usernameElement = new XElement(XName.Get("Username", "http://schemas.microsoft.com/windowsazure"));
                                    usernameElement.Value = configurationSetsItem.DomainJoin.Credentials.UserName;
                                    credentialsElement.Add(usernameElement);
                                    
                                    XElement passwordElement = new XElement(XName.Get("Password", "http://schemas.microsoft.com/windowsazure"));
                                    passwordElement.Value = configurationSetsItem.DomainJoin.Credentials.Password;
                                    credentialsElement.Add(passwordElement);
                                }
                                
                                if (configurationSetsItem.DomainJoin.DomainToJoin != null)
                                {
                                    XElement joinDomainElement = new XElement(XName.Get("JoinDomain", "http://schemas.microsoft.com/windowsazure"));
                                    joinDomainElement.Value = configurationSetsItem.DomainJoin.DomainToJoin;
                                    domainJoinElement.Add(joinDomainElement);
                                }
                                
                                if (configurationSetsItem.DomainJoin.LdapMachineObjectOU != null)
                                {
                                    XElement machineObjectOUElement = new XElement(XName.Get("MachineObjectOU", "http://schemas.microsoft.com/windowsazure"));
                                    machineObjectOUElement.Value = configurationSetsItem.DomainJoin.LdapMachineObjectOU;
                                    domainJoinElement.Add(machineObjectOUElement);
                                }
                                
                                if (configurationSetsItem.DomainJoin.Provisioning != null)
                                {
                                    XElement provisioningElement = new XElement(XName.Get("Provisioning", "http://schemas.microsoft.com/windowsazure"));
                                    domainJoinElement.Add(provisioningElement);
                                    
                                    if (configurationSetsItem.DomainJoin.Provisioning.AccountData != null)
                                    {
                                        XElement accountDataElement = new XElement(XName.Get("AccountData", "http://schemas.microsoft.com/windowsazure"));
                                        accountDataElement.Value = configurationSetsItem.DomainJoin.Provisioning.AccountData;
                                        provisioningElement.Add(accountDataElement);
                                    }
                                }
                            }
                            
                            if (configurationSetsItem.StoredCertificateSettings != null)
                            {
                                XElement storedCertificateSettingsSequenceElement = new XElement(XName.Get("StoredCertificateSettings", "http://schemas.microsoft.com/windowsazure"));
                                foreach (StoredCertificateSettings storedCertificateSettingsItem in configurationSetsItem.StoredCertificateSettings)
                                {
                                    XElement certificateSettingElement = new XElement(XName.Get("CertificateSetting", "http://schemas.microsoft.com/windowsazure"));
                                    storedCertificateSettingsSequenceElement.Add(certificateSettingElement);
                                    
                                    XElement storeLocationElement = new XElement(XName.Get("StoreLocation", "http://schemas.microsoft.com/windowsazure"));
                                    storeLocationElement.Value = "LocalMachine";
                                    certificateSettingElement.Add(storeLocationElement);
                                    
                                    XElement storeNameElement = new XElement(XName.Get("StoreName", "http://schemas.microsoft.com/windowsazure"));
                                    storeNameElement.Value = storedCertificateSettingsItem.StoreName;
                                    certificateSettingElement.Add(storeNameElement);
                                    
                                    XElement thumbprintElement = new XElement(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                                    thumbprintElement.Value = storedCertificateSettingsItem.Thumbprint;
                                    certificateSettingElement.Add(thumbprintElement);
                                }
                                configurationSetElement.Add(storedCertificateSettingsSequenceElement);
                            }
                            
                            if (configurationSetsItem.WindowsRemoteManagement != null)
                            {
                                XElement winRMElement = new XElement(XName.Get("WinRM", "http://schemas.microsoft.com/windowsazure"));
                                configurationSetElement.Add(winRMElement);
                                
                                if (configurationSetsItem.WindowsRemoteManagement.Listeners != null)
                                {
                                    XElement listenersSequenceElement = new XElement(XName.Get("Listeners", "http://schemas.microsoft.com/windowsazure"));
                                    foreach (WindowsRemoteManagementListener listenersItem in configurationSetsItem.WindowsRemoteManagement.Listeners)
                                    {
                                        XElement listenerElement = new XElement(XName.Get("Listener", "http://schemas.microsoft.com/windowsazure"));
                                        listenersSequenceElement.Add(listenerElement);
                                        
                                        XElement protocolElement3 = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                        protocolElement3.Value = listenersItem.ListenerType.ToString();
                                        listenerElement.Add(protocolElement3);
                                        
                                        if (listenersItem.CertificateThumbprint != null)
                                        {
                                            XElement certificateThumbprintElement = new XElement(XName.Get("CertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                            certificateThumbprintElement.Value = listenersItem.CertificateThumbprint;
                                            listenerElement.Add(certificateThumbprintElement);
                                        }
                                    }
                                    winRMElement.Add(listenersSequenceElement);
                                }
                            }
                            
                            if (configurationSetsItem.AdminUserName != null)
                            {
                                XElement adminUsernameElement = new XElement(XName.Get("AdminUsername", "http://schemas.microsoft.com/windowsazure"));
                                adminUsernameElement.Value = configurationSetsItem.AdminUserName;
                                configurationSetElement.Add(adminUsernameElement);
                            }
                            
                            if (configurationSetsItem.HostName != null)
                            {
                                XElement hostNameElement = new XElement(XName.Get("HostName", "http://schemas.microsoft.com/windowsazure"));
                                hostNameElement.Value = configurationSetsItem.HostName;
                                configurationSetElement.Add(hostNameElement);
                            }
                            
                            if (configurationSetsItem.UserName != null)
                            {
                                XElement userNameElement = new XElement(XName.Get("UserName", "http://schemas.microsoft.com/windowsazure"));
                                userNameElement.Value = configurationSetsItem.UserName;
                                configurationSetElement.Add(userNameElement);
                            }
                            
                            if (configurationSetsItem.UserPassword != null)
                            {
                                XElement userPasswordElement = new XElement(XName.Get("UserPassword", "http://schemas.microsoft.com/windowsazure"));
                                userPasswordElement.Value = configurationSetsItem.UserPassword;
                                configurationSetElement.Add(userPasswordElement);
                            }
                            
                            if (configurationSetsItem.DisableSshPasswordAuthentication != null)
                            {
                                XElement disableSshPasswordAuthenticationElement = new XElement(XName.Get("DisableSshPasswordAuthentication", "http://schemas.microsoft.com/windowsazure"));
                                disableSshPasswordAuthenticationElement.Value = configurationSetsItem.DisableSshPasswordAuthentication.ToString().ToLower();
                                configurationSetElement.Add(disableSshPasswordAuthenticationElement);
                            }
                            
                            if (configurationSetsItem.SshSettings != null)
                            {
                                XElement sSHElement = new XElement(XName.Get("SSH", "http://schemas.microsoft.com/windowsazure"));
                                configurationSetElement.Add(sSHElement);
                                
                                if (configurationSetsItem.SshSettings.PublicKeys != null)
                                {
                                    XElement publicKeysSequenceElement = new XElement(XName.Get("PublicKeys", "http://schemas.microsoft.com/windowsazure"));
                                    foreach (SshSettingPublicKey publicKeysItem in configurationSetsItem.SshSettings.PublicKeys)
                                    {
                                        XElement publicKeyElement = new XElement(XName.Get("PublicKey", "http://schemas.microsoft.com/windowsazure"));
                                        publicKeysSequenceElement.Add(publicKeyElement);
                                        
                                        XElement fingerPrintElement = new XElement(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                        fingerPrintElement.Value = publicKeysItem.Fingerprint;
                                        publicKeyElement.Add(fingerPrintElement);
                                        
                                        XElement pathElement2 = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                        pathElement2.Value = publicKeysItem.Path;
                                        publicKeyElement.Add(pathElement2);
                                    }
                                    sSHElement.Add(publicKeysSequenceElement);
                                }
                                
                                if (configurationSetsItem.SshSettings.KeyPairs != null)
                                {
                                    XElement keyPairsSequenceElement = new XElement(XName.Get("KeyPairs", "http://schemas.microsoft.com/windowsazure"));
                                    foreach (SshSettingKeyPair keyPairsItem in configurationSetsItem.SshSettings.KeyPairs)
                                    {
                                        XElement keyPairElement = new XElement(XName.Get("KeyPair", "http://schemas.microsoft.com/windowsazure"));
                                        keyPairsSequenceElement.Add(keyPairElement);
                                        
                                        XElement fingerPrintElement2 = new XElement(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                        fingerPrintElement2.Value = keyPairsItem.Fingerprint;
                                        keyPairElement.Add(fingerPrintElement2);
                                        
                                        XElement pathElement3 = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                        pathElement3.Value = keyPairsItem.Path;
                                        keyPairElement.Add(pathElement3);
                                    }
                                    sSHElement.Add(keyPairsSequenceElement);
                                }
                            }
                        }
                        roleElement.Add(configurationSetsSequenceElement);
                    }
                    
                    if (roleListItem.AvailabilitySetName != null)
                    {
                        XElement availabilitySetNameElement = new XElement(XName.Get("AvailabilitySetName", "http://schemas.microsoft.com/windowsazure"));
                        availabilitySetNameElement.Value = roleListItem.AvailabilitySetName;
                        roleElement.Add(availabilitySetNameElement);
                    }
                    
                    if (roleListItem.DataVirtualHardDisks != null)
                    {
                        XElement dataVirtualHardDisksSequenceElement = new XElement(XName.Get("DataVirtualHardDisks", "http://schemas.microsoft.com/windowsazure"));
                        foreach (DataVirtualHardDisk dataVirtualHardDisksItem in roleListItem.DataVirtualHardDisks)
                        {
                            XElement dataVirtualHardDiskElement = new XElement(XName.Get("DataVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                            dataVirtualHardDisksSequenceElement.Add(dataVirtualHardDiskElement);
                            
                            if (dataVirtualHardDisksItem.HostCaching != null)
                            {
                                XElement hostCachingElement = new XElement(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                                hostCachingElement.Value = dataVirtualHardDisksItem.HostCaching.ToString();
                                dataVirtualHardDiskElement.Add(hostCachingElement);
                            }
                            
                            if (dataVirtualHardDisksItem.DiskLabel != null)
                            {
                                XElement diskLabelElement = new XElement(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                                diskLabelElement.Value = dataVirtualHardDisksItem.DiskLabel;
                                dataVirtualHardDiskElement.Add(diskLabelElement);
                            }
                            
                            if (dataVirtualHardDisksItem.DiskName != null)
                            {
                                XElement diskNameElement = new XElement(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                                diskNameElement.Value = dataVirtualHardDisksItem.DiskName;
                                dataVirtualHardDiskElement.Add(diskNameElement);
                            }
                            
                            if (dataVirtualHardDisksItem.LogicalUnitNumber != null)
                            {
                                XElement lunElement = new XElement(XName.Get("Lun", "http://schemas.microsoft.com/windowsazure"));
                                lunElement.Value = dataVirtualHardDisksItem.LogicalUnitNumber.ToString();
                                dataVirtualHardDiskElement.Add(lunElement);
                            }
                            
                            XElement logicalDiskSizeInGBElement = new XElement(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                            logicalDiskSizeInGBElement.Value = dataVirtualHardDisksItem.LogicalDiskSizeInGB.ToString();
                            dataVirtualHardDiskElement.Add(logicalDiskSizeInGBElement);
                            
                            if (dataVirtualHardDisksItem.MediaLink != null)
                            {
                                XElement mediaLinkElement = new XElement(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                                mediaLinkElement.Value = dataVirtualHardDisksItem.MediaLink.ToString();
                                dataVirtualHardDiskElement.Add(mediaLinkElement);
                            }
                        }
                        roleElement.Add(dataVirtualHardDisksSequenceElement);
                    }
                    
                    if (roleListItem.Label != null)
                    {
                        XElement labelElement2 = new XElement(XName.Get("Label", "http://schemas.microsoft.com/windowsazure"));
                        labelElement2.Value = roleListItem.Label;
                        roleElement.Add(labelElement2);
                    }
                    
                    if (roleListItem.OSVirtualHardDisk != null)
                    {
                        XElement oSVirtualHardDiskElement = new XElement(XName.Get("OSVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                        roleElement.Add(oSVirtualHardDiskElement);
                        
                        if (roleListItem.OSVirtualHardDisk.HostCaching != null)
                        {
                            XElement hostCachingElement2 = new XElement(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                            hostCachingElement2.Value = roleListItem.OSVirtualHardDisk.HostCaching.ToString();
                            oSVirtualHardDiskElement.Add(hostCachingElement2);
                        }
                        
                        if (roleListItem.OSVirtualHardDisk.DiskLabel != null)
                        {
                            XElement diskLabelElement2 = new XElement(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                            diskLabelElement2.Value = roleListItem.OSVirtualHardDisk.DiskLabel;
                            oSVirtualHardDiskElement.Add(diskLabelElement2);
                        }
                        
                        if (roleListItem.OSVirtualHardDisk.DiskName != null)
                        {
                            XElement diskNameElement2 = new XElement(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                            diskNameElement2.Value = roleListItem.OSVirtualHardDisk.DiskName;
                            oSVirtualHardDiskElement.Add(diskNameElement2);
                        }
                        
                        if (roleListItem.OSVirtualHardDisk.MediaLink != null)
                        {
                            XElement mediaLinkElement2 = new XElement(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                            mediaLinkElement2.Value = roleListItem.OSVirtualHardDisk.MediaLink.ToString();
                            oSVirtualHardDiskElement.Add(mediaLinkElement2);
                        }
                        
                        if (roleListItem.OSVirtualHardDisk.SourceImageName != null)
                        {
                            XElement sourceImageNameElement = new XElement(XName.Get("SourceImageName", "http://schemas.microsoft.com/windowsazure"));
                            sourceImageNameElement.Value = roleListItem.OSVirtualHardDisk.SourceImageName;
                            oSVirtualHardDiskElement.Add(sourceImageNameElement);
                        }
                        
                        if (roleListItem.OSVirtualHardDisk.OperatingSystem != null)
                        {
                            XElement osElement = new XElement(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                            osElement.Value = roleListItem.OSVirtualHardDisk.OperatingSystem;
                            oSVirtualHardDiskElement.Add(osElement);
                        }
                    }
                    
                    if (roleListItem.RoleSize != null)
                    {
                        XElement roleSizeElement = new XElement(XName.Get("RoleSize", "http://schemas.microsoft.com/windowsazure"));
                        roleSizeElement.Value = roleListItem.RoleSize.ToString();
                        roleElement.Add(roleSizeElement);
                    }
                    
                    if (roleListItem.DefaultWinRmCertificateThumbprint != null)
                    {
                        XElement defaultWinRmCertificateThumbprintElement = new XElement(XName.Get("DefaultWinRmCertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                        defaultWinRmCertificateThumbprintElement.Value = roleListItem.DefaultWinRmCertificateThumbprint;
                        roleElement.Add(defaultWinRmCertificateThumbprintElement);
                    }
                }
                deploymentElement.Add(roleListSequenceElement);
                
                if (parameters.VirtualNetworkName != null)
                {
                    XElement virtualNetworkNameElement = new XElement(XName.Get("VirtualNetworkName", "http://schemas.microsoft.com/windowsazure"));
                    virtualNetworkNameElement.Value = parameters.VirtualNetworkName;
                    deploymentElement.Add(virtualNetworkNameElement);
                }
                
                if (parameters.DnsSettings != null)
                {
                    XElement dnsElement = new XElement(XName.Get("Dns", "http://schemas.microsoft.com/windowsazure"));
                    deploymentElement.Add(dnsElement);
                    
                    if (parameters.DnsSettings.DnsServers != null)
                    {
                        XElement dnsServersSequenceElement = new XElement(XName.Get("DnsServers", "http://schemas.microsoft.com/windowsazure"));
                        foreach (DnsServer dnsServersItem in parameters.DnsSettings.DnsServers)
                        {
                            XElement dnsServerElement = new XElement(XName.Get("DnsServer", "http://schemas.microsoft.com/windowsazure"));
                            dnsServersSequenceElement.Add(dnsServerElement);
                            
                            if (dnsServersItem.Name != null)
                            {
                                XElement nameElement3 = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                nameElement3.Value = dnsServersItem.Name;
                                dnsServerElement.Add(nameElement3);
                            }
                            
                            if (dnsServersItem.Address != null)
                            {
                                XElement addressElement = new XElement(XName.Get("Address", "http://schemas.microsoft.com/windowsazure"));
                                addressElement.Value = dnsServersItem.Address;
                                dnsServerElement.Add(addressElement);
                            }
                        }
                        dnsElement.Add(dnsServersSequenceElement);
                    }
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Create Virtual Machine Deployment operation provisions a
        /// virtual machine based on the supplied configuration.  When you
        /// create a deployment of a virtual machine, you should make sure
        /// that the cloud service and the disk or image that you use are
        /// located in the same region. For example, if the cloud service was
        /// created in the West US region, the disk or image that you use
        /// should also be located in a stor4age account in the West US
        /// region.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157194.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Create Virtual Machine Deployment
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> CreateDeploymentAsync(string serviceName, VirtualMachineCreateDeploymentParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "CreateDeploymentAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.VirtualMachines.BeginCreatingDeploymentAsync(serviceName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Role operation deletes the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157184.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to delete.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginDeletingAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (virtualMachineName == null)
            {
                throw new ArgumentNullException("virtualMachineName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                Tracing.Enter(invocationId, this, "BeginDeletingAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roles/" + virtualMachineName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Delete;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Delete Role operation deletes the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157184.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to delete.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> DeleteAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                Tracing.Enter(invocationId, this, "DeleteAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.VirtualMachines.BeginDeletingAsync(serviceName, deploymentName, virtualMachineName, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Download RDP file operation retrieves the Remote Desktop
        /// Protocol configuration file from the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157183.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Download RDP file operation response.
        /// </returns>
        public async Task<VirtualMachineGetRemoteDesktopFileResponse> GetRemoteDesktopFileAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (virtualMachineName == null)
            {
                throw new ArgumentNullException("virtualMachineName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                Tracing.Enter(invocationId, this, "GetRemoteDesktopFileAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roleinstances/" + virtualMachineName + "/ModelFile?FileType=RDP";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    VirtualMachineGetRemoteDesktopFileResponse result = new VirtualMachineGetRemoteDesktopFileResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    result.RemoteDesktopFile = Encoding.UTF8.GetBytes(responseContent);
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Get Role operation retrieves information about the specified
        /// virtual machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157193.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The Get Virtual Machine operation response.
        /// </returns>
        public async Task<VirtualMachineGetResponse> GetAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (virtualMachineName == null)
            {
                throw new ArgumentNullException("virtualMachineName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                Tracing.Enter(invocationId, this, "GetAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roles/" + virtualMachineName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Get;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.OK)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, null, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    VirtualMachineGetResponse result = new VirtualMachineGetResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    // Deserialize Response
                    cancellationToken.ThrowIfCancellationRequested();
                    string responseContent = await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false);
                    XDocument responseDoc = XDocument.Parse(responseContent);
                    
                    XElement persistentVMRoleElement = responseDoc.Element(XName.Get("PersistentVMRole", "http://schemas.microsoft.com/windowsazure"));
                    if (persistentVMRoleElement != null)
                    {
                        XElement roleNameElement = persistentVMRoleElement.Element(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                        if (roleNameElement != null)
                        {
                            string roleNameInstance = roleNameElement.Value;
                            result.RoleName = roleNameInstance;
                        }
                        
                        XElement osVersionElement = persistentVMRoleElement.Element(XName.Get("OsVersion", "http://schemas.microsoft.com/windowsazure"));
                        if (osVersionElement != null)
                        {
                            string osVersionInstance = osVersionElement.Value;
                            result.OsVersion = osVersionInstance;
                        }
                        
                        XElement roleTypeElement = persistentVMRoleElement.Element(XName.Get("RoleType", "http://schemas.microsoft.com/windowsazure"));
                        if (roleTypeElement != null)
                        {
                            VirtualMachineRoleType roleTypeInstance = (VirtualMachineRoleType)Enum.Parse(typeof(VirtualMachineRoleType), roleTypeElement.Value, false);
                            result.RoleType = roleTypeInstance;
                        }
                        
                        XElement availabilitySetNameElement = persistentVMRoleElement.Element(XName.Get("AvailabilitySetName", "http://schemas.microsoft.com/windowsazure"));
                        if (availabilitySetNameElement != null)
                        {
                            string availabilitySetNameInstance = availabilitySetNameElement.Value;
                            result.AvailabilitySetName = availabilitySetNameInstance;
                        }
                        
                        XElement roleSizeElement = persistentVMRoleElement.Element(XName.Get("RoleSize", "http://schemas.microsoft.com/windowsazure"));
                        if (roleSizeElement != null)
                        {
                            VirtualMachineRoleSize roleSizeInstance = (VirtualMachineRoleSize)Enum.Parse(typeof(VirtualMachineRoleSize), roleSizeElement.Value, false);
                            result.RoleSize = roleSizeInstance;
                        }
                        
                        XElement defaultWinRmCertificateThumbprintElement = persistentVMRoleElement.Element(XName.Get("DefaultWinRmCertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                        if (defaultWinRmCertificateThumbprintElement != null)
                        {
                            string defaultWinRmCertificateThumbprintInstance = defaultWinRmCertificateThumbprintElement.Value;
                            result.DefaultWinRmCertificateThumbprint = defaultWinRmCertificateThumbprintInstance;
                        }
                        
                        XElement configurationSetsSequenceElement = persistentVMRoleElement.Element(XName.Get("ConfigurationSets", "http://schemas.microsoft.com/windowsazure"));
                        if (configurationSetsSequenceElement != null)
                        {
                            foreach (XElement configurationSetsElement in configurationSetsSequenceElement.Elements(XName.Get("ConfigurationSet", "http://schemas.microsoft.com/windowsazure")))
                            {
                                ConfigurationSet configurationSetInstance = new ConfigurationSet();
                                result.ConfigurationSets.Add(configurationSetInstance);
                                
                                XElement configurationSetTypeElement = configurationSetsElement.Element(XName.Get("ConfigurationSetType", "http://schemas.microsoft.com/windowsazure"));
                                if (configurationSetTypeElement != null)
                                {
                                    string configurationSetTypeInstance = configurationSetTypeElement.Value;
                                    configurationSetInstance.ConfigurationSetType = configurationSetTypeInstance;
                                }
                                
                                XElement inputEndpointsSequenceElement = configurationSetsElement.Element(XName.Get("InputEndpoints", "http://schemas.microsoft.com/windowsazure"));
                                if (inputEndpointsSequenceElement != null)
                                {
                                    foreach (XElement inputEndpointsElement in inputEndpointsSequenceElement.Elements(XName.Get("InputEndpoint", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        InputEndpoint inputEndpointInstance = new InputEndpoint();
                                        configurationSetInstance.InputEndpoints.Add(inputEndpointInstance);
                                        
                                        XElement loadBalancedEndpointSetNameElement = inputEndpointsElement.Element(XName.Get("LoadBalancedEndpointSetName", "http://schemas.microsoft.com/windowsazure"));
                                        if (loadBalancedEndpointSetNameElement != null)
                                        {
                                            string loadBalancedEndpointSetNameInstance = loadBalancedEndpointSetNameElement.Value;
                                            inputEndpointInstance.LoadBalancedEndpointSetName = loadBalancedEndpointSetNameInstance;
                                        }
                                        
                                        XElement localPortElement = inputEndpointsElement.Element(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                                        if (localPortElement != null && string.IsNullOrEmpty(localPortElement.Value) == false)
                                        {
                                            int localPortInstance = int.Parse(localPortElement.Value, CultureInfo.InvariantCulture);
                                            inputEndpointInstance.LocalPort = localPortInstance;
                                        }
                                        
                                        XElement nameElement = inputEndpointsElement.Element(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                        if (nameElement != null)
                                        {
                                            string nameInstance = nameElement.Value;
                                            inputEndpointInstance.Name = nameInstance;
                                        }
                                        
                                        XElement portElement = inputEndpointsElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                        if (portElement != null && string.IsNullOrEmpty(portElement.Value) == false)
                                        {
                                            int portInstance = int.Parse(portElement.Value, CultureInfo.InvariantCulture);
                                            inputEndpointInstance.Port = portInstance;
                                        }
                                        
                                        XElement loadBalancerProbeElement = inputEndpointsElement.Element(XName.Get("LoadBalancerProbe", "http://schemas.microsoft.com/windowsazure"));
                                        if (loadBalancerProbeElement != null)
                                        {
                                            LoadBalancerProbe loadBalancerProbeInstance = new LoadBalancerProbe();
                                            inputEndpointInstance.LoadBalancerProbe = loadBalancerProbeInstance;
                                            
                                            XElement pathElement = loadBalancerProbeElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                            if (pathElement != null)
                                            {
                                                string pathInstance = pathElement.Value;
                                                loadBalancerProbeInstance.Path = pathInstance;
                                            }
                                            
                                            XElement portElement2 = loadBalancerProbeElement.Element(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                            if (portElement2 != null)
                                            {
                                                int portInstance2 = int.Parse(portElement2.Value, CultureInfo.InvariantCulture);
                                                loadBalancerProbeInstance.Port = portInstance2;
                                            }
                                            
                                            XElement protocolElement = loadBalancerProbeElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                            if (protocolElement != null)
                                            {
                                                LoadBalancerProbeTransportProtocol protocolInstance = ComputeManagementClient.ParseLoadBalancerProbeTransportProtocol(protocolElement.Value);
                                                loadBalancerProbeInstance.Protocol = protocolInstance;
                                            }
                                            
                                            XElement intervalInSecondsElement = loadBalancerProbeElement.Element(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                            if (intervalInSecondsElement != null && string.IsNullOrEmpty(intervalInSecondsElement.Value) == false)
                                            {
                                                int intervalInSecondsInstance = int.Parse(intervalInSecondsElement.Value, CultureInfo.InvariantCulture);
                                                loadBalancerProbeInstance.IntervalInSeconds = intervalInSecondsInstance;
                                            }
                                            
                                            XElement timeoutInSecondsElement = loadBalancerProbeElement.Element(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                            if (timeoutInSecondsElement != null && string.IsNullOrEmpty(timeoutInSecondsElement.Value) == false)
                                            {
                                                int timeoutInSecondsInstance = int.Parse(timeoutInSecondsElement.Value, CultureInfo.InvariantCulture);
                                                loadBalancerProbeInstance.TimeoutInSeconds = timeoutInSecondsInstance;
                                            }
                                        }
                                        
                                        XElement protocolElement2 = inputEndpointsElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                        if (protocolElement2 != null)
                                        {
                                            string protocolInstance2 = protocolElement2.Value;
                                            inputEndpointInstance.Protocol = protocolInstance2;
                                        }
                                        
                                        XElement vipElement = inputEndpointsElement.Element(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                                        if (vipElement != null)
                                        {
                                            string vipInstance = vipElement.Value;
                                            inputEndpointInstance.VirtualIPAddress = vipInstance;
                                        }
                                        
                                        XElement enableDirectServerReturnElement = inputEndpointsElement.Element(XName.Get("EnableDirectServerReturn", "http://schemas.microsoft.com/windowsazure"));
                                        if (enableDirectServerReturnElement != null && string.IsNullOrEmpty(enableDirectServerReturnElement.Value) == false)
                                        {
                                            bool enableDirectServerReturnInstance = bool.Parse(enableDirectServerReturnElement.Value);
                                            inputEndpointInstance.EnableDirectServerReturn = enableDirectServerReturnInstance;
                                        }
                                        
                                        XElement accessControlListElement = inputEndpointsElement.Element(XName.Get("AccessControlList", "http://schemas.microsoft.com/windowsazure"));
                                        if (accessControlListElement != null)
                                        {
                                            AccessControlList accessControlListInstance = new AccessControlList();
                                            inputEndpointInstance.AccessControlList = accessControlListInstance;
                                            
                                            XElement rulesSequenceElement = accessControlListElement.Element(XName.Get("Rules", "http://schemas.microsoft.com/windowsazure"));
                                            if (rulesSequenceElement != null)
                                            {
                                                foreach (XElement rulesElement in rulesSequenceElement.Elements(XName.Get("Rule", "http://schemas.microsoft.com/windowsazure")))
                                                {
                                                    AccessControlListRule ruleInstance = new AccessControlListRule();
                                                    accessControlListInstance.Rules.Add(ruleInstance);
                                                    
                                                    XElement orderElement = rulesElement.Element(XName.Get("Order", "http://schemas.microsoft.com/windowsazure"));
                                                    if (orderElement != null && string.IsNullOrEmpty(orderElement.Value) == false)
                                                    {
                                                        int orderInstance = int.Parse(orderElement.Value, CultureInfo.InvariantCulture);
                                                        ruleInstance.Order = orderInstance;
                                                    }
                                                    
                                                    XElement actionElement = rulesElement.Element(XName.Get("Action", "http://schemas.microsoft.com/windowsazure"));
                                                    if (actionElement != null)
                                                    {
                                                        string actionInstance = actionElement.Value;
                                                        ruleInstance.Action = actionInstance;
                                                    }
                                                    
                                                    XElement remoteSubnetElement = rulesElement.Element(XName.Get("RemoteSubnet", "http://schemas.microsoft.com/windowsazure"));
                                                    if (remoteSubnetElement != null)
                                                    {
                                                        string remoteSubnetInstance = remoteSubnetElement.Value;
                                                        ruleInstance.RemoteSubnet = remoteSubnetInstance;
                                                    }
                                                    
                                                    XElement descriptionElement = rulesElement.Element(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                                                    if (descriptionElement != null)
                                                    {
                                                        string descriptionInstance = descriptionElement.Value;
                                                        ruleInstance.Description = descriptionInstance;
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                                
                                XElement subnetNamesSequenceElement = configurationSetsElement.Element(XName.Get("SubnetNames", "http://schemas.microsoft.com/windowsazure"));
                                if (subnetNamesSequenceElement != null)
                                {
                                    foreach (XElement subnetNamesElement in subnetNamesSequenceElement.Elements(XName.Get("SubnetName", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        configurationSetInstance.SubnetNames.Add(subnetNamesElement.Value);
                                    }
                                }
                                
                                XElement computerNameElement = configurationSetsElement.Element(XName.Get("ComputerName", "http://schemas.microsoft.com/windowsazure"));
                                if (computerNameElement != null)
                                {
                                    string computerNameInstance = computerNameElement.Value;
                                    configurationSetInstance.ComputerName = computerNameInstance;
                                }
                                
                                XElement adminPasswordElement = configurationSetsElement.Element(XName.Get("AdminPassword", "http://schemas.microsoft.com/windowsazure"));
                                if (adminPasswordElement != null)
                                {
                                    string adminPasswordInstance = adminPasswordElement.Value;
                                    configurationSetInstance.AdminPassword = adminPasswordInstance;
                                }
                                
                                XElement resetPasswordOnFirstLogonElement = configurationSetsElement.Element(XName.Get("ResetPasswordOnFirstLogon", "http://schemas.microsoft.com/windowsazure"));
                                if (resetPasswordOnFirstLogonElement != null && string.IsNullOrEmpty(resetPasswordOnFirstLogonElement.Value) == false)
                                {
                                    bool resetPasswordOnFirstLogonInstance = bool.Parse(resetPasswordOnFirstLogonElement.Value);
                                    configurationSetInstance.ResetPasswordOnFirstLogon = resetPasswordOnFirstLogonInstance;
                                }
                                
                                XElement enableAutomaticUpdatesElement = configurationSetsElement.Element(XName.Get("EnableAutomaticUpdates", "http://schemas.microsoft.com/windowsazure"));
                                if (enableAutomaticUpdatesElement != null && string.IsNullOrEmpty(enableAutomaticUpdatesElement.Value) == false)
                                {
                                    bool enableAutomaticUpdatesInstance = bool.Parse(enableAutomaticUpdatesElement.Value);
                                    configurationSetInstance.EnableAutomaticUpdates = enableAutomaticUpdatesInstance;
                                }
                                
                                XElement timeZoneElement = configurationSetsElement.Element(XName.Get("TimeZone", "http://schemas.microsoft.com/windowsazure"));
                                if (timeZoneElement != null)
                                {
                                    string timeZoneInstance = timeZoneElement.Value;
                                    configurationSetInstance.TimeZone = timeZoneInstance;
                                }
                                
                                XElement domainJoinElement = configurationSetsElement.Element(XName.Get("DomainJoin", "http://schemas.microsoft.com/windowsazure"));
                                if (domainJoinElement != null)
                                {
                                    DomainJoinSettings domainJoinInstance = new DomainJoinSettings();
                                    configurationSetInstance.DomainJoin = domainJoinInstance;
                                    
                                    XElement credentialsElement = domainJoinElement.Element(XName.Get("Credentials", "http://schemas.microsoft.com/windowsazure"));
                                    if (credentialsElement != null)
                                    {
                                        DomainJoinCredentials credentialsInstance = new DomainJoinCredentials();
                                        domainJoinInstance.Credentials = credentialsInstance;
                                        
                                        XElement domainElement = credentialsElement.Element(XName.Get("Domain", "http://schemas.microsoft.com/windowsazure"));
                                        if (domainElement != null)
                                        {
                                            string domainInstance = domainElement.Value;
                                            credentialsInstance.Domain = domainInstance;
                                        }
                                        
                                        XElement usernameElement = credentialsElement.Element(XName.Get("Username", "http://schemas.microsoft.com/windowsazure"));
                                        if (usernameElement != null)
                                        {
                                            string usernameInstance = usernameElement.Value;
                                            credentialsInstance.UserName = usernameInstance;
                                        }
                                        
                                        XElement passwordElement = credentialsElement.Element(XName.Get("Password", "http://schemas.microsoft.com/windowsazure"));
                                        if (passwordElement != null)
                                        {
                                            string passwordInstance = passwordElement.Value;
                                            credentialsInstance.Password = passwordInstance;
                                        }
                                    }
                                    
                                    XElement joinDomainElement = domainJoinElement.Element(XName.Get("JoinDomain", "http://schemas.microsoft.com/windowsazure"));
                                    if (joinDomainElement != null)
                                    {
                                        string joinDomainInstance = joinDomainElement.Value;
                                        domainJoinInstance.DomainToJoin = joinDomainInstance;
                                    }
                                    
                                    XElement machineObjectOUElement = domainJoinElement.Element(XName.Get("MachineObjectOU", "http://schemas.microsoft.com/windowsazure"));
                                    if (machineObjectOUElement != null)
                                    {
                                        string machineObjectOUInstance = machineObjectOUElement.Value;
                                        domainJoinInstance.LdapMachineObjectOU = machineObjectOUInstance;
                                    }
                                    
                                    XElement provisioningElement = domainJoinElement.Element(XName.Get("Provisioning", "http://schemas.microsoft.com/windowsazure"));
                                    if (provisioningElement != null)
                                    {
                                        DomainJoinProvisioning provisioningInstance = new DomainJoinProvisioning();
                                        domainJoinInstance.Provisioning = provisioningInstance;
                                        
                                        XElement accountDataElement = provisioningElement.Element(XName.Get("AccountData", "http://schemas.microsoft.com/windowsazure"));
                                        if (accountDataElement != null)
                                        {
                                            string accountDataInstance = accountDataElement.Value;
                                            provisioningInstance.AccountData = accountDataInstance;
                                        }
                                    }
                                }
                                
                                XElement storedCertificateSettingsSequenceElement = configurationSetsElement.Element(XName.Get("StoredCertificateSettings", "http://schemas.microsoft.com/windowsazure"));
                                if (storedCertificateSettingsSequenceElement != null)
                                {
                                    foreach (XElement storedCertificateSettingsElement in storedCertificateSettingsSequenceElement.Elements(XName.Get("CertificateSetting", "http://schemas.microsoft.com/windowsazure")))
                                    {
                                        StoredCertificateSettings certificateSettingInstance = new StoredCertificateSettings();
                                        configurationSetInstance.StoredCertificateSettings.Add(certificateSettingInstance);
                                        
                                        XElement storeLocationElement = storedCertificateSettingsElement.Element(XName.Get("StoreLocation", "http://schemas.microsoft.com/windowsazure"));
                                        if (storeLocationElement != null)
                                        {
                                        }
                                        
                                        XElement storeNameElement = storedCertificateSettingsElement.Element(XName.Get("StoreName", "http://schemas.microsoft.com/windowsazure"));
                                        if (storeNameElement != null)
                                        {
                                            string storeNameInstance = storeNameElement.Value;
                                            certificateSettingInstance.StoreName = storeNameInstance;
                                        }
                                        
                                        XElement thumbprintElement = storedCertificateSettingsElement.Element(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                                        if (thumbprintElement != null)
                                        {
                                            string thumbprintInstance = thumbprintElement.Value;
                                            certificateSettingInstance.Thumbprint = thumbprintInstance;
                                        }
                                    }
                                }
                                
                                XElement winRMElement = configurationSetsElement.Element(XName.Get("WinRM", "http://schemas.microsoft.com/windowsazure"));
                                if (winRMElement != null)
                                {
                                    WindowsRemoteManagementSettings winRMInstance = new WindowsRemoteManagementSettings();
                                    configurationSetInstance.WindowsRemoteManagement = winRMInstance;
                                    
                                    XElement listenersSequenceElement = winRMElement.Element(XName.Get("Listeners", "http://schemas.microsoft.com/windowsazure"));
                                    if (listenersSequenceElement != null)
                                    {
                                        foreach (XElement listenersElement in listenersSequenceElement.Elements(XName.Get("Listener", "http://schemas.microsoft.com/windowsazure")))
                                        {
                                            WindowsRemoteManagementListener listenerInstance = new WindowsRemoteManagementListener();
                                            winRMInstance.Listeners.Add(listenerInstance);
                                            
                                            XElement protocolElement3 = listenersElement.Element(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                            if (protocolElement3 != null)
                                            {
                                                VirtualMachineWindowsRemoteManagementListenerType protocolInstance3 = (VirtualMachineWindowsRemoteManagementListenerType)Enum.Parse(typeof(VirtualMachineWindowsRemoteManagementListenerType), protocolElement3.Value, false);
                                                listenerInstance.ListenerType = protocolInstance3;
                                            }
                                            
                                            XElement certificateThumbprintElement = listenersElement.Element(XName.Get("CertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                            if (certificateThumbprintElement != null)
                                            {
                                                string certificateThumbprintInstance = certificateThumbprintElement.Value;
                                                listenerInstance.CertificateThumbprint = certificateThumbprintInstance;
                                            }
                                        }
                                    }
                                }
                                
                                XElement adminUsernameElement = configurationSetsElement.Element(XName.Get("AdminUsername", "http://schemas.microsoft.com/windowsazure"));
                                if (adminUsernameElement != null)
                                {
                                    string adminUsernameInstance = adminUsernameElement.Value;
                                    configurationSetInstance.AdminUserName = adminUsernameInstance;
                                }
                                
                                XElement hostNameElement = configurationSetsElement.Element(XName.Get("HostName", "http://schemas.microsoft.com/windowsazure"));
                                if (hostNameElement != null)
                                {
                                    string hostNameInstance = hostNameElement.Value;
                                    configurationSetInstance.HostName = hostNameInstance;
                                }
                                
                                XElement userNameElement = configurationSetsElement.Element(XName.Get("UserName", "http://schemas.microsoft.com/windowsazure"));
                                if (userNameElement != null)
                                {
                                    string userNameInstance = userNameElement.Value;
                                    configurationSetInstance.UserName = userNameInstance;
                                }
                                
                                XElement userPasswordElement = configurationSetsElement.Element(XName.Get("UserPassword", "http://schemas.microsoft.com/windowsazure"));
                                if (userPasswordElement != null)
                                {
                                    string userPasswordInstance = userPasswordElement.Value;
                                    configurationSetInstance.UserPassword = userPasswordInstance;
                                }
                                
                                XElement disableSshPasswordAuthenticationElement = configurationSetsElement.Element(XName.Get("DisableSshPasswordAuthentication", "http://schemas.microsoft.com/windowsazure"));
                                if (disableSshPasswordAuthenticationElement != null && string.IsNullOrEmpty(disableSshPasswordAuthenticationElement.Value) == false)
                                {
                                    bool disableSshPasswordAuthenticationInstance = bool.Parse(disableSshPasswordAuthenticationElement.Value);
                                    configurationSetInstance.DisableSshPasswordAuthentication = disableSshPasswordAuthenticationInstance;
                                }
                                
                                XElement sSHElement = configurationSetsElement.Element(XName.Get("SSH", "http://schemas.microsoft.com/windowsazure"));
                                if (sSHElement != null)
                                {
                                    SshSettings sSHInstance = new SshSettings();
                                    configurationSetInstance.SshSettings = sSHInstance;
                                    
                                    XElement publicKeysSequenceElement = sSHElement.Element(XName.Get("PublicKeys", "http://schemas.microsoft.com/windowsazure"));
                                    if (publicKeysSequenceElement != null)
                                    {
                                        foreach (XElement publicKeysElement in publicKeysSequenceElement.Elements(XName.Get("PublicKey", "http://schemas.microsoft.com/windowsazure")))
                                        {
                                            SshSettingPublicKey publicKeyInstance = new SshSettingPublicKey();
                                            sSHInstance.PublicKeys.Add(publicKeyInstance);
                                            
                                            XElement fingerPrintElement = publicKeysElement.Element(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                            if (fingerPrintElement != null)
                                            {
                                                string fingerPrintInstance = fingerPrintElement.Value;
                                                publicKeyInstance.Fingerprint = fingerPrintInstance;
                                            }
                                            
                                            XElement pathElement2 = publicKeysElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                            if (pathElement2 != null)
                                            {
                                                string pathInstance2 = pathElement2.Value;
                                                publicKeyInstance.Path = pathInstance2;
                                            }
                                        }
                                    }
                                    
                                    XElement keyPairsSequenceElement = sSHElement.Element(XName.Get("KeyPairs", "http://schemas.microsoft.com/windowsazure"));
                                    if (keyPairsSequenceElement != null)
                                    {
                                        foreach (XElement keyPairsElement in keyPairsSequenceElement.Elements(XName.Get("KeyPair", "http://schemas.microsoft.com/windowsazure")))
                                        {
                                            SshSettingKeyPair keyPairInstance = new SshSettingKeyPair();
                                            sSHInstance.KeyPairs.Add(keyPairInstance);
                                            
                                            XElement fingerPrintElement2 = keyPairsElement.Element(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                            if (fingerPrintElement2 != null)
                                            {
                                                string fingerPrintInstance2 = fingerPrintElement2.Value;
                                                keyPairInstance.Fingerprint = fingerPrintInstance2;
                                            }
                                            
                                            XElement pathElement3 = keyPairsElement.Element(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                            if (pathElement3 != null)
                                            {
                                                string pathInstance3 = pathElement3.Value;
                                                keyPairInstance.Path = pathInstance3;
                                            }
                                        }
                                    }
                                }
                            }
                        }
                        
                        XElement dataVirtualHardDisksSequenceElement = persistentVMRoleElement.Element(XName.Get("DataVirtualHardDisks", "http://schemas.microsoft.com/windowsazure"));
                        if (dataVirtualHardDisksSequenceElement != null)
                        {
                            foreach (XElement dataVirtualHardDisksElement in dataVirtualHardDisksSequenceElement.Elements(XName.Get("DataVirtualHardDisk", "http://schemas.microsoft.com/windowsazure")))
                            {
                                DataVirtualHardDisk dataVirtualHardDiskInstance = new DataVirtualHardDisk();
                                result.DataVirtualHardDisks.Add(dataVirtualHardDiskInstance);
                                
                                XElement hostCachingElement = dataVirtualHardDisksElement.Element(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                                if (hostCachingElement != null && string.IsNullOrEmpty(hostCachingElement.Value) == false)
                                {
                                    VirtualHardDiskHostCaching hostCachingInstance = (VirtualHardDiskHostCaching)Enum.Parse(typeof(VirtualHardDiskHostCaching), hostCachingElement.Value, false);
                                    dataVirtualHardDiskInstance.HostCaching = hostCachingInstance;
                                }
                                
                                XElement diskLabelElement = dataVirtualHardDisksElement.Element(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                                if (diskLabelElement != null)
                                {
                                    string diskLabelInstance = diskLabelElement.Value;
                                    dataVirtualHardDiskInstance.DiskLabel = diskLabelInstance;
                                }
                                
                                XElement diskNameElement = dataVirtualHardDisksElement.Element(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                                if (diskNameElement != null)
                                {
                                    string diskNameInstance = diskNameElement.Value;
                                    dataVirtualHardDiskInstance.DiskName = diskNameInstance;
                                }
                                
                                XElement lunElement = dataVirtualHardDisksElement.Element(XName.Get("Lun", "http://schemas.microsoft.com/windowsazure"));
                                if (lunElement != null && string.IsNullOrEmpty(lunElement.Value) == false)
                                {
                                    int lunInstance = int.Parse(lunElement.Value, CultureInfo.InvariantCulture);
                                    dataVirtualHardDiskInstance.LogicalUnitNumber = lunInstance;
                                }
                                
                                XElement logicalDiskSizeInGBElement = dataVirtualHardDisksElement.Element(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                                if (logicalDiskSizeInGBElement != null)
                                {
                                    int logicalDiskSizeInGBInstance = int.Parse(logicalDiskSizeInGBElement.Value, CultureInfo.InvariantCulture);
                                    dataVirtualHardDiskInstance.LogicalDiskSizeInGB = logicalDiskSizeInGBInstance;
                                }
                                
                                XElement mediaLinkElement = dataVirtualHardDisksElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                                if (mediaLinkElement != null)
                                {
                                    Uri mediaLinkInstance = TypeConversion.TryParseUri(mediaLinkElement.Value);
                                    dataVirtualHardDiskInstance.MediaLink = mediaLinkInstance;
                                }
                            }
                        }
                        
                        XElement oSVirtualHardDiskElement = persistentVMRoleElement.Element(XName.Get("OSVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                        if (oSVirtualHardDiskElement != null)
                        {
                            OSVirtualHardDisk oSVirtualHardDiskInstance = new OSVirtualHardDisk();
                            result.OSVirtualHardDisk = oSVirtualHardDiskInstance;
                            
                            XElement hostCachingElement2 = oSVirtualHardDiskElement.Element(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                            if (hostCachingElement2 != null && string.IsNullOrEmpty(hostCachingElement2.Value) == false)
                            {
                                VirtualHardDiskHostCaching hostCachingInstance2 = (VirtualHardDiskHostCaching)Enum.Parse(typeof(VirtualHardDiskHostCaching), hostCachingElement2.Value, false);
                                oSVirtualHardDiskInstance.HostCaching = hostCachingInstance2;
                            }
                            
                            XElement diskLabelElement2 = oSVirtualHardDiskElement.Element(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                            if (diskLabelElement2 != null)
                            {
                                string diskLabelInstance2 = diskLabelElement2.Value;
                                oSVirtualHardDiskInstance.DiskLabel = diskLabelInstance2;
                            }
                            
                            XElement diskNameElement2 = oSVirtualHardDiskElement.Element(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                            if (diskNameElement2 != null)
                            {
                                string diskNameInstance2 = diskNameElement2.Value;
                                oSVirtualHardDiskInstance.DiskName = diskNameInstance2;
                            }
                            
                            XElement mediaLinkElement2 = oSVirtualHardDiskElement.Element(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                            if (mediaLinkElement2 != null)
                            {
                                Uri mediaLinkInstance2 = TypeConversion.TryParseUri(mediaLinkElement2.Value);
                                oSVirtualHardDiskInstance.MediaLink = mediaLinkInstance2;
                            }
                            
                            XElement sourceImageNameElement = oSVirtualHardDiskElement.Element(XName.Get("SourceImageName", "http://schemas.microsoft.com/windowsazure"));
                            if (sourceImageNameElement != null)
                            {
                                string sourceImageNameInstance = sourceImageNameElement.Value;
                                oSVirtualHardDiskInstance.SourceImageName = sourceImageNameInstance;
                            }
                            
                            XElement osElement = oSVirtualHardDiskElement.Element(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                            if (osElement != null)
                            {
                                string osInstance = osElement.Value;
                                oSVirtualHardDiskInstance.OperatingSystem = osInstance;
                            }
                        }
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Restart role operation restarts the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157197.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginRestartingAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (virtualMachineName == null)
            {
                throw new ArgumentNullException("virtualMachineName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                Tracing.Enter(invocationId, this, "BeginRestartingAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roleinstances/" + virtualMachineName + "/Operations";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                requestContent = "<RestartRoleOperation xmlns=\"http://schemas.microsoft.com/windowsazure\"><OperationType>RestartRoleOperation</OperationType></RestartRoleOperation>";
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Restart role operation restarts the specified virtual machine.
        /// (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157197.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to restart.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> RestartAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                Tracing.Enter(invocationId, this, "RestartAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.VirtualMachines.BeginRestartingAsync(serviceName, deploymentName, virtualMachineName, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Shutdown Role operation shuts down the specified virtual
        /// machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157195.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to shutdown.
        /// </param>
        /// <param name='parameters'>
        /// The parameters for the shutdown vm operation
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginShutdownAsync(string serviceName, string deploymentName, string virtualMachineName, VirtualMachineShutdownParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (virtualMachineName == null)
            {
                throw new ArgumentNullException("virtualMachineName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginShutdownAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roleinstances/" + virtualMachineName + "/Operations";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement shutdownRoleOperationElement = new XElement(XName.Get("ShutdownRoleOperation", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(shutdownRoleOperationElement);
                
                XElement operationTypeElement = new XElement(XName.Get("OperationType", "http://schemas.microsoft.com/windowsazure"));
                operationTypeElement.Value = "ShutdownRoleOperation";
                shutdownRoleOperationElement.Add(operationTypeElement);
                
                XElement postShutdownActionElement = new XElement(XName.Get("PostShutdownAction", "http://schemas.microsoft.com/windowsazure"));
                postShutdownActionElement.Value = parameters.PostShutdownAction.ToString();
                shutdownRoleOperationElement.Add(postShutdownActionElement);
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Shutdown Role operation shuts down the specified virtual
        /// machine.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157195.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to shutdown.
        /// </param>
        /// <param name='parameters'>
        /// The parameters for the shutdown vm operation
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> ShutdownAsync(string serviceName, string deploymentName, string virtualMachineName, VirtualMachineShutdownParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "ShutdownAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.VirtualMachines.BeginShutdownAsync(serviceName, deploymentName, virtualMachineName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Shutdown Roles operation stops the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to shutdown and their post
        /// shutdown state.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginShuttingDownRolesAsync(string serviceName, string deploymentName, VirtualMachineShutdownRolesParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginShuttingDownRolesAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/Roles/Operations";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement shutdownRolesOperationElement = new XElement(XName.Get("ShutdownRolesOperation", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(shutdownRolesOperationElement);
                
                XElement operationTypeElement = new XElement(XName.Get("OperationType", "http://schemas.microsoft.com/windowsazure"));
                operationTypeElement.Value = "ShutdownRolesOperation";
                shutdownRolesOperationElement.Add(operationTypeElement);
                
                if (parameters.Roles != null)
                {
                    XElement rolesSequenceElement = new XElement(XName.Get("Roles", "http://schemas.microsoft.com/windowsazure"));
                    foreach (string rolesItem in parameters.Roles)
                    {
                        XElement rolesItemElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        rolesItemElement.Value = rolesItem;
                        rolesSequenceElement.Add(rolesItemElement);
                    }
                    shutdownRolesOperationElement.Add(rolesSequenceElement);
                }
                
                if (parameters.PostShutdownAction != null)
                {
                    XElement postShutdownActionElement = new XElement(XName.Get("PostShutdownAction", "http://schemas.microsoft.com/windowsazure"));
                    postShutdownActionElement.Value = parameters.PostShutdownAction.ToString();
                    shutdownRolesOperationElement.Add(postShutdownActionElement);
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Shutdown Roles operation stops the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to shutdown and their post
        /// shutdown state.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> ShutdownRolesAsync(string serviceName, string deploymentName, VirtualMachineShutdownRolesParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "ShutdownRolesAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.VirtualMachines.BeginShuttingDownRolesAsync(serviceName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Start Role operation starts the specified virtual machine.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/jj157189.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to start.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginStartingAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (virtualMachineName == null)
            {
                throw new ArgumentNullException("virtualMachineName");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                Tracing.Enter(invocationId, this, "BeginStartingAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roleinstances/" + virtualMachineName + "/Operations";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                requestContent = "<StartRoleOperation xmlns=\"http://schemas.microsoft.com/windowsazure\"><OperationType>StartRoleOperation</OperationType></StartRoleOperation>";
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Start Role operation starts the specified virtual machine.
        /// (see http://msdn.microsoft.com/en-us/library/windowsazure/jj157189.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of the virtual machine to start.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> StartAsync(string serviceName, string deploymentName, string virtualMachineName, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                Tracing.Enter(invocationId, this, "StartAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.VirtualMachines.BeginStartingAsync(serviceName, deploymentName, virtualMachineName, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Start Roles operation starts the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to start.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginStartingRolesAsync(string serviceName, string deploymentName, VirtualMachineStartRolesParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginStartingRolesAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/Roles/Operations";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement startRolesOperationElement = new XElement(XName.Get("StartRolesOperation", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(startRolesOperationElement);
                
                XElement operationTypeElement = new XElement(XName.Get("OperationType", "http://schemas.microsoft.com/windowsazure"));
                operationTypeElement.Value = "StartRolesOperation";
                startRolesOperationElement.Add(operationTypeElement);
                
                if (parameters.Roles != null)
                {
                    XElement rolesSequenceElement = new XElement(XName.Get("Roles", "http://schemas.microsoft.com/windowsazure"));
                    foreach (string rolesItem in parameters.Roles)
                    {
                        XElement rolesItemElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                        rolesItemElement.Value = rolesItem;
                        rolesSequenceElement.Add(rolesItemElement);
                    }
                    startRolesOperationElement.Add(rolesSequenceElement);
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Start Roles operation starts the specified set of virtual
        /// machines.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// The set of virtual machine roles to start.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> StartRolesAsync(string serviceName, string deploymentName, VirtualMachineStartRolesParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "StartRolesAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.VirtualMachines.BeginStartingRolesAsync(serviceName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Update Role operation adds a virtual machine to an existing
        /// deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157187.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of your virtual machine.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginUpdatingAsync(string serviceName, string deploymentName, string virtualMachineName, VirtualMachineUpdateParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (virtualMachineName == null)
            {
                throw new ArgumentNullException("virtualMachineName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            if (parameters.RoleName == null)
            {
                throw new ArgumentNullException("parameters.RoleName");
            }
            foreach (ConfigurationSet configurationSetsParameterItem in parameters.ConfigurationSets)
            {
                if (configurationSetsParameterItem.DomainJoin != null)
                {
                    if (configurationSetsParameterItem.DomainJoin.Credentials != null)
                    {
                        if (configurationSetsParameterItem.DomainJoin.Credentials.UserName == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.DomainJoin.Credentials.UserName");
                        }
                        if (configurationSetsParameterItem.DomainJoin.Credentials.Password == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.DomainJoin.Credentials.Password");
                        }
                    }
                }
                foreach (StoredCertificateSettings storedCertificateSettingsParameterItem in configurationSetsParameterItem.StoredCertificateSettings)
                {
                    if (storedCertificateSettingsParameterItem.StoreName == null)
                    {
                        throw new ArgumentNullException("parameters.ConfigurationSets.StoredCertificateSettings.StoreName");
                    }
                    if (storedCertificateSettingsParameterItem.Thumbprint == null)
                    {
                        throw new ArgumentNullException("parameters.ConfigurationSets.StoredCertificateSettings.Thumbprint");
                    }
                }
                if (configurationSetsParameterItem.HostName != null && configurationSetsParameterItem.HostName.Length < 1)
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.HostName");
                }
                if (configurationSetsParameterItem.HostName != null && configurationSetsParameterItem.HostName.Length > 64)
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.HostName");
                }
                if (configurationSetsParameterItem.UserName != null && configurationSetsParameterItem.UserName.Length < 1)
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.UserName");
                }
                if (configurationSetsParameterItem.UserName != null && configurationSetsParameterItem.UserName.Length > 32)
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.UserName");
                }
                if (configurationSetsParameterItem.UserPassword != null && configurationSetsParameterItem.UserPassword.Length < 6 && (configurationSetsParameterItem.DisableSshPasswordAuthentication == false || configurationSetsParameterItem.UserPassword.Length != 0))
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.UserPassword");
                }
                if (configurationSetsParameterItem.UserPassword != null && configurationSetsParameterItem.UserPassword.Length > 72)
                {
                    throw new ArgumentOutOfRangeException("parameters.ConfigurationSets.UserPassword");
                }
                if (configurationSetsParameterItem.SshSettings != null)
                {
                    foreach (SshSettingPublicKey publicKeysParameterItem in configurationSetsParameterItem.SshSettings.PublicKeys)
                    {
                        if (publicKeysParameterItem.Fingerprint == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.SshSettings.PublicKeys.Fingerprint");
                        }
                        if (publicKeysParameterItem.Path == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.SshSettings.PublicKeys.Path");
                        }
                    }
                    foreach (SshSettingKeyPair keyPairsParameterItem in configurationSetsParameterItem.SshSettings.KeyPairs)
                    {
                        if (keyPairsParameterItem.Fingerprint == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.SshSettings.KeyPairs.Fingerprint");
                        }
                        if (keyPairsParameterItem.Path == null)
                        {
                            throw new ArgumentNullException("parameters.ConfigurationSets.SshSettings.KeyPairs.Path");
                        }
                    }
                }
            }
            if (parameters.OSVirtualHardDisk == null)
            {
                throw new ArgumentNullException("parameters.OSVirtualHardDisk");
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginUpdatingAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "/roles/" + virtualMachineName;
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Put;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement persistentVMRoleElement = new XElement(XName.Get("PersistentVMRole", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(persistentVMRoleElement);
                
                XElement roleNameElement = new XElement(XName.Get("RoleName", "http://schemas.microsoft.com/windowsazure"));
                roleNameElement.Value = parameters.RoleName;
                persistentVMRoleElement.Add(roleNameElement);
                
                XElement roleTypeElement = new XElement(XName.Get("RoleType", "http://schemas.microsoft.com/windowsazure"));
                roleTypeElement.Value = "PersistentVMRole";
                persistentVMRoleElement.Add(roleTypeElement);
                
                if (parameters.ConfigurationSets != null)
                {
                    XElement configurationSetsSequenceElement = new XElement(XName.Get("ConfigurationSets", "http://schemas.microsoft.com/windowsazure"));
                    foreach (ConfigurationSet configurationSetsItem in parameters.ConfigurationSets)
                    {
                        XElement configurationSetElement = new XElement(XName.Get("ConfigurationSet", "http://schemas.microsoft.com/windowsazure"));
                        configurationSetsSequenceElement.Add(configurationSetElement);
                        
                        if (configurationSetsItem.ConfigurationSetType != null)
                        {
                            XElement configurationSetTypeElement = new XElement(XName.Get("ConfigurationSetType", "http://schemas.microsoft.com/windowsazure"));
                            configurationSetTypeElement.Value = configurationSetsItem.ConfigurationSetType;
                            configurationSetElement.Add(configurationSetTypeElement);
                        }
                        
                        if (configurationSetsItem.InputEndpoints != null)
                        {
                            XElement inputEndpointsSequenceElement = new XElement(XName.Get("InputEndpoints", "http://schemas.microsoft.com/windowsazure"));
                            foreach (InputEndpoint inputEndpointsItem in configurationSetsItem.InputEndpoints)
                            {
                                XElement inputEndpointElement = new XElement(XName.Get("InputEndpoint", "http://schemas.microsoft.com/windowsazure"));
                                inputEndpointsSequenceElement.Add(inputEndpointElement);
                                
                                if (inputEndpointsItem.LoadBalancedEndpointSetName != null)
                                {
                                    XElement loadBalancedEndpointSetNameElement = new XElement(XName.Get("LoadBalancedEndpointSetName", "http://schemas.microsoft.com/windowsazure"));
                                    loadBalancedEndpointSetNameElement.Value = inputEndpointsItem.LoadBalancedEndpointSetName;
                                    inputEndpointElement.Add(loadBalancedEndpointSetNameElement);
                                }
                                
                                if (inputEndpointsItem.LocalPort != null)
                                {
                                    XElement localPortElement = new XElement(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                                    localPortElement.Value = inputEndpointsItem.LocalPort.ToString();
                                    inputEndpointElement.Add(localPortElement);
                                }
                                
                                if (inputEndpointsItem.Name != null)
                                {
                                    XElement nameElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                                    nameElement.Value = inputEndpointsItem.Name;
                                    inputEndpointElement.Add(nameElement);
                                }
                                
                                if (inputEndpointsItem.Port != null)
                                {
                                    XElement portElement = new XElement(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                    portElement.Value = inputEndpointsItem.Port.ToString();
                                    inputEndpointElement.Add(portElement);
                                }
                                
                                if (inputEndpointsItem.LoadBalancerProbe != null)
                                {
                                    XElement loadBalancerProbeElement = new XElement(XName.Get("LoadBalancerProbe", "http://schemas.microsoft.com/windowsazure"));
                                    inputEndpointElement.Add(loadBalancerProbeElement);
                                    
                                    if (inputEndpointsItem.LoadBalancerProbe.Path != null)
                                    {
                                        XElement pathElement = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                        pathElement.Value = inputEndpointsItem.LoadBalancerProbe.Path;
                                        loadBalancerProbeElement.Add(pathElement);
                                    }
                                    
                                    XElement portElement2 = new XElement(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                                    portElement2.Value = inputEndpointsItem.LoadBalancerProbe.Port.ToString();
                                    loadBalancerProbeElement.Add(portElement2);
                                    
                                    XElement protocolElement = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                    protocolElement.Value = ComputeManagementClient.LoadBalancerProbeTransportProtocolToString(inputEndpointsItem.LoadBalancerProbe.Protocol);
                                    loadBalancerProbeElement.Add(protocolElement);
                                    
                                    if (inputEndpointsItem.LoadBalancerProbe.IntervalInSeconds != null)
                                    {
                                        XElement intervalInSecondsElement = new XElement(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                        intervalInSecondsElement.Value = inputEndpointsItem.LoadBalancerProbe.IntervalInSeconds.ToString();
                                        loadBalancerProbeElement.Add(intervalInSecondsElement);
                                    }
                                    
                                    if (inputEndpointsItem.LoadBalancerProbe.TimeoutInSeconds != null)
                                    {
                                        XElement timeoutInSecondsElement = new XElement(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                        timeoutInSecondsElement.Value = inputEndpointsItem.LoadBalancerProbe.TimeoutInSeconds.ToString();
                                        loadBalancerProbeElement.Add(timeoutInSecondsElement);
                                    }
                                }
                                
                                if (inputEndpointsItem.Protocol != null)
                                {
                                    XElement protocolElement2 = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                    protocolElement2.Value = inputEndpointsItem.Protocol;
                                    inputEndpointElement.Add(protocolElement2);
                                }
                                
                                if (inputEndpointsItem.VirtualIPAddress != null)
                                {
                                    XElement vipElement = new XElement(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                                    vipElement.Value = inputEndpointsItem.VirtualIPAddress;
                                    inputEndpointElement.Add(vipElement);
                                }
                                
                                if (inputEndpointsItem.EnableDirectServerReturn != null)
                                {
                                    XElement enableDirectServerReturnElement = new XElement(XName.Get("EnableDirectServerReturn", "http://schemas.microsoft.com/windowsazure"));
                                    enableDirectServerReturnElement.Value = inputEndpointsItem.EnableDirectServerReturn.ToString().ToLower();
                                    inputEndpointElement.Add(enableDirectServerReturnElement);
                                }
                                
                                if (inputEndpointsItem.AccessControlList != null)
                                {
                                    XElement accessControlListElement = new XElement(XName.Get("AccessControlList", "http://schemas.microsoft.com/windowsazure"));
                                    inputEndpointElement.Add(accessControlListElement);
                                    
                                    if (inputEndpointsItem.AccessControlList.Rules != null)
                                    {
                                        XElement rulesSequenceElement = new XElement(XName.Get("Rules", "http://schemas.microsoft.com/windowsazure"));
                                        foreach (AccessControlListRule rulesItem in inputEndpointsItem.AccessControlList.Rules)
                                        {
                                            XElement ruleElement = new XElement(XName.Get("Rule", "http://schemas.microsoft.com/windowsazure"));
                                            rulesSequenceElement.Add(ruleElement);
                                            
                                            if (rulesItem.Order != null)
                                            {
                                                XElement orderElement = new XElement(XName.Get("Order", "http://schemas.microsoft.com/windowsazure"));
                                                orderElement.Value = rulesItem.Order.ToString();
                                                ruleElement.Add(orderElement);
                                            }
                                            
                                            if (rulesItem.Action != null)
                                            {
                                                XElement actionElement = new XElement(XName.Get("Action", "http://schemas.microsoft.com/windowsazure"));
                                                actionElement.Value = rulesItem.Action;
                                                ruleElement.Add(actionElement);
                                            }
                                            
                                            if (rulesItem.RemoteSubnet != null)
                                            {
                                                XElement remoteSubnetElement = new XElement(XName.Get("RemoteSubnet", "http://schemas.microsoft.com/windowsazure"));
                                                remoteSubnetElement.Value = rulesItem.RemoteSubnet;
                                                ruleElement.Add(remoteSubnetElement);
                                            }
                                            
                                            if (rulesItem.Description != null)
                                            {
                                                XElement descriptionElement = new XElement(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                                                descriptionElement.Value = rulesItem.Description;
                                                ruleElement.Add(descriptionElement);
                                            }
                                        }
                                        accessControlListElement.Add(rulesSequenceElement);
                                    }
                                }
                            }
                            configurationSetElement.Add(inputEndpointsSequenceElement);
                        }
                        
                        if (configurationSetsItem.SubnetNames != null)
                        {
                            XElement subnetNamesSequenceElement = new XElement(XName.Get("SubnetNames", "http://schemas.microsoft.com/windowsazure"));
                            foreach (string subnetNamesItem in configurationSetsItem.SubnetNames)
                            {
                                XElement subnetNamesItemElement = new XElement(XName.Get("SubnetName", "http://schemas.microsoft.com/windowsazure"));
                                subnetNamesItemElement.Value = subnetNamesItem;
                                subnetNamesSequenceElement.Add(subnetNamesItemElement);
                            }
                            configurationSetElement.Add(subnetNamesSequenceElement);
                        }
                        
                        if (configurationSetsItem.ComputerName != null)
                        {
                            XElement computerNameElement = new XElement(XName.Get("ComputerName", "http://schemas.microsoft.com/windowsazure"));
                            computerNameElement.Value = configurationSetsItem.ComputerName;
                            configurationSetElement.Add(computerNameElement);
                        }
                        
                        if (configurationSetsItem.AdminPassword != null)
                        {
                            XElement adminPasswordElement = new XElement(XName.Get("AdminPassword", "http://schemas.microsoft.com/windowsazure"));
                            adminPasswordElement.Value = configurationSetsItem.AdminPassword;
                            configurationSetElement.Add(adminPasswordElement);
                        }
                        
                        if (configurationSetsItem.ResetPasswordOnFirstLogon != null)
                        {
                            XElement resetPasswordOnFirstLogonElement = new XElement(XName.Get("ResetPasswordOnFirstLogon", "http://schemas.microsoft.com/windowsazure"));
                            resetPasswordOnFirstLogonElement.Value = configurationSetsItem.ResetPasswordOnFirstLogon.ToString().ToLower();
                            configurationSetElement.Add(resetPasswordOnFirstLogonElement);
                        }
                        
                        if (configurationSetsItem.EnableAutomaticUpdates != null)
                        {
                            XElement enableAutomaticUpdatesElement = new XElement(XName.Get("EnableAutomaticUpdates", "http://schemas.microsoft.com/windowsazure"));
                            enableAutomaticUpdatesElement.Value = configurationSetsItem.EnableAutomaticUpdates.ToString().ToLower();
                            configurationSetElement.Add(enableAutomaticUpdatesElement);
                        }
                        
                        if (configurationSetsItem.TimeZone != null)
                        {
                            XElement timeZoneElement = new XElement(XName.Get("TimeZone", "http://schemas.microsoft.com/windowsazure"));
                            timeZoneElement.Value = configurationSetsItem.TimeZone;
                            configurationSetElement.Add(timeZoneElement);
                        }
                        
                        if (configurationSetsItem.DomainJoin != null)
                        {
                            XElement domainJoinElement = new XElement(XName.Get("DomainJoin", "http://schemas.microsoft.com/windowsazure"));
                            configurationSetElement.Add(domainJoinElement);
                            
                            if (configurationSetsItem.DomainJoin.Credentials != null)
                            {
                                XElement credentialsElement = new XElement(XName.Get("Credentials", "http://schemas.microsoft.com/windowsazure"));
                                domainJoinElement.Add(credentialsElement);
                                
                                if (configurationSetsItem.DomainJoin.Credentials.Domain != null)
                                {
                                    XElement domainElement = new XElement(XName.Get("Domain", "http://schemas.microsoft.com/windowsazure"));
                                    domainElement.Value = configurationSetsItem.DomainJoin.Credentials.Domain;
                                    credentialsElement.Add(domainElement);
                                }
                                
                                XElement usernameElement = new XElement(XName.Get("Username", "http://schemas.microsoft.com/windowsazure"));
                                usernameElement.Value = configurationSetsItem.DomainJoin.Credentials.UserName;
                                credentialsElement.Add(usernameElement);
                                
                                XElement passwordElement = new XElement(XName.Get("Password", "http://schemas.microsoft.com/windowsazure"));
                                passwordElement.Value = configurationSetsItem.DomainJoin.Credentials.Password;
                                credentialsElement.Add(passwordElement);
                            }
                            
                            if (configurationSetsItem.DomainJoin.DomainToJoin != null)
                            {
                                XElement joinDomainElement = new XElement(XName.Get("JoinDomain", "http://schemas.microsoft.com/windowsazure"));
                                joinDomainElement.Value = configurationSetsItem.DomainJoin.DomainToJoin;
                                domainJoinElement.Add(joinDomainElement);
                            }
                            
                            if (configurationSetsItem.DomainJoin.LdapMachineObjectOU != null)
                            {
                                XElement machineObjectOUElement = new XElement(XName.Get("MachineObjectOU", "http://schemas.microsoft.com/windowsazure"));
                                machineObjectOUElement.Value = configurationSetsItem.DomainJoin.LdapMachineObjectOU;
                                domainJoinElement.Add(machineObjectOUElement);
                            }
                            
                            if (configurationSetsItem.DomainJoin.Provisioning != null)
                            {
                                XElement provisioningElement = new XElement(XName.Get("Provisioning", "http://schemas.microsoft.com/windowsazure"));
                                domainJoinElement.Add(provisioningElement);
                                
                                if (configurationSetsItem.DomainJoin.Provisioning.AccountData != null)
                                {
                                    XElement accountDataElement = new XElement(XName.Get("AccountData", "http://schemas.microsoft.com/windowsazure"));
                                    accountDataElement.Value = configurationSetsItem.DomainJoin.Provisioning.AccountData;
                                    provisioningElement.Add(accountDataElement);
                                }
                            }
                        }
                        
                        if (configurationSetsItem.StoredCertificateSettings != null)
                        {
                            XElement storedCertificateSettingsSequenceElement = new XElement(XName.Get("StoredCertificateSettings", "http://schemas.microsoft.com/windowsazure"));
                            foreach (StoredCertificateSettings storedCertificateSettingsItem in configurationSetsItem.StoredCertificateSettings)
                            {
                                XElement certificateSettingElement = new XElement(XName.Get("CertificateSetting", "http://schemas.microsoft.com/windowsazure"));
                                storedCertificateSettingsSequenceElement.Add(certificateSettingElement);
                                
                                XElement storeLocationElement = new XElement(XName.Get("StoreLocation", "http://schemas.microsoft.com/windowsazure"));
                                storeLocationElement.Value = "LocalMachine";
                                certificateSettingElement.Add(storeLocationElement);
                                
                                XElement storeNameElement = new XElement(XName.Get("StoreName", "http://schemas.microsoft.com/windowsazure"));
                                storeNameElement.Value = storedCertificateSettingsItem.StoreName;
                                certificateSettingElement.Add(storeNameElement);
                                
                                XElement thumbprintElement = new XElement(XName.Get("Thumbprint", "http://schemas.microsoft.com/windowsazure"));
                                thumbprintElement.Value = storedCertificateSettingsItem.Thumbprint;
                                certificateSettingElement.Add(thumbprintElement);
                            }
                            configurationSetElement.Add(storedCertificateSettingsSequenceElement);
                        }
                        
                        if (configurationSetsItem.WindowsRemoteManagement != null)
                        {
                            XElement winRMElement = new XElement(XName.Get("WinRM", "http://schemas.microsoft.com/windowsazure"));
                            configurationSetElement.Add(winRMElement);
                            
                            if (configurationSetsItem.WindowsRemoteManagement.Listeners != null)
                            {
                                XElement listenersSequenceElement = new XElement(XName.Get("Listeners", "http://schemas.microsoft.com/windowsazure"));
                                foreach (WindowsRemoteManagementListener listenersItem in configurationSetsItem.WindowsRemoteManagement.Listeners)
                                {
                                    XElement listenerElement = new XElement(XName.Get("Listener", "http://schemas.microsoft.com/windowsazure"));
                                    listenersSequenceElement.Add(listenerElement);
                                    
                                    XElement protocolElement3 = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                                    protocolElement3.Value = listenersItem.ListenerType.ToString();
                                    listenerElement.Add(protocolElement3);
                                    
                                    if (listenersItem.CertificateThumbprint != null)
                                    {
                                        XElement certificateThumbprintElement = new XElement(XName.Get("CertificateThumbprint", "http://schemas.microsoft.com/windowsazure"));
                                        certificateThumbprintElement.Value = listenersItem.CertificateThumbprint;
                                        listenerElement.Add(certificateThumbprintElement);
                                    }
                                }
                                winRMElement.Add(listenersSequenceElement);
                            }
                        }
                        
                        if (configurationSetsItem.AdminUserName != null)
                        {
                            XElement adminUsernameElement = new XElement(XName.Get("AdminUsername", "http://schemas.microsoft.com/windowsazure"));
                            adminUsernameElement.Value = configurationSetsItem.AdminUserName;
                            configurationSetElement.Add(adminUsernameElement);
                        }
                        
                        if (configurationSetsItem.HostName != null)
                        {
                            XElement hostNameElement = new XElement(XName.Get("HostName", "http://schemas.microsoft.com/windowsazure"));
                            hostNameElement.Value = configurationSetsItem.HostName;
                            configurationSetElement.Add(hostNameElement);
                        }
                        
                        if (configurationSetsItem.UserName != null)
                        {
                            XElement userNameElement = new XElement(XName.Get("UserName", "http://schemas.microsoft.com/windowsazure"));
                            userNameElement.Value = configurationSetsItem.UserName;
                            configurationSetElement.Add(userNameElement);
                        }
                        
                        if (configurationSetsItem.UserPassword != null)
                        {
                            XElement userPasswordElement = new XElement(XName.Get("UserPassword", "http://schemas.microsoft.com/windowsazure"));
                            userPasswordElement.Value = configurationSetsItem.UserPassword;
                            configurationSetElement.Add(userPasswordElement);
                        }
                        
                        if (configurationSetsItem.DisableSshPasswordAuthentication != null)
                        {
                            XElement disableSshPasswordAuthenticationElement = new XElement(XName.Get("DisableSshPasswordAuthentication", "http://schemas.microsoft.com/windowsazure"));
                            disableSshPasswordAuthenticationElement.Value = configurationSetsItem.DisableSshPasswordAuthentication.ToString().ToLower();
                            configurationSetElement.Add(disableSshPasswordAuthenticationElement);
                        }
                        
                        if (configurationSetsItem.SshSettings != null)
                        {
                            XElement sSHElement = new XElement(XName.Get("SSH", "http://schemas.microsoft.com/windowsazure"));
                            configurationSetElement.Add(sSHElement);
                            
                            if (configurationSetsItem.SshSettings.PublicKeys != null)
                            {
                                XElement publicKeysSequenceElement = new XElement(XName.Get("PublicKeys", "http://schemas.microsoft.com/windowsazure"));
                                foreach (SshSettingPublicKey publicKeysItem in configurationSetsItem.SshSettings.PublicKeys)
                                {
                                    XElement publicKeyElement = new XElement(XName.Get("PublicKey", "http://schemas.microsoft.com/windowsazure"));
                                    publicKeysSequenceElement.Add(publicKeyElement);
                                    
                                    XElement fingerPrintElement = new XElement(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                    fingerPrintElement.Value = publicKeysItem.Fingerprint;
                                    publicKeyElement.Add(fingerPrintElement);
                                    
                                    XElement pathElement2 = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                    pathElement2.Value = publicKeysItem.Path;
                                    publicKeyElement.Add(pathElement2);
                                }
                                sSHElement.Add(publicKeysSequenceElement);
                            }
                            
                            if (configurationSetsItem.SshSettings.KeyPairs != null)
                            {
                                XElement keyPairsSequenceElement = new XElement(XName.Get("KeyPairs", "http://schemas.microsoft.com/windowsazure"));
                                foreach (SshSettingKeyPair keyPairsItem in configurationSetsItem.SshSettings.KeyPairs)
                                {
                                    XElement keyPairElement = new XElement(XName.Get("KeyPair", "http://schemas.microsoft.com/windowsazure"));
                                    keyPairsSequenceElement.Add(keyPairElement);
                                    
                                    XElement fingerPrintElement2 = new XElement(XName.Get("FingerPrint", "http://schemas.microsoft.com/windowsazure"));
                                    fingerPrintElement2.Value = keyPairsItem.Fingerprint;
                                    keyPairElement.Add(fingerPrintElement2);
                                    
                                    XElement pathElement3 = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                    pathElement3.Value = keyPairsItem.Path;
                                    keyPairElement.Add(pathElement3);
                                }
                                sSHElement.Add(keyPairsSequenceElement);
                            }
                        }
                    }
                    persistentVMRoleElement.Add(configurationSetsSequenceElement);
                }
                
                if (parameters.AvailabilitySetName != null)
                {
                    XElement availabilitySetNameElement = new XElement(XName.Get("AvailabilitySetName", "http://schemas.microsoft.com/windowsazure"));
                    availabilitySetNameElement.Value = parameters.AvailabilitySetName;
                    persistentVMRoleElement.Add(availabilitySetNameElement);
                }
                
                if (parameters.DataVirtualHardDisks != null)
                {
                    XElement dataVirtualHardDisksSequenceElement = new XElement(XName.Get("DataVirtualHardDisks", "http://schemas.microsoft.com/windowsazure"));
                    foreach (DataVirtualHardDisk dataVirtualHardDisksItem in parameters.DataVirtualHardDisks)
                    {
                        XElement dataVirtualHardDiskElement = new XElement(XName.Get("DataVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                        dataVirtualHardDisksSequenceElement.Add(dataVirtualHardDiskElement);
                        
                        if (dataVirtualHardDisksItem.HostCaching != null)
                        {
                            XElement hostCachingElement = new XElement(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                            hostCachingElement.Value = dataVirtualHardDisksItem.HostCaching.ToString();
                            dataVirtualHardDiskElement.Add(hostCachingElement);
                        }
                        
                        if (dataVirtualHardDisksItem.DiskLabel != null)
                        {
                            XElement diskLabelElement = new XElement(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                            diskLabelElement.Value = dataVirtualHardDisksItem.DiskLabel;
                            dataVirtualHardDiskElement.Add(diskLabelElement);
                        }
                        
                        if (dataVirtualHardDisksItem.DiskName != null)
                        {
                            XElement diskNameElement = new XElement(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                            diskNameElement.Value = dataVirtualHardDisksItem.DiskName;
                            dataVirtualHardDiskElement.Add(diskNameElement);
                        }
                        
                        if (dataVirtualHardDisksItem.LogicalUnitNumber != null)
                        {
                            XElement lunElement = new XElement(XName.Get("Lun", "http://schemas.microsoft.com/windowsazure"));
                            lunElement.Value = dataVirtualHardDisksItem.LogicalUnitNumber.ToString();
                            dataVirtualHardDiskElement.Add(lunElement);
                        }
                        
                        XElement logicalDiskSizeInGBElement = new XElement(XName.Get("LogicalDiskSizeInGB", "http://schemas.microsoft.com/windowsazure"));
                        logicalDiskSizeInGBElement.Value = dataVirtualHardDisksItem.LogicalDiskSizeInGB.ToString();
                        dataVirtualHardDiskElement.Add(logicalDiskSizeInGBElement);
                        
                        if (dataVirtualHardDisksItem.MediaLink != null)
                        {
                            XElement mediaLinkElement = new XElement(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                            mediaLinkElement.Value = dataVirtualHardDisksItem.MediaLink.ToString();
                            dataVirtualHardDiskElement.Add(mediaLinkElement);
                        }
                    }
                    persistentVMRoleElement.Add(dataVirtualHardDisksSequenceElement);
                }
                
                XElement oSVirtualHardDiskElement = new XElement(XName.Get("OSVirtualHardDisk", "http://schemas.microsoft.com/windowsazure"));
                persistentVMRoleElement.Add(oSVirtualHardDiskElement);
                
                if (parameters.OSVirtualHardDisk.HostCaching != null)
                {
                    XElement hostCachingElement2 = new XElement(XName.Get("HostCaching", "http://schemas.microsoft.com/windowsazure"));
                    hostCachingElement2.Value = parameters.OSVirtualHardDisk.HostCaching.ToString();
                    oSVirtualHardDiskElement.Add(hostCachingElement2);
                }
                
                if (parameters.OSVirtualHardDisk.DiskLabel != null)
                {
                    XElement diskLabelElement2 = new XElement(XName.Get("DiskLabel", "http://schemas.microsoft.com/windowsazure"));
                    diskLabelElement2.Value = parameters.OSVirtualHardDisk.DiskLabel;
                    oSVirtualHardDiskElement.Add(diskLabelElement2);
                }
                
                if (parameters.OSVirtualHardDisk.DiskName != null)
                {
                    XElement diskNameElement2 = new XElement(XName.Get("DiskName", "http://schemas.microsoft.com/windowsazure"));
                    diskNameElement2.Value = parameters.OSVirtualHardDisk.DiskName;
                    oSVirtualHardDiskElement.Add(diskNameElement2);
                }
                
                if (parameters.OSVirtualHardDisk.MediaLink != null)
                {
                    XElement mediaLinkElement2 = new XElement(XName.Get("MediaLink", "http://schemas.microsoft.com/windowsazure"));
                    mediaLinkElement2.Value = parameters.OSVirtualHardDisk.MediaLink.ToString();
                    oSVirtualHardDiskElement.Add(mediaLinkElement2);
                }
                
                if (parameters.OSVirtualHardDisk.SourceImageName != null)
                {
                    XElement sourceImageNameElement = new XElement(XName.Get("SourceImageName", "http://schemas.microsoft.com/windowsazure"));
                    sourceImageNameElement.Value = parameters.OSVirtualHardDisk.SourceImageName;
                    oSVirtualHardDiskElement.Add(sourceImageNameElement);
                }
                
                if (parameters.OSVirtualHardDisk.OperatingSystem != null)
                {
                    XElement osElement = new XElement(XName.Get("OS", "http://schemas.microsoft.com/windowsazure"));
                    osElement.Value = parameters.OSVirtualHardDisk.OperatingSystem;
                    oSVirtualHardDiskElement.Add(osElement);
                }
                
                if (parameters.RoleSize != null)
                {
                    XElement roleSizeElement = new XElement(XName.Get("RoleSize", "http://schemas.microsoft.com/windowsazure"));
                    roleSizeElement.Value = parameters.RoleSize.ToString();
                    persistentVMRoleElement.Add(roleSizeElement);
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The Update Role operation adds a virtual machine to an existing
        /// deployment.  (see
        /// http://msdn.microsoft.com/en-us/library/windowsazure/jj157187.aspx
        /// for more information)
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='virtualMachineName'>
        /// The name of your virtual machine.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Virtual Machine operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> UpdateAsync(string serviceName, string deploymentName, string virtualMachineName, VirtualMachineUpdateParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("virtualMachineName", virtualMachineName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "UpdateAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.VirtualMachines.BeginUpdatingAsync(serviceName, deploymentName, virtualMachineName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The UpdateLoadBalancedEndpointSet operation changes the specified
        /// load-balanced InputEndpoints on all the roles of an Infrastructure
        /// as a Service deployment. Non load-balanced endpoints must be
        /// changed using UpdateRole.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Load Balanced Endpoint Set
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// A standard service response including an HTTP status code and
        /// request ID.
        /// </returns>
        public async Task<OperationResponse> BeginUpdatingLoadBalancedEndpointSetAsync(string serviceName, string deploymentName, VirtualMachineUpdateLoadBalancedSetParameters parameters, CancellationToken cancellationToken)
        {
            // Validate
            if (serviceName == null)
            {
                throw new ArgumentNullException("serviceName");
            }
            if (deploymentName == null)
            {
                throw new ArgumentNullException("deploymentName");
            }
            if (parameters == null)
            {
                throw new ArgumentNullException("parameters");
            }
            foreach (VirtualMachineUpdateLoadBalancedSetParameters.InputEndpoint loadBalancedEndpointsParameterItem in parameters.LoadBalancedEndpoints)
            {
                if (loadBalancedEndpointsParameterItem.LoadBalancedEndpointSetName == null)
                {
                    throw new ArgumentNullException("parameters.LoadBalancedEndpoints.LoadBalancedEndpointSetName");
                }
            }
            
            // Tracing
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "BeginUpdatingLoadBalancedEndpointSetAsync", tracingParameters);
            }
            
            // Construct URL
            string url = this.Client.BaseUri + "/" + this.Client.Credentials.SubscriptionId + "/services/hostedservices/" + serviceName + "/deployments/" + deploymentName + "?comp=UpdateLbSet";
            
            // Create HTTP transport objects
            HttpRequestMessage httpRequest = null;
            try
            {
                httpRequest = new HttpRequestMessage();
                httpRequest.Method = HttpMethod.Post;
                httpRequest.RequestUri = new Uri(url);
                
                // Set Headers
                httpRequest.Headers.Add("x-ms-version", "2013-06-01");
                
                // Set Credentials
                cancellationToken.ThrowIfCancellationRequested();
                await this.Client.Credentials.ProcessHttpRequestAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                
                // Serialize Request
                string requestContent = null;
                XDocument requestDoc = new XDocument();
                
                XElement loadBalancedEndpointListElement = new XElement(XName.Get("LoadBalancedEndpointList", "http://schemas.microsoft.com/windowsazure"));
                requestDoc.Add(loadBalancedEndpointListElement);
                
                if (parameters.LoadBalancedEndpoints != null)
                {
                    foreach (VirtualMachineUpdateLoadBalancedSetParameters.InputEndpoint loadBalancedEndpointsItem in parameters.LoadBalancedEndpoints)
                    {
                        XElement inputEndpointElement = new XElement(XName.Get("InputEndpoint", "http://schemas.microsoft.com/windowsazure"));
                        loadBalancedEndpointListElement.Add(inputEndpointElement);
                        
                        XElement loadBalancedEndpointSetNameElement = new XElement(XName.Get("LoadBalancedEndpointSetName", "http://schemas.microsoft.com/windowsazure"));
                        loadBalancedEndpointSetNameElement.Value = loadBalancedEndpointsItem.LoadBalancedEndpointSetName;
                        inputEndpointElement.Add(loadBalancedEndpointSetNameElement);
                        
                        if (loadBalancedEndpointsItem.LocalPort != null)
                        {
                            XElement localPortElement = new XElement(XName.Get("LocalPort", "http://schemas.microsoft.com/windowsazure"));
                            localPortElement.Value = loadBalancedEndpointsItem.LocalPort.ToString();
                            inputEndpointElement.Add(localPortElement);
                        }
                        
                        if (loadBalancedEndpointsItem.Name != null)
                        {
                            XElement nameElement = new XElement(XName.Get("Name", "http://schemas.microsoft.com/windowsazure"));
                            nameElement.Value = loadBalancedEndpointsItem.Name;
                            inputEndpointElement.Add(nameElement);
                        }
                        
                        if (loadBalancedEndpointsItem.Port != null)
                        {
                            XElement portElement = new XElement(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                            portElement.Value = loadBalancedEndpointsItem.Port.ToString();
                            inputEndpointElement.Add(portElement);
                        }
                        
                        if (loadBalancedEndpointsItem.LoadBalancerProbe != null)
                        {
                            XElement loadBalancerProbeElement = new XElement(XName.Get("LoadBalancerProbe", "http://schemas.microsoft.com/windowsazure"));
                            inputEndpointElement.Add(loadBalancerProbeElement);
                            
                            if (loadBalancedEndpointsItem.LoadBalancerProbe.Path != null)
                            {
                                XElement pathElement = new XElement(XName.Get("Path", "http://schemas.microsoft.com/windowsazure"));
                                pathElement.Value = loadBalancedEndpointsItem.LoadBalancerProbe.Path;
                                loadBalancerProbeElement.Add(pathElement);
                            }
                            
                            XElement portElement2 = new XElement(XName.Get("Port", "http://schemas.microsoft.com/windowsazure"));
                            portElement2.Value = loadBalancedEndpointsItem.LoadBalancerProbe.Port.ToString();
                            loadBalancerProbeElement.Add(portElement2);
                            
                            XElement protocolElement = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                            protocolElement.Value = ComputeManagementClient.LoadBalancerProbeTransportProtocolToString(loadBalancedEndpointsItem.LoadBalancerProbe.Protocol);
                            loadBalancerProbeElement.Add(protocolElement);
                            
                            if (loadBalancedEndpointsItem.LoadBalancerProbe.IntervalInSeconds != null)
                            {
                                XElement intervalInSecondsElement = new XElement(XName.Get("IntervalInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                intervalInSecondsElement.Value = loadBalancedEndpointsItem.LoadBalancerProbe.IntervalInSeconds.ToString();
                                loadBalancerProbeElement.Add(intervalInSecondsElement);
                            }
                            
                            if (loadBalancedEndpointsItem.LoadBalancerProbe.TimeoutInSeconds != null)
                            {
                                XElement timeoutInSecondsElement = new XElement(XName.Get("TimeoutInSeconds", "http://schemas.microsoft.com/windowsazure"));
                                timeoutInSecondsElement.Value = loadBalancedEndpointsItem.LoadBalancerProbe.TimeoutInSeconds.ToString();
                                loadBalancerProbeElement.Add(timeoutInSecondsElement);
                            }
                        }
                        
                        if (loadBalancedEndpointsItem.Protocol != null)
                        {
                            XElement protocolElement2 = new XElement(XName.Get("Protocol", "http://schemas.microsoft.com/windowsazure"));
                            protocolElement2.Value = loadBalancedEndpointsItem.Protocol;
                            inputEndpointElement.Add(protocolElement2);
                        }
                        
                        if (loadBalancedEndpointsItem.VirtualIPAddress != null)
                        {
                            XElement vipElement = new XElement(XName.Get("Vip", "http://schemas.microsoft.com/windowsazure"));
                            vipElement.Value = loadBalancedEndpointsItem.VirtualIPAddress;
                            inputEndpointElement.Add(vipElement);
                        }
                        
                        if (loadBalancedEndpointsItem.EnableDirectServerReturn != null)
                        {
                            XElement enableDirectServerReturnElement = new XElement(XName.Get("EnableDirectServerReturn", "http://schemas.microsoft.com/windowsazure"));
                            enableDirectServerReturnElement.Value = loadBalancedEndpointsItem.EnableDirectServerReturn.ToString().ToLower();
                            inputEndpointElement.Add(enableDirectServerReturnElement);
                        }
                        
                        XElement endpointAclElement = new XElement(XName.Get("EndpointAcl", "http://schemas.microsoft.com/windowsazure"));
                        inputEndpointElement.Add(endpointAclElement);
                        
                        if (loadBalancedEndpointsItem.Rules != null)
                        {
                            XElement rulesSequenceElement = new XElement(XName.Get("Rules", "http://schemas.microsoft.com/windowsazure"));
                            foreach (AccessControlListRule rulesItem in loadBalancedEndpointsItem.Rules)
                            {
                                XElement ruleElement = new XElement(XName.Get("Rule", "http://schemas.microsoft.com/windowsazure"));
                                rulesSequenceElement.Add(ruleElement);
                                
                                if (rulesItem.Order != null)
                                {
                                    XElement orderElement = new XElement(XName.Get("Order", "http://schemas.microsoft.com/windowsazure"));
                                    orderElement.Value = rulesItem.Order.ToString();
                                    ruleElement.Add(orderElement);
                                }
                                
                                if (rulesItem.Action != null)
                                {
                                    XElement actionElement = new XElement(XName.Get("Action", "http://schemas.microsoft.com/windowsazure"));
                                    actionElement.Value = rulesItem.Action;
                                    ruleElement.Add(actionElement);
                                }
                                
                                if (rulesItem.RemoteSubnet != null)
                                {
                                    XElement remoteSubnetElement = new XElement(XName.Get("RemoteSubnet", "http://schemas.microsoft.com/windowsazure"));
                                    remoteSubnetElement.Value = rulesItem.RemoteSubnet;
                                    ruleElement.Add(remoteSubnetElement);
                                }
                                
                                if (rulesItem.Description != null)
                                {
                                    XElement descriptionElement = new XElement(XName.Get("Description", "http://schemas.microsoft.com/windowsazure"));
                                    descriptionElement.Value = rulesItem.Description;
                                    ruleElement.Add(descriptionElement);
                                }
                            }
                            endpointAclElement.Add(rulesSequenceElement);
                        }
                    }
                }
                
                requestContent = requestDoc.ToString();
                httpRequest.Content = new StringContent(requestContent, Encoding.UTF8);
                httpRequest.Content.Headers.ContentType = new MediaTypeHeaderValue("application/xml");
                
                // Send Request
                HttpResponseMessage httpResponse = null;
                try
                {
                    if (shouldTrace)
                    {
                        Tracing.SendRequest(invocationId, httpRequest);
                    }
                    cancellationToken.ThrowIfCancellationRequested();
                    httpResponse = await this.Client.HttpClient.SendAsync(httpRequest, cancellationToken).ConfigureAwait(false);
                    if (shouldTrace)
                    {
                        Tracing.ReceiveResponse(invocationId, httpResponse);
                    }
                    HttpStatusCode statusCode = httpResponse.StatusCode;
                    if (statusCode != HttpStatusCode.Accepted)
                    {
                        cancellationToken.ThrowIfCancellationRequested();
                        CloudException ex = CloudException.CreateFromXml(httpRequest, requestContent, httpResponse, await httpResponse.Content.ReadAsStringAsync().ConfigureAwait(false));
                        if (shouldTrace)
                        {
                            Tracing.Error(invocationId, ex);
                        }
                        throw ex;
                    }
                    
                    // Create Result
                    OperationResponse result = new OperationResponse();
                    result.StatusCode = statusCode;
                    if (httpResponse.Headers.Contains("x-ms-request-id"))
                    {
                        result.RequestId = httpResponse.Headers.GetValues("x-ms-request-id").FirstOrDefault();
                    }
                    
                    if (shouldTrace)
                    {
                        Tracing.Exit(invocationId, result);
                    }
                    return result;
                }
                finally
                {
                    if (httpResponse != null)
                    {
                        httpResponse.Dispose();
                    }
                }
            }
            finally
            {
                if (httpRequest != null)
                {
                    httpRequest.Dispose();
                }
            }
        }
        
        /// <summary>
        /// The UpdateLoadBalancedEndpointSet operation changes the specified
        /// load-balanced InputEndpoints on all the roles of an Infrastructure
        /// as a Service deployment. Non load-balanced endpoints must be
        /// changed using UpdateRole.
        /// </summary>
        /// <param name='serviceName'>
        /// The name of your service.
        /// </param>
        /// <param name='deploymentName'>
        /// The name of your deployment.
        /// </param>
        /// <param name='parameters'>
        /// Parameters supplied to the Update Load Balanced Endpoint Set
        /// operation.
        /// </param>
        /// <param name='cancellationToken'>
        /// Cancellation token.
        /// </param>
        /// <returns>
        /// The response body contains the status of the specified asynchronous
        /// operation, indicating whether it has succeeded, is inprogress, or
        /// has failed. Note that this status is distinct from the HTTP status
        /// code returned for the Get Operation Status operation itself.  If
        /// the asynchronous operation succeeded, the response body includes
        /// the HTTP status code for the successful request.  If the
        /// asynchronous operation failed, the response body includes the HTTP
        /// status code for the failed request, and also includes error
        /// information regarding the failure.
        /// </returns>
        public async Task<ComputeOperationStatusResponse> UpdateLoadBalancedEndpointSetAsync(string serviceName, string deploymentName, VirtualMachineUpdateLoadBalancedSetParameters parameters, CancellationToken cancellationToken)
        {
            ComputeManagementClient client = this.Client;
            bool shouldTrace = CloudContext.Configuration.Tracing.IsEnabled;
            string invocationId = null;
            if (shouldTrace)
            {
                invocationId = Tracing.NextInvocationId.ToString();
                Dictionary<string, object> tracingParameters = new Dictionary<string, object>();
                tracingParameters.Add("serviceName", serviceName);
                tracingParameters.Add("deploymentName", deploymentName);
                tracingParameters.Add("parameters", parameters);
                Tracing.Enter(invocationId, this, "UpdateLoadBalancedEndpointSetAsync", tracingParameters);
            }
            try
            {
                if (shouldTrace)
                {
                    client = this.Client.WithHandler(new ClientRequestTrackingHandler(invocationId));
                }
                
                cancellationToken.ThrowIfCancellationRequested();
                OperationResponse originalResponse = await client.VirtualMachines.BeginUpdatingLoadBalancedEndpointSetAsync(serviceName, deploymentName, parameters, cancellationToken).ConfigureAwait(false);
                cancellationToken.ThrowIfCancellationRequested();
                ComputeOperationStatusResponse result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                int delayInSeconds = 100;
                while (result.Status == OperationStatus.InProgress)
                {
                    cancellationToken.ThrowIfCancellationRequested();
                    await TaskEx.Delay(delayInSeconds * 1000, cancellationToken).ConfigureAwait(false);
                    cancellationToken.ThrowIfCancellationRequested();
                    result = await client.GetOperationStatusAsync(originalResponse.RequestId, cancellationToken).ConfigureAwait(false);
                    delayInSeconds = 30;
                }
                
                if (shouldTrace)
                {
                    Tracing.Exit(invocationId, result);
                }
                
                return result;
            }
            finally
            {
                if (client != null && shouldTrace)
                {
                    client.Dispose();
                }
            }
        }
    }
}
