<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="DeveloperBuild" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <!-- Product properties -->
  <PropertyGroup>
    <ProductSolution>WindowsAzureLibraries.sln</ProductSolution>
    <ProductFriendlyName>Windows Azure Management Libraries</ProductFriendlyName>
    <ProductSourceFolder>$(MSBuildThisFileDirectory)src</ProductSourceFolder>
  </PropertyGroup>
  
  <!--
  NuGet Packages
  -->
  <Import Project="nuget.targets" />

  <!--
  Windows Azure Management Libraries SDK Builder Guide
  - - -

  Available Targets:

  /t:DeveloperBuild
    Builds the .NET solution using the development key pair.
    Does not drop into the binaries folder.

  /t:OfficialBuild  
    Builds officially delay signed binaries.
    Drops into the binaries\unsigned folder.

  /t:BuildPackages
    Builds NuGet packages using the binaries folder contents.
    The packages will drop to .\binaries\packages.

  /t:PublishPackages
    Publishes the built packages. You will need to include your
    publishing key when running. Include: /p:NuGetKey=YOUR_PUBLISHING_KEY 

  Targets for build servers:
  /t:NightlyBuild
  /t:ContinuousIntegrationBuild
  /t:OfficialSignedBuild

  Properties of interest:

  /p:BuildVersionSuffix=BUILD_SUFFIX  
    Inserts a string suffix value at the end of all the NuGet package versions
    built and published.

  /p:NuGetKey=NUGET_PUBLISHING_KEY
    Provides the key used to publish to a NuGet or MyGet server.

    This key should never be committed to source control.

  /p:PublishSymbolSourcePackages
    A true/false value indicating whether to push the symbol + source
    packages to a symbol server.

  /p:NuGetPublishingSource=Uri
    The NuGet Server to push packages to.

  /p:NuGetSymbolPublishingSource=Uri
    The NuGet Server to push symbol + source packages to.

  -->

  <!--
  Helpful build tasks in this tree
  -->
  <Import Project="..\tools\Microsoft.WindowsAzure.Build.msbuild" />
  <UsingTask AssemblyFile="..\tools\Microsoft.WindowsAzure.Build.Tasks.dll" TaskName="ValidateStrongNameSignatureTask" />
  <UsingTask AssemblyFile="..\tools\Microsoft.WindowsAzure.Build.Tasks.dll" TaskName="RegexReplacementTask" />

  <!--
  Build tasks (on-premise only)
  -->
  <UsingTask Condition=" Exists($(OnPremiseBuildTasks)) " TaskName="CodeSigningTask" AssemblyFile="$(OnPremiseBuildTasks)\Microsoft.WindowsAzure.Tools.Build.Tasks.OnPremise.dll" />
  <UsingTask Condition=" Exists($(OnPremiseBuildTasks)) " TaskName="CorporateValidation" AssemblyFile="$(OnPremiseBuildTasks)\Microsoft.WindowsAzure.Tools.Build.Tasks.OnPremise.dll" />
  <Import Condition=" Exists($(OnPremiseBuildTasks)) " Project="$(OnPremiseBuildTasks)\Microsoft.WindowsAzure.Build.OnPremise.msbuild" />
  <PropertyGroup>
    <OnPremiseBuild Condition=" Exists($(OnPremiseBuildTasks)) ">true</OnPremiseBuild>
    <OnPremiseBuild Condition=" ! Exists($(OnPremiseBuildTasks)) ">false</OnPremiseBuild>
  </PropertyGroup>

  <!--
  Build version parameters
  -->
  <PropertyGroup>
    <BuildVersionSuffix></BuildVersionSuffix>
    <AdditionalVersionSuffix></AdditionalVersionSuffix>
  </PropertyGroup>

  <!-- 
    Compliance signing properties
    - - -
    Developer builds are signed using the c66ce9294aae1300 full key pair that
    is unofficial and provided to the public via the Development.snk key pair.
    
    Official builds should never be shipped with the developer key pair token.
    -->
  <PropertyGroup>
    <MicrosoftLibrariesStrongNameToken>31bf3856ad364e35</MicrosoftLibrariesStrongNameToken>
  </PropertyGroup>

  <!-- Package and source/symbol publishing configuration -->
  <PropertyGroup>
    <NuGetPublishingSource></NuGetPublishingSource>
    <NuGetSymbolPublishingSource></NuGetSymbolPublishingSource>
    <NuGetKey></NuGetKey>
  </PropertyGroup>

  <!--
  Build profiles
  -->
  <PropertyGroup>
    <DeveloperBuildProperties>Configuration=Debug;Platform=Any CPU</DeveloperBuildProperties>
    <OfficialMSBuildProperties>Configuration=Release;OfficialBuild=true;Platform=Any CPU</OfficialMSBuildProperties>
    <Net40BuildProperty>BuildSecondConfiguration=true</Net40BuildProperty>
  </PropertyGroup>

  <!--
  Regular developer build
  -->
  <Target Name="DeveloperBuild" DependsOnTargets="BuildEngineeringDependencies">
    <MSBuild Projects="$(ProductSolution)"
             Properties="$(DeveloperBuildProperties)"
             Targets="Rebuild" />
    <MSBuild Projects="$(ProductSolution)"
             Properties="$(DeveloperBuildProperties);$(Net40BuildProperty)"
             Targets="Rebuild" />
  </Target>

  <!--
  Clean produced binaries and object files
  -->
  <Target Name="Clean">
    <MSBuild Projects="$(ProductSolution)"
             Properties="$(DeveloperBuildProperties)"
             Targets="Clean" />
    <MSBuild Projects="$(ProductSolution)"
             Properties="$(DeveloperBuildProperties)"
             Targets="Clean" />
    <RemoveDir Directories="binaries" Condition="Exists('binaries\')" ContinueOnError="true" />
  </Target>

  <!--
  An official build is designed for use while shipping. It generates a release
  build and places binaries ready for the official Microsoft signing process
  inside the binaries\unsigned folder.
  
  After signing is complete, additional work is required to prepare the NuGet
  packages for shipping.
  
  This target can be run on any machine, but only on-premise build servers will
  be able to generate and ship a complete product build as this is only part of
  the story.
  -->
  <Target Name="OfficialBuild"
          DependsOnTargets="BuildEngineeringDependencies;Clean">
    <CallTarget Targets="BuildServerPreparation" />
    <MSBuild Projects="$(ProductSolution)"
             Properties="$(OfficialMSBuildProperties)"
             Targets="Rebuild" />
    <MSBuild Projects="$(ProductSolution)"
             Properties="$(OfficialMSBuildProperties);$(Net40BuildProperty)"
             Targets="Rebuild" />
  </Target>

  <!--
  Nightly and continuous builds. Nightly builds can push to a NuGet server.
  -->
  <Target Name="NightlyBuild"
          DependsOnTargets="BuildEngineeringDependencies; Clean; NightlyBuildSetProperties">
    <Error Condition=" '$(NuGetKey)' == '' " Text="NuGetKey is not set." />
    <CallTarget Targets="BuildServerPreparation" />
    <Message Text="Packages will have the version suffix of: $(BuildVersionSuffix)$(AdditionalVersionSuffix)" Importance="high" />
    <CallTarget Targets="OfficialSignedBuild; PublishPackages" />
  </Target>
  
  <Target Name="NightlyBuildSetProperties"
          DependsOnTargets="GetGeneratedBuildDate">
    <Message Text="Nightly builds today have the date of $(GeneratedBuildDate)." />
    <CreateProperty Value="-pre-$(GeneratedBuildDate)">
      <Output PropertyName="BuildVersionSuffix" TaskParameter="Value" />
    </CreateProperty>
  </Target>

  <Target Name="ContinuousIntegrationBuild"
          DependsOnTargets="BuildEngineeringDependencies; Clean; ContinuousIntegrationBuildSetProperties">
    <CallTarget Targets="BuildServerPreparation" />
    <Message Text="Packages will have the version suffix of: $(BuildVersionSuffix)$(AdditionalVersionSuffix)" Importance="high" />
    <CallTarget Targets="OfficialSignedBuild" />
  </Target>

  <Target Name="ContinuousIntegrationBuildSetProperties"
          DependsOnTargets="GetGeneratedBuildDate">
    <CreateProperty Value="-ci-$(GeneratedBuildDate)">
      <Output PropertyName="BuildVersionSuffix" TaskParameter="Value" />
    </CreateProperty>
  </Target>
  
  <!--
  Perform an on-premise official build server drop of this project. Sign the
  generated binaries, build officially-versioned packages, perform compliance
  validation tasks. Only build servers will be able to execute this target.
  -->
  <Target Name="OfficialSignedBuild" DependsOnTargets="OfficialSignedBuildNoPublish" />
  <Target Name="OfficialSignedBuildNoPublish"
          DependsOnTargets="OfficialBuild">

    <Message Text="Validate the unsigned files" />
    <CallTarget Targets="ValidateOfficialBuildBinariesBeforeSigning" />

    <Error Condition=" !Exists($(OnPremiseBuildTasks)) " Text="No OnPremiseBuildTasks available, the official build will be unable to continue. $(OnPremiseBuildTasks)" />

    <Message Text="Code signing" Importance="high" />
    <ItemGroup>
      <AssembliesToBuild Include="binaries\unsigned\Microsoft.WindowsAzure.*.dll" />
      <Net40AssembliesToBuild Include="binaries\net40\unsigned\Microsoft.WindowsAzure.*.dll" />
    </ItemGroup>

    <CodeSigningTask
        Description="Windows Azure SDK"
        Keywords="Windows Azure .NET SDK"
        UnsignedFiles="@(AssembliesToBuild)"
        DestinationPath="binaries\"
        SigningLogPath="binaries\signing.log"
        ToolsPath="$(OnPremiseBuildTasks)" />
    <Error Condition=" !Exists('binaries\Microsoft.WindowsAzure.Common.dll') " Text="The Microsoft.WindowsAzure.Common.dll binary is not in the .\binaries\ folder. Code signing likely failed." />

    <Message Text="Signing .NET Framework 4.0 assemblies..." />
    <CodeSigningTask
      Description="Windows Azure SDK"
      Keywords="Windows Azure .NET SDK"
      UnsignedFiles="@(Net40AssembliesToBuild)"
      DestinationPath="binaries\net40\"
      SigningLogPath="binaries\net40\signing.log"
      ToolsPath="$(OnPremiseBuildTasks)" />
    <Error Condition=" !Exists('binaries\net40\Microsoft.WindowsAzure.Common.dll') " Text="The Microsoft.WindowsAzure.Common.dll binary is not in the .\binaries\ folder. .NET 4.0 code signing likely failed." />

    <Message Text="Validate the signed files" />
    <CallTarget Targets="ValidateOfficialBuildBinaries" />

    <Message Text="Validating the source tree, binaries, packages and more..." />
    <CallTarget Targets="ValidateCorporateCompliance" />

    <Message Text="Build the official NuGet packages" />
    <CallTarget Targets="BuildPackages" />

    <RemoveDir Directories="binaries\unsigned" Condition="Exists('binaries\unsigned')" ContinueOnError="true" />
    <RemoveDir Directories="binaries\net40\unsigned" Condition="Exists('binaries\net40\unsigned')" ContinueOnError="true" />
    <Message Text="Have a nice day." />
  </Target>

  <!--
  Everything should be delay-signed with the corporate public key token before
  code signing is performed. Otherwise, the build may have mixed official and
  developer-signed bits.
  -->
  <Target Name="ValidateOfficialBuildBinariesBeforeSigning">
    <GetFrameworkSdkPath>
      <Output TaskParameter="Path" PropertyName="WindowsSdkPath"/>
    </GetFrameworkSdkPath>
    <ItemGroup>
      <DelaySignedAssembliesToValidate Include="binaries\unsigned\*.dll" />
      <DelaySignedAssembliesToValidate Include="binaries\net40\unsigned\*.dll" />
    </ItemGroup>
    <ValidateStrongNameSignatureTask
        WindowsSdkPath="$(WindowsSdkPath)"
        Assembly="%(DelaySignedAssembliesToValidate.Identity)"
        ExpectedTokenSignature="$(MicrosoftLibrariesStrongNameToken)"
        ExpectedDelaySigned="true"
        ContinueOnError="ErrorAndContinue" />
  </Target>

  <!--
  After code signing, officially-signed bits will be available on on-premise
  build servers.
  -->
  <Target Name="ValidateOfficialBuildBinaries">
    <GetFrameworkSdkPath>
      <Output TaskParameter="Path" PropertyName="WindowsSdkPath"/>
    </GetFrameworkSdkPath>
    <ItemGroup>
      <AfterSignedAssembliesToValidate Include="binaries\*.dll" />
      <AfterSignedAssembliesToValidate Include="binaries\net40\*.dll" />
    </ItemGroup>
    <ValidateStrongNameSignatureTask
        WindowsSdkPath="$(WindowsSdkPath)"
        Assembly="%(AfterSignedAssembliesToValidate.Identity)"
        ExpectedTokenSignature="$(MicrosoftLibrariesStrongNameToken)"
        ExpectedDelaySigned="false"
        ContinueOnError="ErrorAndContinue" />
  </Target>

  <!--
  Publish packages to a NuGet Server (nuget.org or myget.org).
  -->
  <Target Name="PublishPackages" DependsOnTargets="BuildPackages">
    <CallTarget Targets="PublishPackagesOnly" />
  </Target>

  <!--
  Pre-build the tasks file used for validating strong name signatures,
  providing date-based build numbers, and processing regular expression
  replacements in files such as NuGet specs.
  -->
  <Target Name="BuildEngineeringDependencies">
    <MSBuild Projects="..\tools\Microsoft.WindowsAzure.Build.Tasks\Microsoft.WindowsAzure.Build.Tasks.csproj"
             Targets="Build"
             Properties="Configuration=Debug;Platform=AnyCPU" />
  </Target>

  <!--
  We have some important work to do when building our official product bits.
  -->
  <PropertyGroup>
    <CorporateScanPaths>
      $([System.IO.Path]::GetFullPath('$(MSBuildThisFileDirectory)\src'))
    </CorporateScanPaths>
  </PropertyGroup>
  <Target Name="ValidateCorporateCompliance">
    <Message Text="$(CorporateScanPaths)" />
    <Error Text="This target must be run in an on-premise build server." Condition=" '$(OnPremiseBuild)'=='false' " />
    <CallTarget Targets="CorporateValidation" />
  </Target>

  <!--
  Tasks that should be performed on any build server before getting to work.
  -->
  <Target Name="BuildServerPreparation">
    <!-- Log server information -->
    <Message Text="Build Server Information" Importance="high" />
    <Message Text="Hostname      : $(COMPUTERNAME)" />
    <Message Text="Build Account : $(USERDOMAIN)\$(USERNAME)" />
    
    <!-- Useful variables to log -->
    <Message Text="Build Properties and Variables" Importance="high" />
    <Message Text="Solution      : $(ProductSolution)" />
    <Message Text="Product       : $(ProductFriendlyName)" />
    <Message Text="Source folder : $(ProductSourceFolder)" />

    <!-- Modify local files -->
    <CallTarget Targets="BurnBuildVersions" />
  </Target>

  <!--
  Burn the build information into the assembly file information, NuGet specs, 
  and other source files before beginning a build.
  
  This updates the AssemblyFileVersion for .NET assemblies. This is not the
  same thing as an AssemblyVersion; it is only used typically by test teams and
  developers when reporting bugs and associating a build to report.
  
  WARNING:
  This target actively modifies source files and should only be used in build
  server scenarios where the source tree is archived or discarded after use,
  but not used again for additional builds.
  
  If you accidentally run this within your enlistment, revert AssemblyInfo.cs
  changes before commiting to Git.
  -->
  <Target Name="BurnBuildVersions"
          DependsOnTargets="GetGeneratedBuildDate">
    <Message Text="Destructive burn of assembly file versions to include the build number in the revision component." />
    <ItemGroup>
      <AssemblyInfoFilesToUpdate Include="$(ProductSourceFolder)\**\Properties\AssemblyInfo.cs" />
    </ItemGroup>
    <RegexReplacementTask Files="@(AssemblyInfoFilesToUpdate)"
                          Find="AssemblyFileVersion\(&quot;(?&lt;semver&gt;\d{1,3}\.\d{1,3}\.\d{1,3}).(?&lt;revision&gt;)\d{1,3}&quot;\)"
                          Replace="AssemblyFileVersion(&quot;${semver}.$(GeneratedBuildDate)&quot;)"
                          LogReplacement="true" /><!--
                          CONSIDER:
                          A future nice-to-have might be to burn the associated
                          NuGet semver for each assembly along with the build
                          information, but this would require refactoring the
                          build item groups. -->
  </Target>
</Project>