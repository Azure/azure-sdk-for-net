<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  
  <!--
  Available Targets:

  /t:Clean
    Removes temporary build outputs.
    
  /t:Build
    Builds assemblies.

  /t:Package 
    Builds NuGet packages using the binaries folder contents.
    The packages will drop to .\binaries\packages.

  /t:Test
    Runs tests

  /t:Publish
    Publishes the built packages. You will need to include your
    publishing key when running. Include: /p:NuGetKey=YOUR_PUBLISHING_KEY

  Properties of interest:
  /P:CodeSign=True
    Code sign binaries, mainly for official release 

  /p:CodeSign=True;DelaySign=True
    Test the code sign workflow locally

  /p:NuGetKey=NUGET_PUBLISHING_KEY
    Provides the key used to publish to a NuGet or MyGet server.

    This key should never be committed to source control.

  /p:PublishSymbolSourcePackages
    A true/false value indicating whether to push the symbol + source
    packages to a symbol server.

  /p:NuGetPublishingSource=Uri
    The NuGet Server to push packages to.

  /p:NuGetSymbolPublishingSource=Uri
    The NuGet Server to push symbol + source packages to.

  /p:GenerateCodeFromSpecs
    True if you want to invoke codegen tool to regenerate libraries. 
  -->  
  
  <PropertyGroup>
    <LibraryRoot>$(MSBuildThisFileDirectory)</LibraryRoot>
    <LibrarySourceFolder>$(LibraryRoot)src</LibrarySourceFolder>
    <LibraryToolsFolder>$(LibraryRoot)tools</LibraryToolsFolder>
    <LibraryFriendlyName>Microsoft Azure Management Libraries</LibraryFriendlyName>
    <CommonSolution>AzureCommonLibraries.sln</CommonSolution>
    <ExtensionsSolution>AzureExtensions.sln</ExtensionsSolution>
    <ManagementLibrariesSolution>AzureManagementLibraries.sln</ManagementLibrariesSolution>
    <BinariesFolder>$(LibraryRoot)binaries</BinariesFolder>
    <PackageOutputDir>$(BinariesFolder)\packages</PackageOutputDir>
    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
    <CodeSign Condition=" '$(CodeSign)' == '' ">false</CodeSign>
    <!--Set this true only if you want to test the code sign workflow locally-->
    <DelaySign Condition =" '$(DelaySign)' == '' ">false</DelaySign>
    <!-- 'Common': only build common; 'All': Both common and servies; "Extensions": Azure Extensions; 'full path to a library project': build that project -->
    <Scope Condition=" '$(Scope)' == '' ">All</Scope>
  </PropertyGroup>

  <ItemGroup>
    <ManagementLibrariesProjects Include="$(ManagementLibrariesSolution)" Condition="$(MamlProjectName) == ''" />
    <ManagementLibrariesProjects Include="$(LibrarySourceFolder)\$(MamlProjectName)\*.csproj" Condition="$(MamlProjectName) != ''" />
    <LibraryFxTargetList Condition=" '$(FxTargetList)' == '' " Include="portable;net40;net45" />
    <LibraryFxTargetList Condition=" '$(FxTargetList)' != '' " Include="$(FxTargetList)" />
  </ItemGroup>
  
  <PropertyGroup>
    <NuGetCommand>$(LibraryToolsFolder)\nuget.exe</NuGetCommand>
  </PropertyGroup>

  <Import Project="$(LibraryToolsFolder)\Microsoft.WindowsAzure.Build.msbuild" />
  <UsingTask AssemblyFile="$(LibraryToolsFolder)\Microsoft.WindowsAzure.Build.Tasks.dll" TaskName="RegexReplacementTask" />
  <UsingTask AssemblyFile="$(LibraryToolsFolder)\Microsoft.WindowsAzure.Build.Tasks.dll" TaskName="ValidateStrongNameSignatureTask" />

  <!--
  CI build related
  -->
  <PropertyGroup>
    <!--OnPremiseBuildTasks is not a good name, but CI server is using that, will update across soon-->
    <CIToolsPath>$(OnPremiseBuildTasks)</CIToolsPath>
    <OnPremiseBuild Condition=" Exists($(OnPremiseBuildTasks)) ">true</OnPremiseBuild>
    <OnPremiseBuild Condition=" ! Exists($(OnPremiseBuildTasks)) ">false</OnPremiseBuild>
  </PropertyGroup>
  <UsingTask Condition=" $(OnPremiseBuild) " TaskName="CodeSigningTask" AssemblyFile="$(CIToolsPath)\Microsoft.WindowsAzure.Tools.Build.Tasks.OnPremise.dll" />
  <UsingTask Condition=" $(OnPremiseBuild) " TaskName="CorporateValidation" AssemblyFile="$(CIToolsPath)\Microsoft.WindowsAzure.Tools.Build.Tasks.OnPremise.dll" />
  <Import Condition=" $(OnPremiseBuild) " Project="$(CIToolsPath)\Microsoft.WindowsAzure.Build.OnPremise.msbuild" />

  <Target Name="Build" DependsOnTargets="RestoreNugetPackages">
    <PropertyGroup>
      <_ExtraPropertyList>CodeSign=$(CodeSign);GenerateHydraSpecs=$(GenerateCodeFromSpecs)</_ExtraPropertyList>
    </PropertyGroup>
    <CallTarget Targets="BuildMsBuildTask" />
    <CallTarget Targets="BuildServerPreparation" Condition=" '$(CodeSign)' == 'true' " />
    <!--The solution contains configurations for each platform such as Net40-Debug, Net45-Release, etc
    So when invoke msbuild, feed the right configuration name-->
    <MSBuild Projects="$(CommonSolution)"
             Properties="Configuration=%(LibraryFxTargetList.Identity)-$(Configuration);Platform=Any CPU;$(_ExtraPropertyList)"
             Targets="Build"
             Condition=" '$(Scope)' == 'Common' or '$(Scope)' == 'All' " />
    
    <MSBuild Projects="$(ExtensionsSolution)"
             Properties="Configuration=Net45-$(Configuration);Platform=Any CPU;$(_ExtraPropertyList)"
             Targets="Build"
             Condition=" '$(Scope)' == 'Extensions' or '$(Scope)' == 'All' " />
    
    <MSBuild Projects="$(ManagementLibrariesSolution)"
             Properties="Configuration=%(LibraryFxTargetList.Identity)-$(Configuration);Platform=Any CPU;$(_ExtraPropertyList)"
             Targets="Build" 
             Condition=" '$(Scope)' == 'All' " />
    
    <MSBuild Projects="$(Scope)"
             Properties="Configuration=%(LibraryFxTargetList.Identity)-$(Configuration);Platform=AnyCPU;$(_ExtraPropertyList)"
             Targets="Build"
             Condition=" '$(Scope)' != 'Common' and '$(Scope)' != 'All' and '$(Scope)' != 'Extensions' " />

    <CallTarget Targets="CodeSignBinaries" Condition=" '$(CodeSign)' == 'true' " />

  </Target>

  <!-- Projects import BCL target, so make sure the packages get restored first -->
  <Target Name="Clean" DependsOnTargets="RestoreNugetPackages">
    <MSBuild Projects="$(CommonSolution)"
             Properties="Configuration=%(LibraryFxTargetList.Identity)-$(Configuration);Platform=Any CPU"
             Targets="Clean" />
    <MSBuild Projects="$(ManagementLibrariesSolution)"
             Properties="Configuration=%(LibraryFxTargetList.Identity)-$(Configuration);Platform=Any CPU"
             Targets="Clean" />
    <RemoveDir Directories="$(BinariesFolder)" />
  </Target>

  <!--
  Run all tests
  -->
  <UsingTask TaskName="Xunit.Runner.msbuild.xunit" AssemblyFile="packages\xunit.1.9.2\lib\net20\xunit.runner.msbuild.dll" />
  <Target Name="Test">
    <ItemGroup>
      <!--test projects should always have net45 in its target framework list-->
      <TestDlls Include=".\src\*.Test\bin\net45*\*Test.dll"/>
    </ItemGroup>
    <MakeDir Directories="$(LibraryRoot)TestResults"/>
    <Message Text="%(TestDlls.Filename)" />
    <xunit Assemblies="@(TestDlls)" Html="$(MSBuildProjectDirectory)\TestResults\xunit.results.html" ContinueOnError="false" />
  </Target>
  
  <PropertyGroup>
    <!--This property is used by build script at CI server. Do not remove it unless you will update CI as well -->
    <CorporateScanPaths>$(LibrarySourceFolder)</CorporateScanPaths>
  </PropertyGroup>
  <Target Name="SignBinariesForAFxTarget">
    <PropertyGroup>
      <!--public token associated with MSSharedLibKey.snk-->
      <StrongNameToken Condition=" '$(StrongNameToken)' == '' ">31bf3856ad364e35</StrongNameToken>
    </PropertyGroup>
    <GetFrameworkSdkPath>
      <Output TaskParameter="Path" PropertyName="WindowsSdkPath"/>
    </GetFrameworkSdkPath>

    <ItemGroup>
      <DelaySignedAssembliesToValidate Include="binaries\$(LibraryFxTarget)\unsigned\*.dll" />
    </ItemGroup>
    <ValidateStrongNameSignatureTask
        WindowsSdkPath="$(WindowsSdkPath)"
        Assembly="%(DelaySignedAssembliesToValidate.Identity)"
        ExpectedTokenSignature="$(StrongNameToken)"
        ExpectedDelaySigned="true"
        ContinueOnError="false" />

    <CodeSigningTask
        Description="Microsoft Azure SDK"
        Keywords="Microsoft Azure .NET SDK"
        UnsignedFiles="@(DelaySignedAssembliesToValidate)"
        DestinationPath="binaries\$(LibraryFxTarget)"
        SigningLogPath="binaries\$(LibraryFxTarget)\signing.log"
        ToolsPath="$(CIToolsPath)"
        Condition="!$(DelaySign)"/>
    <!--If we are testing locally then we copy the binaries and do not submit to the code sign server-->
    <Copy SourceFiles="@(DelaySignedAssembliesToValidate)" DestinationFolder="binaries\$(LibraryFxTarget)" Condition="$(DelaySign)" />
    
    <Error Condition=" !Exists('binaries\$(LibraryFxTarget)\Microsoft.Azure.Common.dll') " Text="The Microsoft.Azure.Common.dll binary is not in the .\binaries\$(LibraryFxTarget) folder. Code signing likely failed." />

    <ItemGroup>
      <AfterSignedAssembliesToValidate Include="binaries\$(LibraryFxTarget)\*.dll" />
    </ItemGroup>
    <ValidateStrongNameSignatureTask
        WindowsSdkPath="$(WindowsSdkPath)"
        Assembly="%(AfterSignedAssembliesToValidate.Identity)"
        ExpectedTokenSignature="$(StrongNameToken)"
        ExpectedDelaySigned="false"
        ContinueOnError="false" 
        Condition="!$(DelaySign)"/>
    
    <RemoveDir Directories="binaries\$(LibraryFxTarget)\unsigned;" ContinueOnError="true" />
  </Target>
   
  <Target Name="CodeSignBinaries">

    <Error Condition=" !$(OnPremiseBuild) and !$(DelaySign) " Text="No CI tools path available, the code sign will be unable to continue. $(CIToolsPath)" />

    <Message Text="Code signing" Importance="high" />

    <MSBuild Projects="$(MSBuildProjectFullPath)"
             Targets="SignBinariesForAFxTarget"
             Properties="LibraryFxTarget=%(LibraryFxTargetList.Identity);StrongNameToken=$(StrongNameToken)">    
    </MSBuild>
    
    <CallTarget Targets="ValidateCorporateCompliance" Condition="!$(DelaySign)"/>
  </Target>

  <!--
  Pre-build the tasks file used for validating strong name signatures,
  providing date-based build numbers, and processing regular expression
  replacements in files such as NuGet specs.
  -->
  <Target Name="BuildMsBuildTask" DependsOnTargets="RestoreNugetPackages">
    <MSBuild Projects="$(LibraryToolsFolder)\Microsoft.WindowsAzure.Build.Tasks\Microsoft.WindowsAzure.Build.Tasks.csproj"
             Targets="Build"
             Properties="Configuration=Debug;Platform=AnyCPU" />
  </Target>

  <Target Name="RestoreNugetPackages">
    <CallTarget Targets="RestoreAllNugetPackages"  Condition=" '$(PRIVATE_FEED_URL)' != '' or '$(SECONDARY_FEED_URL)' != '' " />
    <CallTarget Targets="RestorePublicNugetPackages"  Condition=" '$(PRIVATE_FEED_URL)' == '' and '$(SECONDARY_FEED_URL)' == '' " />
  </Target>
  <!--
  Force nuget package restore so that packages that include .targets files
  do not need to be checked into source control.

  Assumes use of a private feed.
    PRIVATE_FEED_URL: The url of the feed to pull from with specific credentials (in addition to the public default feed)
    PRIVATE_FEED_USER_NAME: User name for access to the feed
    PRIVATE_FEED_PASSWORD: Password for access to the feed
  -->
  <Target Name="RestoreAllNugetPackages">
    <PropertyGroup>
      <NuGetRestoreConfigFile>$(LibraryRoot)restore.config</NuGetRestoreConfigFile>
      <NuGetRestoreConfigSwitch>-ConfigFile &quot;$(NuGetRestoreConfigFile)&quot;</NuGetRestoreConfigSwitch>
    </PropertyGroup>

    <!-- Create config for user name and password for private feed access -->
    <Delete Files="$(NuGetRestoreConfigFile)" />
    <WriteLinesToFile
      File="$(NuGetRestoreConfigFile)"
      Lines="&lt;configuration&gt;&lt;/configuration&gt;"
      Overwrite="true"
      Encoding="Unicode"/>
    <!-- Private versions of packages are picked up from these feeds, defined with environment variables -->
    <Exec Command="$(NuGetCommand) sources add -Name PrimaryFeed -Source &quot;$(PRIVATE_FEED_URL)&quot; $(NuGetRestoreConfigSwitch)" Condition=" '$(PRIVATE_FEED_URL)'!='' "/>
    <Exec Command="$(NuGetCommand) sources Update -Name PrimaryFeed -UserName $(PRIVATE_FEED_USER_NAME) -Password &quot;$(PRIVATE_FEED_PASSWORD)&quot; $(NuGetRestoreConfigSwitch)" EchoOff="true" Condition=" '$(PRIVATE_FEED_PASSWORD)'!='' AND '$(PRIVATE_FEED_USER_NAME)'!='' "/>
    <Exec Command="$(NuGetCommand) sources add -Name SecondaryFeed -Source &quot;$(SECONDARY_FEED_URL)&quot; $(NuGetRestoreConfigSwitch)" Condition=" '$(SECONDARY_FEED_URL)'!='' "/>
    <Exec Command="$(NuGetCommand) sources Update -Name SecondaryFeed -UserName $(SECONDARY_FEED_USER_NAME) -Password &quot;$(SECONDARY_FEED_PASSWORD)&quot; $(NuGetRestoreConfigSwitch)" EchoOff="true" Condition=" '$(SECONDARY_FEED_PASSWORD)'!='' AND '$(SECONDARY_FEED_USER_NAME)'!='' "/>
    <Exec Command="$(NuGetCommand) sources add -Name AzureSdkInternalFeed -Source &quot;https://www.myget.org/F/azure-sdk-internal/&quot; $(NuGetRestoreConfigSwitch)"/>

    <Exec Command="$(NuGetCommand) restore $(CommonSolution) $(NuGetRestoreConfigSwitch)"/>
    <Exec Command="$(NuGetCommand) restore $(ManagementLibrariesSolution) $(NuGetRestoreConfigSwitch)" />

    <!-- delete config file, don't want to leave passwords hanging around on the build server file system -->
    <Delete Files="$(NuGetRestoreConfigFile)" />
  </Target>

  <Target Name="RestorePublicNugetPackages">
    <Exec Command="$(NuGetCommand) restore $(LibraryToolsFolder)\Packages.config -PackagesDirectory $(LibraryRoot)\packages -NonInteractive" />
  </Target>

  <!--
  We have some important work to do when building our official Library bits.
  -->
  <Target Name="ValidateCorporateCompliance">
    <Error Text="This target must be run in an on-premise build server." Condition=" '$(OnPremiseBuild)'=='false' " />
    <CallTarget Targets="CorporateValidation" />
  </Target>

  <!--
  Tasks that should be performed on any build server before getting to work.
  -->
  <Target Name="BuildServerPreparation">
    <!-- Log server information -->
    <Message Text="Build Server Information" Importance="high" />
    <Message Text="Hostname      : $(COMPUTERNAME)" />
    <Message Text="Build Account : $(USERDOMAIN)\$(USERNAME)" />

    <!-- Useful variables to log -->
    <Message Text="Build Properties and Variables" Importance="high" />
    <Message Text="Common Solution    : $(CommonSolution)" />
    <Message Text="Libraries Solution : $(ManagementLibrariesSolution)" />
    <Message Text="Library            : $(LibraryFriendlyName)" />
    <Message Text="Source folder      : $(LibrarySourceFolder)" />

    <!-- Modify local files -->
    <CallTarget Targets="BurnBuildVersions" />
  </Target>

  <!--
  Burn the build information into the assembly file information, NuGet specs,
  and other source files before beginning a build.

  This updates the AssemblyFileVersion for .NET assemblies. 
  
  If you accidentally run this within your enlistment, revert AssemblyInfo.cs
  changes before commiting to Git.
  -->
  <Target Name="BurnBuildVersions"
          DependsOnTargets="GetGeneratedBuildDate">
    <Message Text="Destructive burn of assembly file versions to include the build number in the revision component." />
    <ItemGroup>
      <AssemblyInfoFilesToUpdate Include="$(LibrarySourceFolder)\*\Properties\AssemblyInfo.cs" />
    </ItemGroup>
    <RegexReplacementTask Files="@(AssemblyInfoFilesToUpdate)"
                          Find="AssemblyFileVersion\(&quot;(?&lt;semver&gt;\d{1,3}\.\d{1,3}\.\d{1,3}).(?&lt;revision&gt;)\d{1,3}&quot;\)"
                          Replace="AssemblyFileVersion(&quot;${semver}.$(GeneratedBuildDate)&quot;)"
                          LogReplacement="true" />
  </Target>

  <Target Name="GetGeneratedBuildDate">
    <GetBuildVersionTask>
      <Output TaskParameter="Date" PropertyName="GeneratedBuildDate" />
    </GetBuildVersionTask>
  </Target>

  <Import Project="$(LibraryToolsFolder)\nuget.targets" />

</Project>
