<?xml version="1.0" encoding="utf-8"?>
<Project DefaultTargets="Build" ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
	<!--
	Available Targets:

	/t:Clean
	Removes temporary build outputs.

	/t:Build
	Builds assemblies.

	/t:Package 
	Builds NuGet packages using the binaries folder contents.
	The packages will drop to .\binaries\packages.

	/t:Test
	Runs tests

	/t:Publish
	Publishes the built packages. You will need to include your
	publishing key when running. Include: /p:NuGetKey=YOUR_PUBLISHING_KEY

	Properties of interest:
	/p:Scope 
	'Common' : build Azure Common
	'Subfolder under /src, with solution files, such as 'ResourceManagement\Compute'': build individual packages
	'Authentication': build Authentication
	By default, it builds all.

	/P:CodeSign=True
	Code sign binaries, mainly for official release. Default is false.

	/p:CodeSign=True;DelaySign=True
	Test the code sign workflow locally. 

	/p:NuGetKey=NUGET_PUBLISHING_KEY
	Provides the key used to publish to a NuGet or MyGet server.
	This key should never be committed to source control.

	/p:NuGetPublishingSource=Uri
	The NuGet Server to push packages to.
	-->  

	<PropertyGroup>
		<LibraryRoot>$(MSBuildThisFileDirectory)</LibraryRoot>
		<LibrarySourceFolder>$(LibraryRoot)src</LibrarySourceFolder>
		<LibraryToolsFolder>$(LibraryRoot)tools</LibraryToolsFolder>
		<LibraryNugetPackageFolder>$(LibraryRoot)\packages</LibraryNugetPackageFolder>
		<LibraryFriendlyName>Microsoft Azure Management Libraries</LibraryFriendlyName>
		<AuthenticationSolution>src\Authentication\Authentication.sln</AuthenticationSolution>
		<ManagementLibrariesSolution>AzureManagementLibraries.sln</ManagementLibrariesSolution>
		<BinariesFolder>$(LibraryRoot)binaries</BinariesFolder>
		<PackageOutputDir>$(BinariesFolder)\packages</PackageOutputDir>
		<Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
		<CodeSign Condition=" '$(CodeSign)' == '' ">false</CodeSign>
		<!--Set this true only if you want to test the code sign workflow locally-->
		<DelaySign Condition =" '$(DelaySign)' == '' ">false</DelaySign>
		<Scope Condition=" '$(Scope)' == '' ">All</Scope>
		<FxTargetList>portable;net40;net45</FxTargetList>
		<FxTargetList Condition=" '$(Scope)' == 'authentication' ">net45</FxTargetList>
		<ZipExeFolder>$(LibraryToolsFolder)\7-Zip</ZipExeFolder>
		<ZipExe>$(ZipExeFolder)\7z.exe</ZipExe>
		<NuGetCommand>&quot;$(LibraryToolsFolder)\nuget.exe&quot;</NuGetCommand>
	</PropertyGroup>

	<ItemGroup Condition="'$(PublishTestProjects)' == 'false' Or '$(PublishTestProjects)' == ''">
		<LibrariesToBuild Include="$(LibrarySourceFolder)\$(Scope)\*.sln" Condition=" '$(Scope)' != 'all'  " />
		<LibrariesToBuild Include="$(LibrarySourceFolder)\**\*.sln" Condition=" '$(Scope)' == 'all'  " />
		<LibraryFxTargetList Include="$(FxTargetList)" />
		<AutoRestLibraryFxTargetList Include="portable;net45" />
		<ClientRuntimeProjects Include="$(LibrarySourceFolder)\ClientRuntime\**\*.xproj"/>
		<ClientRuntimeTests Include="$(LibrarySourceFolder)\ClientRuntime\*.Tests\*.xproj"/>
		<ClientRuntimeRootDir Include="%(ClientRuntimeProjects.RootDir)"/>
	</ItemGroup>
  
	<Import Condition="$(PublishTestProjects) == 'true'" Project="$(LibraryToolsFolder)\Microsoft.WindowsAzure.Build.Tasks\Build.Tasks.Tests\PublishNugetPackageTests.proj" />

	<UsingTask TaskName="ValidateStrongNameSignatureTask" AssemblyFile="$(LibraryToolsFolder)\Microsoft.WindowsAzure.Build.Tasks.dll"  />
	<UsingTask TaskName="FilterOutAutoRestLibraries" AssemblyFile="$(LibraryToolsFolder)\Microsoft.WindowsAzure.Build.Tasks.dll"  />
	<UsingTask TaskName="BuildProjectTemplatesTask" AssemblyFile="$(LibraryToolsFolder)\Microsoft.WindowsAzure.Build.Tasks.dll"  />
  
	<!-- Building ClientRuntime projects -->
	<Target Name="BuildClientRuntime" Condition="Exists($(ClientRuntimeRootDir))">
	  <Exec Command="dotnet restore" WorkingDirectory="%(ClientRuntimeProjects.RootDir)\%(ClientRuntimeProjects.Directory)"/>
	  <Exec Command="dotnet build --configuration $(Configuration)" WorkingDirectory="%(ClientRuntimeProjects.RootDir)\%(ClientRuntimeProjects.Directory)"/>
	</Target>

	<Target Name="DisableSN" > 
		<!-- Check for admin privs -->
		<Exec Command="net session" IgnoreExitCode="true" StandardErrorImportance="Low">
		<Output PropertyName="isadmin" TaskParameter="ExitCode" />
		</Exec>

		<!-- Disable strong name checking -->  
		<Exec Command='"C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6.1 Tools\sn.exe" -Vr *' Condition="$(isadmin) == 0"/>
		<Exec Command='"C:\Program Files (x86)\Microsoft SDKs\Windows\v10.0A\bin\NETFX 4.6.1 Tools\x64\sn.exe" -Vr *' Condition="$(isadmin) == 0"/>
	</Target>
    
	<Target Name="EnableSN" > 
		<!-- Check for admin privs -->
		<Exec Command="net session" IgnoreExitCode="true" StandardErrorImportance="Low">
		<Output PropertyName="isadmin" TaskParameter="ExitCode" />
		</Exec>

		<!-- Enable strong name checking -->  
		<Exec Command='$(WindowsSDK_ExecutablePath_x86)\sn.exe -Vx *' Condition="$(isadmin) == 0"/>
		<Exec Command='$(WindowsSDK_ExecutablePath_x64)\sn.exe -Vx *' Condition="$(isadmin) == 0"/>
	</Target>

	<!--
	CI build related
	-->
	<PropertyGroup>
		<!--OnPremiseBuildTasks is not a good name, but CI server is using that, will update across soon-->
		<CIToolsPath>$(OnPremiseBuildTasks)</CIToolsPath>
		<OnPremiseBuild Condition=" Exists($(OnPremiseBuildTasks)) ">true</OnPremiseBuild>
		<OnPremiseBuild Condition=" ! Exists($(OnPremiseBuildTasks)) ">false</OnPremiseBuild>
	</PropertyGroup>
	<UsingTask Condition=" $(OnPremiseBuild) " TaskName="CodeSigningTask" AssemblyFile="$(CIToolsPath)\Microsoft.WindowsAzure.Tools.Build.Tasks.OnPremise.dll" />
	<UsingTask Condition=" $(OnPremiseBuild) " TaskName="CorporateValidation" AssemblyFile="$(CIToolsPath)\Microsoft.WindowsAzure.Tools.Build.Tasks.OnPremise.dll" />
	<Import Condition=" $(OnPremiseBuild) " Project="$(CIToolsPath)\Microsoft.WindowsAzure.Build.OnPremise.msbuild" />
  
	<Target Name="PrepareForAutoRestLibraries">
		<FilterOutAutoRestLibraries AllLibraries="@(LibrariesToBuild)" AutoRestMark="AutoRestProjects" NugetPackagesToPublish="$(PackageName)">
		  <Output TaskParameter="Non_NetCore_AutoRestLibraries" ItemName="Non_NetCore_AutoRestLibraries" />
		  <Output TaskParameter="NetCore_AutoRestLibraries" ItemName="NetCore_AutoRestLibraries" />
		</FilterOutAutoRestLibraries>
		<Message Text="Non NetCore based AutoRest Libraries: @(Non_NetCore_AutoRestLibraries)" />
		<Message Text="NetCore AutoRest Libraries: @(NetCore_AutoRestLibraries)" />

		<!--Do not build old libraries except Authentication, which Azure PowerShell still uses-->
		<ItemGroup>
			<NonAutoRestLibraries Include="$(LibrarySourceFolder)\Authentication\Authentication.sln"	  
								Condition=" '$(Scope)' == 'all' or '$(Scope)' == 'Authentication' " />    	
		</ItemGroup>

		<Message Text="Non-AutoRest Libraries: @(NonAutoRestLibraries)" />     
		<Message Text="Ensure 7zip is available" />
		<Exec
		  Command="$(LibraryToolsFolder)\AzCopy\AzCopy.exe /Source:https://azuresdktools.blob.core.windows.net/7-zip  /S /Dest:$(ZipExeFolder) /Y"
		  Condition="!Exists('$(ZipExe)')" />
	</Target>
  
	<Target Name="Build" DependsOnTargets="BuildClientRuntime;BuildMsBuildTask;PrepareForAutoRestLibraries;RestoreNugetPackages">
		<PropertyGroup>
		  <_ExtraPropertyList>CodeSign=$(CodeSign)</_ExtraPropertyList>
		  <_TemporaryNetCoreFeeds>-s https://api.nuget.org/v3/index.json -s https://dotnet.myget.org/F/cli-deps/api/v3/index.json</_TemporaryNetCoreFeeds>
		</PropertyGroup>
		<CallTarget Targets="DisableSN" Condition=" '$(OS)' == 'Windows_NT'"/> 
		<CallTarget Targets="BuildServerPreparation" Condition=" '$(CodeSign)' == 'true' " />

		<MSBuild Projects="@(NonAutoRestLibraries)"
				 Properties="Configuration=%(LibraryFxTargetList.Identity)-$(Configuration);Platform=Any CPU;$(_ExtraPropertyList)"
				 Targets="Build" />

		<MSBuild Projects="@(Non_NetCore_AutoRestLibraries)"
				 Properties="Configuration=%(AutoRestLibraryFxTargetList.Identity)-$(Configuration);Platform=Any CPU;$(_ExtraPropertyList)"
				 Targets="Build" />

		<!-- Restoring everyting from the root folder wipes out Storage nuget references and adds Storage project reference to all projects. -->
		<!-- Restoring from root directory when publishing scope packages -->
		<Exec Command="dotnet restore" WorkingDirectory="$(LibraryRoot)" />

		<Exec Command="dotnet restore" WorkingDirectory="%(NetCore_AutoRestLibraries.Library)" Condition=" @(NetCore_AutoRestLibraries) != '' "/>
		<Exec Command="dotnet restore" WorkingDirectory="%(NetCore_AutoRestLibraries.Test)" Condition=" @(NetCore_AutoRestLibraries) != '' and '%(NetCore_AutoRestLibraries.Test)' != '' and '$(Configuration)' != 'Release' "/>

		<CallTarget Targets="BuildNetCoreLibraries" Condition=" @(NetCore_AutoRestLibraries) != '' " />
		<CallTarget Targets="CodeSignBinaries" Condition=" '$(CodeSign)' == 'true' " />
	</Target>

	<Target Name="BuildNetCoreLibraries">
		<Exec Command="dotnet build --configuration $(Configuration)" WorkingDirectory="%(NetCore_AutoRestLibraries.Library)" Condition=" '%(NetCore_AutoRestLibraries.Library)'!= '' "/>
		<Exec Command="dotnet build --configuration $(Configuration)" WorkingDirectory="%(NetCore_AutoRestLibraries.Test)" Condition=" '$(Configuration)' != 'Release' and '%(NetCore_AutoRestLibraries.Test)' != '' "/>
	</Target>
 
	<Target Name="Clean" DependsOnTargets="BuildMsBuildTask;PrepareForAutoRestLibraries;RestoreNugetPackages">
		<!--<MSBuild Projects="@(NonAutoRestLibraries)"
				 Properties="Configuration=%(LibraryFxTargetList.Identity)-$(Configuration);Platform=Any CPU"
				 Targets="Clean" />-->

		<MSBuild Projects="@(Non_NetCore_AutoRestLibraries)"
				 Properties="Configuration=%(AutoRestLibraryFxTargetList.Identity)-$(Configuration);Platform=Any CPU;$(_ExtraPropertyList)"
				 Targets="Clean" />

		<RemoveDir Directories="$(BinariesFolder)" />
	</Target>

	<Target Name="Test" DependsOnTargets="PrepareForAutoRestLibraries">
		<PropertyGroup>
			<!--Extrat out service name from 'Scope' to use as test dll filter-->
			<!--For example, from 'ServiceManagement\Storage', get 'Storage'.-->
			<TestPartialName>$([System.IO.Path]::GetFileName($(Scope)))</TestPartialName>
		</PropertyGroup>
		<ItemGroup>
		  <!--TODO: improve the logic to be more explicit -->
		  <TestDlls Include=".\src\**\*.Tests\bin\net45-$(Configuration)\*.Tests.dll" Condition=" '$(Scope)' == 'All' " />
		  <TestDlls Include=".\src\$(Scope)\**\*.Tests\bin\net45-$(Configuration)\*.Tests.dll"
					Condition=" '$(Scope)' != 'All' " />
		</ItemGroup>
		<MakeDir Directories="$(LibraryRoot)TestResults"/>
		<Message Text="%(TestDlls.Filename)" />
		<Exec Command="$(LibraryNugetPackageFolder)\xunit.runner.console.2.0.0\tools\xunit.console.x86.exe &quot;%(TestDlls.Identity)&quot; -html &quot;$(MSBuildProjectDirectory)\TestResults\%(TestDlls.Filename).html&quot;"
		  Condition=" '@(TestDlls)' != '' "  
		  ContinueOnError="false"/>
		
		<!--Based on https://github.com/xunit/xunit/issues/653, only xml is supported -->
		<Exec Command="dotnet test -xml &quot;$(MSBuildProjectDirectory)\TestResults\%(NetCore_AutoRestLibraries.Filename).xml&quot;" 
			  WorkingDirectory="%(NetCore_AutoRestLibraries.Test)"
			  Condition=" @(NetCore_AutoRestLibraries) != '' and '%(NetCore_AutoRestLibraries.Test)' != '' "/>
		<Exec Command="dotnet test -xml &quot;$(MSBuildProjectDirectory)\TestResults\%(ClientRuntimeTests.Filename).xml&quot;" 
			  WorkingDirectory="%(ClientRuntimeTests.RootDir)\%(ClientRuntimeTests.Directory)"/>
  </Target>
  
	<PropertyGroup>
		<!--This property is used by build script at CI server. Do not remove it unless you will update CI as well -->
		<!--TODO: research to include all library folders but exlude test folders with huge recorded json files.
		  For now we run subset of folders to avoid long build delay and avoid errors reported on recorded json files-->
		<CorporateScanPaths>$(LibrarySourceFolder)\Authentication</CorporateScanPaths>
		<!--public token associated with MSSharedLibKey.snk-->
		<StrongNameToken Condition=" '$(StrongNameToken)' == '' ">31bf3856ad364e35</StrongNameToken>
	</PropertyGroup>
	<Target Name="SignBinariesForAFxTarget">
		<GetFrameworkSdkPath>
		  <Output TaskParameter="Path" PropertyName="WindowsSdkPath"/>
		</GetFrameworkSdkPath>

		<ItemGroup>
		  <DelaySignedAssembliesToValidate Include="binaries\$(LibraryFxTarget)\unsigned\*.dll" />
		</ItemGroup>

		<Message Importance="high" Text="Binaries\$(LibraryFxTarget)\unsigned contains no files. Code sign will skip." 
				 Condition="'@(DelaySignedAssembliesToValidate)' == ''" />

		<ValidateStrongNameSignatureTask
			WindowsSdkPath="$(WindowsSdkPath)"
			Assembly="%(DelaySignedAssembliesToValidate.Identity)"
			ExpectedTokenSignature="$(StrongNameToken)"
			ExpectedDelaySigned="true"
			ContinueOnError="false" 
			Condition="'@(DelaySignedAssembliesToValidate)' != ''"/>

		<CodeSigningTask
			Description="Microsoft Azure SDK"
			Keywords="Microsoft Azure .NET SDK"
			UnsignedFiles="@(DelaySignedAssembliesToValidate)"
			DestinationPath="binaries\$(LibraryFxTarget)"
			SigningLogPath="binaries\$(LibraryFxTarget)\signing.log"
			ToolsPath="$(CIToolsPath)"
			Condition="!$(DelaySign) and '@(DelaySignedAssembliesToValidate)' != ''"/>
		<!--If we are testing locally then we copy the binaries and do not submit to the code sign server-->
		<Copy SourceFiles="@(DelaySignedAssembliesToValidate)" DestinationFolder="binaries\$(LibraryFxTarget)" Condition="$(DelaySign)" />

		<ItemGroup>
		  <AfterSignedAssembliesToValidate Include="binaries\$(LibraryFxTarget)\*.dll" />
		</ItemGroup>
		<ValidateStrongNameSignatureTask
			WindowsSdkPath="$(WindowsSdkPath)"
			Assembly="%(AfterSignedAssembliesToValidate.Identity)"
			ExpectedTokenSignature="$(StrongNameToken)"
			ExpectedDelaySigned="false"
			ContinueOnError="false" 
			Condition="!$(DelaySign) and '@(DelaySignedAssembliesToValidate)' != ''"/>

		<RemoveDir Directories="binaries\$(LibraryFxTarget)\unsigned;" ContinueOnError="true" />
	</Target>
   
	<Target Name="CodeSignBinaries">
		<Error Condition=" !$(OnPremiseBuild) and !$(DelaySign) " Text="No CI tools path available, the code sign will be unable to continue. $(CIToolsPath)" />

		<Message Text="Code signing" Importance="high" />
		<Message Text="Signing project: $(MSBuildProjectFullPath)" />
		<MSBuild Projects="$(MSBuildProjectFullPath)"
				 Targets="SignBinariesForAFxTarget"
				 Properties="LibraryFxTarget=%(LibraryFxTargetList.Identity);StrongNameToken=$(StrongNameToken)">    
		</MSBuild>

		<CallTarget Targets="ValidateCorporateCompliance" Condition="!$(DelaySign)"/>
	</Target>

	<!--
	Pre-build the tasks file used for validating strong name signatures,
	providing date-based build numbers, and processing regular expression
	replacements in files such as NuGet specs.
	-->
	<Target Name="BuildMsBuildTask">
		<Exec Command="$(NuGetCommand) restore $(LibraryToolsFolder)\Microsoft.WindowsAzure.Build.Tasks\Microsoft.WindowsAzure.Build.Tasks.sln -PackagesDirectory $(LibraryToolsFolder)\Microsoft.WindowsAzure.Build.Tasks\packages"/>
		<MSBuild Projects="$(LibraryToolsFolder)\Microsoft.WindowsAzure.Build.Tasks\Microsoft.WindowsAzure.Build.Tasks.csproj"
				 Targets="Build"
				 Properties="Configuration=Debug;Platform=AnyCPU" />
	</Target>

	<Target Name="RestoreNugetPackages">
		<PropertyGroup>
			<NuGetRestoreConfigSwitch>-PackagesDirectory $(LibraryNugetPackageFolder)</NuGetRestoreConfigSwitch>
		</PropertyGroup>
		<Exec Command="$(NuGetCommand) restore $(LibrarySourceFolder)\$(Scope) $(NuGetRestoreConfigSwitch)" Condition=" '$(Scope)' != 'all' AND ('@(Non_NetCore_AutoRestLibraries)' != '' OR '@(NonAutoRestLibraries)' != '')"/>
		<Exec Command="$(NuGetCommand) restore %(Non_NetCore_AutoRestLibraries.Identity) $(NuGetRestoreConfigSwitch)" Condition=" @(Non_NetCore_AutoRestLibraries) != '' "/>
		<Exec Command="$(NuGetCommand) restore %(NonAutoRestLibraries.Identity) $(NuGetRestoreConfigSwitch)" Condition=" @(NonAutoRestLibraries) != '' "/>
		<Exec Command="$(NuGetCommand) install xunit.runner.console -Version 2.0.0 -o $(LibraryNugetPackageFolder)" />
	</Target>

	<!-- Task to build project templates -->  
	<Target Name="BuildProjectTemplates">
		<Message Text="Building Project Templates" />
		<BuildProjectTemplatesTask>
		  <Output TaskParameter="TaskErrorDetected" PropertyName="BuildTemplateTaskFailed" />
		</BuildProjectTemplatesTask>
		<Message Text="Building Project Templates Completed" />
	</Target>
	<!--
	We have some important work to do when building our official Library bits.
	-->
	<Target Name="ValidateCorporateCompliance">
		<Error Text="This target must be run in an on-premise build server." Condition=" '$(OnPremiseBuild)'=='false' " />
		<CallTarget Targets="CorporateValidation" />
	</Target>

	<!--
	Tasks that should be performed on any build server before getting to work.
	-->
	<Target Name="BuildServerPreparation">
		<!-- Log server information -->
		<Message Text="Build Server Information" Importance="high" />
		<Message Text="Hostname      : $(COMPUTERNAME)" />
		<Message Text="Build Account : $(USERDOMAIN)\$(USERNAME)" />

		<!-- Useful variables to log -->
		<Message Text="Build Properties and Variables" Importance="high" />
		<Message Text="Libraries Solution : $(ManagementLibrariesSolution)" />
		<Message Text="Library            : $(LibraryFriendlyName)" />
		<Message Text="Source folder      : $(LibrarySourceFolder)" />
	</Target>

	<Import Project="$(LibraryToolsFolder)\nuget.targets" />

	<Target Name="SignAssembliesInNetCorePackages">
		<ItemGroup>
			<_NetCorePackagesTemp Include="$(PackageOutputDir)\%(NetCore_AutoRestLibraries.PackageName)*.nupkg"/>
		</ItemGroup>
		
		<RemoveDuplicates Inputs="@(_NetCorePackagesTemp)">
			<Output TaskParameter="Filtered" ItemName="_NetCorePackages" />
		</RemoveDuplicates>
		<PropertyGroup>
			<_UnsignedFolder>$(PackageOutputDir)\unsigned</_UnsignedFolder>
			<_SignedFolder>$(PackageOutputDir)\signed</_SignedFolder>
		</PropertyGroup>    

		<Message Text="%(_NetCorePackages.Identity)" Importance="low" />

		<RemoveDir Directories="$(_UnsignedFolder);$(_SignedFolder)" ContinueOnError="false" />
		<RemoveDir Directories="@(_NetCorePackages->'$(PackageOutputDir)\%(Filename)')" ContinueOnError="false" />

		<MakeDir Directories="$(_UnsignedFolder);$(_SignedFolder)" />

		<Exec Command="$(ZipExe) x -y -scsUTF-8 -o@(_NetCorePackages->'$(PackageOutputDir)\%(Filename)') %(_NetCorePackages.Identity)" />

		<RemoveDir Directories="@(_NetCorePackages->'%(RootDir)%(Directory)\%(Filename)\_rels')" />
		<Delete Files="@(_NetCorePackages->'%(RootDir)%(Directory)\%(Filename)\[Content_Types].xml')" />

		<ItemGroup>
			<_TempBinaries Include="$(PackageOutputDir)\**\*.dll"/>
			<_PackageBinaries Include="@(_TempBinaries)">
			<!-- Flattened file for signing -->
			<UnsignedFlatFileName>$(_UnsignedFolder)\$([System.String]::new('%(RecursiveDir)%(FileName)%(Extension)').Replace('\', '__'))</UnsignedFlatFileName>
			<SignedFlatFileName>$(_SignedFolder)\$([System.String]::new('%(RecursiveDir)%(FileName)%(Extension)').Replace('\', '__'))</SignedFlatFileName>
			</_PackageBinaries>
		</ItemGroup>

		<Copy SourceFiles="@(_PackageBinaries)" DestinationFiles="@(_PackageBinaries->'%(UnsignedFlatFileName)')"></Copy>

		<CodeSigningTask
		  Description="Microsoft Azure SDK"
		  Keywords="Microsoft Azure .NET SDK"
		  UnsignedFiles="@(_PackageBinaries->'%(UnsignedFlatFileName)')"
		  DestinationPath="$(_SignedFolder)"
		  SigningLogPath="$(PackageOutputDir)\signing.log"
		  ToolsPath="$(CIToolsPath)"
		  Condition="!$(DelaySign)"/>

		<!--If we are testing locally then we copy the binaries and do not submit to the code sign server-->
		<Copy SourceFiles="@(_PackageBinaries->'%(UnsignedFlatFileName)')" DestinationFolder="$(_SignedFolder)" Condition="$(DelaySign)" />

		<GetFrameworkSdkPath>
			<Output TaskParameter="Path" PropertyName="WindowsSdkPath"/>
		</GetFrameworkSdkPath>
		<ValidateStrongNameSignatureTask
			WindowsSdkPath="$(WindowsSdkPath)"
			Assembly="%(_PackageBinaries.SignedFlatFileName)"
			ExpectedTokenSignature="$(StrongNameToken)"
			ExpectedDelaySigned="false"
			ContinueOnError="false"
			Condition="!$(DelaySign)"/>

		<Copy SourceFiles="@(_PackageBinaries->'%(SignedFlatFileName)')" DestinationFiles="@(_PackageBinaries->'%(FullPath)')"></Copy>
		<Exec Command="$(ZipExe) a -tzip -mx9 -r -y $(PackageOutputDir)\%(_NetCorePackages.Filename).nupkg" WorkingDirectory="$(PackageOutputDir)\%(_NetCorePackages.Filename)" />
	</Target>
</Project>
