<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Azure Cognitive Language Services Conversations client library for .NET | Azure SDK for .NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Azure Cognitive Language Services Conversations client library for .NET | Azure SDK for .NET ">
    <meta name="generator" content="docfx 2.43.2.0">
    
    <link rel="shortcut icon" href="./https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="./styles/docfx.vendor.css">
    <link rel="stylesheet" href="./styles/docfx.css">
    <link rel="stylesheet" href="./styles/main.css">
    <meta property="docfx:navrel" content="./toc.html">
    <meta property="docfx:tocrel" content="./api/toc.html">
    
    
    <meta property="docfx:newtab" content="true">
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-62780441-41"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
  
      gtag('config', 'UA-62780441-41');
    </script>
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="./index.html">
                <img id="logo" class="svg" src="./logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="azure-cognitive-language-services-conversations-client-library-for-net">Azure Cognitive Language Services Conversations client library for .NET</h1>

<p>Conversational Language Understanding - aka CLU for short - is a cloud-based conversational AI service which provides many language understanding capabilities like:</p>
<ul>
<li>Conversation App: It's used in extracting intents and entities in conversations</li>
<li>Workflow app: Acts like an orchestrator to select the best candidate to analyze conversations to get best response from apps like Qna, Luis, and Conversation App</li>
<li>Conversational Issue Summarization: Used to summarize conversations in the form of issues, and final resolutions</li>
<li>Conversational PII: Used to extract and redact personally-identifiable info (PII)</li>
</ul>
<p><a href="https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/cognitivelanguage/Azure.AI.Language.Conversations/src/">Source code</a> | <a href="https://www.nuget.org/packages/Azure.AI.Language.Conversations/1.0.0-beta.1">Package (NuGet)</a> | <a href="https://review.docs.microsoft.com/dotnet/api/azure.ai.language.conversations">API reference documentation</a> | <a href="https://docs.microsoft.com/azure/cognitive-services/language-service/conversational-language-understanding/overview">Product documentation</a> | <a href="https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/cognitivelanguage/Azure.AI.Language.Conversations/samples/">Samples</a></p>
<h2 id="getting-started">Getting started</h2>
<h3 id="install-the-package">Install the package</h3>
<p>Install the Azure Cognitive Language Services Conversations client library for .NET with <a href="https://www.nuget.org/">NuGet</a>:</p>
<pre><code class="lang-powershell">dotnet add package Azure.AI.Language.Conversations --prerelease
</code></pre>
<h3 id="prerequisites">Prerequisites</h3>
<ul>
<li>An <a href="https://azure.microsoft.com/free/dotnet/">Azure subscription</a></li>
<li>An existing Azure Language Service Resource</li>
</ul>
<h3 id="authenticate-the-client">Authenticate the client</h3>
<p>In order to interact with the Conversations service, you'll need to create an instance of the <a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/cognitivelanguage/Azure.AI.Language.Conversations/src/ConversationAnalysisClient.cs"><code>ConversationAnalysisClient</code></a> class. You will need an <strong>endpoint</strong>, and an <strong>API key</strong> to instantiate a client object. For more information regarding authenticating with Cognitive Services, see <a href="https://docs.microsoft.com/azure/cognitive-services/authentication/">Authenticate requests to Azure Cognitive Services</a>.</p>
<h4 id="get-an-api-key">Get an API key</h4>
<p>You can get the <strong>endpoint</strong> and an <strong>API key</strong> from the Cognitive Services resource in the <a href="https://portal.azure.com/">Azure Portal</a>.</p>
<p>Alternatively, use the <a href="https://docs.microsoft.com/cli/azure/">Azure CLI</a> command shown below to get the API key from the Cognitive Service resource.</p>
<pre><code class="lang-powershell">az cognitiveservices account keys list --resource-group &lt;resource-group-name&gt; --name &lt;resource-name&gt;
</code></pre>
<h4 id="create-a-conversationanalysisclient">Create a ConversationAnalysisClient</h4>
<p>Once you've determined your <strong>endpoint</strong> and <strong>API key</strong> you can instantiate a <code>ConversationAnalysisClient</code>:</p>
<pre><code class="lang-C#">Uri endpoint = new Uri(&quot;https://myaccount.api.cognitive.microsoft.com&quot;);
AzureKeyCredential credential = new AzureKeyCredential(&quot;{api-key}&quot;);

ConversationAnalysisClient client = new ConversationAnalysisClient(endpoint, credential);
</code></pre>
<h2 id="key-concepts">Key concepts</h2>
<h3 id="conversationanalysisclient">ConversationAnalysisClient</h3>
<p>The <a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/cognitivelanguage/Azure.AI.Language.Conversations/src/ConversationAnalysisClient.cs"><code>ConversationAnalysisClient</code></a> is the primary interface for making predictions using your deployed Conversations models. It provides both synchronous and asynchronous APIs to submit queries.</p>
<h3 id="thread-safety">Thread safety</h3>
<p>We guarantee that all client instance methods are thread-safe and independent of each other (<a href="https://azure.github.io/azure-sdk/dotnet_introduction.html#dotnet-service-methods-thread-safety">guideline</a>). This ensures that the recommendation of reusing client instances is always safe, even across threads.</p>
<h3 id="additional-concepts">Additional concepts</h3>
<!-- CLIENT COMMON BAR -->
<p><a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/README.md#configuring-service-clients-using-clientoptions">Client options</a> |
<a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/README.md#accessing-http-response-details-using-responset">Accessing the response</a> |
<a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/README.md#consuming-long-running-operations-using-operationt">Long-running operations</a> |
<a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/README.md#reporting-errors-requestfailedexception">Handling failures</a> |
<a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/Diagnostics.md">Diagnostics</a> |
<a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/README.md#mocking">Mocking</a> |
<a href="https://devblogs.microsoft.com/azure-sdk/lifetime-management-and-thread-safety-guarantees-of-azure-sdk-net-clients/">Client lifetime</a></p>
<!-- CLIENT COMMON BAR -->
<h2 id="examples">Examples</h2>
<p>The Azure.AI.Language.Conversations client library provides both synchronous and asynchronous APIs.</p>
<p>The following examples show common scenarios using the <code>client</code> <a href="#create-a-conversationanalysisclient">created above</a>.</p>
<h3 id="analyze-a-conversation">Analyze a conversation</h3>
<p>To analyze a conversation, you can call the <code>client.AnalyzeConversation()</code> method which takes a <code>TextConversationItem</code> and <code>ConversationsProject</code> as parameters.</p>
<pre><code class="lang-C#">ConversationsProject conversationsProject = new ConversationsProject(&quot;Menu&quot;, &quot;production&quot;);

Response&lt;AnalyzeConversationTaskResult&gt; response = client.AnalyzeConversation(
    &quot;Send an email to Carol about the tomorrow's demo.&quot;,
    conversationsProject);

CustomConversationalTaskResult customConversationalTaskResult = response.Value as CustomConversationalTaskResult;
ConversationPrediction conversationPrediction = customConversationalTaskResult.Result.Prediction as ConversationPrediction;

Console.WriteLine($&quot;Top intent: {conversationPrediction.TopIntent}&quot;);

Console.WriteLine(&quot;Intents:&quot;);
foreach (ConversationIntent intent in conversationPrediction.Intents)
{
    Console.WriteLine($&quot;Category: {intent.Category}&quot;);
    Console.WriteLine($&quot;Confidence: {intent.Confidence}&quot;);
    Console.WriteLine();
}

Console.WriteLine(&quot;Entities:&quot;);
foreach (ConversationEntity entity in conversationPrediction.Entities)
{
    Console.WriteLine($&quot;Category: {entity.Category}&quot;);
    Console.WriteLine($&quot;Text: {entity.Text}&quot;);
    Console.WriteLine($&quot;Offset: {entity.Offset}&quot;);
    Console.WriteLine($&quot;Length: {entity.Length}&quot;);
    Console.WriteLine($&quot;Confidence: {entity.Confidence}&quot;);
    Console.WriteLine();

    foreach (BaseResolution resolution in entity.Resolutions)
    {
        if (resolution is DateTimeResolution dateTimeResolution)
        {
            Console.WriteLine($&quot;Datetime Sub Kind: {dateTimeResolution.DateTimeSubKind}&quot;);
            Console.WriteLine($&quot;Timex: {dateTimeResolution.Timex}&quot;);
            Console.WriteLine($&quot;Value: {dateTimeResolution.Value}&quot;);
            Console.WriteLine();
        }
    }
}
</code></pre>
<p>The specified parameters can also be used to initialize a <code>AnalyzeConversationOptions</code> instance. You can then call <code>AnalyzeConversation()</code> using the options object as a parameter as shown below.</p>
<p>You can also set the verbose parameter in the <code>AnalyzeConversation()</code> method.</p>
<pre><code class="lang-C#">TextConversationItem input = new TextConversationItem(
    participantId: &quot;1&quot;,
    id: &quot;1&quot;,
    text: &quot;Send an email to Carol about the tomorrow's demo.&quot;);
AnalyzeConversationOptions options = new AnalyzeConversationOptions(input)
{
    Verbose = true
};

ConversationsProject conversationsProject = new ConversationsProject(&quot;Menu&quot;, &quot;production&quot;);

Response&lt;AnalyzeConversationTaskResult&gt; response = client.AnalyzeConversation(
    &quot;Send an email to Carol about the tomorrow's demo.&quot;,
    conversationsProject,
    options);

CustomConversationalTaskResult customConversationalTaskResult = response.Value as CustomConversationalTaskResult;
ConversationPrediction conversationPrediction = customConversationalTaskResult.Result.Prediction as ConversationPrediction;

Console.WriteLine($&quot;Project Kind: {customConversationalTaskResult.Result.Prediction.ProjectKind}&quot;);
Console.WriteLine($&quot;Top intent: {conversationPrediction.TopIntent}&quot;);

Console.WriteLine(&quot;Intents:&quot;);
foreach (ConversationIntent intent in conversationPrediction.Intents)
{
    Console.WriteLine($&quot;Category: {intent.Category}&quot;);
    Console.WriteLine($&quot;Confidence: {intent.Confidence}&quot;);
    Console.WriteLine();
}

Console.WriteLine(&quot;Entities:&quot;);
foreach (ConversationEntity entity in conversationPrediction.Entities)
{
    Console.WriteLine($&quot;Category: {entity.Category}&quot;);
    Console.WriteLine($&quot;Text: {entity.Text}&quot;);
    Console.WriteLine($&quot;Offset: {entity.Offset}&quot;);
    Console.WriteLine($&quot;Length: {entity.Length}&quot;);
    Console.WriteLine($&quot;Confidence: {entity.Confidence}&quot;);
    Console.WriteLine();

    foreach (BaseResolution resolution in entity.Resolutions)
    {
        if (resolution is DateTimeResolution dateTimeResolution)
        {
            Console.WriteLine($&quot;Datetime Sub Kind: {dateTimeResolution.DateTimeSubKind}&quot;);
            Console.WriteLine($&quot;Timex: {dateTimeResolution.Timex}&quot;);
            Console.WriteLine($&quot;Value: {dateTimeResolution.Value}&quot;);
            Console.WriteLine();
        }
    }
}
</code></pre>
<h3 id="analyze-a-conversation-in-a-different-language">Analyze a conversation in a different language</h3>
<p>The language property in the <code>TextConversationItem</code> can be used to specify the language of the conversation.</p>
<pre><code class="lang-C#">TextConversationItem input = new TextConversationItem(
    participantId: &quot;1&quot;,
    id: &quot;1&quot;,
    text: &quot;Tendremos 2 platos de nigiri de salmón braseado.&quot;)
{
    Language = &quot;es&quot;
};
AnalyzeConversationOptions options = new AnalyzeConversationOptions(input);

ConversationsProject conversationsProject = new ConversationsProject(&quot;Menu&quot;, &quot;production&quot;);

Response&lt;AnalyzeConversationTaskResult&gt; response = client.AnalyzeConversation(
    textConversationItem,
    conversationsProject,
    options);

CustomConversationalTaskResult customConversationalTaskResult = response.Value as CustomConversationalTaskResult;
ConversationPrediction conversationPrediction = customConversationalTaskResult.Result.Prediction as ConversationPrediction;

Console.WriteLine($&quot;Project Kind: {customConversationalTaskResult.Result.Prediction.ProjectKind}&quot;);
Console.WriteLine($&quot;Top intent: {conversationPrediction.TopIntent}&quot;);

Console.WriteLine(&quot;Intents:&quot;);
foreach (ConversationIntent intent in conversationPrediction.Intents)
{
    Console.WriteLine($&quot;Category: {intent.Category}&quot;);
    Console.WriteLine($&quot;Confidence: {intent.Confidence}&quot;);
    Console.WriteLine();
}

Console.WriteLine(&quot;Entities:&quot;);
foreach (ConversationEntity entity in conversationPrediction.Entities)
{
    Console.WriteLine($&quot;Category: {entity.Category}&quot;);
    Console.WriteLine($&quot;Text: {entity.Text}&quot;);
    Console.WriteLine($&quot;Offset: {entity.Offset}&quot;);
    Console.WriteLine($&quot;Length: {entity.Length}&quot;);
    Console.WriteLine($&quot;Confidence: {entity.Confidence}&quot;);
    Console.WriteLine();

    foreach (BaseResolution resolution in entity.Resolutions)
    {
        if (resolution is DateTimeResolution dateTimeResolution)
        {
            Console.WriteLine($&quot;Datetime Sub Kind: {dateTimeResolution.DateTimeSubKind}&quot;);
            Console.WriteLine($&quot;Timex: {dateTimeResolution.Timex}&quot;);
            Console.WriteLine($&quot;Value: {dateTimeResolution.Value}&quot;);
            Console.WriteLine();
        }
    }
}
</code></pre>
<p>Other optional properties can be set such as verbosity and whether service logging is enabled.</p>
<h3 id="analyze-a-conversation---orchestration-project">Analyze a conversation - Orchestration Project</h3>
<p>To analyze a conversation using an orchestration project, you can then call the <code>client.AnalyzeConversation()</code> just like the conversation project. But you have to cast the prediction to <code>OrchestratorPrediction</code>. Also, you have to cast the intent type into the one you need.</p>
<h3 id="orchestration-project---conversation-prediction">Orchestration Project - Conversation Prediction</h3>
<pre><code class="lang-C#">string respondingProjectName = orchestratorPrediction.TopIntent;
TargetIntentResult targetIntentResult = orchestratorPrediction.Intents[respondingProjectName];

if (targetIntentResult.TargetProjectKind == TargetProjectKind.Conversation)
{
    ConversationTargetIntentResult cluTargetIntentResult = targetIntentResult as ConversationTargetIntentResult;

    ConversationResult conversationResult = cluTargetIntentResult.Result;
    ConversationPrediction conversationPrediction = conversationResult.Prediction;

    Console.WriteLine($&quot;Top Intent: {conversationResult.Prediction.TopIntent}&quot;);
    Console.WriteLine($&quot;Intents:&quot;);
    foreach (ConversationIntent intent in conversationPrediction.Intents)
    {
        Console.WriteLine($&quot;Intent Category: {intent.Category}&quot;);
        Console.WriteLine($&quot;Confidence: {intent.Confidence}&quot;);
        Console.WriteLine();
    }

    Console.WriteLine($&quot;Entities:&quot;);
    foreach (ConversationEntity entity in conversationPrediction.Entities)
    {
        Console.WriteLine($&quot;Entity Text: {entity.Text}&quot;);
        Console.WriteLine($&quot;Entity Category: {entity.Category}&quot;);
        Console.WriteLine($&quot;Confidence: {entity.Confidence}&quot;);
        Console.WriteLine($&quot;Starting Position: {entity.Offset}&quot;);
        Console.WriteLine($&quot;Length: {entity.Length}&quot;);
        Console.WriteLine();

        foreach (BaseResolution resolution in entity.Resolutions)
        {
            if (resolution is DateTimeResolution dateTimeResolution)
            {
                Console.WriteLine($&quot;Datetime Sub Kind: {dateTimeResolution.DateTimeSubKind}&quot;);
                Console.WriteLine($&quot;Timex: {dateTimeResolution.Timex}&quot;);
                Console.WriteLine($&quot;Value: {dateTimeResolution.Value}&quot;);
                Console.WriteLine();
            }
        }
    }
}
</code></pre>
<h3 id="orchestration-project---questionanswering-prediction">Orchestration Project - QuestionAnswering Prediction</h3>
<pre><code class="lang-C#">string respondingProjectName = orchestratorPrediction.TopIntent;
TargetIntentResult targetIntentResult = orchestratorPrediction.Intents[respondingProjectName];

if (targetIntentResult.TargetProjectKind == TargetProjectKind.QuestionAnswering)
{
    Console.WriteLine($&quot;Top intent: {respondingProjectName}&quot;);

    QuestionAnsweringTargetIntentResult qnaTargetIntentResult = targetIntentResult as QuestionAnsweringTargetIntentResult;

    BinaryData questionAnsweringResponse = qnaTargetIntentResult.Result;
    Console.WriteLine($&quot;Qustion Answering Response: {questionAnsweringResponse.ToString()}&quot;);
}
</code></pre>
<h3 id="orchestration-project---luis-prediction">Orchestration Project - Luis Prediction</h3>
<pre><code class="lang-C#">string respondingProjectName = orchestratorPrediction.TopIntent;
TargetIntentResult targetIntentResult = orchestratorPrediction.Intents[respondingProjectName];

if (targetIntentResult.TargetProjectKind == TargetProjectKind.Luis)
{
    LuisTargetIntentResult luisTargetIntentResult = targetIntentResult as LuisTargetIntentResult;
    BinaryData luisResponse = luisTargetIntentResult.Result;

    Console.WriteLine($&quot;LUIS Response: {luisResponse.ToString()}&quot;);
}
</code></pre>
<h3 id="analyze-a-conversation---conversation-summarization">Analyze a conversation - Conversation Summarization</h3>
<p>First, you should prepare the input:</p>
<pre><code class="lang-C#">var textConversationItems = new List&lt;TextConversationItem&gt;()
{
    new TextConversationItem(&quot;1&quot;, &quot;Agent&quot;, &quot;Hello, how can I help you?&quot;),
    new TextConversationItem(&quot;2&quot;, &quot;Customer&quot;, &quot;How to upgrade Office? I am getting error messages the whole day.&quot;),
    new TextConversationItem(&quot;3&quot;, &quot;Agent&quot;, &quot;Press the upgrade button please. Then sign in and follow the instructions.&quot;),
};

var input = new List&lt;TextConversation&gt;()
{
    new TextConversation(&quot;1&quot;, &quot;en&quot;, textConversationItems)
};

var conversationSummarizationTaskParameters = new ConversationSummarizationTaskParameters(new List&lt;SummaryAspect&gt;() { SummaryAspect.Issue, SummaryAspect.Resolution });

var tasks = new List&lt;AnalyzeConversationLROTask&gt;()
{
    new AnalyzeConversationSummarizationTask(&quot;1&quot;, AnalyzeConversationLROTaskKind.ConversationalSummarizationTask, conversationSummarizationTaskParameters),
};
</code></pre>
<p>Then you can start analyzing by calling the <code>StartAnalyzeConversation</code>, and because this is a long running operation, you have to wait until it's finished by calling <code>WaitForCompletion</code> function.</p>
<h2 id="synchronous">Synchronous</h2>
<pre><code class="lang-C#">var analyzeConversationOperation = client.StartAnalyzeConversation(input, tasks);
analyzeConversationOperation.WaitForCompletion();
</code></pre>
<h2 id="asynchronous">Asynchronous</h2>
<pre><code class="lang-C#">var analyzeConversationOperation = await client.StartAnalyzeConversationAsync(input, tasks);
await analyzeConversationOperation.WaitForCompletionAsync();
</code></pre>
<p>You can finally print the results:</p>
<pre><code class="lang-C#">var jobResults = analyzeConversationOperation.Value;
foreach (var result in jobResults.Tasks.Items)
{
    var analyzeConversationSummarization = result as AnalyzeConversationSummarizationResult;

    var results = analyzeConversationSummarization.Results;

    Console.WriteLine(&quot;Conversations:&quot;);
    foreach (var conversation in results.Conversations)
    {
        Console.WriteLine($&quot;Conversation #:{conversation.Id}&quot;);
        Console.WriteLine(&quot;Summaries:&quot;);
        foreach (var summary in conversation.Summaries)
        {
            Console.WriteLine($&quot;Text: {summary.Text}&quot;);
            Console.WriteLine($&quot;Aspect: {summary.Aspect}&quot;);
        }
        Console.WriteLine();
    }
}
</code></pre>
<h3 id="analyze-a-conversation---conversation-pii---text-input">Analyze a conversation - Conversation PII - Text Input</h3>
<p>First, you should prepare the input:</p>
<pre><code class="lang-C#">var textConversationItems = new List&lt;TextConversationItem&gt;()
{
    new TextConversationItem(&quot;1&quot;, &quot;0&quot;, &quot;Hi, I am John Doe.&quot;),
    new TextConversationItem(&quot;2&quot;, &quot;1&quot;, &quot;Hi John, how are you doing today?&quot;),
    new TextConversationItem(&quot;3&quot;, &quot;0&quot;, &quot;Pretty good.&quot;),
};

var input = new List&lt;TextConversation&gt;()
{
    new TextConversation(&quot;1&quot;, &quot;en&quot;, textConversationItems)
};

var conversationPIITaskParameters = new ConversationPIITaskParameters(false, &quot;2022-05-15-preview&quot;, new List&lt;ConversationPIICategory&gt;() { ConversationPIICategory.All }, false, null);

var tasks = new List&lt;AnalyzeConversationLROTask&gt;()
{
    new AnalyzeConversationPIITask(&quot;analyze&quot;, AnalyzeConversationLROTaskKind.ConversationalPIITask, conversationPIITaskParameters),
};
</code></pre>
<p>Then you can start analyzing by calling the <code>StartAnalyzeConversation</code>, and because this is a long running operation, you have to wait until it's finished by calling <code>WaitForCompletion</code> function.</p>
<h2 id="synchronous-1">Synchronous</h2>
<pre><code class="lang-C#">var analyzeConversationOperation = client.StartAnalyzeConversation(input, tasks);
analyzeConversationOperation.WaitForCompletion();
</code></pre>
<h2 id="asynchronous-1">Asynchronous</h2>
<pre><code class="lang-C#">var analyzeConversationOperation = await client.StartAnalyzeConversationAsync(input, tasks);
await analyzeConversationOperation.WaitForCompletionAsync();
</code></pre>
<p>You can finally print the results:</p>
<pre><code class="lang-C#">var jobResults = analyzeConversationOperation.Value;
foreach (var result in jobResults.Tasks.Items)
{
    var analyzeConversationPIIResult = result as AnalyzeConversationPIIResult;

    var results = analyzeConversationPIIResult.Results;

    Console.WriteLine(&quot;Conversations:&quot;);
    foreach (var conversation in results.Conversations)
    {
        Console.WriteLine($&quot;Conversation #:{conversation.Id}&quot;);
        Console.WriteLine(&quot;Conversation Items: &quot;);
        foreach (var conversationItem in conversation.ConversationItems)
        {
            Console.WriteLine($&quot;Conversation Item #:{conversationItem.Id}&quot;);

            Console.WriteLine($&quot;Redacted Text: {conversationItem.RedactedContent.Text}&quot;);

            Console.WriteLine(&quot;Entities:&quot;);
            foreach (var entity in conversationItem.Entities)
            {
                Console.WriteLine($&quot;Text: {entity.Text}&quot;);
                Console.WriteLine($&quot;Offset: {entity.Offset}&quot;);
                Console.WriteLine($&quot;Category: {entity.Category}&quot;);
                Console.WriteLine($&quot;Confidence Score: {entity.ConfidenceScore}&quot;);
                Console.WriteLine($&quot;Length: {entity.Length}&quot;);
                Console.WriteLine();
            }
        }
        Console.WriteLine();
    }
}
</code></pre>
<h3 id="analyze-a-conversation---conversation-pii---transcript-input">Analyze a conversation - Conversation PII - Transcript Input</h3>
<p>First, you should prepare the input:</p>
<pre><code class="lang-C#">var transciprtConversationItemOne = new TranscriptConversationItem(
   id: &quot;1&quot;,
   participantId: &quot;speaker&quot;,
   itn: &quot;hi&quot;,
   maskedItn: &quot;hi&quot;,
   text: &quot;Hi&quot;,
   lexical: &quot;hi&quot;);
transciprtConversationItemOne.AudioTimings.Add(new WordLevelTiming(4500000, 2800000, &quot;hi&quot;));

var transciprtConversationItemTwo = new TranscriptConversationItem(
   id: &quot;2&quot;,
   participantId: &quot;speaker&quot;,
   itn: &quot;jane doe&quot;,
   maskedItn: &quot;jane doe&quot;,
   text: &quot;Jane doe&quot;,
   lexical: &quot;jane doe&quot;);
transciprtConversationItemTwo.AudioTimings.Add(new WordLevelTiming(7100000, 4800000, &quot;jane&quot;));
transciprtConversationItemTwo.AudioTimings.Add(new WordLevelTiming(12000000, 1700000, &quot;jane&quot;));

var transciprtConversationItemThree = new TranscriptConversationItem(
    id: &quot;3&quot;,
    participantId: &quot;agent&quot;,
    itn: &quot;hi jane what's your phone number&quot;,
    maskedItn: &quot;hi jane what's your phone number&quot;,
    text: &quot;Hi Jane, what's your phone number?&quot;,
    lexical: &quot;hi jane what's your phone number&quot;);
transciprtConversationItemThree.AudioTimings.Add(new WordLevelTiming(7700000, 3100000, &quot;hi&quot;));
transciprtConversationItemThree.AudioTimings.Add(new WordLevelTiming(10900000, 5700000, &quot;jane&quot;));
transciprtConversationItemThree.AudioTimings.Add(new WordLevelTiming(17300000, 2600000, &quot;what's&quot;));
transciprtConversationItemThree.AudioTimings.Add(new WordLevelTiming(20000000, 1600000, &quot;your&quot;));
transciprtConversationItemThree.AudioTimings.Add(new WordLevelTiming(21700000, 1700000, &quot;phone&quot;));
transciprtConversationItemThree.AudioTimings.Add(new WordLevelTiming(23500000, 2300000, &quot;number&quot;));

var transcriptConversationItems = new List&lt;TranscriptConversationItem&gt;()
{
    transciprtConversationItemOne,
    transciprtConversationItemTwo,
    transciprtConversationItemThree,
};

var input = new List&lt;TranscriptConversation&gt;()
{
    new TranscriptConversation(&quot;1&quot;, &quot;en&quot;, transcriptConversationItems)
};

var conversationPIITaskParameters = new ConversationPIITaskParameters(false, &quot;2022-05-15-preview&quot;, new List&lt;ConversationPIICategory&gt;() { ConversationPIICategory.All }, false, TranscriptContentType.Lexical);

var tasks = new List&lt;AnalyzeConversationLROTask&gt;()
{
    new AnalyzeConversationPIITask(&quot;analyze&quot;, AnalyzeConversationLROTaskKind.ConversationalPIITask, conversationPIITaskParameters),
};
</code></pre>
<p>Then you can start analyzing by calling the <code>StartAnalyzeConversation</code>, and because this is a long running operation, you have to wait until it's finished by calling <code>WaitForCompletion</code> function.</p>
<h2 id="synchronous-2">Synchronous</h2>
<pre><code class="lang-C#">var analyzeConversationOperation = client.StartAnalyzeConversation(input, tasks);
analyzeConversationOperation.WaitForCompletion();
</code></pre>
<h2 id="asynchronous-2">Asynchronous</h2>
<pre><code class="lang-C#">var analyzeConversationOperation = await client.StartAnalyzeConversationAsync(input, tasks);
await analyzeConversationOperation.WaitForCompletionAsync();
</code></pre>
<p>You can finally print the results:</p>
<pre><code class="lang-C#">var jobResults = analyzeConversationOperation.Value;
foreach (var result in jobResults.Tasks.Items)
{
    var analyzeConversationPIIResult = result as AnalyzeConversationPIIResult;

    var results = analyzeConversationPIIResult.Results;

    Console.WriteLine(&quot;Conversations:&quot;);
    foreach (var conversation in results.Conversations)
    {
        Console.WriteLine($&quot;Conversation #:{conversation.Id}&quot;);
        Console.WriteLine(&quot;Conversation Items: &quot;);
        foreach (var conversationItem in conversation.ConversationItems)
        {
            Console.WriteLine($&quot;Conversation Item #:{conversationItem.Id}&quot;);

            Console.WriteLine($&quot;Redacted Text: {conversationItem.RedactedContent.Text}&quot;);
            Console.WriteLine($&quot;Redacted Lexical: {conversationItem.RedactedContent.Lexical}&quot;);
            Console.WriteLine($&quot;Redacted AudioTimings: {conversationItem.RedactedContent.AudioTimings}&quot;);
            Console.WriteLine($&quot;Redacted MaskedItn: {conversationItem.RedactedContent.MaskedItn}&quot;);

            Console.WriteLine(&quot;Entities:&quot;);
            foreach (var entity in conversationItem.Entities)
            {
                Console.WriteLine($&quot;Text: {entity.Text}&quot;);
                Console.WriteLine($&quot;Offset: {entity.Offset}&quot;);
                Console.WriteLine($&quot;Category: {entity.Category}&quot;);
                Console.WriteLine($&quot;Confidence Score: {entity.ConfidenceScore}&quot;);
                Console.WriteLine($&quot;Length: {entity.Length}&quot;);
                Console.WriteLine();
            }
        }
        Console.WriteLine();
    }
}
</code></pre>
<h2 id="troubleshooting">Troubleshooting</h2>
<h3 id="general">General</h3>
<p>When you interact with the Cognitive Language Services Conversations client library using the .NET SDK, errors returned by the service correspond to the same HTTP status codes returned for REST API requests.</p>
<p>For example, if you submit a utterance to a non-existant project, a <code>400</code> error is returned indicating &quot;Bad Request&quot;.</p>
<pre><code class="lang-C#">try
{
    ConversationsProject conversationsProject = new ConversationsProject(&quot;invalid-project&quot;, &quot;production&quot;);
    Response&lt;AnalyzeConversationTaskResult&gt; response = client.AnalyzeConversation(
        &quot;Send an email to Carol about the tomorrow's demo&quot;,
        conversationsProject);
}
catch (RequestFailedException ex)
{
    Console.WriteLine(ex.ToString());
}
</code></pre>
<p>You will notice that additional information is logged, like the client request ID of the operation.</p>
<pre><code class="lang-text">Azure.RequestFailedException: The input parameter is invalid.
Status: 400 (Bad Request)
ErrorCode: InvalidArgument

Content:
{
  &quot;error&quot;: {
    &quot;code&quot;: &quot;InvalidArgument&quot;,
    &quot;message&quot;: &quot;The input parameter is invalid.&quot;,
    &quot;innerError&quot;: {
      &quot;code&quot;: &quot;InvalidArgument&quot;,
      &quot;message&quot;: &quot;The input parameter \&quot;payload\&quot; cannot be null or empty.&quot;
    }
  }
}

Headers:
Transfer-Encoding: chunked
pragma: no-cache
request-id: 0303b4d0-0954-459f-8a3d-1be6819745b5
apim-request-id: 0303b4d0-0954-459f-8a3d-1be6819745b5
x-envoy-upstream-service-time: 15
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload
x-content-type-options: nosniff
Cache-Control: no-store, proxy-revalidate, no-cache, max-age=0, private
Content-Type: application/json
</code></pre>
<h3 id="setting-up-console-logging">Setting up console logging</h3>
<p>The simplest way to see the logs is to enable console logging. To create an Azure SDK log listener that outputs messages to the console use the <code>AzureEventSourceListener.CreateConsoleLogger</code> method.</p>
<pre><code class="lang-C#">// Setup a listener to monitor logged events.
using AzureEventSourceListener listener = AzureEventSourceListener.CreateConsoleLogger();
</code></pre>
<p>To learn more about other logging mechanisms see <a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/Diagnostics.md">here</a>.</p>
<h2 id="next-steps">Next steps</h2>
<ul>
<li>View our <a href="https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/cognitivelanguage/Azure.AI.Language.Conversations/samples/">samples</a>.</li>
<li>Read about the different <a href="https://docs.microsoft.com/azure/cognitive-services/language-service/conversational-language-understanding/overview">features</a> of the Conversations service.</li>
<li>Try our service <a href="https://docs.microsoft.com/azure/cognitive-services/language-service/conversational-language-understanding/quickstart">demos</a>.</li>
</ul>
<h2 id="contributing">Contributing</h2>
<p>See the <a href="https://github.com/Azure/azure-sdk-for-net/blob/main/CONTRIBUTING.md">CONTRIBUTING.md</a> for details on building, testing, and contributing to this library.</p>
<p>This project welcomes contributions and suggestions. Most contributions require you to agree to a Contributor License Agreement (CLA) declaring that you have the right to, and actually do, grant us the rights to use your contribution. For details, visit <a href="https://cla.microsoft.com">cla.microsoft.com</a>.</p>
<p>When you submit a pull request, a CLA-bot will automatically determine whether you need to provide a CLA and decorate the PR appropriately (e.g., label, comment). Simply follow the instructions provided by the bot. You will only need to do this once across all repos using our CLA.</p>
<p>This project has adopted the <a href="https://opensource.microsoft.com/codeofconduct/">Microsoft Open Source Code of Conduct</a>. For more information see the <a href="https://opensource.microsoft.com/codeofconduct/faq/">Code of Conduct FAQ</a> or contact <a href="mailto:opencode@microsoft.com">opencode@microsoft.com</a> with any additional questions or comments.</p>
<!-- LINKS -->
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Azure SDK for .NET
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="./styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="./styles/docfx.js"></script>
    <script type="text/javascript" src="./styles/main.js"></script>
  </body>
</html>
