<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Azure Confidential Ledger client library for .NET | Azure SDK for .NET </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Azure Confidential Ledger client library for .NET | Azure SDK for .NET ">
    <meta name="generator" content="docfx 2.43.2.0">
    
    <link rel="shortcut icon" href="./https://c.s-microsoft.com/favicon.ico?v2">
    <link rel="stylesheet" href="./styles/docfx.vendor.css">
    <link rel="stylesheet" href="./styles/docfx.css">
    <link rel="stylesheet" href="./styles/main.css">
    <meta property="docfx:navrel" content="./toc.html">
    <meta property="docfx:tocrel" content="./api/toc.html">
    
    
    <meta property="docfx:newtab" content="true">
  
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async="" src="https://www.googletagmanager.com/gtag/js?id=UA-62780441-41"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());
  
      gtag('config', 'UA-62780441-41');
    </script>
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="./index.html">
                <img id="logo" class="svg" src="./logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="azure-confidential-ledger-client-library-for-net">Azure Confidential Ledger client library for .NET</h1>

<p>Azure Confidential Ledger provides a service for logging to an immutable, tamper-proof ledger. As part of the <a href="https://azure.microsoft.com/solutions/confidential-compute">Azure Confidential Computing</a>
portfolio, Azure Confidential Ledger runs in SGX enclaves. It is built on Microsoft Research's <a href="https://github.com/Microsoft/CCF">Confidential Consortium Framework</a>.</p>
<p><a href="https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/confidentialledger/Azure.Security.ConfidentialLedger">Source code</a> | <a href="https://www.nuget.org/packages?q=Azure.Security.ConfidentialLedger">Package (NuGet)</a> <!--| [API reference documentation][api_reference] | [Samples][samples] --></p>
<h2 id="getting-started">Getting started</h2>
<p>This section should include everything a developer needs to do to install and create their first client connection <em>very quickly</em>.</p>
<h3 id="install-the-package">Install the package</h3>
<p>Install the Confidential Ledger client library for .NET with <a href="https://www.nuget.org/packages?q=Azure.Security.ConfidentialLedger">NuGet</a>:</p>
<pre><code class="lang-dotnetcli">dotnet add package Azure.Security.ConfidentialLedger --prerelease
</code></pre>
<h3 id="prerequisites">Prerequisites</h3>
<ul>
<li>An <a href="https://azure.microsoft.com/free/dotnet/">Azure subscription</a>.</li>
<li>A running instance of Azure Confidential Ledger.</li>
<li>A registered user in the Confidential Ledger with <code>Administrator</code> privileges.</li>
</ul>
<h3 id="authenticate-the-client">Authenticate the client</h3>
<h4 id="using-azure-active-directory">Using Azure Active Directory</h4>
<p>This document demonstrates using <a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/identity/Azure.Identity/README.md#defaultazurecredential">DefaultAzureCredential</a> to authenticate to the Confidential Ledger via Azure Active Directory. However, any of the credentials offered by the <a href="https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/identity/Azure.Identity">Azure.Identity</a> will be accepted.  See the <a href="https://github.com/Azure/azure-sdk-for-net/tree/main/sdk/identity/Azure.Identity">Azure.Identity</a> documentation for more information about other credentials.</p>
<h4 id="using-a-client-certificate">Using a client certificate</h4>
<p>As an alternative to Azure Active Directory, clients may choose to use a client certificate to authenticate via mutual TLS.</p>
<h3 id="create-a-client">Create a client</h3>
<p><code>DefaultAzureCredential</code> will automatically handle most Azure SDK client scenarios. To get started, set environment variables for the AAD identity registered with your Confidential Ledger.</p>
<pre><code class="lang-bash">export AZURE_CLIENT_ID=&quot;generated app id&quot;
export AZURE_CLIENT_SECRET=&quot;random password&quot;
export AZURE_TENANT_ID=&quot;tenant id&quot;
</code></pre>
<p>Then, <code>DefaultAzureCredential</code> will be able to authenticate the <code>ConfidentialLedgerClient</code>.</p>
<p>Constructing the client also requires your Confidential Ledger's URL and id, which you can get from the Azure CLI or the Azure Portal.  When you have retrieved those values, please replace instances of <code>&quot;my-ledger-id&quot;</code> and <code>&quot;https://my-ledger-url.confidential-ledger.azure.com&quot;</code> in the examples below</p>
<p>Because Confidential Ledgers use self-signed certificates securely generated and stored in an SGX enclave, the certificate for each Confidential Ledger  must first be retrieved from the Confidential Ledger Identity Service.</p>
<pre><code class="lang-C#">Uri identityServiceEndpoint = new(&quot;https://identity.confidential-ledger.core.azure.com&quot;) // The hostname from the identityServiceUri
var identityClient = new ConfidentialLedgerIdentityServiceClient(identityServiceEndpoint);

// Get the ledger's  TLS certificate for our ledger.
string ledgerId = &quot;&lt;the ledger id&gt;&quot;; // ex. &quot;my-ledger&quot; from &quot;https://my-ledger.eastus.cloudapp.azure.com&quot;
Response response = identityClient.GetLedgerIdentity(ledgerId);
X509Certificate2 ledgerTlsCert = ConfidentialLedgerIdentityServiceClient.ParseCertificate(response);
</code></pre>
<p>Now we can construct the <code>ConfidentialLedgerClient</code> with a transport configuration that trusts the <code>ledgerTlsCert</code>.</p>
<pre><code class="lang-C#">// Create a certificate chain rooted with our TLS cert.
X509Chain certificateChain = new();
certificateChain.ChainPolicy.RevocationMode = X509RevocationMode.NoCheck;
certificateChain.ChainPolicy.RevocationFlag = X509RevocationFlag.ExcludeRoot;
certificateChain.ChainPolicy.VerificationFlags = X509VerificationFlags.AllowUnknownCertificateAuthority;
certificateChain.ChainPolicy.VerificationTime = DateTime.Now;
certificateChain.ChainPolicy.UrlRetrievalTimeout = new TimeSpan(0, 0, 0);
certificateChain.ChainPolicy.ExtraStore.Add(ledgerTlsCert);

var f = certificateChain.Build(ledgerTlsCert);

// Define a validation function to ensure that the ledger certificate is trusted by the ledger identity TLS certificate.
bool CertValidationCheck(HttpRequestMessage httpRequestMessage, X509Certificate2 cert, X509Chain x509Chain, SslPolicyErrors sslPolicyErrors)
{
    bool isChainValid = certificateChain.Build(cert);
    if (!isChainValid) return false;

    var isCertSignedByTheTlsCert = certificateChain.ChainElements.Cast&lt;X509ChainElement&gt;()
        .Any(x =&gt; x.Certificate.Thumbprint == ledgerTlsCert.Thumbprint);
    return isCertSignedByTheTlsCert;
}

// Create an HttpClientHandler to use our certValidationCheck function.
var httpHandler = new HttpClientHandler();
httpHandler.ServerCertificateCustomValidationCallback = CertValidationCheck;

// Create the ledger client using a transport that uses our custom ServerCertificateCustomValidationCallback.
var options = new ConfidentialLedgerClientOptions { Transport = new HttpClientTransport(httpHandler) };
var ledgerClient = new ConfidentialLedgerClient(TestEnvironment.ConfidentialLedgerUrl, new DefaultAzureCredential(), options);
</code></pre>
<h2 id="key-concepts">Key concepts</h2>
<h3 id="ledger-entries">Ledger entries</h3>
<p>Every write to Confidential Ledger generates an immutable ledger entry in the service. Writes are uniquely identified by transaction ids that increment with each write.</p>
<pre><code class="lang-C#">PostLedgerEntryOperation postOperation = ledgerClient.PostLedgerEntry(
    RequestContent.Create(
        new { contents = &quot;Hello world!&quot; }),
    waitForCompletion: true);

string transactionId = postOperation.Id;
Console.WriteLine($&quot;Appended transaction with Id: {transactionId}&quot;);
</code></pre>
<p>Since Confidential Ledger is a distributed system, rare transient failures may cause writes to be lost. For entries that must be preserved, it is advisable to verify that the write became durable. Note: It may be necessary to call <code>GetTransactionStatus</code> multiple times until it returns a &quot;Committed&quot; status. However, when calling <code>PostLedgerEntry</code>, a successful result indicates that the status is &quot;Committed&quot;.</p>
<pre><code class="lang-C#">Response statusResponse = ledgerClient.GetTransactionStatus(transactionId);

string status = JsonDocument.Parse(statusResponse.Content)
    .RootElement
    .GetProperty(&quot;state&quot;)
    .GetString();

Console.WriteLine($&quot;Transaction status: {status}&quot;);

// Wait for the entry to be committed
while (status == &quot;Pending&quot;)
{
    statusResponse = ledgerClient.GetTransactionStatus(transactionId);
    status = JsonDocument.Parse(statusResponse.Content)
        .RootElement
        .GetProperty(&quot;state&quot;)
        .GetString();
}

Console.WriteLine($&quot;Transaction status: {status}&quot;);
</code></pre>
<h4 id="receipts">Receipts</h4>
<p>State changes to the Confidential Ledger are saved in a data structure called a Merkle tree. To cryptographically verify that writes were correctly saved, a Merkle proof, or receipt, can be retrieved for any transaction id.</p>
<pre><code class="lang-C#">Response receiptResponse = ledgerClient.GetReceipt(transactionId);
string receiptJson = new StreamReader(receiptResponse.ContentStream).ReadToEnd();

Console.WriteLine(receiptJson);
</code></pre>
<h4 id="sub-ledgers">Sub-ledgers</h4>
<p>While most use cases will involve one ledger, we provide the sub-ledger feature in case different logical groups of data need to be stored in the same Confidential Ledger.</p>
<pre><code class="lang-C#">ledgerClient.PostLedgerEntry(
    RequestContent.Create(
        new { contents = &quot;Hello from Chris!&quot;, subLedgerId = &quot;Chris' messages&quot; }),
    waitForCompletion: true);

ledgerClient.PostLedgerEntry(
    RequestContent.Create(
        new { contents = &quot;Hello from Allison!&quot;, subLedgerId = &quot;Allison's messages&quot; }),
    waitForCompletion: true);
</code></pre>
<p>When no sub-ledger id is specified on method calls, the Confidential Ledger service will assume a constant, service-determined sub-ledger id.</p>
<pre><code class="lang-C#">Response postResponse = ledgerClient.PostLedgerEntry(
    RequestContent.Create(
        new { contents = &quot;Hello world!&quot; }),
    waitForCompletion: true);
string transactionId = postOperation.Id;
string subLedgerId = &quot;subledger:0&quot;;

// Provide both the transactionId and subLedgerId.
Response getBySubledgerResponse = ledgerClient.GetLedgerEntry(transactionId,  subLedgerId);

// Try until the entry is available.
bool loaded = false;
JsonElement element = default;
string contents = null;
while (!loaded)
{
    loaded = JsonDocument.Parse(getBySubledgerResponse.Content)
        .RootElement
        .TryGetProperty(&quot;entry&quot;, out element);
    if (loaded)
    {
        contents = element.GetProperty(&quot;contents&quot;).GetString();
    }
    else
    {
        getBySubledgerResponse = ledgerClient.GetLedgerEntry(transactionId, subLedgerId);
    }
}

Console.WriteLine(contents); // &quot;Hello world!&quot;

// Now just provide the transactionId.
getBySubledgerResponse = ledgerClient.GetLedgerEntry(transactionId);

string subLedgerId2 = JsonDocument.Parse(getBySubledgerResponse.Content)
    .RootElement
    .GetProperty(&quot;entry&quot;)
    .GetProperty(&quot;subLedgerId&quot;)
    .GetString();

Console.WriteLine($&quot;{subLedgerId} == {subLedgerId2}&quot;);
</code></pre>
<p>Ledger entries are retrieved from sub-ledgers. When a transaction id is specified, the returned value is the value contained in the specified sub-ledger at the point in time identified by the transaction id. If no transaction id is specified, the latest available value is returned.</p>
<pre><code class="lang-C#">PostLedgerEntryOperation firstPostOperation = ledgerClient.PostLedgerEntry(
    RequestContent.Create(new { contents = &quot;Hello world 0&quot; }),
    waitForCompletion: true);
ledgerClient.PostLedgerEntry(
    RequestContent.Create(new { contents = &quot;Hello world 1&quot; }),
    waitForCompletion: true);
PostLedgerEntryOperation subLedgerPostOperation = ledgerClient.PostLedgerEntry(
    RequestContent.Create(new { contents = &quot;Hello world sub-ledger 0&quot; }),
    &quot;my sub-ledger&quot;,
    waitForCompletion: true);
ledgerClient.PostLedgerEntry(
    RequestContent.Create(new { contents = &quot;Hello world sub-ledger 1&quot; }),
    &quot;my sub-ledger&quot;,
    waitForCompletion: true);

string transactionId = firstPostOperation.Id;

// Wait for the entry to be committed
status = &quot;Pending&quot;;
while (status == &quot;Pending&quot;)
{
    statusResponse = ledgerClient.GetTransactionStatus(transactionId);
    status = JsonDocument.Parse(statusResponse.Content)
        .RootElement
        .GetProperty(&quot;state&quot;)
        .GetString();
}

// The ledger entry written at the transactionId in firstResponse is retrieved from the default sub-ledger.
Response getResponse = ledgerClient.GetLedgerEntry(transactionId);

// Try until the entry is available.
loaded = false;
element = default;
contents = null;
while (!loaded)
{
    loaded = JsonDocument.Parse(getResponse.Content)
        .RootElement
        .TryGetProperty(&quot;entry&quot;, out element);
    if (loaded)
    {
        contents = element.GetProperty(&quot;contents&quot;).GetString();
    }
    else
    {
        getResponse = ledgerClient.GetLedgerEntry(transactionId, subLedgerId);
    }
}

string firstEntryContents = JsonDocument.Parse(getResponse.Content)
    .RootElement
    .GetProperty(&quot;entry&quot;)
    .GetProperty(&quot;contents&quot;)
    .GetString();

Console.WriteLine(firstEntryContents); // &quot;Hello world 0&quot;

// This will return the latest entry available in the default sub-ledger.
getResponse = ledgerClient.GetCurrentLedgerEntry();

// Try until the entry is available.
loaded = false;
element = default;
string latestDefaultSubLedger = null;
while (!loaded)
{
    loaded = JsonDocument.Parse(getResponse.Content)
        .RootElement
        .TryGetProperty(&quot;contents&quot;, out element);
    if (loaded)
    {
        latestDefaultSubLedger = element.GetString();
    }
    else
    {
        getResponse = ledgerClient.GetCurrentLedgerEntry();
    }
}

Console.WriteLine($&quot;The latest ledger entry from the default sub-ledger is {latestDefaultSubLedger}&quot;); //&quot;Hello world 1&quot;

// The ledger entry written at subLedgerTransactionId is retrieved from the sub-ledger 'sub-ledger'.
string subLedgerTransactionId = subLedgerPostOperation.Id;

getResponse = ledgerClient.GetLedgerEntry(subLedgerTransactionId, &quot;my sub-ledger&quot;);
// Try until the entry is available.
loaded = false;
element = default;
string subLedgerEntry = null;
while (!loaded)
{
    loaded = JsonDocument.Parse(getResponse.Content)
        .RootElement
        .TryGetProperty(&quot;entry&quot;, out element);
    if (loaded)
    {
        subLedgerEntry = element.GetProperty(&quot;contents&quot;).GetString();
    }
    else
    {
        getResponse = ledgerClient.GetLedgerEntry(subLedgerTransactionId, &quot;my sub-ledger&quot;);
    }
}

Console.WriteLine(subLedgerEntry); // &quot;Hello world sub-ledger 0&quot;

// This will return the latest entry available in the sub-ledger.
getResponse = ledgerClient.GetCurrentLedgerEntry(&quot;my sub-ledger&quot;);
string latestSubLedger = JsonDocument.Parse(getResponse.Content)
    .RootElement
    .GetProperty(&quot;contents&quot;)
    .GetString();

Console.WriteLine($&quot;The latest ledger entry from the sub-ledger is {latestSubLedger}&quot;); // &quot;Hello world sub-ledger 1&quot;
</code></pre>
<h5 id="ranged-queries">Ranged queries</h5>
<p>Ledger entries in a sub-ledger may be retrieved over a range of transaction ids.
Note: Both ranges are optional; they can be provided individually or not at all.</p>
<pre><code class="lang-C#">ledgerClient.GetLedgerEntries(fromTransactionId: &quot;2.1&quot;, toTransactionId: subLedgerTransactionId);
</code></pre>
<h3 id="user-management">User management</h3>
<p>Users are managed directly with the Confidential Ledger instead of through Azure. New users may be AAD-based or certificate-based.</p>
<pre><code class="lang-C#">string newUserAadObjectId = &quot;&lt;some AAD user or service princpal object Id&gt;&quot;;
ledgerClient.CreateOrUpdateUser(
    newUserAadObjectId,
    RequestContent.Create(new { assignedRole = &quot;Reader&quot; }));
</code></pre>
<h3 id="confidential-consortium-and-enclave-verifications">Confidential consortium and enclave verifications</h3>
<p>One may want to validate details about the Confidential Ledger for a variety of reasons. For example, you may want to view details about how Microsoft may manage your Confidential Ledger as part of <a href="https://microsoft.github.io/CCF/main/governance/index.html">Confidential Consortium Framework governance</a>, or verify that your Confidential Ledger is indeed running in SGX enclaves. A number of client methods are provided for these use cases.</p>
<pre><code class="lang-C#">Response consortiumResponse = ledgerClient.GetConsortiumMembers();
string membersJson = new StreamReader(consortiumResponse.ContentStream).ReadToEnd();

// Consortium members can manage and alter the Confidential Ledger, such as by replacing unhealthy nodes.
Console.WriteLine(membersJson);

// The constitution is a collection of JavaScript code that defines actions available to members,
// and vets proposals by members to execute those actions.
Response constitutionResponse = ledgerClient.GetConstitution();
string constitutionJson = new StreamReader(constitutionResponse.ContentStream).ReadToEnd();

Console.WriteLine(constitutionJson);

// Enclave quotes contain material that can be used to cryptographically verify the validity and contents of an enclave.
Response enclavesResponse = ledgerClient.GetEnclaveQuotes();
string enclavesJson = new StreamReader(enclavesResponse.ContentStream).ReadToEnd();

Console.WriteLine(enclavesJson);
</code></pre>
<p><a href="https://azure.microsoft.com/services/azure-attestation/">Microsoft Azure Attestation Service</a> is one provider of SGX enclave quotes.</p>
<h3 id="thread-safety">Thread safety</h3>
<p>We guarantee that all client instance methods are thread-safe and independent of each other (<a href="https://azure.github.io/azure-sdk/dotnet_introduction.html#dotnet-service-methods-thread-safety">guideline</a>). This ensures that the recommendation of reusing client instances is always safe, even across threads.</p>
<h3 id="additional-concepts">Additional concepts</h3>
<!-- CLIENT COMMON BAR -->
<p><a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/README.md#configuring-service-clients-using-clientoptions">Client options</a> |
<a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/README.md#accessing-http-response-details-using-responset">Accessing the response</a> |
<a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/README.md#consuming-long-running-operations-using-operationt">Long-running operations</a> |
<a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/README.md#reporting-errors-requestfailedexception">Handling failures</a> |
<a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/Diagnostics.md">Diagnostics</a> |
<a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/README.md#mocking">Mocking</a> |
<a href="https://devblogs.microsoft.com/azure-sdk/lifetime-management-and-thread-safety-guarantees-of-azure-sdk-net-clients/">Client lifetime</a></p>
<!-- CLIENT COMMON BAR -->
<h2 id="examples">Examples</h2>
<p>Coming Soon...</p>
<h2 id="troubleshooting">Troubleshooting</h2>
<p>Response values returned from Confidential Ledger client methods are <code>Response</code> objects, which contain information about the http response such as the http <code>Status</code> property and a <code>Headers</code> object containing more information about the failure.</p>
<h3 id="setting-up-console-logging">Setting up console logging</h3>
<p>The simplest way to see the logs is to enable the console logging.
To create an Azure SDK log listener that outputs messages to console use AzureEventSourceListener.CreateConsoleLogger method.</p>
<pre><code class="lang-C#">// Setup a listener to monitor logged events.
using AzureEventSourceListener listener = AzureEventSourceListener.CreateConsoleLogger();
</code></pre>
<p>To learn more about other logging mechanisms see <a href="https://github.com/Azure/azure-sdk-for-net/blob/main/sdk/core/Azure.Core/samples/Diagnostics.md">here</a>.</p>
<h2 id="next-steps">Next steps</h2>
<p>For more extensive documentation on Azure Confidential Ledger, see the API <a href="https://azure.github.io/azure-sdk-for-net/">reference documentation</a>.
You may also read more about Microsoft Research's open-source Confidential <a href="https://github.com/Microsoft/CCF">Consortium Framework</a>.</p>
<h2 id="contributing">Contributing</h2>
<p>This project welcomes contributions and suggestions.  Most contributions require
you to agree to a Contributor License Agreement (CLA) declaring that you have
the right to, and actually do, grant us the rights to use your contribution. For
details, visit <a href="https://cla.microsoft.com">cla.microsoft.com</a>.</p>
<p>This project has adopted the <a href="https://opensource.microsoft.com/codeofconduct/">Microsoft Open Source Code of Conduct</a>.
For more information see the <a href="https://opensource.microsoft.com/codeofconduct/faq">Code of Conduct FAQ</a> or contact
<a href="mailto:opencode@microsoft.com">opencode@microsoft.com</a> with any additional questions or comments.</p>
<!-- LINKS -->
<p><img src="https://azure-sdk-impressions.azurewebsites.net/api/impressions/azure-sdk-for-net%2Fsdk%2Fconfidentialledger%2FAzure.Template%2FREADME.png" alt="Impressions"></p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            Azure SDK for .NET
            
          </div>
        </div>
      </footer>
    </div>
    
    <script type="text/javascript" src="./styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="./styles/docfx.js"></script>
    <script type="text/javascript" src="./styles/main.js"></script>
  </body>
</html>
