<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Microsoft.CodeAnalysis.CSharp</name>
    </assembly>
    <members>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder">
            <summary>
            A Binder converts names in to symbols and syntax nodes into bound trees. It is context
            dependent, relative to a location in source code.
            </summary>
            <summary>
            This portion of the binder converts a AnonymousObjectCreationExpressionSyntax into 
            a bound anonymous object creation node
            </summary>
            <summary>
            This portion of the binder converts an AwaitExpressionSyntax into a BoundExpression
            </summary>
            <summary>
            This portion of the binder converts an <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax"/> into a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundExpression"/>.
            </summary>
            <summary>
            This portion of the binder converts an <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax"/> into a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundExpression"/>.
            </summary>
            <summary>
            This portion of the binder converts a QueryExpressionSyntax into a BoundExpression
            </summary>
            <summary>
            This portion of the binder reports errors arising from resolving queries.
            </summary>
            <summary>
            This portion of the binder converts StatementSyntax nodes into BoundStatements
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.Next">
            <summary>
            Get the next binder in which to look up a name, if not found by this binder.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.CheckOverflow">
            <summary>
            <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Enabled"/> if we are in an explicitly checked context (within checked block or expression).
            <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Disabled"/> if we are in an explcitly unchecked context (within unchecked block or expression).
            <see cref="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Implicit"/> otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.CheckOverflowAtRuntime">
            <summary>
            True if instructions that check overflow should be generated.
            </summary>
            <remarks>
            Spec 7.5.12:
            For non-constant expressions (expressions that are evaluated at run-time) that are not 
            enclosed by any checked or unchecked operators or statements, the default overflow checking
            context is unchecked unless external factors (such as compiler switches and execution 
            environment configuration) call for checked evaluation.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.CheckOverflowAtCompileTime">
            <summary>
            True if the compiler should check for overflow while evaluating constant expressions.
            </summary>
            <remarks>
            Spec 7.5.12:
            For constant expressions (expressions that can be fully evaluated at compile-time), 
            the default overflow checking context is always checked. Unless a constant expression 
            is explicitly placed in an unchecked context, overflows that occur during the compile-time 
            evaluation of the expression always cause compile-time errors.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetBinder(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Some nodes have special binder's for their contents (like Block's)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetDeclaredLocalsForScope(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Get locals declared immediately in scope represented by the node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ContainingMemberOrLambda">
            <summary>
            The member containing the binding context.  Note that for the purposes of the compiler,
            a lambda expression is considered a "member" of its enclosing method, field, or lambda.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.IsInMethodBody">
            <summary>
            Is the contained code within a member method body?
            </summary>
            <remarks>
            May be false in lambdas that are outside of member method bodies, e.g. lambdas in
            field initializers.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.IsDirectlyInIterator">
            <summary>
            Is the contained code within an iterator block?
            </summary>
            <remarks>
            Will be false in a lambda in an iterator.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.IsIndirectlyInIterator">
            <summary>
            Is the contained code within the syntactic span of an
            iterator method?
            </summary>
            <remarks>
            Will be true in a lambda in an iterator.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.BreakLabel">
            <summary>
            If we are inside a context where a break statement is legal,
            returns the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedLabelSymbol"/> that a break statement would branch to.
            Returns null otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ContinueLabel">
            <summary>
            If we are inside a context where a continue statement is legal,
            returns the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.GeneratedLabelSymbol"/> that a continue statement would branch to.
            Returns null otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetIteratorElementType(Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Get the element type of this iterator.
            </summary>
            <param name="node">Node to report diagnostics, if any, such as "yield statement cannot be used
            inside a lambda expression"</param>
            <param name="diagnostics">Where to place any diagnostics</param>
            <returns>Element type of the current iterator, or an error type.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ImportChain">
            <summary>
            The Imports for all containing namespace declarations (innermost-to-outermost, including global).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ContainingType">
            <summary>
            The type containing the binding context
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.BindingTopLevelScriptCode">
            <summary>
            Returns true if the binder is binding top-level script code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportDiagnosticsIfObsolete(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.SyntaxNodeOrToken,System.Boolean)">
            <summary>
            Issue an error or warning for a symbol if it is Obsolete. If there is not enough
            information to report diagnostics, then store the symbols so that diagnostics
            can be reported at a later stage.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportDiagnosticsIfObsoleteInternal(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.SyntaxNodeOrToken,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BinderFlags)">
            <returns>
            True if the symbol is definitely obsolete.
            False if the symbol is definitely not obsolete.
            Unknown if the symbol may be obsolete.
            
            NOTE: The return value reflects obsolete-ness, not whether or not the diagnostic was reported.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind">
            <summary>
            Expression lvalue and rvalue requirements.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.RValue">
            <summary>
            Expression is the RHS of an assignment operation.
            </summary>
            <remarks>
            The following are rvalues: values, variables, null literals, properties
            and indexers with getters, events. The following are not rvalues:
            namespaces, types, method groups, anonymous functions.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.RValueOrMethodGroup">
            <summary>
            Expression is the RHS of an assignment operation
            and may be a method group.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.Assignment">
            <summary>
            Expression is the LHS of a simple assignment operation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.IncrementDecrement">
            <summary>
            Expression is the operand of an increment
            or decrement operation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.CompoundAssignment">
            <summary>
            Expression is the LHS of a compound assignment
            operation (such as +=).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.OutParameter">
            <summary>
            Expression is an out parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.AddressOf">
            <summary>
            Expression is the operand of an address-of operation (&amp;).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind.FixedReceiver">
            <summary>
            Expression is the receiver of a fixed buffer field access
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUseSiteDiagnosticForSynthesizedAttribute(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Report diagnostics that should be reported when using a synthesized attribute. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Implicit">
            <summary>
            Outside of <c>checked</c>, <c>unchecked</c> expression/block.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Disabled">
            <summary>
            Within <c>unchecked</c> expression/block.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Binder.OverflowChecks.Enabled">
            <summary>
            Within <c>checked</c> expression/block.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.RangeVariableMap">
            <summary>
            We represent the set of query variables in scope at a particular point by a RangeVariableMap.
            Each query variable in scope has a key in this map.  If the corresponding value is empty, then
            that query variable is represented directly by a lambda parameter.  If it is non-empty, then
            to get the value of that query variable one starts with the first parameter of the current
            lambda (the first parameter is always the transparent one), and dot through its members using
            the names in the value list, in reverse order.  So, for example, if the query variable "x" has
            a value in this map of ["Item2", "Item1", "Item1"], then the way to compute the value of that
            query variable is starting with the current lambda's first parameter P, compute "P.Item1.Item1.Item2".
            See also WithQueryLambdaParametersBinder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsAnonymousTypesAllowed">
            <summary>
            Actually, defines if an error ERR_AnonymousTypeNotAvailable is to be generated; 
            
            Dev10 rules (which are based on BindingContext::InMethod()) are difficult to 
            reproduce, so this implementation checks both current symbol as well as syntax nodes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetAnonymousTypeFieldType(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@)">
            <summary>
            Returns the type to be used as a field type; generates errors in case the type is not
            supported for anonymous type fields.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetRewrittenAttributeConstructorArguments(System.Collections.Immutable.ImmutableArray{System.Int32}@,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TypedConstant},System.Collections.Immutable.ImmutableArray{System.String},Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@)">
            <summary>
            Gets the rewritten attribute constructor arguments, i.e. the arguments
            are in the order of parameters, which may differ from the source
            if named constructor arguments are used.
            
            For example:
                void Foo(int x, int y, int z, int w = 3);
            
                Foo(0, z: 2, y: 1);
                
                Arguments returned: 0, 1, 2, 3
            </summary>
            <returns>Rewritten attribute constructor arguments</returns>
            <remarks>
            CONSIDER: Can we share some code will call rewriting in the local rewriter?
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.AttributeExpressionVisitor">
            <summary>
            Walk a custom attribute argument bound node and return a TypedConstant.  Verify that the expression is a constant expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CouldBeAwaited(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Return true iff an await with this subexpression would be legal where the expression appears.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ContextForbidsAwait">
            <summary>
            Assuming we are in an async method, return true if we're in a context where await would be illegal.
            Specifically, return true if we're in a lock, catch, or finally.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportBadAwaitWithoutAsync(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Reports an error if the await expression did not occur in an async context.
            </summary>
            <returns>True if the expression contains errors.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportBadAwaitContext(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Report diagnostics if the await expression occurs in a context where it is not allowed.
            </summary>
            <returns>True if errors were found.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetAwaitableExpressionInfo(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@,Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol@,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Finds and validates the required members of an awaitable expression, as described in spec 7.7.7.1.
            </summary>
            <returns>True if the expression is awaitable; false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ValidateAwaitedExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Validates the awaited expression, returning true if no errors are found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetGetAwaiterMethod(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@)">
            <summary>
            Finds the GetAwaiter method of an awaitable expression.
            </summary>
            <remarks>
            Spec 7.7.7.1:
            An awaitable expression t has an accessible instance or extension method called GetAwaiter with no
            parameters and no type parameters, and a return type A that meets the additional requirements for an
            Awaiter.
            NOTE: this is an error in the spec.  An extension method of the form
            Awaiter&lt;T&gt; GetAwaiter&lt;T&gt;(this Task&lt;T&gt;) may be used.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetIsCompletedProperty(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol@)">
            <summary>
            Finds the IsCompleted property of an Awaiter type.
            </summary>
            <remarks>
            Spec 7.7.7.1:
            An Awaiter A has an accessible, readable instance property IsCompleted of type bool.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.AwaiterImplementsINotifyCompletion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Checks that the Awaiter implements System.Runtime.CompilerServices.INotifyCompletion.
            </summary>
            <remarks>
            Spec 7.7.7.1:
            An Awaiter A implements the interface System.Runtime.CompilerServices.INotifyCompletion.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetGetResultMethod(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol@)">
            <summary>
            Finds the GetResult method of an Awaiter type.
            </summary>
            <remarks>
            Spec 7.7.7.1:
            An Awaiter A has an accessible instance method GetResult with no parameters and no type parameters.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeParameterConstraintClauses(Microsoft.CodeAnalysis.CSharp.Symbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Return a collection of bound constraint clauses indexed by type parameter
            ordinal. All constraint clauses are bound, even if there are multiple constraints
            for the same type parameter, or constraints for unrecognized type parameters.
            Extra constraints are not included in the returned collection however.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeParameterConstraints(System.String,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax},Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Bind and return a single type parameter constraint clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsValidConstraintType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Returns true if the type is a valid constraint type.
            Otherwise returns false and generates a diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MemberGroupFinalValidation(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
            <summary>
            This method implements the algorithm in spec section 7.6.5.1.
            
            For method group conversions, there are situations in which the conversion is
            considered to exist ("Otherwise the algorithm produces a single best method M having
            the same number of parameters as D and the conversion is considered to exist"), but
            application of the conversion fails.  These are the "final validation" steps of
            overload resolution.
            </summary>
            <returns>
            True if there is any error.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MemberGroupFinalValidationAccessibilityChecks(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
             <summary>
             Performs the following checks:
             
             Spec 7.6.5: Invocation expressions (definition of Final Validation) 
               The method is validated in the context of the method group: If the best method is a static method, 
               the method group must have resulted from a simple-name or a member-access through a type. If the best 
               method is an instance method, the method group must have resulted from a simple-name, a member-access
               through a variable or value, or a base-access. If neither of these requirements is true, a binding-time
               error occurs.
               (Note that the spec omits to mention, in the case of an instance method invoked through a simple name, that
               the invocation must appear within the body of an instance method)
            
             Spec 7.5.4: Compile-time checking of dynamic overload resolution 
               If F is a static method, the method group must have resulted from a simple-name, a member-access through a type, 
               or a member-access whose receiver can’t be classified as a type or value until after overload resolution (see §7.6.4.1). 
               If F is an instance method, the method group must have resulted from a simple-name, a member-access through a variable or value,
               or a member-access whose receiver can’t be classified as a type or value until after overload resolution (see §7.6.4.1).
             </summary>
             <returns>
             True if there is any error.
             </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.WasImplicitReceiver(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Was the receiver expression compiler-generated?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MethodGroupIsCompatibleWithDelegate(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            This method implements the checks in spec section 15.2.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MethodGroupConversionHasErrors(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            This method combines final validation (section 7.6.5.1) and delegate compatibility (section 15.2).
            </summary>
            <param name="syntax">CSharpSyntaxNode of the expression requiring method group conversion.</param>
            <param name="conversion">Conversion to be performed.</param>
            <param name="receiverOpt">Optional receiver.</param>
            <param name="isExtensionMethod">Method invoked as extension method.</param>
            <param name="delegateType">Target delegate type.</param>
            <param name="diagnostics">Where diagnostics should be added.</param>
            <returns>True if a diagnostic has been added.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MethodGroupConversionDoesNotExistOrHasErrors(Microsoft.CodeAnalysis.CSharp.BoundMethodGroup,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Conversion@)">
            <summary>
            This method is a wrapper around MethodGroupConversionHasErrors.  As a preliminary step,
            it checks whether a conversion exists.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindNamespaceOrTypeSymbolInCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>
            We can't use BindNamespaceOrTypeSymbol, since it doesn't return inaccessible symbols (directly).
            </summary>
            <remarks>
            Guaranteed not to return null.
            
            CONSIDER: As in dev11, we don't handle ambiguity at this level.  Hypothetically,
            we could just pick one, though an "ideal" solution would probably involve a search
            down all ambiguous branches.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ComputeSortedCrefMembers(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.Int32,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Perform lookup (optionally, in a specified container).  If nothing is found and the member name matches the containing type
            name, then use the instance constructors of the type instead.  The resulting symbols are sorted since tie-breaking is based
            on order and we want cref binding to be repeatable.
            </summary>
            <remarks>
            Never returns null.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ProcessCrefMemberLookupResults(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Symbol@,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Given a list of viable lookup results (based on the name, arity, and containing symbol),
            attempt to select one.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ProcessParameterlessCrefMemberLookupResults(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Symbol@,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            At this point, we have a list of viable symbols and no parameter list with which to perform
            overload resolution.  We'll just return the first symbol, giving a diagnostic if there are
            others.
            Caveat: If there are multiple candidates and only one is from source, then the source symbol
            wins and no diagnostic is reported.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetCrefOverloadResolutionCandidates(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Replace any named type in the symbol list with its instance constructors.
            Construct all candidates with the implicitly-declared CrefTypeParameterSymbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.PerformCrefOverloadResolution(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax,Microsoft.CodeAnalysis.CSharp.Symbol@,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Given a list of method and/or property candidates, choose the first one (if any) with a signature
            that matches the parameter list in the cref.  Return null if there isn't one.
            </summary>
            <remarks>
            Produces a diagnostic for ambiguous matches, but not for unresolved members - WRN_BadXMLRef is
            handled in BindMemberCref.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ConstructWithCrefTypeParameters(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            If the member is generic, construct it with the CrefTypeParameterSymbols that should be in scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindCrefParameterOrReturnType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
            <remarks>
            Keep in sync with CSharpSemanticModel.GetSpeculativelyBoundExpression.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.HasThis(System.Boolean,System.Boolean@)">
            <summary>
            Determines whether "this" reference is available within the current context.
            </summary>
            <param name="isExplicit">The reference was explicitly specified in syntax.</param>
            <param name="inStaticContext">True if "this" is not available due to the current method/property/field initializer being static.</param>
            <returns>True if a reference to "this" is available.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsUnboundTypeAllowed(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax)">
            <summary>
            Returns true if the node is in a position where an unbound type
            such as (C&lt;,&gt;) is allowed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, and the given bound child.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundNode[])">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, and the given bound children.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind)">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookup resultKind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind,Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookup resultKind and the given bound child.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind,Microsoft.CodeAnalysis.CSharp.BoundNode[])">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookup resultKind and the given bound children.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookupResultKind and given symbols for GetSemanticInfo API.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookupResultKind and given symbols for GetSemanticInfo API,
            and the given bound child.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.BoundNode[])">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookupResultKind and given symbols for GetSemanticInfo API,
            and the given bound children.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BadExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.LookupResultKind,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            Generates a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> with no known type, given lookupResultKind and given symbols for GetSemanticInfo API,
            and the given bound children.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ToBadExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.LookupResultKind)">
            <summary>
            Helper method to generate a bound expression with HasErrors set to true.
            Returned bound expression is guaranteed to have a non-null type, except when <paramref name="expr"/> is an unbound lambda.
            If <paramref name="expr"/> already has errors and meets the above type requirements, then it is returned unchanged.
            Otherwise, if <paramref name="expr"/> is a BoundBadExpression, then it is updated with the <paramref name="resultKind"/> and non-null type.
            Otherwise, a new <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> wrapping <paramref name="expr"/> is returned. 
            </summary>
            <remarks>
            Returned expression need not be a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/>, but is guaranteed to have HasErrors set to true.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindValue(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind)">
            <summary>
            Bind the expression and verify the expression matches the combination of lvalue and
            rvalue requirements given by valueKind. If the expression was bound successfully, but
            did not meet the requirements, the return value will be a <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundBadExpression"/> that
            (typically) wraps the subexpression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            This function is only needed for SemanticModel to perform binding for erroneous cases.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindIdentifier(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Binds a simple identifier.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindExplicitNullableCastFromNonNullable(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
             <summary>
             This implements the casting behavior described in section 6.2.3 of the spec:
             
             - If the nullable conversion is from S to T?, the conversion is evaluated as the underlying conversion 
               from S to T followed by a wrapping from T to T?.
            
             This particular check is done in the binder because it involves conversion processing rules (like overflow
             checking and constant folding) which are not handled by Conversions.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetNameSyntax(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.String@)">
            <summary>
            Gets the NameSyntax associated with the syntax node
            If no syntax is attached it sets the nameString to plain text
            name and returns a null NameSyntax
            </summary>
            <param name="syntax">Syntax node</param>
            <param name="nameString">Plain text name</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetName(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Gets the plain text name associated with the expression syntax node
            </summary>
            <param name="syntax">Expression syntax node</param>
            <returns>Plain text name</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindArrayInitializerExpressions(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.DiagnosticBag,System.Int32,System.Int32)">
            <summary>
            This method walks through the array's InitializerExpressionSyntax and binds all the initializer expressions recursively.
            NOTE: It doesn't convert the bound initializer expressions to array's element type.
            NOTE: This is done separately in ConvertAndBindArrayInitialization method below.
            </summary>
            <param name="initializer">Initializer Syntax.</param>
            <param name="exprBuilder">Bound expression builder.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="dimension">Current array dimension being processed.</param>
            <param name="rank">Rank of the array type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ConvertAndBindArrayInitialization(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol,System.Nullable{System.Int32}[],System.Int32,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Int32@)">
            <summary>
            Given an array of bound initializer expressions, this method converts these bound expressions
            to array's element type and generates a BoundArrayInitialization with the converted initializers.
            </summary>
            <param name="diagnostics">Diagnostics.</param>
            <param name="node">Initializer Syntax.</param>
            <param name="type">Array type.</param>
            <param name="knownSizes">Known array bounds.</param>
            <param name="dimension">Current array dimension being processed.</param>
            <param name="boundInitExpr">Array of bound initializer expressions.</param>
            <param name="boundInitExprIndex">
            Index into the array of bound initializer expressions to fetch the next bound expression.
            </param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Bind the (implicit or explicit) constructor initializer of a constructor symbol (in source).
            </summary>
            <param name="initializerArgumentListOpt">
            Null for implicit, 
            BaseConstructorInitializerSyntax.ArgumentList, or 
            ThisConstructorInitializerSyntax.ArgumentList, or 
            BaseClassWithArgumentsSyntax.ArgumentList for explicit.</param>
            <param name="constructor">Constructor containing the initializer.</param>
            <param name="diagnostics">Accumulates errors (e.g. unable to find constructor to invoke).</param>
            <returns>A bound expression for the constructor initializer call.</returns>
            <remarks>
            This method should be kept consistent with Compiler.BindConstructorInitializer (e.g. same error codes).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.TryPerformConstructorOverloadResolution(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,System.String,Microsoft.CodeAnalysis.Location,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.MemberResolutionResult{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol}@,System.Boolean)">
            <summary>
            Given the type containing constructors, gets the list of candidate instance constructors and uses overload resolution to determine which one should be called.
            </summary>
            <param name="typeContainingConstructors">The containing type of the constructors.</param>
            <param name="analyzedArguments">The already bound arguments to the constructor.</param>
            <param name="errorName">The name to use in diagnostics if overload resolution fails.</param>
            <param name="errorLocation">The location at which to report overload resolution result diagnostics.</param>
            <param name="suppressResultDiagnostics">True to suppress overload resolution result diagnostics (but not argument diagnostics).</param>
            <param name="diagnostics">Where diagnostics will be reported.</param>
            <param name="memberResolutionResult">If this method returns true, then it will contain a valid MethodResolutionResult.
            Otherwise, it may contain a MethodResolutionResult for an inaccessible constructor (in which case, it will incorrectly indicate success) or nothing at all.</param>
            <param name="candidateConstructors">Candidate instance constructors of type <paramref name="typeContainingConstructors"/> used for overload resolution.</param>
            <param name="allowProtectedConstructorsOfBaseType">It is always legal to access a protected base class constructor
            via a constructor initializer, but not from an object creation expression.</param>
            <returns>True if overload resolution successfully chose an accessible constructor.</returns>
            <remarks>
            The two-pass algorithm (accessible constructors, then all constructors) is the reason for the unusual signature
            of this method (i.e. not populating a pre-existing <see cref="T:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1"/>).
            Presently, rationalizing this behavior is not worthwhile.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindMemberAccess(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Binds a member access expression
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindLeftOfPotentialColorColorMemberAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Attempt to bind the LHS of a member access expression.  If this is a Color Color case (spec 7.6.4.1),
            then return a BoundExpression if we can easily disambiguate or a BoundTypeOrValueExpression if we
            cannot.  If this is not a Color Color case, then return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindMemberAccessWithBoundLeft(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Bind the RHS of a member access expression, given the bound LHS.
            It is assumed that CheckValue has not been called on the LHS.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MakeMemberAccessValue(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Create a value from the expression that can be used as a left-hand-side
            of a member access. This method special-cases method and property
            groups only. All other expressions are returned as is.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindMemberAccessReportError(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.String,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.DiagnosticInfo,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Report the error from member access lookup. Or, if there
            was no explicit error from lookup, report "no such member".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ImplementsWinRTAsyncInterface(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return true if the given type is or implements a WinRTAsyncInterface.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindMemberAccessBadResult(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.String,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.DiagnosticInfo,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.LookupResultKind)">
            <summary>
            Return a BoundExpression representing the invalid member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CombineExtensionMethodArguments(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments)">
            <summary>
            Combine the receiver and arguments of an extension method
            invocation into a single argument list to allow overload resolution
            to treat the invocation as a static method invocation with no receiver.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindMemberOfType(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.BoundMethodGroupFlags,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Binds a static or instance member access.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetSymbolOrMethodOrPropertyGroup(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.String,System.Int32,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@)">
            <summary>
            Given a viable LookupResult, report any ambiguity errors and return either a single
            non-method symbol or a method or property group. If the result set represents a
            collection of methods or a collection of properties where at least one of the properties
            is an indexed property, then 'methodOrPropertyGroup' is populated with the method or
            property group and the method returns null. Otherwise, the method returns a single
            symbol and 'methodOrPropertyGroup' is empty. (Since the result set is viable, there
            must be at least one symbol.) If the result set is ambiguous - either containing multiple
            members of different member types, or multiple properties but no indexed properties -
            then a diagnostic is reported for the ambiguity and a single symbol is returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ResolveMethodGroup(Microsoft.CodeAnalysis.CSharp.BoundMethodGroup,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,System.Boolean)">
            <summary>
            Perform lookup and overload resolution on methods defined directly on the class and any
            extension methods in scope. Lookup will occur for extension methods in all nested scopes
            as necessary until an appropriate method is found. If analyzedArguments is null, the first
            method group is returned, without overload resolution being performed. That method group
            will either be the methods defined on the receiver class directly (no extension methods)
            or the first set of extension methods.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.BinderWithContainingMemberOrLambda">
            <summary>
            Represents a small change from the enclosing/next binder.
            Can specify a BindingLocation and a ContainingMemberOrLambda.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Binder.BinderWithConditionalReceiver">
            <summary>
            Represents a small change from the enclosing/next binder.
            Can specify a receiver Expression for containing conditional member access.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.WithAdditionalFlagsAndContainingMemberOrLambda(Microsoft.CodeAnalysis.CSharp.BinderFlags,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            It seems to be common to do both of these things at once, so provide a way to do so
            without adding two links to the binder chain.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindRegularCSharpFieldInitializers(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer}},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundInitializer},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.ImportChain@)">
            <summary>
            In regular C#, all field initializers are assignments to fields and the assigned expressions
            may not reference instance members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindScriptFieldInitializers(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Collections.Immutable.ImmutableArray{System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer}},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundInitializer},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.ImportChain@)">
            <summary>
            In script C#, some field initializers are assignments to fields and others are global
            statements.  There are no restrictions on accessing instance members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.MakeInvocationExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Boolean,System.Boolean)">
            <summary>
            Helper method to create a synthesized method invocation expression.
            </summary>
            <param name="node">Syntax Node.</param>
            <param name="receiver">Receiver for the method call.</param>
            <param name="methodName">Method to be invoked on the receiver.</param>
            <param name="args">Arguments to the method call.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="typeArgsSyntax">Optional type arguments syntax.</param>
            <param name="typeArgs">Optional type arguments.</param>
            <param name="queryClause">The syntax for the query clause generating this invocation expression, if any.</param>
            <param name="allowFieldsAndProperties">True to allow invocation of fields and properties of delegate type. Only methods are allowed otherwise.</param>
            <param name="allowUnexpandedForm">False to prevent selecting a params method in unexpanded form.</param>
            <returns>Synthesized method invocation expression.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Bind an expression as a method invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.String,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Boolean)">
            <summary>
            Bind an expression as a method invocation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindInvocationExpressionContinued(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.String,Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol},Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,Microsoft.CodeAnalysis.CSharp.MethodGroup,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Perform overload resolution on the method group or expression (BoundMethodGroup)
            and arguments and return a BoundExpression representing the invocation.
            </summary>
            <param name="node">Invocation syntax node.</param>
            <param name="expression">The syntax for the invoked method, including receiver.</param>
            <param name="methodName">Name of the invoked method.</param>
            <param name="result">Overload resolution result for method group executed by caller.</param>
            <param name="analyzedArguments">Arguments bound by the caller.</param>
            <param name="methodGroup">Method group if the invocation represents a potentially overloaded member.</param>
            <param name="delegateTypeOpt">Delegate type if method group represents a delegate.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="queryClause">The syntax for the query clause generating this invocation expression, if any.</param>
            <returns>BoundCall or error expression representing the invocation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetLocationForOverloadResolutionDiagnostic(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <param name="node">Invocation syntax node.</param>
            <param name="expression">The syntax for the invoked method, including receiver.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReplaceTypeOrValueReceiver(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Replace a BoundTypeOrValueExpression with a BoundExpression for either a type (if useType is true)
            or a value (if useType is false).  Any other node is unmodified.
            </summary>
            <remarks>
            Call this once overload resolution has succeeded on the method group of which the BoundTypeOrValueExpression
            is the receiver.  Generally, useType will be true if the chosen method is static and false otherwise.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetDelegateType(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Return the delegate type if this expression represents a delegate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckSyntaxForNameofArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.String@,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
            <summary>
            Returns true if syntax form is OK (so no errors were reported)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.InvocableNameofInScope">
            <summary>
            Helper method that checks whether there is an invocable 'nameof' in scope.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupSymbolsSimpleName(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.Int32,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.LookupOptions,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Performs name lookup for simple generic or non-generic name
            within an optional qualifier namespace or type symbol.
            If LookupOption.AttributeTypeOnly is set, then it performs
            attribute type lookup which involves attribute name lookup
            with and without "Attribute" suffix.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupSymbolsWithFallback(Microsoft.CodeAnalysis.CSharp.LookupResult,System.String,System.Int32,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <summary>
            Look for any symbols in scope with the given name and arity.
            </summary>
            <remarks>
            Makes a second attempt if the results are not viable, in order to produce more detailed failure information (symbols and diagnostics).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupSymbolsOrMembersInternal(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.Int32,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.LookupOptions,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            If qualifierOpt is null, look for any symbols in
            scope with the given name and arity.
            Otherwise look for symbols that are members of the specified qualifierOpt.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupMembersWithFallback(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.Int32,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <summary>
            Look for symbols that are members of the specified namespace or type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupMembersInSubmissions(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.String,System.Int32,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Binder,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Lookup a member name in a submission chain.
            </summary>
            <remarks>
            We start with the current submission class and walk the submission chain back to the first submission.
            The search has two phases
            1) We are looking for any symbol matching the given name, arity, and options. If we don't find any the search is over.
               If we find and overloadable symbol(s) (a method or an indexer) we start looking for overloads of this kind 
               (lookingForOverloadsOfKind) of symbol in phase 2.
            2) If a visited submission contains a matching member of a kind different from lookingForOverloadsOfKind we stop 
               looking further. Otherwise, if we find viable overload(s) we add them into the result.
               
            Note that indexers are not supported in script but we deal with them here to handle errors.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupExtensionMethodsInSingleBinder(Microsoft.CodeAnalysis.CSharp.ExtensionMethodScope,Microsoft.CodeAnalysis.CSharp.LookupResult,System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Lookup extension methods by name and arity in the given binder and
            check viability in this binder. The lookup is performed on a single
            binder because extension method search stops at the first applicable
            method group from the nearest enclosing namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.LookupAttributeType(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,System.Int32,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.LookupOptions,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Lookup attribute name in the given binder. By default two name lookups are performed:
                (1) With the provided name
                (2) With an Attribute suffix added to the provided name
            Lookup with Attribute suffix is performed only if LookupOptions.VerbatimAttributeName is not set.
            
            If either lookup is ambiguous, we return the corresponding result with ambiguous symbols.
            Else if exactly one result is single viable attribute type, we return that result.
            Otherwise, we return a non-viable result with LookupResult.NotAnAttributeType or an empty result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetCandidateExtensionMethods(System.Boolean,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol},System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions,System.Boolean)">
            <summary>
            Return the extension methods from this specific binding scope that match the name and optional
            arity. Since the lookup of extension methods is iterative, proceeding one binding scope at a time,
            GetCandidateExtensionMethods should not defer to the next binding scope. Instead, the caller is
            responsible for walking the nested binding scopes from innermost to outermost. This method is overridden
            to search the available members list in binding types that represent types, namespaces, and usings.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.AddWinRTMembers(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Binder,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            If the type implements one of a select few WinRT interfaces, the interface type is
            projected to the CLR collection type (e.g., IVector to IList).
            When importing a winmd type it may implement one or more winmd collection
            interfaces. When the collection interfaces are projected, we may need
            to add the projected members to the imported type so that calls to those
            members succeed as normal. This method adds the interface methods to
            the lookup, if necessary. The CLR understands that a call to the .NET interface
            should be projected onto the WinRT interface method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsMethodOrIndexer(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            This helper is used to determine whether this symbol hides / is hidden
            based on its signature, as opposed to its name.
            </summary>
            <remarks>
            CONSIDER: It might be nice to generalize this - maybe an extension method
            on Symbol (e.g. IsOverloadable or HidesByName).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckViability(Microsoft.CodeAnalysis.CSharp.Symbol,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <remarks>
            Distinguish from <see cref="M:Microsoft.CodeAnalysis.CSharp.Binder.CanAddLookupSymbolInfo(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)"/>, which performs an analogous task for Add*LookupSymbolsInfo*.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CanAddLookupSymbolInfo(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Used by Add*LookupSymbolsInfo* to determine whether the symbol is of interest.
            Distinguish from <see cref="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckViability(Microsoft.CodeAnalysis.CSharp.Symbol,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol})"/>, which performs an analogous task for LookupSymbols*.
            </summary>
            <remarks>
            Does not consider <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.CanBeReferencedByName"/> - that is left to the caller.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsCrefAccessible(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            A symbol is accessible for referencing in a cref if it is in the same assembly as the reference
            or the symbols's effective visibility is not private.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Check whether "symbol" is accessible from this binder.
            Also checks protected access via "accessThroughType".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Check whether "symbol" is accessible from this binder.
            Also checks protected access via "accessThroughType", and sets "failedThroughTypeCheck" if fails
            the protected access check.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.IsAccessibleHelper(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <remarks>
            Should only be called by <see cref="M:Microsoft.CodeAnalysis.CSharp.Binder.IsAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol})"/>,
            which will already have checked for <see cref="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.IgnoreAccessibility"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.AddLookupSymbolsInfo(Microsoft.CodeAnalysis.CSharp.LookupSymbolsInfo,Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <summary>
            Look for names in scope
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.AddMemberLookupSymbolsInfo(Microsoft.CodeAnalysis.CSharp.LookupSymbolsInfo,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CSharp.LookupOptions,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Look for names of members
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ValidateNameConflictsInScope(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.Location,System.String,Microsoft.CodeAnalysis.DiagnosticBag)">
            <remarks>
            Don't call this one directly - call one of the helpers.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindEventAssignment(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BoundEventAccess,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            For "receiver.event += expr", produce "receiver.add_event(expr)".
            For "receiver.event -= expr", produce "receiver.remove_event(expr)".
            </summary>
            <remarks>
            Performs some validation of the accessor that couldn't be done in CheckEventValueKind, because
            the specific accessor wasn't known.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.TryFoldingNullableEquality(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            If one of the (unconverted) operands has constant value null and the other has
            a null constant value other than null, then they are definitely not equal
            and we can give a constant value for either == or !=.  This is a spec violation
            that we retain from Dev10.
            </summary>
            <param name="kind">The operator kind.  Nothing will happen if it is not a lifted equality operator.</param>
            <param name="left">The left-hand operand of the operation (possibly wrapped in a conversion).</param>
            <param name="right">The right-hand operand of the operation (possibly wrapped in a conversion).</param>
            <returns>
            If the operator represents lifted equality, then constant value true if both arguments have constant
            value null, constant value false if exactly one argument has constant value null, and null otherwise.
            If the operator represents lifted inequality, then constant value false if both arguments have constant
            value null, constant value true if exactly one argument has constant value null, and null otherwise.
            </returns>
            <remarks>
            SPEC VIOLATION: according to the spec (section 7.19) constant expressions cannot
            include implicit nullable conversions or nullable subexpressions.  However, Dev10
            specifically folds over lifted == and != (see ExpressionBinder::TryFoldingNullableEquality).
            Dev 10 does do compile-time evaluation of simple lifted operators, but it does so
            in a rewriting pass (see NullableRewriter) - they are not treated as constant values.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.FoldStringConcatenation(Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.ConstantValue,System.Int32@)">
            <summary>
            Returns ConstantValue.Bad if, and only if, compound string length is out of supported limit.
            The <paramref name="compoundStringLength"/> parameter contains value corresponding to the 
            left node, or zero, which will trigger inference. Upon return, it will 
            be adjusted to correspond future result node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindConditionalOperator(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
             <remarks>
             From ExpressionBinder::EnsureQMarkTypesCompatible:
             
             The v2.0 specification states that the types of the second and third operands T and S of a ternary operator
             must be TT and TS such that either (a) TT==TS, or (b), TT->TS or TS->TT but not both.
            
             Unfortunately that is not what we implemented in v2.0.  Instead, we implemented
             that either (a) TT=TS or (b) T->TS or S->TT but not both.  That is, we looked at the
             convertibility of the expressions, not the types.
            
            
             Changing that to the algorithm in the standard would be a breaking change.
            
             b ? (Func&lt;int&gt;)(delegate(){return 1;}) : (delegate(){return 2;})
            
             and
            
             b ? 0 : myenum
            
             would suddenly stop working.  (The first because o2 has no type, the second because 0 goes to
             any enum but enum doesn't go to int.)
            
             It gets worse.  We would like the 3.0 language features which require type inference to use
             a consistent algorithm, and that furthermore, the algorithm be smart about choosing the best
             of a set of types.  However, the language committee has decided that this algorithm will NOT
             consume information about the convertibility of expressions. Rather, it will gather up all
             the possible types and then pick the "largest" of them.
            
             To maintain backwards compatibility while still participating in the spirit of consistency,
             we implement an algorithm here which picks the type based on expression convertibility, but
             if there is a conflict, then it chooses the larger type rather than producing a type error.
             This means that b?0:myshort will have type int rather than producing an error (because 0->short,
             myshort->int).
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.FoldConditionalOperator(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Constant folding for conditional (aka ternary) operators.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportQueryLookupFailed(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,System.String,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            This is a clone of the Dev10 logic for reporting query errors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.LockedOrDisposedVariables">
            <summary>
            This is the set of parameters and local variables that were used as arguments to 
            lock or using statements in enclosing scopes.
            </summary>
            <remarks>
            using (x) { } // x counts
            using (IDisposable y = null) { } // y does not count
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
            <remarks>
            Noteworthy override is in MemberSemanticModel.IncrementalBinder (used for caching).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckForUnobservedAwaitable(Microsoft.CodeAnalysis.CSharp.BoundExpressionStatement,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Report an error if this is an awaitable async method invocation that is not being awaited.
            </summary>
            <remarks>
            The checks here are equivalent to StatementBinder::CheckForUnobservedAwaitable() in the native compiler.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetFixedLocalCollectionInitializer(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Wrap the initializer in a BoundFixedLocalCollectionInitializer so that the rewriter will have the
            information it needs (e.g. conversions, helper methods).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckIsVariable(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
             <summary>
             The purpose of this method is to determine if the expression is classified by the 
             specification as a *variable*. If it is not then this code gives an appropriate error message.
            
             To determine the appropriate error message we need to know two things:
            
             (1) why do we want to know if this is a variable? Because we are trying to assign it,
                 increment it, or pass it by reference?
            
             (2) Are we trying to determine if the left hand side of a dot is a variable in order
                 to determine if the field or property on the right hand side of a dot is assignable?
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CheckValue(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Binder.BindValueKind,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Check the expression is of the required lvalue and rvalue specified by valueKind.
            The method returns the original expression if the expression is of the required
            type. Otherwise, an appropriate error is added to the diagnostics bag and the
            method returns a BoundBadExpression node. The method returns the original
            expression without generating any error if the expression has errors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetBadEventUsageDiagnosticInfo(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol)">
            <summary>
            There are two BadEventUsage error codes and this method decides which one should
            be used for a given event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.RequiresVariableReceiver(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            SPEC: When a property or indexer declared in a struct-type is the target of an 
            SPEC: assignment, the instance expression associated with the property or indexer 
            SPEC: access must be classified as a variable. If the instance expression is 
            SPEC: classified as a value, a compile-time error occurs. Because of 7.6.4, 
            SPEC: the same rule also applies to fields.
            </summary>
            <remarks>
            NOTE: The spec fails to impose the restriction that the receiver must be classified
            as a variable (unlike for properties - 7.17.1).  This seems like a bug, but we have
            production code that won't build with the restriction in place (see DevDiv #15674).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.CreateBlockFromExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Wrap a given expression e into a block as either { e; } or { return e; } 
            Shared between lambda and expression-bodied method binding.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindExpressionBodyAsBlock(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Binds an expression-bodied member with expression e as either { return e;} or { e; }.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindLambdaExpressionAsBlock(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Binds a lambda with expression e as either { return e;} or { e; }.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@)">
            <summary>
            Binds the type for the syntax taking into account possibility of "var" type.
            </summary>
            <param name="syntax">Type syntax to bind.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="isVar">
            Set to false if syntax binds to a type in the current context and true if
            syntax is "var" and it binds to "var" keyword in the current context.
            </param>
            <returns>
            Bound type if syntax binds to a type in the current context and
            null if syntax binds to "var" keyword in the current context.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@,Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol@)">
            <summary>
            Binds the type for the syntax taking into account possibility of "var" type.
            </summary>
            <param name="syntax">Type syntax to bind.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="isVar">
            Set to false if syntax binds to a type in the current context and true if
            syntax is "var" and it binds to "var" keyword in the current context.
            </param>
            <param name="alias">Alias symbol if syntax binds to an alias.</param>
            <returns>
            Bound type if syntax binds to a type in the current context and
            null if syntax binds to "var" keyword in the current context.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindTypeOrAlias(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@)">
            <summary>
            Binds the type for the syntax taking into account possibility of "var" type.
            If the syntax binds to an alias symbol to a type, it returns the alias symbol.
            </summary>
            <param name="syntax">Type syntax to bind.</param>
            <param name="diagnostics">Diagnostics.</param>
            <param name="isVar">
            Set to false if syntax binds to a type or alias to a type in the current context and true if
            syntax is "var" and it binds to "var" keyword in the current context.
            </param>
            <returns>
            Bound type or alias if syntax binds to a type or alias to a type in the current context and
            null if syntax binds to "var" keyword in the current context.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetContainingNamespaceOrType(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            The immediately containing namespace or named type, or the global
            namespace if containing symbol is neither a namespace or named type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BindSimpleNamespaceOrTypeOrAliasSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.DiagnosticBag,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol},System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol)">
            <summary>
            Binds a simple name or the simple name portion of a qualified name. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ConstructNamedTypeUnlessTypeArgumentOmitted(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.DiagnosticBag)">
            <remarks>
            Keep check and error in sync with ConstructBoundMethodGroupAndReportOmittedTypeArguments.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ConstructBoundMemberGroupAndReportOmittedTypeArguments(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.BoundExpression,System.String,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.BoundMethodGroupFlags,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <remarks>
            Keep check and error in sync with ConstructNamedTypeUnlessTypeArgumentOmitted.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.ShouldCheckConstraints">
            <summary>
            Check generic type constraints unless the type is used as part of a type or method
            declaration. In those cases, constraints checking is handled by the caller.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the special
            member isn't found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUseSiteDiagnostics(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Reports use-site diagnostics for the specified symbol.
            </summary>
            <returns>
            True if there was an error among the reported diagnostics
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUseSiteDiagnostics(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.Location)">
            <summary>
            Reports use-site diagnostics for the specified symbol.
            </summary>
            <returns>
            True if there was an error among the reported diagnostics
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetWellKnownType(Microsoft.CodeAnalysis.WellKnownType,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            This is a layer on top of the Compilation version that generates a diagnostic if the well-known
            type isn't found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetWellKnownTypeMember(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Boolean)">
            <summary>
            Retrieves a well-known type member and reports diagnostics.
            </summary>
            <returns>Null if the symbol is missing.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo.Index">
            <summary>
            Returns -1 if None.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo.Sort(Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo@,Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo@)">
            <summary>
            Prefers symbols from source module, then from added modules, then from referenced assemblies.
            Returns true if values were swapped.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo.IsSecondLocationBetter(Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolLocation,Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolLocation)">
            <summary>
            Returns true if the second is a better location than the first.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetBestSymbolInfo(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.Binder.BestSymbolInfo@)">
            <summary>
            Prefer symbols from source module, then from added modules, then from referenced assemblies.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.NotFound(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.String,System.Int32,System.String,Microsoft.CodeAnalysis.DiagnosticBag,System.String,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <remarks>
            This is only intended to be called when the type isn't found (i.e. not when it is found but is inaccessible, has the wrong arity, etc).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.GetForwardedToAssembly(System.String,System.Int32,System.Boolean@)">
            <summary>
            Look for a type forwarder for the given type in the containing assembly and any referenced assemblies.
            If one is found, search again in the target assembly.  Return the last assembly in the chain.
            </summary>
            <param name="fullName">The metadata name of the (potentially) forwarded type, including the arity (if non-zero).</param>
            <param name="arity">The arity of the forwarded type.</param>
            <param name="encounteredCycle">Set to true if a cycle was found in the type forwarders.</param>
            <returns></returns>
            <remarks>
            Since this method is intended to be used for error reporting, it stops as soon as it finds
            any type forwarder - it does not check other assemblies for consistency or better results.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Binder.InUnsafeRegion">
            <summary>
            True if we are currently in an unsafe region (type, member, or block).
            </summary>
            <remarks>
            Does not imply that this compilation allows unsafe regions (could be in an error recovery scenario).
            To determine that, check this.Compilation.Options.AllowUnsafe.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUnsafeIfNotAllowed(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <returns>True if a diagnostic was reported, or would have been reported if not for
            the suppress flag.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUnsafeIfNotAllowed(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <returns>True if a diagnostic was reported, or would have been reported if not for
            the suppress flag.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUnsafeIfNotAllowed(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.DiagnosticBag)">
            <returns>True if a diagnostic was reported, or would have been reported if not for
            the suppress flag.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Binder.ReportUnsafeIfNotAllowed(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <returns>True if a diagnostic was reported, or would have been reported if not for
            the suppress flag.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.GetMethodName(Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Get the name of the method so that it can be looked up in the containing type.
            </summary>
            <param name="baseMethodDeclarationSyntax">Non-null declaration syntax.</param>
            <param name="outerBinder">Binder for the scope around the method (may be null for operators, constructors, and destructors).</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.GetPropertyOrEventName(Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Get the name of the property, indexer, or event so that it can be looked up in the containing type.
            </summary>
            <param name="basePropertyDeclarationSyntax">Non-null declaration syntax.</param>
            <param name="outerBinder">Non-null binder for the scope around the member.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.InSpan(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Returns true if the location is within the syntax tree and span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.IsInUsing(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Returns true if containingNode has a child that contains the specified position
            and has kind UsingDirective.
            </summary>
            <remarks>
            Usings can't see other usings, so this is extra info when looking at a namespace
            or compilation unit scope.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax)">
            <remarks>
            Used to detect whether we are in a cref parameter type.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax)">
            <remarks>
            Used to detect whether we are in a cref return type.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.GetParameterNameAttributeValueBinder(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            We're in a &lt;param&gt; or &lt;paramref&gt; element, so we want a binder that can see
            the parameters of the associated member and nothing else.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.BinderFactoryVisitor.GetTypeParameterNameAttributeValueBinder(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Boolean,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            We're in a &lt;typeparam&gt; or &lt;typeparamref&gt; element, so we want a binder that can see
            the type parameters of the associated member and nothing else.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.MakeCrefBinder(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.BinderFactory,System.Boolean)">
            <summary>
            Given a CrefSyntax and an associated member declaration syntax node,
            construct an appropriate binder for binding the cref.
            </summary>
            <param name="crefSyntax">Cref that will be bound.</param>
            <param name="memberSyntax">The member to which the documentation comment (logically) containing
            the cref syntax applies.</param>
            <param name="factory">Corresponding binder factory.</param>
            <param name="inParameterOrReturnType">True to get a special binder for cref parameter and return types.</param>
            <remarks>
            The CrefSyntax does not actually have to be within the documentation comment on the member - it
            could be included from another file.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.MakeCrefBinderInternal(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.CSharp.Binder,System.Boolean)">
            <summary>
            Internal version of MakeCrefBinder that allows the caller to explicitly set the underlying binder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.GetEnclosingDocumentationComment(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Walk up from an XML syntax node (attribute or tag) to the enclosing documentation comment trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.GetBinder(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Note, there is no guarantee that the factory always gives back the same binder instance for the same <param name="node"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BinderFactory.GetImportsBinder(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Returns binder that binds usings and aliases 
            </summary>
            <param name="unit">
            Specify <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax"/> imports in the corresponding namespace, or
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax"/> for top-level imports.
            </param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BinderFlags">
            <summary>
            A specific location for binding.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.UnsafeRegion">
            <summary>
            Indicates that the current context allows unsafe constructs.
            </summary>
            <remarks>
            NOTE: Dev10 doesn't seem to treat attributes as being within the unsafe region.
            Fortunately, not following this behavior should not be a breaking change since
            attribute arguments have to be constants and there are no constants of unsafe
            types.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.SuppressUnsafeDiagnostics">
            <summary>
            Indicates that the unsafe diagnostics are not reported in the current context, regardless
            of whether or not it is (part of) an unsafe region.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.SemanticModel">
            <summary>
            Indicates that this binder is being used to answer SemanticModel questions (i.e. not
            for batch compilation).
            </summary>
            <remarks>
            Imports touched by a binder with this flag set are not consider "used".
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.CheckedRegion">
            <summary>Remarks, mutually exclusive with <see cref="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.UncheckedRegion"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.UncheckedRegion">
            <summary>Remarks, mutually exclusive with <see cref="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.CheckedRegion"/>.</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.AllowManagedAddressOf">
            <summary>
            In the debugger, one can take the address of a managed object.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.AllowAwaitInUnsafeContext">
            <summary>
            In the debugger, the context is always unsafe, but one can still await.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.IgnoreCorLibraryDuplicatedTypes">
            <summary>
            Ignore duplicate types from the cor library.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BinderFlagsExtensions">
            <summary>
            Extension methods for the <see cref="T:Microsoft.CodeAnalysis.CSharp.BinderFlags"/> type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BuckStopsHereBinder">
            <summary>
            A binder that knows no symbols and will not delegate further.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConstantFieldsInProgress">
            <summary>
            This is used while computing the values of constant fields.  Since they can depend on each
            other, we need to keep track of which ones we are currently computing in order to avoid (and
            report) cycles.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ConstantFieldsInProgressBinder">
            <summary>
            This binder keeps track of the set of constant fields that are currently being evaluated
            so that the set can be passed into the next call to SourceFieldSymbol.ConstantValue (and
            its callers).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder">
            <summary>
            Each application of an attribute is effectively a constructor call.  Since the attribute constructor
            might have a CallerMemberName parameter, we need to keep track of which method/property/event
            the attribute is on/in (e.g. on a parameter) so that we can use the name of that member as the 
            CallerMemberName argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder.#ctor(Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <param name="enclosing">Next binder in the chain (enclosing).</param>
            <param name="symbol">Symbol to which the attribute was applied (e.g. a parameter).</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder.AttributedMember">
            <summary>
            We're binding an attribute and this is the member to/in which the attribute was applied.
            </summary>
            <remarks>
            Method, property, event, or null.
            A virtual property on Binder (i.e. our usual pattern) would be more robust, but the applicability
            of this property is so narrow that it doesn't seem worthwhile.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ContextualAttributeBinder.GetAttributedMember(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Walk up to the nearest method/property/event.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EarlyWellKnownAttributeBinder">
            <summary>
            This is a special binder used for decoding some special well-known attributes very early in the attribute binding phase.
            It only binds those attribute argument syntax which can produce valid attribute arguments, but doesn't report any diagnostics.
            Subsequent binding phase will rebind such erroneous attributes and generate appropriate diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EarlyWellKnownAttributeBinder.CanBeValidAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Binder)">
            <remarks>
            Since this method is expected to be called on every nested expression of the argument, it doesn't
            need to recurse (directly).
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExecutableCodeBinder">
            <summary>
            This binder owns and lazily creates the map of SyntaxNodes to Binders associated with
            the syntax with which it is created. This binder is not created in reaction to any
            specific syntax node type. It is inserted into the binder chain
            between the binder which it is constructed with and those that it constructs via
            the LocalBinderFactory. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExtensionMethodScope">
            <summary>
            A distinct scope that may expose extension methods. For a particular Binder,  there
            are two possible scopes: one for the namespace, and another for any using statements
            in the namespace. The namespace scope is searched before the using scope.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExtensionMethodScopes">
            <summary>
            An enumerable collection of extension method scopes in search
            order, from the given Binder, out through containing Binders.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExtensionMethodScopeEnumerator">
            <summary>
            An enumerator over ExtensionMethodScopes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo">
            <summary>
            Information to be deduced while binding a foreach loop so that the loop can be lowered
            to a while over an enumerator.  Not applicable to the array or string forms.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder">
            <summary>
            A loop binder that (1) knows how to bind foreach loops and (2) has the foreach iteration variable in scope.
            </summary>
            <remarks>
            This binder produces BoundForEachStatements.  The lowering described in the spec is performed in ControlFlowRewriter.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.BindForEachParts(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Bind the ForEachStatementSyntax at the root of this binder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.GetEnumeratorInfo(Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo.Builder@,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            The spec describes an algorithm for finding the following types:
              1) Collection type
              2) Enumerator type
              3) Element type
              
            The implementation details are a bit difference.  If we're iterating over a string or an array, then we don't need to record anything
            but the inferredType (in case the iteration variable is implicitly typed).  If we're iterating over anything else, then we want the 
            inferred type plus a ForEachEnumeratorInfo.Builder with:
              1) Collection type
              2) Element type
              3) GetEnumerator method of the collection type (return type will be the enumerator type from the spec)
              4) Current property of the enumerator type
              5) MoveNext method of the enumerator type
              
            The caller will have to do some extra conversion checks before creating a ForEachEnumeratorInfo for the BoundForEachStatement.
            </summary>
            <param name="builder">Builder to fill in (partially, all but conversions).</param>
            <param name="collectionExpr">The expression over which to iterate.</param>
            <param name="diagnostics">Populated with binding diagnostics.</param>
            <returns>Partially populated (all but conversions) or null if there was an error.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.SatisfiesGetEnumeratorPattern(Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo.Builder@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Check for a GetEnumerator method on collectionExprType.  Failing to satisfy the pattern is not an error -
            it just means that we have to check for an interface instead.
            </summary>
            <param name="collectionExprType">Type of the expression over which to iterate.</param>
            <param name="diagnostics">Populated with *warnings* if there are near misses.</param>
            <param name="builder">Builder to fill in. <see cref="F:Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo.Builder.GetEnumeratorMethod"/> set if the pattern in satisfied.</param>
            <returns>True if the method was found (still have to verify that the return (i.e. enumerator) type is acceptable).</returns>
            <remarks>
            Only adds warnings, so does not affect control flow (i.e. no need to check for failure).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.FindForEachPatternMethod(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.String,Microsoft.CodeAnalysis.CSharp.LookupResult,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Perform a lookup for the specified method on the specified type.  Perform overload resolution
            on the lookup results.
            </summary>
            <param name="patternType">Type to search.</param>
            <param name="methodName">Method to search for.</param>
            <param name="lookupResult">Passed in for reusability.</param>
            <param name="warningsOnly">True if failures should result in warnings; false if they should result in errors.</param>
            <param name="diagnostics">Populated with binding diagnostics.</param>
            <returns>The desired method or null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.PerformForEachPatternOverloadResolution(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol},System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            The overload resolution portion of FindForEachPatternMethod.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.SatisfiesForEachPattern(Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo.Builder@,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Called after it is determined that the expression being enumerated is of a type that
            has a GetEnumerator method.  Checks to see if the return type of the GetEnumerator
            method is suitable (i.e. has Current and MoveNext).
            </summary>
            <param name="builder">Must be non-null and contain a non-null GetEnumeratorMethod.</param>
            <param name="diagnostics">Will be populated with pattern diagnostics.</param>
            <returns>True if the return type has suitable members.</returns>
            <remarks>
            It seems that every failure path reports the same diagnostics, so that is left to the caller.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.AllInterfacesContainsIEnumerable(Microsoft.CodeAnalysis.CSharp.ForEachEnumeratorInfo.Builder@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@)">
            <summary>
            Checks if the given type implements (or extends, in the case of an interface),
            System.Collections.IEnumerable or System.Collections.Generic.IEnumerable&lt;T&gt;,
            for at least one T.
            </summary>
            <param name="builder">builder to fill in CollectionType.</param>
            <param name="type">Type to check.</param>
            <param name="diagnostics" />
            <param name="foundMultiple">True if multiple T's are found.</param>
            <returns>True if some IEnumerable is found (may still be ambiguous).</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachLoopBinder.ReportPatternMemberLookupDiagnostics(Microsoft.CodeAnalysis.CSharp.LookupResult,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.String,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Report appropriate diagnostics when lookup of a pattern member (i.e. GetEnumerator, Current, or MoveNext) fails.
            </summary>
            <param name="lookupResult">Failed lookup result.</param>
            <param name="patternType">Type in which member was looked up.</param>
            <param name="memberName">Name of looked up member.</param>
            <param name="warningsOnly">True if failures should result in warnings; false if they should result in errors.</param>
            <param name="diagnostics">Populated appropriately.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ImplicitlyTypedFieldBinder">
            <summary>
            Tracks fields that are being bound while binding their initializers.
            </summary>
            <remarks>
            Used to detect circular references like:
            var x = y;
            var y = x;
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ImplicitlyTypedLocalBinder">
            <summary>
            This binder is for binding the initializer of an implicitly typed
            local variable. While binding an implicitly typed local variable
            it is illegal to refer to the variable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Imports">
            <summary>
            Represents symbols imported to the binding scope via using namespace, using alias, and extern alias.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.InContainerBinder">
            <summary>
            A binder that places the members of a symbol in scope.  If there is a container declaration
            with using directives, those are merged when looking up names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InContainerBinder.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Boolean,System.Boolean)">
            <summary>
            Creates a binder for a container with imports (usings and extern aliases) that can be
            retrieved from <paramref name="declarationSyntax"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InContainerBinder.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Imports)">
            <summary>
            Creates a binder with given imports.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.InMethodBinder">
            <summary>
            A binder for a method body, which places the method's parameters in scope
            and notes if the method is an iterator method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InteractiveUsingsBinder.RebindAndAddUsings(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.NamespaceOrTypeAndUsingDirective},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.NamespaceOrTypeAndUsingDirective})">
            <summary>
            Returns a new list of usings with all namespace symbols replaced by namespace symbols updated from current compilation references.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalBinderFactory">
             <summary>
             The LocalBinderFactory is used to build up the map of all Binders within a method body, and the associated
             CSharpSyntaxNode. To do so it traverses all the statements, handling blocks and other
             statements that create scopes. For efficiency reasons, it does not traverse into
             expressions. This means that blocks within lambdas and queries are not created. 
             Blocks within lambdas are bound by their own LocalBinderFactory when they are 
             analyzed.
            
             For reasons of lifetime management, this type is distinct from the BinderFactory 
             which also creates a map from CSharpSyntaxNode to Binder. That type owns it's binders
             and that type's lifetime is that of the compilation. Therefore we do not store
             binders local to method bodies in that type's cache. 
             </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LocalInProgressBinder">
            <summary>
            This binder keeps track of the local variable (if any) that is currently being evaluated
            so that it can be passed into the next call to LocalSymbol.GetConstantValue (and
            its callers).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalScopeBinder.LookupLocal(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Call this when you are sure there is a local declaration on this token.  Returns the local.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LockOrUsingBinder">
            <remarks>
            This type exists to share code between UsingStatementBinder and LockBinder.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LockOrUsingBinder.ExpressionAndDiagnostics">
            <remarks>
            This class exists so these two fields can be set atomically.
            CONSIDER: If this causes too many allocations, we could use start and end flags plus spinlocking
            as for completion parts.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LookupOptions">
            <summary>
            Options that can be used to modify the symbol lookup mechanism. 
            </summary>
            <remarks>
            Multiple options can be combined together.  LookupOptions.AreValid checks for valid combinations.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.Default">
            <summary>
            Consider all symbols, using normal accessibility rules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.NamespaceAliasesOnly">
            <summary>
            Consider only namespace aliases and extern aliases.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.NamespacesOrTypesOnly">
            <summary>
            Consider only namespaces and types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustBeInvocableIfMember">
            <summary>
            Consider non-members, plus invocable members.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustBeInstance">
            <summary>
            Consider only symbols that are instance members. Valid with IncludeExtensionMethods
            since extension methods are invoked on an instance.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustNotBeInstance">
            <summary>
            Do not consider symbols that are instance members.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustNotBeNamespace">
            <summary>
            Do not consider symbols that are namespaces.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.AllMethodsOnArityZero">
            <summary>
            Consider methods of any arity when arity zero is specified. Because type parameters can be inferred, it is
            often desired to consider generic methods when no type arguments were present.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.LabelsOnly">
            <summary>
            Look only for label symbols.  This must be exclusive of all other options.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.UseBaseReferenceAccessibility">
            <summary>
            Usually, when determining if a member is accessible, both the type of the receiver
            and the type containing the access are used.  If this flag is specified, then only
            the containing type will be used (i.e. as if you've written base.XX).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.IncludeExtensionMethods">
            <summary>
            Include extension methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.AttributeTypeOnly">
            <summary>
            Consider only attribute types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.VerbatimNameAttributeTypeOnly">
            <summary>
            Consider lookup name to be a verbatim identifier.
            If this flag is specified, then only one lookup is performed for attribute name: lookup with the given name,
            and attribute name lookup with "Attribute" suffix is skipped.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.AllNamedTypesOnArityZero">
            <summary>
            Consider named types of any arity when arity zero is specified. It is specifically desired for nameof in such situations: nameof(System.Collections.Generic.List)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LookupOptions.MustNotBeMethodTypeParameter">
            <summary>
            Do not consider symbols that are method type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LookupOptionExtensions.AreValid(Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <summary>
            Are these options valid in their current combination?
            </summary>
            <remarks>
            Some checks made here:
            
            - Default is valid.
            - If LabelsOnly is set, it must be the only option.
            - If one of MustBeInstance or MustNotBeInstance are set, the other one must not be set.
            - If any of MustNotBeInstance, MustBeInstance, or MustNotBeNonInvocableMember are set,
              the options are considered valid.
            - If MustNotBeNamespace is set, neither NamespaceAliasesOnly nor NamespacesOrTypesOnly must be set.
            - Otherwise, only one of NamespaceAliasesOnly, NamespacesOrTypesOnly, or AllMethodsOnArityZero must be set.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LookupFilter">
            <summary>
            represents one-to-one symbol -> SingleLookupResult filter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LookupResult">
            <summary>
            A LookupResult summarizes the result of a name lookup within a scope It also allows
            combining name lookups from different scopes in an easy way.
            
            A LookupResult can be ONE OF:
               empty - nothing found.
               a viable result - this kind of result prevents lookup into further scopes of lower priority.
                                 Viable results should be without error; ambiguity is handled in the caller.
                                 (Note that handling multiple "viable" results is not the same as in the VB compiler)
               a non-accessible result - this kind of result means that search continues into further scopes of lower priority for
                                 a viable result. An error is attached with the inaccessibility errors. Non-accessible results take priority over
                                 non-viable results.
               a non-viable result - a result that means that the search continues into further scopes of lower priority for
                                     a viable or non-accessible result. An error is attached with the error that indicates
                                     why the result is non-viable.  A typical readon would be that it is the wrong kind of symbol.
            
            Note that the class is poolable so its instances can be obtained from a pool vai GetInstance.
            Also it is a good idea to call Free on instances after they no longer needed.
            
            The typical pattern is "caller allocates / caller frees" -
               
               var result = LookupResult.GetInstance();
             
               scope.Lookup(result, "foo");
               ... use result ...
                    
               result.Clear();
               anotherScope.Lookup(result, "moo");
               ... use result ...
            
               result.Free();   //result and its content is invalid after this
               
            
            
            </summary>
            <remarks>
            Currently LookupResult is intended only for name lookup, not for overload resolution. It is
            not clear if overload resolution will work with the structure as is, require enhancements,
            or be best served by an alternate mechanism.
            
            We might want to extend this to a more general priority scheme.
            
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.LookupResult.SingleSymbolOrDefault">
            <summary>
            Return the single symbol if there is exactly one, otherwise null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.LookupResult.IsMultiViable">
            <summary>
            Is the result viable with one or more symbols?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.LookupResult.IsSingleViable">
            <summary>
            NOTE: Even there is a single viable symbol, it may be an error type symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LookupResult.SetFrom(Microsoft.CodeAnalysis.CSharp.SingleLookupResult)">
            <summary>
            Set current result according to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LookupResult.SetFrom(Microsoft.CodeAnalysis.CSharp.LookupResult)">
            <summary>
            Set current result according to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LookupResult.MergeEqual(Microsoft.CodeAnalysis.CSharp.LookupResult)">
            <summary>
            Merge another result with this one, with the symbols combined if both
            this and other are viable. Otherwise the highest priority result wins (this if equal 
            priority and non-viable.)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LookupResultKind">
            <summary>
            Classifies the different ways in which a found symbol might be incorrect.
            Higher values are considered "better" than lower values. These values are used
            in a few different places:
               1) Inside a LookupResult to indicate the quality of a symbol from lookup.
               2) Inside a bound node (for example, BoundBadExpression), to indicate
                  the "binding quality" of the symbols referenced by that bound node.
               3) Inside an error type symbol, to indicate the reason that the candidate symbols
                  in the error type symbols were not good.
                  
            While most of the values can occur in all places, some of the problems are not
            detected at lookup time (e.g., NotAVariable), so only occur in bound nodes.
            </summary>
            <remarks>
            This enumeration is parallel to and almost the same as as the CandidateReason enumeration.
            Changes to one should usually result in changes to the other.
            
            There are two enumerations because:
              1) CandidateReason in language-independent, while this enum is language specific.
              2) The name "CandidateReason" didn't make much sense in the way LookupResultKind is used internally.
              3) Viable isn't used in CandidateReason, but we need it in LookupResultKind, and there isn't a 
                 a way to have internal enumeration values.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LookupResultKindExtensions.ToCandidateReason(Microsoft.CodeAnalysis.CSharp.LookupResultKind)">
            <summary>
            Maps a LookupResultKind to a CandidateReason. Should not be called on LookupResultKind.Viable!
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MethodGroupResolution">
            <summary>
            Packages up the various parts returned when resolving a method group. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AccessCheck">
            <summary>
            Contains the code for determining C# accessibility rules.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.  
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within type 'within', with
            an optional qualifier of type "throughTypeOpt".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Checks if 'symbol' is accessible from within type 'within', with
            an qualifier of type "throughTypeOpt". Sets "failedThroughTypeCheck" to true
            if it failed the "through type" check.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AccessCheck.IsSymbolAccessibleCore(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean@,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Checks if 'symbol' is accessible from within 'within', which must be a NamedTypeSymbol
            or an AssemblySymbol. 
            
            Note that NamedTypeSymbol, if available, is the type that is associated with the binder 
            that found the 'symbol', not the inner-most type that contains the access to the
            'symbol'.
            
            If 'symbol' is accessed off of an expression then 'throughTypeOpt' is the type of that
            expression. This is needed to properly do protected access checks. Sets
            "failedThroughTypeCheck" to true if this protected check failed.
            
            NOTE(cyrusn): I expect this function to be called a lot.  As such, i do not do any memory
            allocations in the function itself (including not making any iterators).  This does mean
            that certain helper functions that we'd like to call are inlined in this method to
            prevent the overhead of returning collections or enumerators.  
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BestTypeInferrer.InferBestType(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.ConversionsBase,System.Boolean@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <remarks>
            This method finds the best common type of a set of expressions as per section 7.5.2.14 of the specification.
            NOTE: If some or all of the expressions have error types, we return error type as the inference result.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BestTypeInferrer.InferBestTypeForConditionalOperator(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.ConversionsBase,System.Boolean@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <remarks>
            This method implements best type inference for the conditional operator ?:.
            NOTE: If either expression is an error type, we return error type as the inference result.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Conversion">
            <summary>
            Summarizes whether a conversion is allowed, and if so, which kind of conversion (and in some cases, the
            associated symbol).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.Exists">
            <summary>
            Returns true if the conversion exists, either as an implicit or explicit conversion.
            </summary>
            <remarks>
            The existence of a conversion does not necessarily imply that the conversion is valid.
            For example, an ambiguous user-defined conversion may exist but may not be valid.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsImplicit">
            <summary>
            Returns true if the conversion is implicit.
            </summary>
            <remarks>
            Implicit conversions are described in section 6.1 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsExplicit">
            <summary>
            Returns true if the conversion is explicit.
            </summary>
            <remarks>
            Explicit conversions are described in section 6.2 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsIdentity">
            <summary>
            Returns true if the conversion is an identity conversion.
            </summary>
            <remarks>
            Identity conversions are described in section 6.1.1 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsNumeric">
            <summary>
            Returns true if the conversion is an implicit numeric conversion or explicit numeric conversion. 
            </summary>
            <remarks>
            Implicit and explicit numeric conversions are described in sections 6.1.2 and 6.2.1 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsEnumeration">
            <summary>
            Returns true if the conversion is an implicit enumeration conversion or explicit enumeration conversion.
            </summary>
            <remarks>
            Implicit and explicit enumeration conversions are described in sections 6.1.3 and 6.2.2 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsInterpolatedString">
            <summary>
            Returns true if the conversion is an interpolated string conversion.
            </summary>
            <remarks>
            The interpolated string conversion described in section 6.1.N of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsNullable">
            <summary>
            Returns true if the conversion is an implicit nullable conversion or explicit nullable conversion.
            </summary>
            <remarks>
            Implicit and explicit nullable conversions are described in sections 6.1.4 and 6.2.3 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsReference">
            <summary>
            Returns true if the conversion is an implicit reference conversion or explicit reference conversion.
            </summary>
            <remarks>
            Implicit and explicit reference conversions are described in sections 6.1.6 and 6.2.4 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsUserDefined">
            <summary>
            Returns true if the conversion is an implicit user-defined conversion or explicit user-defined conversion.
            </summary>
            <remarks>
            Implicit and explicit user-defined conversions are described in section 6.4 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsBoxing">
            <summary>
            Returns true if the conversion is an implicit boxing conversion.
            </summary>
            <remarks>
            Implicit boxing conversions are described in section 6.1.7 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsUnboxing">
            <summary>
            Returns true if the conversion is an explicit unboxing conversion.
            </summary>
            <remarks>
            Explicit unboxing conversions as described in section 6.2.5 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsNullLiteral">
            <summary>
            Returns true if the conversion is an implicit null literal conversion.
            </summary>
            <remarks>
            Null literal conversions are described in section 6.1.5 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsDynamic">
            <summary>
            Returns true if the conversion is an implicit dynamic conversion. 
            </summary>
            <remarks>
            Implicit dynamic conversions are described in section 6.1.8 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsConstantExpression">
            <summary>
            Returns true if the conversion is an implicit constant expression conversion.
            </summary>
            <remarks>
            Implicit constant expression conversions are described in section 6.1.9 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsAnonymousFunction">
            <summary>
            Returns true if the conversion is an implicit anonymous function conversion.
            </summary>
            <remarks>
            Implicit anonymous function conversions are described in section 6.5 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsMethodGroup">
            <summary>
            Returns true if the conversion is an implicit method group conversion.
            </summary>
            <remarks>
            Implicit method group conversions are described in section 6.6 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsPointer">
            <summary>
            Returns true if the conversion is a pointer conversion 
            </summary>
            <remarks>
            Pointer conversions are described in section 18.4 of the C# language specification.
            
            Returns true if the conversion is a conversion 
             a) from a pointer type to void*, 
             b) from a pointer type to another pointer type (other than void*),
             c) from the null literal to a pointer type,
             d) from an integral numeric type to a pointer type, or
             e) from a pointer type to an integral numeric type.
            
            Does not return true for user-defined conversions to/from pointer types.
            Does not return true for conversions between pointer types and IntPtr/UIntPtr.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsIntPtr">
            <summary>
            Returns true if the conversion is a conversion to or from IntPtr or UIntPtr.
            </summary>
            <remarks>
            Returns true if the conversion is a conversion to or from IntPtr or UIntPtr.
            This includes:
              IntPtr to/from int
              IntPtr to/from long
              IntPtr to/from void*
              UIntPtr to/from int
              UIntPtr to/from long
              UIntPtr to/from void*
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.MethodSymbol">
            <summary>
            Returns the method used to create the delegate for a method group conversion if <see cref="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsMethodGroup"/> is true 
            or the method used to perform the conversion for a user-defined conversion if <see cref="P:Microsoft.CodeAnalysis.CSharp.Conversion.IsUserDefined"/> is true.
            Otherwise, returns null.
            </summary>
            <remarks>
            Method group conversions are described in section 6.6 of the C# language specification.
            User-defined conversions are described in section 6.4 of the C# language specification.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.ResultKind">
            <summary>
            Gives an indication of how successful the conversion was.
            Viable - found a best built-in or user-defined conversion.
            Empty - found no applicable built-in or user-defined conversions.
            OverloadResolutionFailure - found applicable conversions, but no unique best.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.UserDefinedFromConversion">
            <summary>
            Conversion applied to operand of the user-defined conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.UserDefinedToConversion">
            <summary>
            Conversion applied to the result of the user-defined conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Conversion.OriginalUserDefinedConversions">
            <summary>
            The user-defined operators that were considered when attempting this conversion
            (i.e. the arguments to overload resolution).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.ToString">
            <summary>
            Returns a string that represents the <see cref="F:Microsoft.CodeAnalysis.CSharp.Conversion.Kind"/> of the conversion.
            </summary>
            <returns>A string that represents the <see cref="F:Microsoft.CodeAnalysis.CSharp.Conversion.Kind"/> of the conversion.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.Equals(System.Object)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object is equal to the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.
            </summary>
            <param name="obj">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object to compare with the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <returns>true if the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object is equal to the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.Equals(Microsoft.CodeAnalysis.CSharp.Conversion)">
            <summary>
            Determines whether the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object is equal to the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.
            </summary>
            <param name="other">The <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object to compare with the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <returns>true if the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object is equal to the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object; otherwise, false.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.GetHashCode">
            <summary>
            Returns a hash code for the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.
            </summary>
            <returns>A hash code for the current <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.op_Equality(Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Conversion)">
            <summary>
            Returns true if the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> objects are equal and false otherwise.
            </summary>
            <param name="left">The first <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <param name="right">The second <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversion.op_Inequality(Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Conversion)">
            <summary>
            Returns false if the specified <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> objects are equal and true otherwise.
            </summary>
            <param name="left">The first <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <param name="right">The second <see cref="T:Microsoft.CodeAnalysis.CSharp.Conversion"/> object.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyConversionFromExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Determines if the source expression is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source expression to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the implicit conversion.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyConversionForCast(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Determines if the source expression is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source expression to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the built-in conversion.
            
            An implicit conversion exists from an expression of a dynamic type to any type.
            An explicit conversion exists from a dynamic type to any type. 
            When casting we prefer the explicit conversion.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitConversionFromExpression(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Determines if the source expression is convertible to the destination type via
            any built-in or user-defined implicit conversion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.FastClassifyConversion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Attempt a quick classification of builtin conversions.  As result of "no conversion"
            means that there is no built-in conversion, though there still may be a user-defined
            conversion if compiling against a custom mscorlib.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.IsBaseInterface(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            IsBaseInterface returns true if baseType is on the base interface list of derivedType or
            any base class of derivedType. It may be on the base interface list either directly or
            indirectly.
            * baseType must be an interface.
            * type parameters do not have base interfaces. (They have an "effective interface list".)
            * an interface is not a base of itself.
            * this does not check for variance conversions; if a type inherits from
              IEnumerable&lt;string> then IEnumerable&lt;object> is not a base interface.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyConversion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,System.Boolean)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source type to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the implicit conversion.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyConversionForCast(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any conversion: implicit, explicit, user-defined or built-in.
            </summary>
            <remarks>
            It is rare but possible for a source type to be convertible to a destination type
            by both an implicit user-defined conversion and a built-in explicit conversion.
            In that circumstance, this method classifies the conversion as the built-in conversion.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyStandardConversion(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any standard implicit or standard explicit conversion.
            </summary>
            <remarks>
            Not all built-in explicit conversions are standard explicit conversions.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ClassifyImplicitConversion(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Determines if the source type is convertible to the destination type via
            any user-defined or built-in implicit conversion.
            </summary>
            <remarks>
            Not all built-in explicit conversions are standard explicit conversions.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.AnalyzeImplicitUserDefinedConversions(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <remarks>
            NOTE: Keep this method in sync with AnalyzeImplicitUserDefinedConversionForSwitchGoverningType.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.ComputeApplicableUserDefinedImplicitConversionSet(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.UserDefinedConversionAnalysis},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@,System.Boolean)">
            <summary>
            This method find the set of applicable user-defined and lifted conversion operators, u.
            The set consists of the user-defined and lifted implicit conversion operators declared by
            the classes and structs in d that convert from a type encompassing source to a type encompassed by target.
            However if allowAnyTarget is true, then it considers all operators that convert from a type encompassing source
            to any target. This flag must be set only if we are computing user defined conversions from a given source
            type to any target type.
            </summary>
            <remarks>
            Currently allowAnyTarget flag is only set to true by AnalyzeImplicitUserDefinedConversionForSwitchGoverningType,
            where we must consider user defined implicit conversions from the type of the switch expression to
            any of the possible switch governing types.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ConversionsBase.AnalyzeImplicitUserDefinedConversionForSwitchGoverningType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <remarks>
            NOTE: Keep this method in sync with AnalyzeImplicitUserDefinedConversion.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversions.ResolveDelegateMethodGroup(Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.BoundMethodGroup,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Resolve method group based on the optional delegate invoke method.
            If the invoke method is null, ignore arguments in resolution.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Conversions.GetDelegateInvokeMethodIfAvailable(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return the Invoke method symbol if the type is a delegate
            type and the Invoke method is available, otherwise null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolution.HidesByName(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            This is specifically a private helper function (rather than a public property or extension method)
            because applying this predicate to a non-method member doesn't have a clear meaning.  The goal was
            simply to avoid repeating ad-hoc code in a group of related collections.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BinaryOperatorSignature.Priority">
            <summary>
            To duplicate native compiler behavior for some scenarios we force a priority among
            operators. If two operators are both applicable and both have a non-null Priority,
            the one with the numerically lower Priority value is preferred.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberAnalysisResult.HasAnyRefOmittedArgument">
            <summary>
            Omit ref feature for COM interop: We can pass arguments by value for ref parameters if we are invoking a method/property on an instance of a COM imported type.
            This property returns a flag indicating whether we had any ref omitted argument for the given call.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberAnalysisResult.HasUseSiteDiagnosticToReportFor(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            Returns false for <see cref="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.UnsupportedMetadata"/>
            because those diagnostics are only reported if no other candidates are
            available.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind">
            <summary>
            Indicates why the compiler accepted or rejected the member during overload resolution.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.None">
            <summary>
            No resolution has (yet) been determined.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.ApplicableInNormalForm">
            <summary>
            The candidate member was accepted in its normal (non-expanded) form.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.ApplicableInExpandedForm">
            <summary>
            The candidate member was accepted in its expanded form, after expanding a "params" parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.InaccessibleTypeArgument">
            <summary>
            The candidate member was rejected because an inferred type argument is inaccessible.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.NoCorrespondingParameter">
            <summary>
            The candidate member was rejected because an argument was specified that did not have a corresponding
            parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.NoCorrespondingNamedParameter">
            <summary>
            The candidate member was rejected because a named argument was specified that did not have a corresponding
            parameter.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.RequiredParameterMissing">
            <summary>
            The candidate member was rejected because an required parameter had no corresponding argument.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.NameUsedForPositional">
            <summary>
            The candidate member was rejected because a named argument was used that corresponded to a previously-given positional argument.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.UseSiteError">
            <summary>
            The candidate member was rejected because it is not supported by the language or cannot be used 
            given the current set of assembly references.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.UnsupportedMetadata">
            <summary>
            The candidate member was rejected because it is not supported by the language.
            </summary>
            <remarks>
            No diagnostics will be reported for such candidates unless they "win" overload resolution.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.BadArguments">
            <summary>
            The candidate member was rejected because an argument could not be converted to the appropriate parameter
            type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.TypeInferenceFailed">
            <summary>
            The candidate member was rejected because type inference failed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.TypeInferenceExtensionInstanceArgument">
            <summary>
            The extension method candidate was rejected because type
            inference based on the "instance" argument failed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.ConstructedParameterFailedConstraintCheck">
            <summary>
            The candidate member was rejected because it a constraint on a type parameter was not satisfied.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.LessDerived">
            <summary>
            The candidate member was rejected because another member further down in the inheritance hierarchy was
            present.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MemberResolutionKind.Worse">
            <summary>
            The candidate member was rejected because it was considered worse that another member (according to section
            7.5.3.2 of the language specification).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1">
            <summary>
            Represents the results of overload resolution for a single member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1.Member">
            <summary>
            The member considered during overload resolution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1.LeastOverriddenMember">
            <summary>
            The least overridden member that is accessible from the call site that performed overload resolution. 
            Typically a virtual or abstract method (but not necessarily).
            </summary>
            <remarks>
            The member whose parameter types and params modifiers were considered during overload resolution.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1.Resolution">
            <summary>
            Indicates why the compiler accepted or rejected the member during overload resolution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1.IsValid">
            <summary>
            Returns true if the compiler accepted this member as the sole correct result of overload resolution.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberResolutionResult`1.Result">
            <summary>
            The result of member analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodTypeInferrer.GetInterfaceInferenceBound(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol},Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Return the interface with an original definition matches
            the original definition of the target. If the are no matches,
            or multiple multiple matches, the return value is null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodTypeInferrer.GetInferredTypeArguments">
            <summary>
            Return the inferred type arguments using null
            for any type arguments that were not inferred.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1">
            <summary>
            Summarizes the results of an overload resolution analysis, as described in section 7.5 of
            the language specification. Describes whether overload resolution succeeded, and which
            method was selected if overload resolution succeeded, as well as detailed information about
            each method that was considered. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.Succeeded">
            <summary>
            True if overload resolution successfully selected a single best method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.ValidResult">
            <summary>
            If overload resolution successfully selected a single best method, returns information
            about that method. Otherwise returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.BestResult">
            <summary>
            If there was a method that overload resolution considered better than all others,
            returns information about that method. A method may be returned even if that method was
            not considered a successful overload resolution, as long as it was better that any other
            potential method considered.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.Results">
            <summary>
            Returns information about each method that was considered during overload resolution,
            and what the results of overload resolution were for that method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.HasAnyApplicableMember">
            <summary>
            Returns true if one or more of the members in the group are applicable. (Note that
            Succeeded implies IsApplicable but IsApplicable does not imply Succeeded.  It is possible
            that no applicable member was better than all others.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.GetAllApplicableMembers">
            <summary>
            Returns all methods in the group that are applicable, <see cref="P:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.HasAnyApplicableMember"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.ReportDiagnostics``1(Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.DiagnosticBag,System.String,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.AnalyzedArguments,System.Collections.Immutable.ImmutableArray{``0},Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Boolean)">
            <summary>
            Called when overload resolution has failed.  Figures out the best way to describe what went wrong.
            </summary>
            <remarks>
            Overload resolution (effectively) starts out assuming that all candidates are valid and then
            gradually disqualifies them.  Therefore, our strategry will be to perform our checks in the
            reverse order - the farther a candidate got through the process without being flagged, the
            "better" it was.
            
            Note that "final validation" is performed after overload resolution,
            so final validation errors are not seen here. Final validation errors include
            violations of constraints on method type parameters, static/instance mismatches,
            and so on.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.OverloadResolutionResult`1.UnwrapIfParamsArray(Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol)">
            <summary>
            If an argument fails to convert to the type of the corresponding parameter and that
            parameter is a params array, then the error message should reflect the element type
            of the params array - not the array type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbol">
            <summary>
            The base class for all symbols (namespaces, classes, method, parameters, etc.) that are 
            exposed by the compiler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Checks if 'symbol' is accessible from within named type 'within'.  If 'symbol' is accessed off
            of an expression then 'throughTypeOpt' is the type of that expression. This is needed to
            properly do protected access checks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <summary>
            Checks if 'symbol' is accessible from within assembly 'within'.  
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.CheckDefinitionInvariant">
            <summary>
            Checks if this symbol is a definition and its containing module is a SourceModuleSymbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsDefinitionOrDistinct">
            <summary>
            Return whether the symbol is either the original definition
            or distinct from the original. Intended for use in Debug.Assert
            only since it may include a deep comparison.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetCustomAttributesToEmit(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData},System.Boolean,System.Boolean)">
            <summary>
            Returns a list of attributes to emit to CustomAttribute table.
            The <paramref name="synthesized"/> builder is freed after all its items are enumerated.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.RequiresCompletion">
            <summary>
            True if this Symbol should be completed by calling ForceComplete.
            Intuitively, true for source entities (from any compilation).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.MetadataName">
            <summary>
            Gets the name of a symbol as it appears in metadata. Most of the time, this
            is the same as the Name property, with the following exceptions:
            1) The metadata name of generic types includes the "`1", "`2" etc. suffix that
            indicates the number of type parameters (it does not include, however, names of
            containing types or namespaces).
            2) The metadata name of explicit interface names have spaces removed, compared to
            the name property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ContainingSymbol">
            <summary>
            Get the symbol that logically contains this symbol. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ContainingType">
            <summary>
            Returns the nearest lexically enclosing type, or null if there is none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ContainingNamespace">
            <summary>
            Gets the nearest enclosing namespace for this namespace or type. For a nested type,
            returns the namespace that contains its container.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ContainingAssembly">
            <summary>
            Returns the assembly containing this symbol. If this symbol is shared across multiple
            assemblies, or doesn't belong to an assembly, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.DeclaringCompilation">
            <summary>
            For a source assembly, the associated compilation.
            For any other assembly, null.
            For a source module, the DeclaringCompilation of the associated source assembly.
            For any other module, null.
            For any other symbol, the DeclaringCompilation of the associated module.
            </summary>
            <remarks>
            We're going through the containing module, rather than the containing assembly,
            because of /addmodule (symbols in such modules should return null).
            
            Remarks, not "ContainingCompilation" because it isn't transitive.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ContainingModule">
            <summary>
            Returns the module containing this symbol. If this symbol is shared across multiple
            modules, or doesn't belong to a module, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsDefinition">
            <summary>
            Returns true if this is the original definition of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetLexicalSortKey">
            <summary>
            <para>
            Get a source location key for sorting. For performance, it's important that this
            be able to be returned from a symbol without doing any additional allocations (even
            if nothing is cached yet.)
            </para>
            <para>
            Only (original) source symbols and namespaces that can be merged
            need implement this function if they want to do so for efficiency.
            </para>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.Locations">
            <summary>
            Gets the locations where this symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.DeclaringSyntaxReferences">
            <summary>
            <para>
            Get the syntax node(s) where this symbol was declared in source. Some symbols (for
            example, partial classes) may be defined in more than one location. This property should
            return one or more syntax nodes only if the symbol was declared in source code and also
            was not implicitly declared (see the <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsImplicitlyDeclared"/> property). 
            </para>
            <para>
            Note that for namespace symbol, the declaring syntax might be declaring a nested
            namespace. For example, the declaring syntax node for N1 in "namespace N1.N2 {...}" is
            the entire <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax"/> for N1.N2. For the global namespace, the declaring
            syntax will be the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax"/>.
            </para>
            </summary>
            <returns>
            The syntax node(s) that declared the symbol. If the symbol was declared in metadata or
            was implicitly declared, returns an empty read-only array.
            </returns>
            <remarks>
            To go the opposite direction (from syntax node to symbol), see <see
            cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetDeclaringSyntaxReferenceHelper``1(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.Location})">
            <summary>
            Helper for implementing <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.DeclaringSyntaxReferences"/> for derived classes that store a location but not a 
            <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> or <see cref="T:Microsoft.CodeAnalysis.SyntaxReference"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns <see cref="F:Microsoft.CodeAnalysis.Accessibility.NotApplicable"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the <c>static</c> modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the <c>virtual</c> modifier. Does not return true for
            members declared as abstract or override.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the <c>override</c> modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
            <remarks>
            Even for metadata symbols, <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsOverride"/> = true does not imply that <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.OverriddenMethod"/> will
            be non-null.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the <c>abstract</c> modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the <c>sealed</c> modifier. Also set for
            types that do not allow a derived class (declared with <c>sealed</c> or <c>static</c> or <c>struct</c>
            or <c>enum</c> or <c>delegate</c>).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            <c>extern</c> modifier. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.IsImplicitlyDeclared">
            <summary>
            Returns true if this symbol was automatically created by the compiler, and does not
            have an explicit corresponding source code declaration.  
            
            This is intended for symbols that are ordinary symbols in the language sense,
            and may be used by code, but that are simply declared implicitly rather than
            with explicit language syntax.
            
            Examples include (this list is not exhaustive):
              the default constructor for a class or struct that is created if one is not provided,
              the BeginInvoke/Invoke/EndInvoke methods for a delegate,
              the generated backing field for an auto property or a field-like event,
              the "this" parameter for non-static methods,
              the "value" parameter for a property setter,
              the parameters on indexer accessor methods (not on the indexer itself),
              methods in anonymous types,
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.CanBeReferencedByName">
            <summary>
            Returns true if this symbol can be referenced by its name in code. Examples of symbols
            that cannot be referenced by name are:
               constructors, destructors, operators, explicit interface implementations,
               accessor methods for properties and events, array types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.CanBeReferencedByNameIgnoringIllegalCharacters">
            <summary>
            As an optimization, viability checking in the lookup code should use this property instead
            of <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbol.CanBeReferencedByName"/>. The full name check will then be performed in the <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel"/>.
            </summary>
            <remarks>
            This property exists purely for performance reasons.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.AfterAddingTypeMembersChecks(Microsoft.CodeAnalysis.CSharp.ConversionsBase,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Perform additional checks after the member has been
            added to the member list of the containing type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.op_Equality(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Compare two symbol objects to see if they refer to the same symbol. You should always
            use <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.op_Equality(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol)"/> and <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.op_Inequality(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol)"/>, or the <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.Equals(System.Object)"/> method, to compare two symbols for equality.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.op_Inequality(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Compare two symbol objects to see if they refer to the same symbol. You should always
            use == and !=, or the Equals method, to compare two symbols for equality.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.ToString">
            <summary>
            Returns a string representation of this symbol, suitable for debugging purposes, or
            for placing in an error message.
            </summary>
            <remarks>
            This will provide a useful representation, but it would be clearer to call <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.ToDisplayString(Microsoft.CodeAnalysis.SymbolDisplayFormat)"/>
            directly and provide an explicit format.
            Sealed so that <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.ToString"/> and <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.ToDisplayString(Microsoft.CodeAnalysis.SymbolDisplayFormat)"/> can't get out of sync.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.AddSynthesizedAttributes(Microsoft.CodeAnalysis.CSharp.ModuleCompilationState,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData}@)">
            <summary>
            Build and add synthesized attributes for this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.AddSynthesizedAttribute(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData}@,Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData)">
            <summary>
            Convenience helper called by subclasses to add a synthesized attribute to a collection of attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetEffectiveDefaultMarshallingCharSet">
            <summary>
            <see cref="T:System.Runtime.InteropServices.CharSet"/> effective for this symbol (type or DllImport method).
            Nothing if <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> isn't applied on the containing module or it doesn't apply on this symbol.
            </summary>
            <remarks>
            Determined based upon value specified via <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> applied on the containing module.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.Dangerous_IsFromSomeCompilation">
            <summary>
            Always prefer <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsFromCompilation(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)"/>.
            </summary>
            <remarks>
            <para>
            Unfortunately, when determining overriding/hiding/implementation relationships, we don't 
            have the "current" compilation available.  We could, but that would clutter up the API 
            without providing much benefit.  As a compromise, we consider all compilations "current".
            </para>
            <para>
            Unlike in VB, we are not allowing retargeting symbols.  This method is used as an approximation
            for <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.IsFromCompilation(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)"/> when a compilation is not available and that method will never return
            true for retargeting symbols.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetDocumentationCommentId">
            <summary>
            Returns the Documentation Comment ID for the symbol, or null if the symbol doesn't
            support documentation comments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetDocumentationCommentXml(System.Globalization.CultureInfo,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Fetches the documentation comment for this element with a cancellation token.
            </summary>
            <param name="preferredCulture">Optionally, retrieve the comments formatted for a particular culture. No impact on source documentation comments.</param>
            <param name="expandIncludes">Optionally, expand <![CDATA[<include>]]> elements. No impact on non-source documentation comments.</param>
            <param name="cancellationToken">Optionally, allow cancellation of documentation comment retrieval.</param>
            <returns>The XML that would be written to the documentation file for the symbol.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.HasUseSiteError">
            <summary>
            True if the symbol has a use-site diagnostic with error severity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetUseSiteDiagnostic">
            <summary>
            Returns diagnostic info that should be reported at the use site of the symbol, or null if there is none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            Supposed to be ErrorCode, but it causes inconsistent accessibility error.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.HasUnsupportedMetadata">
            <summary>
            Indicates that this symbol uses metadata that cannot be supported by the language.
            
            Examples include:
               - Pointer types in VB
               - ByRef return type
               - Required custom modifiers
               
            This is distinguished from, for example, references to metadata symbols defined in assemblies that weren't referenced.
            Symbols where this returns true can never be used successfully, and thus should never appear in any IDE feature.
            
            This is set for metadata symbols, as follows:
            Type - if a type is unsupported (e.g., a pointer type, etc.)
            Method - parameter or return type is unsupported
            Field - type is unsupported
            Event - type is unsupported
            Property - type is unsupported
            Parameter - type is unsupported
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.MergeUseSiteDiagnostics(Microsoft.CodeAnalysis.DiagnosticInfo@,Microsoft.CodeAnalysis.DiagnosticInfo)">
            <summary>
            Merges given diagnostic to the existing result diagnostic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.ReportUseSiteDiagnostic(Microsoft.CodeAnalysis.DiagnosticInfo,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.Location)">
            <summary>
            Reports specified use-site diagnostic to given diagnostic bag. 
            </summary>
            <remarks>
            This method should be the only method adding use-site diagnostics to a diagnostic bag. 
            It performs additional adjustments of the location for unification related diagnostics and 
            may be the place where to add more use-site location post-processing.
            </remarks>
            <returns>True if the diagnostic has error severity.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.DeriveUseSiteDiagnosticFromType(Microsoft.CodeAnalysis.DiagnosticInfo@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Derive error info from a type symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ObsoleteState">
            <summary>
            True if this symbol has been marked with the <see cref="T:System.ObsoleteAttribute"/> attribute. 
            This property returns <see cref="F:Microsoft.CodeAnalysis.ThreeState.Unknown"/> if the <see cref="T:System.ObsoleteAttribute"/> attribute hasn't been cracked yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from <see cref="T:System.ObsoleteAttribute"/> attribute or null if there is no <see cref="T:System.ObsoleteAttribute"/> attribute.
            This property returns <see cref="F:Microsoft.CodeAnalysis.ObsoleteAttributeData.Uninitialized"/> if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetGuidStringDefaultImplementation(System.String@)">
            <summary>
            Returns true and a <see cref="T:System.String"/> from the first <see cref="T:System.Runtime.InteropServices.GuidAttribute"/> on the symbol, 
            the string might be null or an invalid guid representation. False, 
            if there is no <see cref="T:System.Runtime.InteropServices.GuidAttribute"/> with string argument.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetAttributes">
            <summary>
            Gets the attributes for this symbol. Returns an empty <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> if
            there are no attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetAttributeTarget">
            <summary>
            Gets the attribute target kind corresponding to the symbol kind
            If attributes cannot be applied to this symbol kind, returns
            an invalid AttributeTargets value of 0
            </summary>
            <returns>AttributeTargets or 0</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.EarlyDecodeWellKnownAttributeType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>
            Method to early decode the type of well-known attribute which can be queried during the BindAttributeType phase.
            This method is called first during attribute binding so that any attributes that affect semantics of type binding
            can be decoded here.
            </summary>
            <remarks>
            NOTE: If you are early decoding any new well-known attribute, make sure to update PostEarlyDecodeWellKnownAttributeTypes 
            to default initialize this data.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.PostEarlyDecodeWellKnownAttributeTypes">
            <summary>
            This method is called during attribute binding after EarlyDecodeWellKnownAttributeTypes has been executed.
            Symbols should default initialize the data for early decoded well-known attributes here.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.EarlyDecodeWellKnownAttribute(Microsoft.CodeAnalysis.EarlyDecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.CSharp.EarlyWellKnownAttributeBinder,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation}@)">
            <summary>
            Method to early decode applied well-known attribute which can be queried by the binder.
            This method is called during attribute binding after we have bound the attribute types for all attributes,
            but haven't yet bound the attribute arguments/attribute constructor.
            Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol
            when binding the attribute arguments/attribute constructor without causing attribute binding cycle.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.DecodeWellKnownAttribute(Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation}@)">
            <summary>
            This method is called by the binder when it is finished binding a set of attributes on the symbol so that
            the symbol can extract data from the attribute arguments and potentially perform validation specific to
            some well known attributes.
            <para>
            NOTE: If we are decoding a well-known attribute that could be queried by the binder, consider decoding it during early decoding pass.
            </para>
            </summary>
            <remarks>
            <para>
            Symbol types should override this if they want to handle a specific well-known attribute.
            If the attribute is of a type that the symbol does not wish to handle, it should delegate back to
            this (base) method.
            </para>
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.PostDecodeWellKnownAttributes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,Microsoft.CodeAnalysis.WellKnownAttributeData)">
            <summary>
            Called to report attribute related diagnostics after all attributes have been bound and decoded.
            Called even if there are no attributes.
            </summary>
            <remarks>
            This method is called by the binder from <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany{Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax}},Microsoft.CodeAnalysis.CustomAttributesBag{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData}@,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,System.Boolean)"/> after it has finished binding attributes on the symbol,
            has executed <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.DecodeWellKnownAttribute(Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation}@)"/> for attributes applied on the symbol and has stored the decoded data in the
            lazyCustomAttributesBag on the symbol. Bound attributes haven't been stored on the bag yet.
            
            Post-validation for attributes that is dependant on other attributes can be done here.
            
            This method should not have any side effects on the symbol, i.e. it SHOULD NOT change the symbol state.
            </remarks>
            <param name="boundAttributes">Bound attributes.</param>
            <param name="allAttributeSyntaxNodes">Syntax nodes of attributes in order they are specified in source, or null if there are no attributes.</param>
            <param name="diagnostics">Diagnostic bag.</param>
            <param name="symbolPart">Specific part of the symbol to which the attributes apply, or <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation.None"/> if the attributes apply to the symbol itself.</param>
            <param name="decodedData">Decoded well-known attribute data, could be null.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.LoadAndValidateAttributes(Roslyn.Utilities.OneOrMany{Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax}},Microsoft.CodeAnalysis.CustomAttributesBag{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData}@,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,System.Boolean)">
            <summary>
            This method does the following set of operations in the specified order:
            (1) GetAttributesToBind: Merge attributes from the given attributesSyntaxLists and filter out attributes by attribute target.
            (2) BindAttributeTypes: Bind all the attribute types to enable early decode of certain well-known attributes by type.
            (3) EarlyDecodeWellKnownAttributes: Perform early decoding of certain well-known attributes that could be queried by the binder in subsequent steps.
                (NOTE: This step has the side effect of updating the symbol state based on the data extracted from well known attributes).
            (4) GetAttributes: Bind the attributes (attribute arguments and constructor) using bound attribute types.
            (5) DecodeWellKnownAttributes: Decode and validate bound well known attributes.
                (NOTE: This step has the side effect of updating the symbol state based on the data extracted from well known attributes).
            (6) StoreBoundAttributesAndDoPostValidation:
                (a) Store the bound attributes in lazyCustomAttributes in a thread safe manner.
                (b) Perform some additional post attribute validations, such as
                    1) Duplicate attributes, attribute usage target validation, etc.
                    2) Post validation for attributes dependant on other attributes
                    These validations cannot be performed prior to step 6(a) as we might need to
                    perform a GetAttributes() call on a symbol which can introduce a cycle in attribute binding.
                    We avoid this cycle by performing such validations in PostDecodeWellKnownAttributes after lazyCustomAttributes have been set.
                NOTE: PostDecodeWellKnownAttributes SHOULD NOT change the symbol state.
            </summary>
            <remarks>
            Current design of early decoding well-known attributes doesn't permit decoding attribute arguments/constructor as this can lead to binding cycles.
            For well-known attributes used by the binder, where we need the decoded arguments, we must handle them specially in one of the following possible ways:
              (a) Avoid decoding the attribute arguments during binding and delay the corresponding binder tasks to a separate post-pass executed after binding.
              (b) As the cycles can be caused only when we are binding attribute arguments/constructor, special case the corresponding binder tasks based on the current BinderFlags.
            </remarks>
            <param name="attributesSyntaxLists"></param>
            <param name="lazyCustomAttributesBag"></param>
            <param name="symbolPart">Specific part of the symbol to which the attributes apply, or <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation.None"/> if the attributes apply to the symbol itself.</param>
            <param name="earlyDecodingOnly">Indicates that only early decoding should be performed.  WARNING: the resulting bag will not be sealed.</param>
            <returns>Flag indicating whether lazyCustomAttributes were stored on this thread. Caller should check for this flag and perform NotePartComplete if true.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.GetAttributesToBind(Roslyn.Utilities.OneOrMany{Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax}},Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Binder}@)">
            <summary>
            Method to merge attributes from the given attributesSyntaxLists and filter out attributes by attribute target.
            This is the first step in attribute binding.
            </summary>
            <remarks>
            This method can generate diagnostics for few cases where we have an invalid target specifier and the parser hasn't generated the necessary diagnostics.
            It should not perform any bind operations as it can lead to an attribute binding cycle.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.EarlyDecodeWellKnownAttributes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Binder},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax},Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData[])">
            <summary>
            Method to early decode certain well-known attributes which can be queried by the binder.
            This method is called during attribute binding after we have bound the attribute types for all attributes,
            but haven't yet bound the attribute arguments/attribute constructor.
            Early decoding certain well-known attributes enables the binder to use this decoded information on this symbol
            when binding the attribute arguments/attribute constructor without causing attribute binding cycle.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.ValidateAttributeUsageAndDecodeWellKnownAttributes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Binder},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData},Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation)">
            <summary>
            This method validates attribute usage for each bound attribute and calls <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbol.DecodeWellKnownAttribute(Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation}@)"/>
            on attributes with valid attribute usage.
            This method is called by the binder when it is finished binding a set of attributes on the symbol so that
            the symbol can extract data from the attribute arguments and potentially perform validation specific to
            some well known attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.ValidateAttributeUsage(Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation,Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol})">
            <summary>
            Validate attribute usage target and duplicate attributes.
            </summary>
            <param name="attribute">Bound attribute</param>
            <param name="node">Syntax node for attribute specification</param>
            <param name="compilation">Compilation</param>
            <param name="symbolPart">Symbol part to which the attribute has been applied.</param>
            <param name="diagnostics">Diagnostics</param>
            <param name="uniqueAttributeTypes">Set of unique attribute types applied to the symbol</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbol.ForceCompleteObsoleteAttribute">
            <summary>
            Ensure that attributes are bound and the ObsoleteState of this symbol is known.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SingleLookupResult">
            <summary>
            Represents a result of lookup operation over a 0 or 1 symbol (as opposed to a scope). The
            typical use is to represent that a particular symbol is good/bad/unavailable.
            
            For more explanation of Kind, Symbol, Error - see LookupResult.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TypeofBinder">
            <summary>
            This binder is for binding the argument to typeof.  It traverses
            the syntax marking each open type ("unbound generic type" in the
            C# spec) as either allowed or not allowed, so that BindType can 
            appropriately return either the corresponding type symbol or an 
            error type.  It also indicates whether the argument as a whole 
            should be considered open so that the flag can be set 
            appropriately in BoundTypeOfOperator.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TypeofBinder.OpenTypeVisitor">
            <summary>
            This visitor walks over a type expression looking for open types.
            Open types are allowed if an only if:
              1) There is no constructed generic type elsewhere in the visited syntax; and
              2) The open type is not used as a type argument or array/pointer/nullable
                   element type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeofBinder.OpenTypeVisitor.Visit(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax,System.Boolean}@,System.Boolean@)">
            <param name="typeSyntax">The argument to typeof.</param>
            <param name="allowedMap">
            Keys are GenericNameSyntax nodes representing unbound generic types.
            Values are false if the node should result in an error and true otherwise.
            </param>
            <param name="isUnboundGenericType">True if no constructed generic type was encountered.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.WithClassTypeParametersBinder">
            <summary>
            A binder that places class/interface/struct/delegate type parameters in scope
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.WithCrefTypeParametersBinder">
            <summary>
            The scope within a documentation cref.  Contains the implicitly declared type parameters
            of the cref (see <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.CrefTypeParameterSymbol"/> for details).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.WithMethodTypeParametersBinder">
            <summary>
            A binder that places method type parameters in scope.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.WithParametersBinder">
            <summary>
            Binder used to place the parameters of a method, property, indexer, or delegate
            in scope when binding &lt;param&gt; tags inside of XML documentation comments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundExpression.SuppressVirtualCalls">
            <summary>
            Returns true if calls and delegate invocations with this
            expression as the receiver should be non-virtual calls.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundExpression.Display">
            <summary>
            Returns a serializable object that is used for displaying this expression in a diagnostic message.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundCall.OriginalMethodsOpt">
            <summary>
            The set of method symbols from which this call's method was chosen. 
            Only kept in the tree if the call was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundIndexerAccess.OriginalIndexersOpt">
            <summary>
            The set of indexer symbols from which this call's indexer was chosen. 
            Only kept in the tree if the call was an error and overload resolution
            was unable to choose a best indexer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator.OriginalUserDefinedOperatorsOpt">
            <summary>
            The set of method symbols from which this operator's method was chosen. 
            Only kept in the tree if the operator was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundUserDefinedConditionalLogicalOperator.OriginalUserDefinedOperatorsOpt">
            <summary>
            The set of method symbols from which this operator's method was chosen. 
            Only kept in the tree if the operator was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundUnaryOperator.OriginalUserDefinedOperatorsOpt">
            <summary>
            The set of method symbols from which this operator's method was chosen. 
            Only kept in the tree if the operator was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundIncrementOperator.OriginalUserDefinedOperatorsOpt">
            <summary>
            The set of method symbols from which this operator's method was chosen. 
            Only kept in the tree if the operator was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundCompoundAssignmentOperator.OriginalUserDefinedOperatorsOpt">
            <summary>
            The set of method symbols from which this operator's method was chosen. 
            Only kept in the tree if the operator was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundConversion.OriginalUserDefinedConversionsOpt">
            <summary>
            The set of method symbols from which this conversion's method was chosen. 
            Only kept in the tree if the conversion was an error and overload resolution
            was unable to choose a best method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundConversion.ConversionHasSideEffects">
            <summary>
            Returns true when conversion itself (not the operand) may have sideeffects
            A typical sideeffect of a conversion is an exception when conversion is unsuccessful.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundConversion.SynthesizedNonUserDefined(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.ConversionKind,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.ConstantValue)">
            <remarks>
            This method is intended for passes other than the LocalRewriter.
            Use MakeConversion helper method in the LocalRewriter instead,
            it generates a synthesized conversion in its lowered form.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundConversion.Synthesized(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Conversion,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <remarks>
            NOTE:    This method is intended for passes other than the LocalRewriter.
            NOTE:    Use MakeConversion helper method in the LocalRewriter instead,
            NOTE:    it generates a synthesized conversion in its lowered form.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.BoundObjectCreationExpression.UpdateArgumentsAndInitializer(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Build an object creation expression without performing any rewriting
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.BoundMethodGroupFlags.HasImplicitReceiver">
            <summary>
            Set if the group has a receiver but none was not specified in syntax.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundNode.HasAnyErrors">
            <summary>
            Determines if a bound node, or associated syntax or type has an error (not a warning) 
            diagnostic associated with it.
            
            Typically used in the binder as a way to prevent cascading errors. 
            In most other cases a more lightweight HasErrors should be used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundNode.HasErrors">
            <summary>
            Determines if a bound node, or any child, grandchild, etc has an error (not warning)
            diagnostic associated with it. The HasError bit is initially set for a node by providing it
            to the node constructor. If any child nodes of a node have
            the HasErrors bit set, then it is automatically set to true on the parent bound node.
            
            HasErrors indicates that the tree is not emittable and used to shortcircuit lowering/emit stages.
            NOTE: not having HasErrors does not guarantee that we do not have any diagnostic associated
                  with corresponding syntax or type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundNode.WasCompilerGenerated">
            <remarks>
            NOTE: not generally set in rewriters.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundQueryClause.Operation">
            <summary>
            The bound expression that invokes the operation of the query clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundQueryClause.Cast">
            <summary>
            The bound expression that is the invocation of a "Cast" method specified by the query translation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.BoundQueryClause.UnoptimizedForm">
            <summary>
            The bound expression that is the query expression in "unoptimized" form.  Specifically, a final ".Select"
            invocation that is omitted by the specification is included here.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.PseudoVariableExpressions">
            <summary>
            BoundExpressions to be used for emit. The expressions are assumed
            to be lowered and will not be visited by <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundTreeWalker"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.UnboundLambdaState.CanonicallyCompareDiagnostics(Microsoft.CodeAnalysis.Diagnostic,Microsoft.CodeAnalysis.Diagnostic)">
            <summary>
            What we need to do is find a *repeatable* arbitrary way to choose between
            two errors; we can for example simply take the one that is lower in alphabetical
            order when converted to a string.  As an optimization, we compare error codes
            first and skip string comparison if they differ.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator._indirectReturnState">
            <summary>
            In some cases returns are handled as gotos to return epilogue.
            This is used to track the state of the epilogue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAddress(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.AddressKind)">
            <summary>
            Emits address as in &amp; 
            
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAddressOfTempClone(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Emits address of a temp.
            Used in cases where taking address directly is not possible 
            (typically because expression does not have a home)
            
            Introduce a temp which it will return.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitSequenceAddress(Microsoft.CodeAnalysis.CSharp.BoundSequence,Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.AddressKind)">
            <summary>
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.HasHome(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Checks if expression directly or indirectly represents a value with its own home. In
            such cases it is possible to get a reference without loading into a temporary.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.HasHome(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess)">
            <summary>
            Special HasHome for fields. Fields have homes when they are writeable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitFieldAddress(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess)">
            <summary>
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitReceiverRef(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Emits receiver in a form that allows member accesses ( O or &amp; ). For verifiably
            reference types it is the actual reference. For generic types it is a address of the
            receiver with readonly intent. For the value types it is an address of the receiver.
            
            isAccessConstrained indicates that receiver is a target of a constrained callvirt
            in such case it is unnecessary to box a receier that is typed to a type parameter
            
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitInstanceFieldAddress(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess)">
            <summary>
            May introduce a temp which it will return. (otherwise returns null)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitArrayInitializers(Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundArrayInitialization)">
            <summary>
            Entry point to the array initialization.
            Assumes that we have newly created array on the stack.
            
            inits could be an array of values for a single dimensional array
            or an   array (of array)+  of values for a multidimensional case
            
            in either case it is expected that number of leaf values will match number 
            of elements in the array and nesting level should match the rank of the array.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.IndexDesc">
            <summary>
            To handle array initialization of arbitrary rank it is convenient to 
            approach multidimensional initialization as a recursively nested.
            
            ForAll{i, j, k} Init(i, j, k) ===> 
            ForAll{i} ForAll{j, k} Init(i, j, k) ===>
            ForAll{i} ForAll{j} ForAll{k} Init(i, j, k)
            
            This structure is used for capturing initializers of a given index and 
            the index value itself.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitAllElementInitializersRecursive(Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.IndexDesc},System.Boolean)">
            <summary>
            Emits all initializers that match indices on the stack recursively.
            
            Example: 
             if array has [0..2, 0..3, 0..2] shape
             and we have {1, 2} indices on the stack
             initializers for 
                         [1, 2, 0]
                         [1, 2, 1]
                         [1, 2, 2]
            
             will be emitted and the top index will be pushed off the stack 
             as at that point we would be completely done with emitting initializers 
             corresponding to that index.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.InitializerCountRecursive(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},System.Int32@,System.Int32@)">
            <summary>
            Count of all nontrivial initializers and count of those that are constants.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetRawData(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            Produces a serialized blob of all constant initializers.
            Nonconstat initializers are matched with a zero of corresponding size.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.IsMultidimensionalInitializer(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            Check if it is a regular collection of expressions or there are nested initializers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.CanUseCallOnRefTypeReceiver(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Used to decide if we need to emit call or callvirt.
            It basically checks if the receiver expression cannot be null, but it is not 100% precise. 
            There are cases where it really can be null, but we do not care.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.IsThisReceiver(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            checks if receiver is effectively ldarg.0
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.MayUseCallForStructMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Used to decide if we need to emit 'call' or 'callvirt' for structure method.
            It basically checks if the method overrides any other and method's defining type
            is not a 'special' or 'special-by-ref' type. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.TreatLongsAsNative(Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            When array operation get long or ulong arguments the args should be 
            cast to native int.
            Note that the cast is always checked.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitVectorElementStore(Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Emit an element store instruction for a single dimensional array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitConditionalOperator(Microsoft.CodeAnalysis.CSharp.BoundConditionalOperator,System.Boolean)">
            <summary>
            Emit code for a conditional (aka ternary) operator.
            </summary>
            <remarks>
            (b ? x : y) becomes
                push b
                if pop then goto CONSEQUENCE
                push y
                goto DONE
              CONSEQUENCE:
                push x
              DONE:
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitNullCoalescingOperator(Microsoft.CodeAnalysis.CSharp.BoundNullCoalescingOperator,System.Boolean)">
            <summary>
            Emit code for a null-coalescing operator.
            </summary>
            <remarks>
            x ?? y becomes
              push x
              dup x
              if pop != null goto LEFT_NOT_NULL
                pop 
                push y
              LEFT_NOT_NULL:
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.CodeForJump(Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator,System.Boolean,Microsoft.CodeAnalysis.CodeGen.ILOpCode@)">
            <summary>
            Produces opcode for a jump that corresponds to given opearation and sense.
            Also produces a reverse opcode - opcode for the same condition with inverted sense.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitCatchBlock(Microsoft.CodeAnalysis.CSharp.BoundCatchBlock)">
             <remarks>
             The interesting part in the following method is the support for exception filters. 
             === Example:
            
             try
             {
                TryBlock
             }
             catch (ExceptionType ex) when (Condition)
             {
                Handler
             }
            
             gets emitted as something like ===>
            
             Try           
                 TryBlock
             Filter 
                 var tmp = Pop() as {ExceptionType}
                 if (tmp == null)
                 {
                     Push 0
                 }
                 else
                 {
                     ex = tmp
                     Push Condition ? 1 : 0
                 }
             End Filter // leaves 1 or 0 on the stack
             Catch      // gets called after finalization of nested exception frames if condition above produced 1
                 Pop    // CLR pushes the exception object again
                 variable ex can be used here
                 Handler
             EndCatch
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.EmitStringCompareAndBranch(Microsoft.CodeAnalysis.CodeGen.LocalOrParameter,Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ConstantValue,System.Object,Microsoft.Cci.IReference)">
            <summary>
            Delegate to emit string compare call and conditional branch based on the compare result.
            </summary>
            <param name="key">Key to compare</param>
            <param name="syntaxNode">Node for diagnostics.</param>
            <param name="stringConstant">Case constant to compare the key against</param>
            <param name="targetLabel">Target label to branch to if key = stringConstant</param>
            <param name="stringEqualityMethodRef">String equality method</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetLocal(Microsoft.CodeAnalysis.CSharp.BoundLocal)">
            <summary>
            Gets already declared and initialized local.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.GetLocalDebugName(Microsoft.CodeAnalysis.ILocalSymbolInternal,Microsoft.CodeAnalysis.CodeGen.LocalDebugId@)">
            <summary>
            Gets the name and id of the local that are going to be generated into the debug metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.FreeLocal(Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol)">
            <summary>
            Releases a local.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.AllocateTemp(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Allocates a temp without identity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.FreeTemp(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
            <summary>
            Frees a temp.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.FreeOptTemp(Microsoft.CodeAnalysis.CodeGen.LocalDefinition)">
            <summary>
            Frees an optional temp.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.FinallyCloner">
            <summary>
            Clones all labels used in a finally block.
            This allows creating an emittable clone of finally.
            It is safe to do because no branches can go in or out of the finally handler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.CodeGenerator.FinallyCloner.MakeFinallyClone(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            The argument is BoundTryStatement (and not a BoundBlock) specifically 
            to support only Finally blocks where it is guaranteed to not have incoming or leaving branches.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.LocalDefUseSpan.ConflictsWith(Microsoft.CodeAnalysis.CSharp.CodeGen.LocalDefUseSpan)">
            <summary>
            when current and other use spans are regular spans we can have only 2 conflict cases:
            [1, 3) conflicts with [0, 2)
            [1, 3) conflicts with [2, 4)
            specifically:
            [1, 3) does not conflict with [0, 1)
            
            NOTE: with regular spans, it is not possible 
            to have start1 == start2 or end1 == end 
            since at the same node we can access only one real local.
            
            However at the same node we can access one or more dummy locals.
            So we can have start1 == start2 and end1 == end2 scenarios, but only if 
            other span is a span of a dummy.
            
            In such cases we consider 
               start2 == span1.start ==> start2 IS included in span1
               end2 == span1.end ==> end2 IS NOT included in span1
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CodeGen.StackOptimizerPass1.ReuseOrVisit(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.CodeGen.ExprContext)">
            <summary>
            Recursively rewrites the node or simply replaces it with a dup node
            if we have just seen exactly same node.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments">
            <summary>
            The command line arguments to a C# <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpCompiler"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments.CompilationOptions">
            <summary>
            Gets the compilation options for the C# <see cref="T:Microsoft.CodeAnalysis.Compilation"/>
            created from the <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpCompiler"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments.ParseOptions">
            <summary>
            Gets the parse options for the C# <see cref="T:Microsoft.CodeAnalysis.Compilation"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineArguments.ShouldIncludeErrorEndLocation">
            <value>
            Should the format of error messages include the line and column of
            the end of the offending text.
            </value>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CommandLineDiagnosticFormatter.RelativizeNormalizedPath(System.String)">
            <summary>
            Get the path name starting from the <see cref="F:Microsoft.CodeAnalysis.CSharp.CommandLineDiagnosticFormatter._baseDirectory"/>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser.Parse(System.Collections.Generic.IEnumerable{System.String},System.String,System.String,System.String)">
            <summary>
            Parses a command line.
            </summary>
            <param name="args">A collection of strings representing the command line arguments.</param>
            <param name="baseDirectory">The base directory used for qualifying file locations.</param>
            <param name="sdkDirectory">The directory to search for mscorlib.</param>
            <param name="additionalReferenceDirectories">A string representing additional reference paths.</param>
            <returns>a commandlinearguments object representing the parsed command line.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCommandLineParser.AddDiagnostic(System.Collections.Generic.IList{Microsoft.CodeAnalysis.Diagnostic},System.Collections.Generic.Dictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic},Microsoft.CodeAnalysis.CSharp.ErrorCode,System.Object[])">
            <summary>
            Diagnostic for the errorCode added if the warningOptions does not mention suppressed for the errorCode.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompiler.GetOutputFileName(Microsoft.CodeAnalysis.Compilation,System.Threading.CancellationToken)">
            <summary>
            Given a compilation and a destination directory, determine three names:
              1) The name with which the assembly should be output.
              2) The path of the assembly/module file.
              3) The path of the pdb file.
            
            When csc produces an executable, but the name of the resulting assembly
            is not specified using the "/out" switch, the name is taken from the name
            of the file (note: file, not class) containing the assembly entrypoint
            (as determined by binding and the "/main" switch).
            
            For example, if the command is "csc /target:exe a.cs b.cs" and b.cs contains the
            entrypoint, then csc will produce "b.exe" and "b.pdb" in the output directory,
            with assembly name "b" and module name "b.exe" embedded in the file.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompiler.PrintLogo(System.IO.TextWriter)">
            <summary>
            Print compiler logo
            </summary>
            <param name="consoleOutput"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompiler.PrintHelp(System.IO.TextWriter)">
            <summary>
            Print Commandline help message (up to 80 English characters per line)
            </summary>
            <param name="consoleOutput"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AttributeSemanticModel">
            <summary>
            A binding for an attribute.  Represents the result of binding an attribute constructor and
            the positional and named arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AttributeSemanticModel.Create(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Creates an AttributeSemanticModel that allows asking semantic questions about an attribute node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AttributeSemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol,Microsoft.CodeAnalysis.CSharp.Binder,System.Int32)">
            <summary>
            Creates a speculative AttributeSemanticModel that allows asking semantic questions about an attribute node that did not appear in the original source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AwaitExpressionInfo">
            <summary>
            Structure containing all semantic information about an await expression.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.BuiltInOperators">
            <summary>
            Internal cahe of built-in operators.
            Cache is compilation-specific becuse it uses compilation-specific SpecialTypes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation">
            <summary>
            The compilation object is an immutable representation of a single invocation of the
            compiler. Although immutable, a compilation is also on-demand, and will realize and cache
            data as necessary. A compilation can produce a new compilation from existing compilation
            with the application of small deltas. In many cases, it is more efficient than creating a
            new compilation from scratch, as the new compilation can reuse information from the old
            compilation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._anonymousTypeManager">
            <summary>
            Manages anonymous types declared in this compilation. Unifies types that are structurally equivalent.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyAssemblySymbol">
            <summary>
            The <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol"/> for this compilation. Do not access directly, use Assembly property
            instead. This field is lazily initialized by ReferenceManager, ReferenceManager.CacheLockObject must be locked
            while ReferenceManager "calculates" the value and assigns it, several threads must not perform duplicate
            "calculation" simultaneously.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._referenceManager">
            <summary>
            Holds onto data related to reference binding.
            The manager is shared among multiple compilations that we expect to have the same result of reference binding.
            In most cases this can be determined without performing the binding. If the compilation however contains a circular 
            metadata reference (a metadata reference that refers back to the compilation) we need to avoid sharing of the binding results.
            We do so by creating a new reference manager for such compilation. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyEntryPoint">
            <summary>
            Contains the main method of this assembly, if there is one.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyCompilationUnitCompletedTrees">
            <summary>
            The set of trees for which a <see cref="T:Microsoft.CodeAnalysis.Diagnostics.CompilationUnitCompletedEvent"/> has been added to the queue.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Options">
            <summary>
            The options the compilation was created with. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.FeatureStrictEnabled">
            <summary>
            True when the compiler is run in "strict" mode, in which it enforces the language specification
            in some cases even at the expense of full compatibility. Such differences typically arise when
            earlier versions of the compiler failed to enforce the full language specification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.LanguageVersion">
            <summary>
            The language version that was used to parse the syntax trees of this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Create(System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions)">
            <summary>
            Creates a new compilation from scratch. Methods such as AddSyntaxTrees or AddReferences
            on the returned object will allow to continue building up the Compilation incrementally.
            </summary>
            <param name="assemblyName">Simple assembly name.</param>
            <param name="syntaxTrees">The syntax trees with the source code for the new compilation.</param>
            <param name="references">The references for the new compilation.</param>
            <param name="options">The compiler options to use.</param>
            <returns>A new compilation.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CreateSubmission(System.String,Microsoft.CodeAnalysis.SyntaxTree,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference},Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions,Microsoft.CodeAnalysis.Compilation,System.Type,System.Type)">
            <summary>
            Creates a new compilation that can be used in scripting.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Clone">
            <summary>
            Create a duplicate of this compilation with different symbol instances.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithAssemblyName(System.String)">
            <summary>
            Creates a new compilation with the specified name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
            <remarks>
            The new <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation"/> will query the given <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/> for the underlying 
            metadata as soon as the are needed. 
            
            The new compilation uses whatever metadata is currently being provided by the <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/>.
            E.g. if the current compilation references a metadata file that has changed since the creation of the compilation
            the new compilation is going to use the updated version, while the current compilation will be using the previous (it doesn't change).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation with the specified references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithOptions(Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions)">
            <summary>
            Creates a new compilation with the specified compilation options.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithPreviousSubmission(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Returns a new compilation with the given compilation set as the previous submission.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.WithEventQueue(Microsoft.CodeAnalysis.Diagnostics.AsyncQueue{Microsoft.CodeAnalysis.Diagnostics.CompilationEvent})">
            <summary>
            Returns a new compilation with a given event queue.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSubmissionResultType(System.Boolean@)">
            <summary>
            Returns the type of the submission return value. 
            </summary>
            <returns>
            The type of the last expression of the submission. 
            Null if the type of the last expression is unknown (null).
            Void type if the type of the last expression statement is void or 
            the submission ends with a declaration or statement that is not an expression statement.
            </returns>
            <remarks>
            Note that the return type is System.Void for both compilations "System.Console.WriteLine();" and "System.Console.WriteLine()", 
            and <paramref name="hasValue"/> is <c>False</c> for the former and <c>True</c> for the latter.
            </remarks>
            <param name="hasValue">True if the submission has value, i.e. if it ends with a statement that is an expression statement.</param>
            <exception cref="T:System.InvalidOperationException">The compilation doesn't represent a submission (<see cref="P:Microsoft.CodeAnalysis.Compilation.IsSubmission"/> return false).</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.SyntaxTrees">
            <summary>
            The syntax trees (parsed from source code) that this compilation was created with.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ContainsSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns true if this compilation contains the specified tree.  False otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})">
            <summary>
            Creates a new compilation with additional syntax trees.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveSyntaxTrees(Microsoft.CodeAnalysis.SyntaxTree[])">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveSyntaxTrees(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTree})">
            <summary>
            Creates a new compilation without the specified syntax trees. Preserves metadata info for use with trees
            added later. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveAllSyntaxTrees">
            <summary>
            Creates a new compilation without any syntax trees. Preserves metadata info
            from this compilation for use with trees added later. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReplaceSyntaxTree(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Creates a new compilation without the old tree but with the new tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetAssemblyOrModuleSymbol(Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol"/> for a metadata reference used to create this compilation.
            </summary>
            <returns><see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol"/> corresponding to the given reference or null if there is none.</returns>
            <remarks>
            Uses object identity when comparing two references. 
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceDirectives">
            <summary>
            All reference directives used in this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDirectiveReference(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax)">
            <summary>
            Returns a metadata reference that a given #r resolves to.
            </summary>
            <param name="directive">#r directive.</param>
            <returns>Metadata reference the specified directive resolves to.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AddReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation with additional metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveReferences(Microsoft.CodeAnalysis.MetadataReference[])">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveReferences(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.MetadataReference})">
            <summary>
            Creates a new compilation without the specified metadata references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.RemoveAllReferences">
            <summary>
            Creates a new compilation without any metadata references
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReplaceReference(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference)">
            <summary>
            Creates a new compilation with an old metadata reference replaced with a new metadata reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetMetadataReference(Microsoft.CodeAnalysis.IAssemblySymbol)">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.MetadataReference"/> that corresponds to the assembly symbol. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.SourceAssembly">
            <summary>
            The AssemblySymbol that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.Assembly">
            <summary>
            The AssemblySymbol that represents the assembly being created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.SourceModule">
            <summary>
            Get a ModuleSymbol that refers to the module being created by compiling all of the code.
            By getting the GlobalNamespace property of that module, all of the namespaces and types
            defined in source code can be obtained.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GlobalNamespace">
            <summary>
            Gets the root namespace that contains all namespaces and types defined in source code or in 
            referenced metadata, merged into a single namespace hierarchy.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetCompilationNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)">
            <summary>
            Given for the specified module or assembly namespace, gets the corresponding compilation
            namespace (merged namespace representation for all namespace declarations and references
            with contributions for the namespaceSymbol).  Can return null if no corresponding
            namespace can be bound in this compilation with the same name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ScriptClass">
            <summary>
            A symbol representing the implicit Script class. This is null if the class is not
            defined in the compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.BindScriptClass">
            <summary>
            Resolves a symbol that represents script container (Script class). Uses the
            full name of the container class stored in <see cref="P:Microsoft.CodeAnalysis.CompilationOptions.ScriptClassName"/> to find the symbol.
            </summary>
            <returns>The Script class symbol or null if it is not defined.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Get the symbol for the predefined type from the COR Library referenced by this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Get the symbol for the predefined type member from the COR Library referenced by this compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetTypeByMetadataName(System.String)">
            <summary>
            Gets the type within the compilation's assembly and all referenced assemblies (other than
            those that can only be referenced via an extern alias) using its canonical CLR metadata name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.DynamicType">
            <summary>
            The TypeSymbol for the type 'dynamic' in this Compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ObjectType">
            <summary>
            The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
            Error if there was no COR Library in this Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CreateArrayTypeSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Int32)">
            <summary>
            Returns a new ArrayTypeSymbol representing an array type tied to the base types of the
            COR Library in this Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.CreatePointerTypeSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Returns a new PointerTypeSymbol representing a pointer type tied to a type in this Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Gets a new SyntaxTreeSemanticModel for the specified syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetImports(Microsoft.CodeAnalysis.CSharp.SingleNamespaceDeclaration)">
            <summary>
            Returns imported symbols for the given declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.DeclarationDiagnostics">
            <summary>
            The bag in which semantic analysis should deposit its diagnostics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.AdditionalCodegenWarnings">
            <summary>
            A bag in which diagnostics that should be reported after code gen can be deposited.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetParseDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during the parsing stage of a compilation. There are no diagnostics for declarations or accessor or
            method bodies, for example.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDeclarationDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during symbol declaration headers.  There are no diagnostics for accessor or
            method bodies, for example.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetMethodBodyDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the diagnostics produced during the analysis of method bodies and field initializers.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets the all the diagnostics for the compilation, including syntax, declaration, and binding. Does not
            include any diagnostics that might be produced during emit.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.FilterAndAppendAndFreeDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.DiagnosticBag@)">
            <summary>
            Filter out warnings based on the compiler options (/nowarn, /warn and /warnaserror) and the pragma warning directives.
            'incoming' is freed.
            </summary>
            <returns>True when there is no error or warning treated as an error.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.FilterAndAppendDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.Diagnostic})">
            <summary>
            Filter out warnings based on the compiler options (/nowarn, /warn and /warnaserror) and the pragma warning directives.
            </summary>
            <returns>True when there is no error.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ContainsSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Return true if there is a source declaration symbol name that meets given predicate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetSymbolsWithName(System.Func{System.String,System.Boolean},Microsoft.CodeAnalysis.SymbolFilter,System.Threading.CancellationToken)">
            <summary>
            Return source declaration symbols whose name meets given predicate.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.EnableEnumArrayBlockInitialization">
            <summary>
            Determine if enum arrays can be initialized using block initialization.
            </summary>
            <returns>True if it's safe to use block initialization for enum arrays.</returns>
            <remarks>
            In NetFx 4.0, block array initializers do not work on all combinations of {32/64 X Debug/Retail} when array elements are enums.
            This is fixed in 4.5 thus enabling block array initialization for a very common case.
            We look for the presence of <see cref="F:System.Runtime.GCLatencyMode.SustainedLowLatency"/> which was introduced in .Net 4.5
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyWellKnownTypes">
            <summary>
            An array of cached well known types available for use in this Compilation.
            Lazily filled by GetWellKnownType method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation._lazyWellKnownTypeMembers">
            <summary>
            Lazy cache of well known members.
            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.GetWellKnownTypeMember(Microsoft.CodeAnalysis.WellKnownMember)">
            <summary>
            Lookup member declaration in well known type used by this Compilation.
            </summary>
            <remarks>
            If a well-known member of a generic type instantiation is needed use this method to get the corresponding generic definition and 
            <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.AsMember(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)"/> to construct an instantiation.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.TrySynthesizeAttribute(Microsoft.CodeAnalysis.WellKnownMember,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.TypedConstant},System.Collections.Immutable.ImmutableArray{System.Collections.Generic.KeyValuePair{Microsoft.CodeAnalysis.WellKnownMember,Microsoft.CodeAnalysis.TypedConstant}})">
            <summary>
            Synthesizes a custom attribute. 
            Returns null if the <paramref name="constructor"/> symbol is missing,
            or any of the members in <paramref name="namedArguments" /> are missing.
            The attribute is synthesized only if present.
            </summary>
            <param name="constructor">
            Constructor of the attribute. If it doesn't exist, the attribute is not created.
            </param>
            <param name="arguments">Arguments to the attribute constructor.</param>
            <param name="namedArguments">
            Takes a list of pairs of well-known members and constants. The constants
            will be passed to the field/property referenced by the well-known member.
            If the well-known member does not exist in the compilation then no attribute
            will be synthesized.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.SynthesizeDynamicAttribute(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Int32,Microsoft.CodeAnalysis.RefKind)">
            <summary>
            Given a type <paramref name="type"/>, which is either dynamic type OR is a constructed type with dynamic type present in it's type argument tree,
            returns a synthesized DynamicAttribute with encoded dynamic transforms array.
            </summary>
            <remarks>This method is port of AttrBind::CompileDynamicAttr from the native C# compiler.</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.DynamicTransformsEncoder">
            <summary>
            Used to generate the dynamic attributes for the required typesymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager">
            <summary>
            ReferenceManager encapsulates functionality to create an underlying SourceAssemblySymbol 
            (with underlying ModuleSymbols) for Compilation and AssemblySymbols for referenced
            assemblies (with underlying ModuleSymbols) all properly linked together based on
            reference resolution between them.
            
            ReferenceManager is also responsible for reuse of metadata readers for imported modules
            and assemblies as well as existing AssemblySymbols for referenced assemblies. In order
            to do that, it maintains global cache for metadata readers and AssemblySymbols
            associated with them. The cache uses WeakReferences to refer to the metadata readers and
            AssemblySymbols to allow memory and resources being reclaimed once they are no longer
            used. The tricky part about reusing existing AssemblySymbols is to find a set of
            AssemblySymbols that are created for the referenced assemblies, which (the
            AssemblySymbols from the set) are linked in a way, consistent with the reference
            resolution between the referenced assemblies.
            
            When existing Compilation is used as a metadata reference, there are scenarios when its
            underlying SourceAssemblySymbol cannot be used to provide symbols in context of the new
            Compilation. Consider classic multi-targeting scenario: compilation C1 references v1 of
            Lib.dll and compilation C2 references C1 and v2 of Lib.dll. In this case,
            SourceAssemblySymbol for C1 is linked to AssemblySymbol for v1 of Lib.dll. However,
            given the set of references for C2, the same reference for C1 should be resolved against
            v2 of Lib.dll. In other words, in context of C2, all types from v1 of Lib.dll leaking
            through C1 (through method signatures, etc.) must be retargeted to the types from v2 of
            Lib.dll. In this case, ReferenceManager creates a special RetargetingAssemblySymbol for
            C1, which is responsible for the type retargeting. The RetargetingAssemblySymbols could
            also be reused for different Compilations, ReferenceManager maintains a cache of
            RetargetingAssemblySymbols (WeakReferences) for each Compilation.
            
            The only public entry point of this class is CreateSourceAssembly() method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.CheckPropertiesConsistency(Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.MetadataReference,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Checks if the properties of <paramref name="duplicateReference"/> are compatible with properties of <paramref name="primaryReference"/>.
            Reports inconsistencies to the given diagnostic bag.
            </summary>
            <returns>True if the properties are compatible and hence merged, false if the duplicate reference should not merge it's properties with primary reference.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.WeakIdentityPropertiesEquivalent(Microsoft.CodeAnalysis.AssemblyIdentity,Microsoft.CodeAnalysis.AssemblyIdentity)">
            <summary>
            C# only considers culture when comparing weak identities.
            It ignores versions of weak identities and reports an error if there are two weak assembly 
            references passed to a compilation that have the same simple name.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.CreatePEAssemblyForAssemblyMetadata(Microsoft.CodeAnalysis.AssemblyMetadata,Microsoft.CodeAnalysis.MetadataImportOptions)">
            <summary>
            Creates a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol"/> from specified metadata. 
            </summary>
            <remarks>
            Used by EnC to create symbols for emit baseline. The PE symbols are used by <see cref="T:Microsoft.CodeAnalysis.CSharp.Emit.CSharpSymbolMatcher"/>.
            
            The assembly references listed in the metadata AssemblyRef table are matched to the resolved references 
            stored on this <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager"/>. Each AssemblyRef is matched against the assembly identities
            using an exact equality comparison. No unification or further resolution is performed.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.AssemblyDataForFile._compilationImportOptions">
            <summary>
            Import options of the compilation being built.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.AssemblyDataForFile.CachedSymbols">
            <summary>
            Guarded by <see cref="F:Microsoft.CodeAnalysis.CommonReferenceManager.SymbolCacheAndReferenceManagerStateGuard"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.IsSourceAssemblySymbolCreated(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            For testing purposes only.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilation.ReferenceManager.IsReferenceManagerInitialized(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            For testing purposes only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilationReference">
            <summary>
            Represents a reference to another C# compilation. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilationReference.Compilation">
            <summary>
            Returns the referenced Compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpCompilationReference.#ctor(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.Collections.Immutable.ImmutableArray{System.String},System.Boolean)">
            <summary>
            Create a metadata reference to a compilation.
            </summary>
            <param name="compilation">The compilation to reference.</param>
            <param name="aliases">Extern aliases for this reference.</param>
            <param name="embedInteropTypes">Should interop types be embedded in the created assembly?</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFilter">
            <summary>
            Applies C#-specific modification and filtering of <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/>s.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpDiagnosticFilter.Filter(Microsoft.CodeAnalysis.Diagnostic,System.Int32,Microsoft.CodeAnalysis.ReportDiagnostic,System.Collections.Generic.IDictionary{System.String,Microsoft.CodeAnalysis.ReportDiagnostic})">
            <summary>
            Modifies an input <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> per the given options. For example, the
            severity may be escalated, or the <see cref="T:Microsoft.CodeAnalysis.Diagnostic"/> may be filtered out entirely
            (by returning null).
            </summary>
            <param name="d">The input diagnostic</param>
            <param name="warningLevelOption">The maximum warning level to allow. Diagnostics with a higher warning level will be filtered out.</param>
            <param name="generalDiagnosticOption">How warning diagnostics should be reported</param>
            <param name="specificDiagnosticOptions">How specific diagnostics should be reported</param>
            <returns>A diagnostic updated to reflect the options, or null if it has been filtered out</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel">
            <summary>
            Allows asking semantic questions about a tree of syntax nodes in a Compilation. Typically,
            an instance is obtained by a call to <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Compilation"/>.<see
            cref="M:Microsoft.CodeAnalysis.Compilation.GetSemanticModel(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)"/>. 
            </summary>
            <remarks>
            <para>An instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel"/> caches local symbols and semantic
            information. Thus, it is much more efficient to use a single instance of <see
            cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel"/> when asking multiple questions about a syntax tree, because
            information from the first question may be reused. This also means that holding onto an
            instance of SemanticModel for a long time may keep a significant amount of memory from being
            garbage collected.
            </para>
            <para>
            When an answer is a named symbol that is reachable by traversing from the root of the symbol
            table, (that is, from an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> of the <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Compilation"/>),
            that symbol will be returned (i.e. the returned value will be reference-equal to one
            reachable from the root of the symbol table). Symbols representing entities without names
            (e.g. array-of-int) may or may not exhibit reference equality. However, some named symbols
            (such as local variables) are not reachable from the root. These symbols are visible as
            answers to semantic questions. When the same SemanticModel object is used, the answers
            exhibit reference-equality.  
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Compilation">
            <summary>
            The compilation this object was obtained from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.Root">
            <summary>
            The root node of the syntax tree that this binding is based on.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="options">Options to control behavior.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetCollectionInitializerSymbolInfoWorker(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets symbol information about the 'Add' method corresponding to an expression syntax <paramref name="node"/> within collection initializer.
            This is the worker function that is overridden in various derived kinds of Semantic Models. It can assume that 
            CheckSyntaxNode has already been called and the <paramref name="node"/> is in the right place in the syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfoWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetMemberGroupWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
            <summary>
            Gets a list of method or indexed property symbols for a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="options"></param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetIndexerGroupWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions,System.Threading.CancellationToken)">
            <summary>
            Gets a list of indexer symbols for a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="options"></param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetConstantValueWorker(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the constant value for a syntax node. This is overridden by various specializations of SemanticModel.
            It can assume that CheckSyntaxNode and CanGetSemanticInfo have already been called, as well as that named
            argument nodes have been handled.
            </summary>
            <param name="node">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativelyBoundExpression(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption,Microsoft.CodeAnalysis.CSharp.Binder@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol}@)">
            <summary>
            Bind the given expression speculatively at the given position, and return back
            the resulting bound node. May return null in some error cases.
            </summary>
            <remarks>
            Keep in sync with Binder.BindCrefParameterOrReturnType.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativelyBoundAttribute(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Binder@)">
            <summary>
            Bind the given attribute speculatively at the given position, and return back
            the resulting bound node. May return null in some error cases.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information for an ordering clause in an orderby query clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a select or group clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given expression syntax bound to in the program.
            
            An AliasSymbol will never be returned by this method. What the alias refers to will be
            returned instead. To get information about aliases, call GetAliasInfo.
            
            If binding the type name C in the expression "new C(...)" the actual constructor bound to
            will be returned (or all constructor if overload resolution failed). This occurs as long as C
            unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple
            types, or C binds to a static class, then type(s) are returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax 
            within <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.Initializer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
            </summary>
            <param name="constructorInitializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given attribute syntax bound to in the program.
            </summary>
            <param name="attributeSyntax">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a documentation comment cref.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The symbol information for the topmost node of the expression.</returns>
            <remarks>
            The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".
            
            <paramref name="bindingOption"/> is ignored if <paramref name="position"/> is within a documentation
            comment cref attribute value.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>
            Bind the attribute in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about an attribute
            that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel. In order to obtain
            the correct scoping rules for the attribute, position should be the Start position of the Span of the symbol that
            the attribute is being applied to.
            </param>
            <param name="attribute">A syntax node that represents a parsed attribute. This syntax node
            need not and typically does not appear in the source code referred to SemanticModel instance.</param>
            <returns>The semantic information for the topmost node of the attribute.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)">
            <summary>
            Bind the constructor initializer in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about a constructor
            initializer that did not actually appear in the source code.
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            Furthermore, it must be within the span of an existing constructor initializer.
            </param>
            <param name="constructorInitializer">A syntax node that represents a parsed constructor initializer. This syntax node
            need not and typically does not appear in the source code referred to SemanticModel instance.</param>
            <returns>The semantic information for the topmost node of the constructor initializer.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeSymbolInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions)">
            <summary>
            Bind the cref in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about a cref
            that did not actually appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel. In order to obtain
            the correct scoping rules for the cref, position should be the Start position of the Span of the original cref.
            </param>
            <param name="cref">A syntax node that represents a parsed cref. This syntax node
            need not and typically does not appear in the source code referred to SemanticModel instance.</param>
            <param name="options">SymbolInfo options.</param>
            <returns>The semantic information for the topmost node of the cref.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a constructor initializer.
            </summary>
            <param name="constructorInitializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about an expression.
            </summary>
            <param name="expression">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetTypeInfo(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about an attribute.
            </summary>
            <param name="attributeSyntax">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetConversion(Microsoft.CodeAnalysis.SyntaxNode,System.Threading.CancellationToken)">
            <summary>
            Gets the conversion that occurred between the expression's type and type implied by the expression's context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeTypeInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the expression in the context of the specified location and gets type information.
            This method is used to get type information about an expression that did not actually
            appear in the source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="expression">A syntax node that represents a parsed expression. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the expression as a full expressions,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <returns>The type information for the topmost node of the expression.</returns>
            <remarks>The passed in expression is interpreted as a stand-alone expression, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeConversion(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Gets the conversion that occurred between the expression's type and type implied by the expression's context.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetMemberGroup(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets a list of method or indexed property symbols for a syntax node.
            </summary>
            <param name="expression">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetMemberGroup(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets a list of method or indexed property symbols for a syntax node.
            </summary>
            <param name="attribute">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetMemberGroup(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets a list of method or indexed property symbols for a syntax node.
            </summary>
            <param name="initializer">The syntax node to get semantic information for.</param>
            <param name="cancellationToken">The cancellation token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetIndexerGroup(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.
            </summary>
            <param name="expression">Potential indexer receiver.</param>
            <param name="cancellationToken">To cancel the computation.</param>
            <returns>Accessible, non-hidden indexers.</returns>
            <remarks>
            If the receiver is an indexer expression, the list will contain the indexers that could be applied to the result
            of accessing the indexer, not the set of candidates that were considered during construction of the indexer expression.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetQueryClauseInfo(Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a query clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetAliasInfo(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)">
            <summary>
            If <paramref name="nameSyntax"/> resolves to an alias name, return the AliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetSpeculativeAliasInfo(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="nameSyntax">A syntax node that represents a name. This syntax
            node need not and typically does not appear in the source code referred to by the
            SemanticModel instance.</param>
            <param name="bindingOption">Indicates whether to binding the name as a full expression,
            or as a type or namespace. If SpeculativeBindingOption.BindAsTypeOrNamespace is supplied, then
            expression should derive from TypeSyntax.</param>
            <remarks>The passed in name is interpreted as a stand-alone name, as if it
            appeared by itself somewhere within the scope that encloses "position".</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetEnclosingBinder(System.Int32)">
            <summary>
            Gets the binder that encloses the position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetMemberModel(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Gets the MemberSemanticModel that contains the node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.CheckAndAdjustPosition(System.Int32)">
            <summary>
            Given a position, locates the containing token.  If the position is actually within the
            leading trivia of the containing token or if that token is EOF, moves one token to the
            left.  Returns the start position of the resulting token.
            
            This has the effect of moving the position left until it hits the beginning of a non-EOF
            token.
            
            Throws an ArgumentOutOfRangeException if position is not within the root of this model.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetAdjustedNodePosition(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            A convenience method that determines a position from a node.  If the node is missing,
            then its position will be adjusted using CheckAndAdjustPosition.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)">
            <summary>
            Gets the available named symbols in the context of the specified location and optional container. Only
            symbols that are accessible and visible from the given location are returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the enclosing declaration
            scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <param name="includeReducedExtensionMethods">Consider (reduced) extension methods.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            
            Labels are not considered (see <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupLabels(System.Int32,System.String)"/>).
            
            Non-reduced extension methods are considered regardless of the value of <paramref name="includeReducedExtensionMethods"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupBaseMembers(System.Int32,System.String)">
            <summary>
            Gets the available base type members in the context of the specified location.  Akin to
            calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupSymbols(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String,System.Boolean)"/> with the container set to the immediate base type of
            the type in which <paramref name="position"/> occurs.  However, the accessibility rules
            are different: protected members of the base type will be visible.
            
            Consider the following example:
            
              public class Base
              {
                  protected void M() { }
              }
              
              public class Derived : Base
              {
                  void Test(Base b)
                  {
                      b.M(); // Error - cannot access protected member.
                      base.M();
                  }
              }
            
            Protected members of an instance of another type are only accessible if the instance is known
            to be "this" instance (as indicated by the "base" keyword).
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible.
            
            Non-reduced extension methods are considered, but reduced extension methods are not.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupStaticMembers(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
            <summary>
            Gets the available named static member symbols in the context of the specified location and optional container.
            Only members that are accessible and visible from the given location are returned.
            
            Non-reduced extension methods are considered, since they are static methods.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the enclosing declaration
            scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupNamespacesAndTypes(System.Int32,Microsoft.CodeAnalysis.INamespaceOrTypeSymbol,System.String)">
            <summary>
            Gets the available named namespace and type symbols in the context of the specified location and optional container.
            Only members that are accessible and visible from the given location are returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the enclosing declaration
            scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            
            Does not return INamespaceOrTypeSymbol, because there could be aliases.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupLabels(System.Int32,System.String)">
            <summary>
            Gets the available named label symbols in the context of the specified location and optional container.
            Only members that are accessible and visible from the given location are returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration scope and
            accessibility.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <returns>A list of symbols that were found. If no symbols were found, an empty list is returned.</returns>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if "container" is
            specified, the "position" location is significant for determining which members of "containing" are
            accessible. 
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.LookupSymbolsInternal(System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,System.String,Microsoft.CodeAnalysis.CSharp.LookupOptions,System.Boolean)">
            <summary>
            Gets the available named symbols in the context of the specified location and optional
            container. Only symbols that are accessible and visible from the given location are
            returned.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="container">The container to search for symbols within. If null then the
            enclosing declaration scope around position is used.</param>
            <param name="name">The name of the symbol to find. If null is specified then symbols
            with any names are returned.</param>
            <param name="options">Additional options that affect the lookup process.</param>
            <param name="useBaseReferenceAccessibility">Ignore 'throughType' in accessibility checking. 
            Used in checking accessibility of symbols accessed via 'MyBase' or 'base'.</param>
            <remarks>
            The "position" is used to determine what variables are visible and accessible. Even if
            "container" is specified, the "position" location is significant for determining which
            members of "containing" are accessible. 
            </remarks>
            <exception cref="T:System.ArgumentException">Throws an argument exception if the passed lookup options are invalid.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.IsAccessible(System.Int32,Microsoft.CodeAnalysis.ISymbol)">
            <summary>
            Determines if the symbol is accessible from the specified location. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and
            accessibility. This character position must be within the FullSpan of the Root syntax
            node in this SemanticModel.
            </param>
            <param name="symbol">The symbol that we are checking to see if it accessible.</param>
            <returns>
            True if "symbol is accessible, false otherwise.</returns>
            <remarks>
            This method only checks accessibility from the point of view of the accessibility
            modifiers on symbol and its containing types. Even if true is returned, the given symbol
            may not be able to be referenced for other reasons, such as name hiding.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.IsEventUsableAsField(System.Int32,Microsoft.CodeAnalysis.IEventSymbol)">
            <summary>
            Field-like events can be used as fields in types that can access private
            members of the declaring type of the event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first statement to be included in the analysis.</param>
            <param name="lastStatement">The last statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeControlFlow(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
            <param name="statement">The statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the control flow analysis.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Analyze data-flow within an expression. 
            </summary>
            <param name="expression">The expression within the associated SyntaxTree to analyze.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="firstStatement">The first statement to be included in the analysis.</param>
            <param name="lastStatement">The last statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
            <exception cref="T:System.ArgumentException">The two statements are not contained within the same statement list.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.AnalyzeDataFlow(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
            <param name="statement">The statement to be included in the analysis.</param>
            <returns>An object that can be used to obtain the result of the data flow analysis.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModelForMethodBody(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position"/> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel and must be
            within the FullSpan of a Method body within the Root syntax node.</param>
            <param name="method">A syntax node that represents a parsed method declaration. This method should not be
            present in the syntax tree associated with this object, but must have identical signature to the method containing
            the given <paramref name="position"/> in this SemanticModel.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="method"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="method"/> node is contained any SyntaxTree in the current Compilation</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="method"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModelForMethodBody(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position"/> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel and must be
            within the FullSpan of a Method body within the Root syntax node.</param>
            <param name="accessor">A syntax node that represents a parsed accessor declaration. This accessor should not be
            present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="accessor"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="accessor"/> node is contained any SyntaxTree in the current Compilation</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="accessor"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Get a SemanticModel object that is associated with a type syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a type syntax that did not appear in source code. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            </param>
            <param name="type">A syntax node that represents a parsed expression. This expression should not be
            present in the syntax tree associated with this object.</param>
            <param name="bindingOption">Indicates whether to bind the expression as a full expression,
            or as a type or namespace.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="type"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="type"/> node is contained any SyntaxTree in the current Compilation</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="type"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a statement that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a statement that did not appear in source code. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.</param>
            <param name="statement">A syntax node that represents a parsed statement. This statement should not be
            present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="statement"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="statement"/> node is contained any SyntaxTree in the current Compilation</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="statement"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a field initializer or default parameter value that did not appear in source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            </param>
            <param name="initializer">A syntax node that represents a parsed initializer. This initializer should not be
            present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="initializer"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="initializer"/> node is contained any SyntaxTree in the current Compilation.</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="initializer"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an expression body that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression body that did not appear in source code.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            </param>
            <param name="expressionBody">A syntax node that represents a parsed expression body. This node should not be
            present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="expressionBody"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="expressionBody"/> node is contained any SyntaxTree in the current Compilation.</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="expressionBody"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a constructor initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a constructor initializer that did not appear in source code. 
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            Furthermore, it must be within the span of an existing constructor initializer.
            </param>
            <param name="constructorInitializer">A syntax node that represents a parsed constructor initializer.
            This node should not be present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="constructorInitializer"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="constructorInitializer"/> node is contained any SyntaxTree in the current Compilation.</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="constructorInitializer"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a cref that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a cref that did not appear in source code. 
            
            NOTE: This will only work in locations where there is already a cref.
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.
            Furthermore, it must be within the span of an existing cref.
            </param>
            <param name="crefSyntax">A syntax node that represents a parsed cref syntax.
            This node should not be present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="crefSyntax"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="crefSyntax"/> node is contained any SyntaxTree in the current Compilation.</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="crefSyntax"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.TryGetSpeculativeSemanticModel(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an attribute that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an attribute that did not appear in source code. 
            </summary>
            <param name="position">A character position used to identify a declaration scope and accessibility. This
            character position must be within the FullSpan of the Root syntax node in this SemanticModel.</param>
            <param name="attribute">A syntax node that represents a parsed attribute. This attribute should not be
            present in the syntax tree associated with this object.</param>
            <param name="speculativeModel">A SemanticModel object that can be used to inquire about the semantic
            information associated with syntax nodes within <paramref name="attribute"/>.</param>
            <returns>Flag indicating whether a speculative semantic model was created.</returns>
            <exception cref="T:System.ArgumentException">Throws this exception if the <paramref name="attribute"/> node is contained any SyntaxTree in the current Compilation.</exception>
            <exception cref="T:System.ArgumentNullException">Throws this exception if <paramref name="attribute"/> is null.</exception>
            <exception cref="T:System.InvalidOperationException">Throws this exception if this model is a speculative semantic model, i.e. <see cref="P:Microsoft.CodeAnalysis.SemanticModel.IsSpeculativeSemanticModel"/> is true.
            Chaining of speculative semantic model is not supported.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.ParentModel">
            <summary>
            If this is a speculative semantic model, then returns its parent semantic model.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SyntaxTree">
            <summary>
            The SyntaxTree that this object is associated with.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.ClassifyConversion(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
            <param name="expression">An expression which much occur within the syntax tree
            associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <param name="isExplicitInSource">True if the conversion should be determined as for a cast expression.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.ClassifyConversion(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="expression">The expression to classify. This expression does not need to be
            present in the syntax tree associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <param name="isExplicitInSource">True if the conversion should be determined as for a cast expression.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.ClassifyConversionForCast(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type using an explicit cast.
            </summary>
            <param name="expression">An expression which much occur within the syntax tree
            associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.ClassifyConversionForCast(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type using an explicit cast.
            </summary>
            <param name="position">The character position for determining the enclosing declaration
            scope and accessibility.</param>
            <param name="expression">The expression to classify. This expression does not need to be
            present in the syntax tree associated with this object.</param>
            <param name="destination">The type to attempt conversion to.</param>
            <returns>Returns a Conversion object that summarizes whether the conversion was
            possible, and if so, what kind of conversion it was. If no conversion was possible, a
            Conversion object with a false "Exists" property is returned.</returns>
            <remarks>To determine the conversion between two types (instead of an expression and a
            type), use Compilation.ClassifyConversion.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a member declaration syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for following subtypes of MemberDeclarationSyntax:
            NOTE:   (1) GlobalStatementSyntax as they don't declare any symbols.
            NOTE:   (2) IncompleteMemberSyntax as there are no symbols for incomplete members.
            NOTE:   (3) BaseFieldDeclarationSyntax or its subtypes as these declarations can contain multiple variable declarators.
            NOTE:       GetDeclaredSymbol should be called on the variable declarators directly.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a namespace.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The namespace symbol that was declared by the namespace declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a type.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseTypeDeclarationSyntax as all of them return a NamedTypeSymbol.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a delegate.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an enum member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a method.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseMethodDeclarationSyntax as all of them return a MethodSymbol.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property, indexer or an event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an indexer.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.
            </summary>
            <param name="declaratorSyntax">The syntax node that declares a property.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.
            </summary>
            <param name="declaratorSyntax">The syntax node that declares an anonymoust object.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property or member accessor, get the corresponding
            symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an accessor.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares an expression body, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an expression body.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a variable.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the labeled statement.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the switch label.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a using declaration get the corresponding symbol for the using alias that was
            introduced.
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared.</returns>
            <remarks>
            If the using directive is an error because it attempts to introduce an alias for which an existing alias was
            previously declared in the same scope, the result is a newly-constructed AliasSymbol (i.e. not one from the
            symbol table).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared, or null if a duplicate alias symbol was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a parameter declaration syntax node, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a parameter.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The parameter that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbols(Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base field declaration syntax, get the corresponding symbols.
            </summary>
            <param name="declarationSyntax">The syntax node that declares one or more fields or events.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbols that were declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="typeParameter"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a foreach statement, get the symbol for the iteration variable
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="forEachStatement"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a catch declaration, get the symbol for the exception variable
            </summary>
            <param name="cancellationToken">The cancellation token.</param>
            <param name="catchDeclaration"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the query range variable declared in a join into clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the query range variable declared in a query continuation clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetIndexerGroupSemanticSymbols(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Returns a list of accessible, non-hidden indexers that could be invoked with the given expression
            as a receiver.
            </summary>
            <remarks>
            If the given expression is an indexer access, then this method will return the list of indexers
            that could be invoked on the result, not the list of indexers that were considered.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.FilterOverriddenOrHiddenMethods(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol})">
             <remarks>
             The method group can contain "duplicate" symbols that we do not want to display in the IDE analysis.
            
             For example, there could be an overriding virtual method and the method it overrides both in
             the method group. This, strictly speaking, is a violation of the C# specification because we are
             supposed to strip out overriding methods from the method group before overload resolution; overload
             resolution is supposed to treat overridden methods as being methods of the less derived type. However,
             in the IDE we want to display information about the overriding method, not the overridden method, and
             therefore we leave both in the method group. The overload resolution algorithm has been written
             to handle this departure from the specification.
            
             Similarly, we might have two methods in the method group where one is a "new" method that hides 
             another. Again, in overload resolution this would be handled by the rule that says that methods
             declared on more derived types take priority over methods declared on less derived types. Both
             will be in the method group, but in the IDE we want to only display information about the 
             hiding method, not the hidden method.
            
             We can also have "diamond" inheritance of interfaces leading to multiple copies of the same
             method ending up in the method group:
             
             interface IB { void M(); }
             interface IL : IB {}
             interface IR : IB {}
             interface ID : IL, IR {}
             ...
             id.M();
            
             We only want to display one symbol in the IDE, even if the member lookup algorithm is unsophisticated
             and puts IB.M in the member group twice. (Again, this is a mild spec violation since a method group
             is supposed to be a set, without duplicates.)
            
             Finally, the interaction of multiple inheritance of interfaces and hiding can lead to some subtle
             situations. Suppose we make a slight modification to the scenario above:
            
             interface IL : IB { new void M(); } 
            
             Again, we only want to display one symbol in the method group. The fact that there is a "path"
             to IB.M from ID via IR is irrelevant; if the symbol IB.M is hidden by IL.M then it is hidden
             in ID, period.
             </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetNamedArgumentSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the semantic info of a named argument in an invocation-like expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.FindNamedParameter(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},System.String)">
            <summary>
            Find the first parameter named "argumentName".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.CreateReducedExtensionMethodsFromOriginalsIfNecessary(Microsoft.CodeAnalysis.CSharp.BoundCall)">
            <summary>
            If the call represents an extension method invocation with an explicit receiver, return the original
            methods as ReducedExtensionMethodSymbols. Otherwise, return the original methods unchanged.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.CreateReducedExtensionMethodIfPossible(Microsoft.CodeAnalysis.CSharp.BoundCall)">
            <summary>
            If the call represents an extension method with an explicit receiver, return a
            ReducedExtensionMethodSymbol if it can be constructed. Otherwise, return the 
            original call method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetForEachStatementInfo(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)">
            <summary>
            Gets for each statement info.
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetAwaitExpressionInfo(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)">
            <summary>
            Gets await expression info.
            </summary>
            <param name="node">The node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetPreprocessingSymbolInfo(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)">
            <summary>
            If the given node is within a preprocessing directive, gets the preprocessing symbol info for it.
            </summary>
            <param name="node">Preprocessing symbol identifier node.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions">
            <summary>
            Options to control the internal working of GetSymbolInfoWorker. Not currently exposed
            to public clients, but could be if desired.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions.PreferTypeToConstructors">
            <summary>
            When binding "C" new C(...), return the type C and do not return information about
            which constructor was bound to. Bind "new C(...)" to get information about which constructor
            was chosen.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions.PreferConstructorsToType">
            <summary>
            When binding "C" new C(...), return the constructor of C that was bound to, if C unambiguously
            binds to a single type with at least one constructor. 
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions.ResolveAliases">
            <summary>
            When binding a name X that was declared with a "using X=OtherTypeOrNamespace", return OtherTypeOrNamespace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.SymbolInfoOptions.PreserveAliases">
            <summary>
            When binding a name X that was declared with a "using X=OtherTypeOrNamespace", return the alias symbol X.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSemanticModel.GetEnclosingSymbol(System.Int32,System.Threading.CancellationToken)">
            <summary>
            Given a position in the SyntaxTree for this SemanticModel returns the innermost
            NamedType that the position is considered inside of.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo">
            <summary>
            Structure containing all semantic information about a for each statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.GetEnumeratorMethod">
            <summary>
            Gets the &quot;GetEnumerator&quot; method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.MoveNextMethod">
            <summary>
            Gets the &quot;MoveNext&quot; method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.CurrentProperty">
            <summary>
            Gets the &quot;Current&quot; property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.DisposeMethod">
            <summary>
            Gets the &quot;Dispose&quot; method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.ElementType">
            <summary>
            The intermediate type to which the output of the <see cref="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.CurrentProperty"/> is converted
            before being converted to the iteration variable type.
            </summary>
            <remarks>
            As you might hope, for an array, it is the element type of the array.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.ElementConversion">
            <summary>
            The conversion from the <see cref="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.ElementType"/> to the iteration variable type.
            </summary>
            <remarks>
            May be user-defined.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.CurrentConversion">
            <summary>
            The conversion from the type of the <see cref="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.CurrentProperty"/> to the <see cref="P:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.ElementType"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo.#ctor(Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.IPropertySymbol,Microsoft.CodeAnalysis.IMethodSymbol,Microsoft.CodeAnalysis.ITypeSymbol,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Conversion)">
            <summary>
            Initializes a new instance of the <see cref="T:Microsoft.CodeAnalysis.CSharp.ForEachStatementInfo" /> structure.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel">
            <summary>
            A binding for a field initializer, property initializer, constructor
            initializer, or a parameter default value.
            Represents the result of binding a value expression rather than a
            block (for that, use a <see cref="T:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel.Create(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Creates a SemanticModel for a true field initializer (field = value) of a named type (incl. Enums).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel.Create(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Creates a SemanticModel for an autoprop initializer of a named type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel.Create(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Creates a SemanticModel for a constructor initializer (": this(...)" or ": base(...)").
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel.Create(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Creates a SemanticModel for a constructor initializer (": base-class(...)").
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel.Create(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Creates a SemanticModel for a parameter default value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.InitializerSemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Binder,System.Int32)">
            <summary>
            Creates a speculative SemanticModel for an initializer node (field initializer, constructor initializer, or parameter default value)
            that did not appear in the original source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LexicalOrderSymbolComparer">
            <summary> This is an implementation of a special symbol comparer, which is supposed to be used  for 
            sorting original definition symbols (explicitly or explicitly declared in source  within the same 
            container) in lexical order of their declarations. It will not work on  anything that uses non-source locations. 
            </summary>        
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel">
            <summary>
            Binding info for expressions and statements that are part of a member declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.MemberSymbol">
            <summary>
            The member symbol 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetEnclosingBinder(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Int32)">
            <summary>
            This overload exists for callers who
              a) Already have a node in hand and don't want to search through the tree
              b) May want to search from an indirect container (e.g. node containing node
                 containing position).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundRoot">
            <summary>
            Get the bound node corresponding to the root.
            </summary> 
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetUpperBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Boolean)">
            <summary>
            Get the highest bound node in the tree associated with a particular syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLowerBoundNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Get the lowest bound node in the tree associated with a particular syntax node. Lowest is defined as last
            in a pre-order traversal of the bound tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetQueryEnclosingBinder(System.Int32,Microsoft.CodeAnalysis.CSharp.BoundQueryClause)">
            <remarks>
            Returned binder doesn't need to have <see cref="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.SemanticModel"/> set - the caller will add it.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetLambdaEnclosingBinder(System.Int32,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Binder)">
            <summary>
            Performs the same function as GetEnclosingBinder, but is known to take place within a
            specified lambda.  Walks up the syntax hierarchy until a node with an associated binder
            is found.
            </summary>
            <remarks>
            CONSIDER: can this share code with MemberSemanticModel.GetEnclosingBinder?
            
            Returned binder doesn't need to have <see cref="F:Microsoft.CodeAnalysis.CSharp.BinderFlags.SemanticModel"/> set - the caller will add it.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBoundNodes(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Get all bounds nodes associated with a node, ordered from highest to lowest in the bound tree.
            Strictly speaking, the order is that of a pre-order traversal of the bound tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.GetBindableParentNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            If the node is an expression, return the nearest parent node
            with semantic meaning. Otherwise return null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder">
            <summary>
            The incremental binder is used when binding statements. Whenever a statement
            is bound, it checks the bound node cache to see if that statement was bound, 
            and returns it instead of rebinding it. 
            
            For example, we might have:
               while (x > foo())
               {
                 y = y * x;
                 z = z + y;
               }
            
            We might first get semantic info about "z", and thus bind just the statement
            "z = z + y". Later, we might bind the entire While block. While binding the while
            block, we can reuse the binding we did of "z = z + y".
            </summary>
            <remarks>
            NOTE: any member overridden by this binder should follow the BuckStopsHereBinder pattern.
            Otherwise, a subsequent binder in the chain could suppress the caching behavior.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.IncrementalBinder.GetBinder(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            We override GetBinder so that the BindStatement override is still
            in effect on nested binders.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.NodeMapBuilder.AddToMap(Microsoft.CodeAnalysis.CSharp.BoundNode,System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundNode}},Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Walks the bound tree and adds all non compiler generated bound nodes whose syntax matches the given one
            to the cache.
            </summary>
            <param name="root">The root of the bound tree.</param>
            <param name="map">The cache.</param>
            <param name="node">The syntax node where to add bound nodes for.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.NodeMapBuilder.ShouldAddNode(Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Decides whether to the add the bound node to the cache or not.
            </summary>
            <param name="currentBoundNode">The bound node.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.SpeculativeMemberSemanticModel">
            <summary>
            Allows asking semantic questions about a TypeSyntax (or its descendants) within a member, that did not appear in the original source code.
            Typically, an instance is obtained by a call to SemanticModel.TryGetSpeculativeSemanticModel. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MemberSemanticModel.SpeculativeMemberSemanticModel.#ctor(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Binder,System.Int32)">
            <summary>
            Creates a speculative SemanticModel for a TypeSyntax node at a position within an existing MemberSemanticModel.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Create(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Creates a SemanticModel that creates and owns the ExecutableCodeBinder for the method of which it is a model.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.Create(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>
            Creates a SemanticModel for an ArrowExpressionClause, which includes
            an ExecutableCodeBinder and a ScopedExpressionBinder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Binder,System.Int32)">
            <summary>
            Creates a speculative SemanticModel for a method body that did not appear in the original source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySemanticModel.CreateSpeculative(Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.CSharp.Binder,System.Int32)">
            <summary>
            Creates a speculative SemanticModel for an expression body that did not appear in the original source code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.QueryClauseInfo">
            <summary>
            Semantic information associated with a query clause in a C# query expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.QueryClauseInfo.CastInfo">
            <summary>
            The .Cast&lt;T&gt;() operation generated from the query range variable's type restriction,
            or null if the type restriction isn't specified. 
            </summary>
            <remarks>
            The operation, when present is implemented via <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>.
            To access the type, when this is non-null use <see cref="P:Microsoft.CodeAnalysis.IMethodSymbol.TypeArguments"/>[0].
            If it is an extension method, it is returned in reduced form.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.QueryClauseInfo.OperationInfo">
            <summary>
            The operation (e.g. Select(), Where(), etc) that implements the given clause.
            </summary>
            <remarks>
            The clause can be implemented via <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>, or 
            <see cref="T:Microsoft.CodeAnalysis.IFieldSymbol"/> or <see cref="T:Microsoft.CodeAnalysis.IPropertySymbol"/> that return a delegate.
            If it is an extension method, it is returned in reduced form.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SpeculativeSyntaxTreeSemanticModel">
            <summary>
            Allows asking semantic questions about a tree of syntax nodes that did not appear in the original source code.
            Typically, an instance is obtained by a call to SemanticModel.TryGetSpeculativeSemanticModel. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel">
            <summary>
            Allows asking semantic questions about any node in a SyntaxTree within a Compilation.
            </summary>
            <summary>
            Allows asking semantic questions about any node in a SyntaxTree within a Compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.Compilation">
            <summary>
            The compilation this object was obtained from.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.Root">
            <summary>
            The root node of the syntax tree that this object is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.SyntaxTree">
            <summary>
            The SyntaxTree that this object is associated with.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.IgnoresAccessibility">
            <summary>
            Returns true if this is a SemanticModel that ignores accessibility rules when answering semantic questions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetEnclosingBinderInternal(System.Int32)">
            <summary>
            Gets the enclosing binder associated with the node
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for the declaration
            assembly.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a namespace.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The namespace symbol that was declared by the namespace declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a type.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseTypeDeclarationSyntax as all of them return a NamedTypeSymbol.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a delegate.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The type symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an member declaration syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for following subtypes of MemberDeclarationSyntax:
            NOTE:   (1) GlobalStatementSyntax as they don't declare any symbols.
            NOTE:   (2) IncompleteMemberSyntax as there are no symbols for incomplete members.
            NOTE:   (3) BaseFieldDeclarationSyntax or its subtypes as these declarations can contain multiple variable declarators.
            NOTE:       GetDeclaredSymbol should be called on the variable declarators directly.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an enum member.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a method.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
            <remarks>
            NOTE:   We have no GetDeclaredSymbol overloads for subtypes of BaseMethodDeclarationSyntax as all of them return a MethodSymbol.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property, indexer or an event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a property, indexer or an event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an indexer.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a event.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an syntax node that declares a property or member accessor, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares an accessor.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredMember(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol,Microsoft.CodeAnalysis.Text.TextSpan,System.String)">
            <summary>
            Finds the member in the containing symbol which is inside the given declaration span.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an variable declarator syntax, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a variable.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The symbol that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the labeled statement.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
            <param name="declarationSyntax">The syntax node of the switch label.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The label symbol for that label.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a using declaration get the corresponding symbol for the using alias that was introduced.  
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared.</returns>
            <remarks>
            If the using directive is an error because it attempts to introduce an alias for which an existing alias was
            previously declared in the same scope, the result is a newly-constructed AliasSymbol (i.e. not one from the
            symbol table).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
            <param name="declarationSyntax"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The alias symbol that was declared, or null if a duplicate alias symbol was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbols(Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base field declaration syntax, get the corresponding symbols.
            </summary>
            <param name="declarationSyntax">The syntax node that declares one or more fields or events.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The field symbols that were declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an parameter declaration syntax node, get the corresponding symbol.
            </summary>
            <param name="declarationSyntax">The syntax node that declares a parameter.</param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns>The parameter that was declared.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeSemanticModel.GetDeclaredSymbol(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
            <param name="typeParameter"></param>
            <param name="cancellationToken">The cancellation token.</param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpTypeInfo.Type">
            <summary>
            The type of the expression represented by the syntax node. For expressions that do not
            have a type, null is returned. If the type could not be determined due to an error, than
            an object derived from ErrorTypeSymbol is returned.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpTypeInfo.ConvertedType">
            <summary>
            The type of the expression after it has undergone an implicit conversion. If the type
            did not undergo an implicit conversion, returns the same as Type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpTypeInfo.ImplicitConversion">
            <summary>
            If the expression underwent an implicit conversion, return information about that
            conversion. Otherwise, returns an identity conversion.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager">
            <summary>
            Manages anonymous types created in owning compilation. All requests for 
            anonymous type symbols go via the instance of this class.
            </summary>
            <summary>
            Manages anonymous types created on module level. All requests for anonymous type symbols 
            go via the instance of this class, the symbol will be either created or returned from cache.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeConstructorSymbol">
            <summary>
            Represents an anonymous type constructor.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePropertyGetAccessorSymbol">
            <summary>
            Represents a getter for anonymous type property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeEqualsMethodSymbol">
            <summary>
            Represents an anonymous type 'Equals' method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeGetHashCodeMethodSymbol">
            <summary>
            Represents an anonymous type 'GetHashCode' method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeToStringMethodSymbol">
            <summary>
            Represents an anonymous type 'ToString' method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.Compilation">
            <summary> 
            Current compilation
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.ConstructAnonymousTypeSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor)">
            <summary>
            Given anonymous type descriptor provided constructs an anonymous type symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetAnonymousTypeProperty(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Int32)">
            <summary>
            Get a symbol of constructed anonymous type property by property index
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetAnonymousTypePropertyTypes(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Retrieves anonymous type properties types
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.ConstructAnonymousTypeSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Given an anonymous type and new field types construct a new anonymous type symbol; 
            a new type symbol will reuse type descriptor from the constructed type with new type arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.IsSameType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Logical equality on anonymous types that ignores custom modifiers and/or the object/dynamic distinction.
            Differs from IsSameType for arrays, pointers, and generic instantiations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.ReportMissingOrErroneousSymbols(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Reports all use site errors in special or well known symbols required for anonymous types
            </summary>
            <returns>true if there was at least one error</returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager._lazyAnonymousTypeTemplates">
            <summary>
            Cache of created anonymous type templates used as an implementation of anonymous 
            types in emit phase.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager._lazySynthesizedDelegates">
            <summary>
            Maps delegate signature shape (number of parameters and their ref-ness) to a synthesized generic delegate symbol.
            Unlike anonymous types synthesized delegates are not available thru symbol APIs. They are only used in lowered bound trees.
            Currently used for dynamic call-site sites whose signature doesn't match any of the well-known Func or Action types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.SynthesizedDelegateKey.MakeTypeName">
            <summary>
            Produces name of the synthesized delegate symbol that encodes the parameter byref-ness and return type of the delegate.
            The arity is appended via `N suffix since in MetadataName calculation since the delegate is generic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.ConstructAnonymousTypeImplementationSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePublicSymbol)">
            <summary>
            Given anonymous type provided constructs an implementation type symbol to be used in emit phase; 
            if the anonymous type has at least one field the implementation type symbol will be created based on 
            a generic type template generated for each 'unique' anonymous type structure, otherwise the template
            type will be non-generic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AssignTemplatesNamesAndCompile(Microsoft.CodeAnalysis.CSharp.MethodCompiler,Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Resets numbering in anonymous type names and compiles the
            anonymous type methods. Also seals the collection of templates.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetCreatedAnonymousTypeTemplates(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol})">
            <summary>
            The set of anonymous type templates created by
            this AnonymousTypeManager, in fixed order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetCreatedSynthesizedDelegates(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedDelegateSymbol})">
            <summary>
            The set of synthesized delegates created by
            this AnonymousTypeManager.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetAllCreatedTemplates">
            <summary>
            Returns all templates owned by this type manager
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.IsAnonymousTypeTemplate(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Returns true if the named type is an implementation template for an anonymous type
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.GetAnonymousTypeHiddenMethods(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Retrieves methods of anonymous type template which are not placed to symbol table.
            In current implementation those are overriden 'ToString', 'Equals' and 'GetHashCode'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.TranslateAnonymousTypeSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Translates anonymous type public symbol into an implementation type symbol to be used in emit.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.TranslateAnonymousTypeMethodSymbol(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Translates anonymous type method symbol into an implementation method symbol to be used in emit.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeComparer">
            <summary> 
            Comparator being used for stable ordering in anonymous type indices.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePublicSymbol">
            <summary>
            Represents an anonymous type 'public' symbol which is used in binding and lowering.
            In emit phase it is being substituted with implementation symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePublicSymbol.Properties">
            <summary> Properties defined in the type </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePublicSymbol._nameToSymbols">
            <summary> Maps member names to symbol(s) </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePublicSymbol.Manager">
            <summary> Anonymous type manager owning this template </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePublicSymbol.TypeDescriptor">
            <summary> Anonymous type descriptor </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeFieldSymbol">
            <summary>
            Represents a baking field for an anonymous type template property symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypePropertySymbol">
            <summary>
            Represents an anonymous type template's property symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.SynthesizedMethodBase">
            <summary>
            Represents a base implementation for anonymous type synthesized methods.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol">
            <summary>
            Represents an anonymous type 'template' which is a generic type to be used for all 
            anonymous type having the same structure, i.e. the same number of fields and field names.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol._nameAndIndex">
            <summary> Name to be used as metadata name during emit </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol.SpecialMembers">
            <summary> This list consists of synthesized method symbols for ToString, 
            Equals and GetHashCode which are not part of symbol table </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol.Properties">
            <summary> Properties defined in the template </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol._nameToSymbols">
            <summary> Maps member names to symbol(s) </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol.Manager">
            <summary> Anonymous type manager owning this template </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol._smallestLocation">
            <summary> Smallest location of the template, actually contains the smallest location 
            of all the anonymous type instances created using this template during EMIT </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol.TypeDescriptorKey">
            <summary> Key pf the anonymous type descriptor </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol.SmallestLocation">
            <summary>
            Smallest location of the template, actually contains the smallest location 
            of all the anonymous type instances created using this template during EMIT;
            
            NOTE: if this property is queried, smallest location must not be null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol.AdjustLocation(Microsoft.CodeAnalysis.Location)">
            <summary>
            In emit phase every time a created anonymous type is referenced we try to store the lowest 
            location of the template. It will be used for ordering templates and assigning emitted type names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeTemplateSymbol.TrySynthesizeDebuggerDisplayAttribute">
            <summary>
            Returns a synthesized debugger display attribute or null if one
            could not be synthesized.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeManager.AnonymousTypeParameterSymbol">
            <summary>
            Represents an anonymous type template's type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStringSwitchHashMethod">
            <summary>
            Represents a compiler generated synthesized method symbol
            representing string switch hash function
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStringSwitchHashMethod.ComputeStringHash(System.String)">
            <summary>
            Compute the hashcode of a sub string using FNV-1a
            See http://en.wikipedia.org/wiki/Fowler%E2%80%93Noll%E2%80%93Vo_hash_function
            </summary>
            <remarks>
            This method should be kept consistent with MethodBodySynthesizer.ConstructStringSwitchHashFunctionBody
            The control flow in this method mimics lowered "for" loop. It is exactly what we want to emit
            to ensure that JIT can do range check hoisting.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedExplicitImplementationForwardingMethod">
            <summary>
            When C# interface implementation differs from CLR interface implementation,
            we insert a synthesized explicit interface implementation that delegates
            to the method that C# considers an implicit implementation.
            There are two key scenarios for this:
            1) A single source method is implicitly implementing one or more interface
               methods from metadata and the interface methods have different custom
               modifiers.  In this case, we explicitly implement the interface methods
               and have (all) implementations delegate to the source method.
            2) A non-virtual, non-source method in a base type is implicitly implementing
               an interface method.  Since we can't change the "virtualness" of the 
               non-source method, we introduce an explicit implementation that delegates
               to it instead.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedExplicitImplementationForwardingMethod.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Given a SynthesizedExplicitImplementationMethod (effectively a tuple (interface method, implementing method, implementing type)),
            construct a BoundBlock body.  Consider the tuple (Interface.Foo, Base.Foo, Derived).  The generated method will look like:
            
            R Interface.Foo&lt;T1, T2, ...&gt;(A1 a1, A2 a2, ...)
            {
                //don't return the output if the return type is void
                return this.Foo&lt;T1, T2, ...&gt;(a1, a2, ...);
            }
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSealedPropertyAccessor">
            <summary>
            If a sealed override property defines fewer accessors than the
            original virtual property, it is necessary to synthesize a sealed
            accessor so that the accessor will not be overridable from metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSealedPropertyAccessor.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Given a SynthesizedSealedPropertyAccessor (an accessor with a reference to the accessor it overrides),
            construct a BoundBlock body.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter">
            <summary>
            a bound node rewriter that rewrites types properly (which in some cases the automatically-generated
            base class does not).  This is used in the lambda rewriter, the iterator rewriter, and the async rewriter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.BaseMethodWrapperSymbol">
            <summary>
            A wrapper method that is created for non-virtually calling a base-class 
            virtual method from other classes (like those created for lambdas...).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.BaseMethodWrapperSymbol.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Given a SynthesizedSealedPropertyAccessor (an accessor with a reference to the accessor it overrides),
            construct a BoundBlock body.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.CompilationState">
            <summary> A not-null collection of synthesized methods generated for the current source type. </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.NeedsProxy(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Returns true if the specified local/parameter needs to be hoisted to a field.
            Variable may be hoisted even if it is not captured, to improve debugging experience.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodBodySynthesizer">
            <summary>
            Contains methods related to synthesizing bound nodes in lowered form 
            that does not need any processing before passing to codegen
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodBodySynthesizer.ConstructSingleInvocationMethodBody(Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean)">
            <summary>
            Construct a body for a method containing a call to a single other method with the same signature (modulo name).
            </summary>
            <param name="F">Bound node factory.</param>
            <param name="methodToInvoke">Method to invoke in constructed body.</param>
            <param name="useBaseReference">True for "base.", false for "this.".</param>
            <returns>Body for implementedMethod.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol">
            <summary>
            An ArrayTypeSymbol represents an array type, such as int[] or object[,].
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier},System.Int32)">
            <summary>
            Create a new ArrayTypeSymbol.
            </summary>
            <param name="elementType">The element type of this array type.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
            <param name="rank">The rank of this array type.</param>
            <param name="declaringAssembly">The assembly "declaring"/using the array type.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers associated with the array.
            Returns an empty list if there are no custom modifiers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.Rank">
            <summary>
            Gets the number of dimensions of the array. A regular single-dimensional array
            has rank 1, a two-dimensional array has rank 2, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol.ElementType">
            <summary>
            Gets the type of the elements stored in the array.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData">
            <summary>
            Represents an attribute applied to a Symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.AttributeClass">
            <summary>
            Gets the attribute class being applied.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.AttributeConstructor">
            <summary>
            Gets the constructor used in this application of the attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.ApplicationSyntaxReference">
            <summary>
            Gets a reference to the source for this application of the attribute. Returns null for applications of attributes on metadata Symbols.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.ConstructorArguments">
            <summary>
            Gets the list of constructor arguments specified by this application of the attribute.  This list contains both positional arguments
            and named arguments that are formal parameters to the constructor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.NamedArguments">
            <summary>
            Gets the list of named field or property value arguments specified by this application of the attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.IsTargetAttribute(System.String,System.String)">
            <summary>
            Compares the namespace and type name with the attribute's namespace and type name.
            Returns true if they are the same.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.IsTargetEarlyAttribute(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Checks if an applied attribute with the given attributeType matches the namespace name and type name of the given early attribute's description
            and the attribute description has a signature with parameter count equal to the given attribute syntax's argument list count.
            NOTE: We don't allow early decoded attributes to have optional parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.ToString">
            <summary>
            Returns the <see cref="T:System.String"/> that represents the current AttributeData.
            </summary>
            <returns>A <see cref="T:System.String"/> that represents the current AttributeData.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.CommonAttributeClass">
            <summary>
            Gets the attribute class being applied as an <see cref="T:Microsoft.CodeAnalysis.INamedTypeSymbol"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.CommonAttributeConstructor">
            <summary>
            Gets the constructor used in this application of the attribute as an <see cref="T:Microsoft.CodeAnalysis.IMethodSymbol"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.CommonApplicationSyntaxReference">
            <summary>
            Gets a reference to the source for this application of the attribute. Returns null for applications of attributes on metadata Symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.DecodePermissionSetAttribute(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.DiagnosticBag)">
             <summary>
             Decodes PermissionSetAttribute applied in source to determine if it needs any fixup during codegen.
             </summary>
             <remarks>
             PermissionSetAttribute needs fixup when it contains an assignment to the 'File' property as a single named attribute argument.
             Fixup performed is ported from SecurityAttributes::FixUpPermissionSetAttribute.
             It involves following steps:
              1) Verifying that the specified file name resolves to a valid path.
              2) Reading the contents of the file into a byte array.
              3) Convert each byte in the file content into two bytes containing hexa-decimal characters.
              4) Replacing the 'File = fileName' named argument with 'Hex = hexFileContent' argument, where hexFileContent is the converted output from step 3) above.
            
             Step 1) is performed in this method, i.e. during binding.
             Remaining steps are performed during serialization as we want to avoid retaining the entire file contents throughout the binding/codegen pass.
             See <see cref="T:Microsoft.CodeAnalysis.CodeGen.PermissionSetAttributeWithFileReference"/> for remaining fixup steps.
             </remarks>
             <returns>String containing the resolved file path if PermissionSetAttribute needs fixup during codegen, null otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.ShouldEmitAttribute(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,System.Boolean)">
            <summary>
            This method determines if an applied attribute must be emitted.
            Some attributes appear in symbol model to reflect the source code,
            but should not be emitted.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpCustomModifier">
            <summary>
            Represents a custom modifier (modopt/modreq).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpCustomModifier.Modifier">
            <summary>
            A type used as a tag that indicates which type of modification applies.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol">
            <summary>
            Represents an event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.Type">
            <summary>
            The type of the event. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.AddMethod">
            <summary>
            The 'add' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.RemoveMethod">
            <summary>
            The 'remove' accessor of the event.  Null only in error scenarios.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.IsWindowsRuntimeEvent">
            <summary>
            True if this is a Windows Runtime-style event.
            
            A normal C# event, "event D E", has accessors
                void add_E(D d)
                void remove_E(D d)
            
            A Windows Runtime event, "event D E", has accessors
                EventRegistrationToken add_E(D d)
                void remove_E(EventRegistrationToken t)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.GetFieldAttributes">
            <summary>
            Gets the attributes on event's associated field, if any.
            Returns an empty <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> if
            there are no attributes.
            </summary>
            <remarks>
            This publicly exposes the attributes of the internal backing field.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.OverriddenEvent">
            <summary>
            Returns the overridden event, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.IsExplicitInterfaceImplementation">
            <summary>
            Source: Was the member name qualified with a type name?
            Metadata: Is the member an explicit implementation?
            </summary>
            <remarks>
            Will not always agree with ExplicitInterfaceImplementations.Any()
            (e.g. if binding of the type part of the name fails).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface events explicitly implemented by this event.
            </summary>
            <remarks>
            Events imported from metadata can explicitly implement more than one event.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol">
            <summary>
            Represents a field in a class, struct or enum
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.Type">
            <summary>
            Gets the type of this field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.CustomModifiers">
            <summary>
            Gets the list of custom modifiers, if any, associated with the field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.AssociatedSymbol">
            <summary>
            If this field serves as a backing variable for an automatically generated
            property or a field-like event, returns that 
            property/event. Otherwise returns null.
            Note, the set of possible associated symbols might be expanded in the future to 
            reflect changes in the languages.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsReadOnly">
            <summary>
            Returns true if this field was declared as "readonly". 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsVolatile">
            <summary>
            Returns true if this field was declared as "volatile". 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsFixed">
            <summary>
            Returns true if this field was declared as "fixed".
            Note that for a fixed-size buffer declaration, this.Type will be a pointer type, of which
            the pointed-to type will be the declared element type of the fixed-size buffer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.FixedSize">
            <summary>
            If IsFixed is true, the value between brackets in the fixed-size-buffer declaration.
            If IsFixed is false FixedSize is 0.
            Note that for fixed-a size buffer declaration, this.Type will be a pointer type, of which
            the pointed-to type will be the declared element type of the fixed-size buffer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.FixedImplementationType(Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder)">
            <summary>
            If this.IsFixed is true, returns the underlying implementation type for the
            fixed-size buffer when emitted.  Otherwise returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsCapturedFrame">
            <summary>
            Returns true when field is a backing field for a captured frame pointer (typically "this").
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsConst">
            <summary>
            Returns true if this field was declared as "const" (i.e. is a constant declaration).
            Also returns true for an enum member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.ConstantValue">
            <summary>
            If IsConst returns true, then returns the constant value of the field or enum member. If IsConst returns
            false, then returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsAbstract">
            <summary>
            Returns false because field can't be abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsExtern">
            <summary>
            Returns false because field can't be defined externally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsOverride">
            <summary>
            Returns false because field can't be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsSealed">
            <summary>
            Returns false because field can't be sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsVirtual">
            <summary>
            Returns false because field can't be virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.HasRuntimeSpecialName">
            <summary>
            True if this symbol has a runtime-special name (metadata flag RuntimeSpecialName is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.IsNotSerialized">
            <summary>
            True if this field is not serialized (metadata flag NotSerialized is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.HasPointerType">
            <summary>
            True if this field has a pointer type.
            </summary>
            <remarks>
            By default we defer to this.Type.IsPointerType() 
            However in some cases this may cause circular dependency via binding a
            pointer that points to the type that contains the current field.
            Fortunately in those cases we do not need to force binding of the field's type 
            and can just check the declaration syntax if the field type is not yet known.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.MarshallingInformation">
            <summary>
            Describes how the field is marshalled when passed to native code.
            Null if no specific marshalling information is available for the field.
            </summary>
            <remarks>PE symbols don't provide this information and always return null.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.MarshallingType">
            <summary>
            Returns the marshalling type of this field, or 0 if marshalling information isn't available.
            </summary>
            <remarks>
            By default this information is extracted from <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.MarshallingInformation"/> if available. 
            Since the compiler does only need to know the marshalling type of symbols that aren't emitted 
            PE symbols just decode the type from metadata and don't provide full marshalling information.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.TypeLayoutOffset">
            <summary>
            Offset assigned to the field when the containing type is laid out by the VM.
            Null if unspecified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol">
            <summary>
            Represents a method or method-like symbol (including constructor,
            destructor, operator, or property/event accessor).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsMetadataNewSlot(System.Boolean)">
            <summary>
            This method indicates whether or not the runtime will regard the method
            as newslot (as indicated by the presence of the "newslot" modifier in the
            signature).
            WARN WARN WARN: We won't have a final value for this until declaration
            diagnostics have been computed for all <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol"/>s, so pass
            ignoringInterfaceImplementationChanges: true if you need a value sooner
            and aren't concerned about tweaks made to satisfy interface implementation 
            requirements.
            NOTE: Not ignoring changes can only result in a value that is more true.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsMetadataVirtual(System.Boolean)">
            <summary>
            This method indicates whether or not the runtime will regard the method
            as virtual (as indicated by the presence of the "virtual" modifier in the
            signature).
            WARN WARN WARN: We won't have a final value for this until declaration
            diagnostics have been computed for all <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol"/>s, so pass
            ignoringInterfaceImplementationChanges: true if you need a value sooner
            and aren't concerned about tweaks made to satisfy interface implementation 
            requirements.
            NOTE: Not ignoring changes can only result in a value that is more true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.MethodKind">
            <summary>
            Gets what kind of method this is. There are several different kinds of things in the
            C# language that are represented as methods. This property allow distinguishing those things
            without having to decode the name of the method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.Arity">
            <summary>
            Returns the arity of this method, or the number of type parameters it takes.
            A non-generic method has zero arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsGenericMethod">
            <summary>
            Returns whether this method is generic; i.e., does it have any type parameters?
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsExtensionMethod">
            <summary>
            Returns true if this method is an extension method. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ImplementationAttributes">
            <summary>
            Misc implementation metadata flags (ImplFlags in metadata).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.HasDeclarativeSecurity">
            <summary>
            True if the type has declarative security information (HasSecurity flags).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetDllImportData">
            <summary>
            Platform invoke information, or null if the method isn't a P/Invoke.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetSecurityInformation">
            <summary>
            Declaration security information associated with this type, or null if there is none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReturnValueMarshallingInformation">
            <summary>
            Marshalling information for return value (FieldMarshal in metadata). 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.RequiresSecurityObject">
            <summary>
            True if the method calls another method containing security code (metadata flag RequiresSecurityObject is set).
            </summary>
            <remarks>
            A method can me marked as RequiresSecurityObject by applying the DynamicSecurityMethodAttribute in source.
            DynamicSecurityMethodAttribute is a pseudo custom attribute defined as an internal class in System.Security namespace.
            This attribute is set on certain security methods defined within mscorlib.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.HidesBaseMethodsByName">
            <summary>
            Returns true if this method hides base methods by name. This cannot be specified directly
            in the C# language, but can be true for methods defined in other languages imported from
            metadata. The equivalent of the "hidebyname" flag in metadata. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsVararg">
             <summary>
             Returns whether this method is using CLI VARARG calling convention. This is used for C-style variable
             argument lists. This is used extremely rarely in C# code and is represented using the undocumented “__arglist” keyword.
            
             Note that methods with “params” on the last parameter are indicated with the “IsParams” property on ParameterSymbol, and
             are not represented with this property.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsCheckedBuiltin">
            <summary>
            Returns whether this built-in operator checks for integer overflow.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReturnsVoid">
            <summary>
            Returns true if this method has no return type; i.e., returns "void".
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsAsync">
            <summary>
            Source: Returns whether this method is async; i.e., does it have the async modifier?
            Metadata: Returns false; methods from metadata cannot be async.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReturnType">
            <summary>
            Gets the return type of the method
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a given type parameter,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TypeParameters">
            <summary>
            Get the type parameters on this method. If the method has not generic,
            returns an empty list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ThisParameter">
            <summary>
            Call <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TryGetThisParameter(Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol@)"/> and throw if it returns false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TryGetThisParameter(Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol@)">
            <returns>
            True if this <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/> type supports retrieving the this parameter
            and false otherwise.  Note that a return value of true does not guarantee a non-null
            <paramref name="thisParameter"/> (e.g. fails for static methods).
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ParameterCount">
            <summary>
            Optimization: in many cases, the parameter count (fast) is sufficient and we
            don't need the actual parameter symbols (slow).
            </summary>
            <remarks>
            The default implementation is always correct, but may be unnecessarily slow.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.Parameters">
            <summary>
            Gets the parameters of this method. If this method has no parameters, returns
            an empty list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ConstructedFrom">
            <summary>
            Returns the method symbol that this method was constructed from. The resulting
            method symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsExplicitInterfaceImplementation">
            <summary>
            Source: Was the member name qualified with a type name?
            Metadata: Is the member an explicit implementation?
            </summary>
            <remarks>
            Will not always agree with ExplicitInterfaceImplementations.Any()
            (e.g. if binding of the type part of the name fails).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface methods explicitly implemented by this method.
            </summary>
            <remarks>
            Methods imported from metadata can explicitly implement more than one method, 
            that is why return type is ImmutableArray.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReturnTypeCustomModifiers">
            <summary>
            Returns the list of custom modifiers, if any, associated with the returned value. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetReturnTypeAttributes">
            <summary>
            Gets the attributes on method's return type.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.AssociatedSymbol">
            <summary>
            If this method has MethodKind of MethodKind.PropertyGet or MethodKind.PropertySet,
            returns the property that this method is the getter or setter for.
            If this method has MethodKind of MethodKind.EventAdd or MethodKind.EventRemove,
            returns the event that this method is the adder or remover for.
            Note, the set of possible associated symbols might be expanded in the future to 
            reflect changes in the languages.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetLeastOverriddenMethod(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Returns the original virtual or abstract method which a given method symbol overrides,
            ignoring any other overriding methods in base classes.
            </summary>
            <param name="accessingTypeOpt">The search must respect accessibility from this type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetConstructedLeastOverriddenMethod(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Returns the original virtual or abstract method which a given method symbol overrides,
            ignoring any other overriding methods in base classes.
            Also, if the given method symbol is generic then the resulting virtual or abstract method is constructed with the
            same type arguments as the given method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.OverriddenMethod">
            <summary>
            If this method overrides another method (because it both had the override modifier
            and there correctly was a method to override), returns the overridden method.
            Note that if an overriding method D.M overrides C.M, which in turn overrides 
            virtual method A.M, the "overridden method" of D.M is C.M, not the original virtual
            method A.M. Note also that constructed generic methods are not considered to 
            override anything.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.CallsAreOmitted(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Returns true if calls to this method are omitted in this syntax tree. Calls are omitted
            when the called method is a partial method with no implementation part, or when the
            called method is a conditional method whose condition is not true in the source file
            corresponding to the given syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.CallsAreConditionallyOmitted(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Calls are conditionally omitted if both the following requirements are true:
             (a) IsConditional == true, i.e. it has at least one applied/inherited conditional attribute AND
             (b) None of conditional symbols corresponding to these conditional attributes are defined in the given syntaxTree.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetAppliedConditionalSymbols">
            <summary>
            Returns a sequence of preprocessor symbols specified in <see cref="T:System.Diagnostics.ConditionalAttribute"/> applied on this symbol, or null if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsConditional">
            <summary>
            Returns a flag indicating whether this symbol has at least one applied/inherited conditional attribute.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.CanOverrideOrHide(Microsoft.CodeAnalysis.MethodKind)">
            <summary>
            Some method kinds do not participate in overriding/hiding (e.g. constructors).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.Kind">
            <summary>
            Returns value 'Method' of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsScriptConstructor">
            <summary>
            Returns true if this symbol represents a constructor of a script class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsImplicitConstructor">
            <summary>
            Returns if the method is implicit constructor (normal and static)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsImplicitInstanceConstructor">
            <summary>
            Returns if the method is implicit instance constructor
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsSubmissionConstructor">
            <summary>
            Returns true if this symbol represents a constructor of an interactive submission class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IsEntryPointCandidate">
            <summary>
            Determines whether this method is a candidate for a default assembly entry point 
            (i.e. it is a static method called "Main").
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.HasEntryPointSignature">
            <summary>
            Checks if the method has an entry point compatible signature, i.e.
            - the return type is either void or int
            - has either no parameter or a single parameter of type string[]
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReduceExtensionMethod(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            If this is an extension method that can be applied to a receiver of the given type,
            returns a reduced extension method symbol thus formed. Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReduceExtensionMethod">
            <summary>
            If this is an extension method, returns a reduced extension method
            symbol representing the method. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.CallsiteReducedFromMethod">
            <summary>
            If this method is a reduced extension method, returns the extension method that
            should be used at call site during ILGen. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.PartialImplementationPart">
            <summary>
            If this is a partial method declaration without a body, and the method also
            has a part that implements it with a body, returns that implementing
            definition.  Otherwise null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.PartialDefinitionPart">
            <summary>
            If this is a partial method with a body, returns the corresponding
            definition part (without a body).  Otherwise null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReducedFrom">
            <summary>
            If this method is a reduced extension method, gets the extension method definition that
            this method was reduced from. Otherwise, returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReceiverType">
            <summary>
            If this method can be applied to an object, returns the type of object it is applied to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GetTypeInferredDuringReduction(Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol)">
            <summary>
            If this method is a reduced extension method, returns a type inferred during reduction process for the type parameter. 
            </summary>
            <param name="reducedFromTypeParameter">Type parameter of the corresponding <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReducedFrom"/> method.</param>
            <returns>Inferred type or Nothing if nothing was inferred.</returns>
            <exception cref="T:System.InvalidOperationException">If this is not a reduced extension method.</exception>
            <exception cref="T:System.ArgumentNullException">If <paramref name="reducedFromTypeParameter"/> is null.</exception>
            <exception cref="T:System.ArgumentException">If <paramref name="reducedFromTypeParameter"/> doesn't belong to the corresponding <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ReducedFrom"/> method.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.Construct(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol[])">
            <summary>
            Apply type substitution to a generic method to create an method symbol with the given type parameters supplied.
            </summary>
            <param name="typeArguments"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.Construct(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Apply type substitution to a generic method to create an method symbol with the given type parameters supplied.
            </summary>
            <param name="typeArguments"></param>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol._lazyParameterSignature">
            <summary>
            As a performance optimization, cache parameter types and refkinds - overload resolution uses them a lot.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.ParameterRefKinds">
            <summary>
            Null if no parameter is ref/out. Otherwise the RefKind for each parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.TypeSubstitution">
            <summary>
            Returns the map from type parameters to type arguments.
            If this is not a generic method instantiation, returns null.
            The map targets the original definition of the method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.IteratorElementType">
            <summary>
            If the method was written as an iterator method (i.e. with yield statements in its body) returns the
            element type of the iterator.  Otherwise returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GenerateMethodBody(Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generates bound block representing method's body for methods in lowered form and adds it to
            a collection of method bodies of the current module. This method is supposed to only be 
            called for method symbols which return SynthesizesLoweredBoundBody == true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.SynthesizesLoweredBoundBody">
            <summary>
            Returns true for synthesized sybols which generate synthesized body in lowered form
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.GenerateDebugInfo">
            <summary>
            Return true iff the method contains user code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.CalculateLocalSyntaxOffset(System.Int32,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Calculates a syntax offset for a local (user-defined or long-lived synthesized) declared at <paramref name="localPosition"/>.
            Must be implemented by all methods that may contain user code.
            </summary>
            <remarks>
            Syntax offset is a unique identifier for the local within the emitted method body.
            It's based on position of the local declarator. In single-part method bodies it's simply the distance
            from the start of the method body syntax span. If a method body has multiple parts (such as a constructor 
            comprising of code for member initializers and constructor initializer calls) the offset is calculated
            as if all source these parts were concatenated together and prepended to the constructor body.
            The resulting syntax offset is then negative for locals defined outside of the constructor body.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol.AddSynthesizedReturnTypeAttributes(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData}@)">
            <summary>
            Build and add synthesized return type attributes for this method symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol">
            <summary>
            Represents a type other than an array, a pointer, a type parameter, and dynamic.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetInterfacesToEmit">
            <summary>
            Gets the set of interfaces to emit on this type. This set can be different from the set returned by Interfaces property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.InterfacesVisit(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol}@)">
            <summary>
            Add the type to the builder and then recurse on its interfaces.
            </summary>
            <remarks>
            Pre-order depth-first search.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetMethodsToEmit">
            <summary>
            To represent a gap in interface's v-table null value should be returned in the appropriate position,
            unless the gap has a symbol (happens if it is declared in source, for example).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Arity">
            <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TypeParameters">
            <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ImmutableArray.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TypeArguments">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a give type parameters,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.ConstructedFrom">
            <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.KnownCircularStruct">
            <summary>
            Returns true for a struct type containing a cycle.
            This property is intended for flow analysis only
            since it is only implemented for source types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsExplicitDefinitionOfNoPiaLocalType">
            <summary>
            Is this a NoPia local type explicitly declared in source, i.e.
            top level type with a TypeIdentifier attribute on it?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetGuidString(System.String@)">
            <summary>
            Returns true and a string from the first GuidAttribute on the type, 
            the string might be null or an invalid guid representation. False, 
            if there is no GuidAttribute with string argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.DelegateInvokeMethod">
            <summary>
            For delegate types, gets the delegate's invoke method.  Returns null on
            all other kinds of types.  Note that is is possible to have an ill-formed
            delegate type imported from metadata which does not have an Invoke method.
            Such a type will be classified as a delegate but its DelegateInvokeMethod
            would be null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetOperators(System.String)">
            <summary>
            Get the operators for this type by their metadata name
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.InstanceConstructors">
            <summary>
            Get the instance constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.StaticConstructors">
            <summary>
            Get the static constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Constructors">
            <summary>
            Get the instance and static constructors for this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Indexers">
            <summary>
            Get the indexers for this type.
            </summary>
            <remarks>
            Won't include indexers that are explicit interface implementations.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.MightContainExtensionMethods">
            <summary>
            Returns true if this type might contain extension methods. If this property
            returns false, there are no extension methods in this type.
            </summary>
            <remarks>
            This property allows the search for extension methods to be narrowed quickly.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetAttributeUsageInfo">
            <summary>
            Gets the associated attribute usage info for an attribute type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsScriptClass">
            <summary>
            Returns true if the type is a Script class. 
            It might be an interactive submission class or a Script class in a csx file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsImplicitClass">
            <summary>
            Returns true if the type is the implicit class that holds onto invalid global members (like methods or
            statements in a non script file).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.MetadataName">
            <summary>
            Return the name including the metadata arity suffix.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.MangleName">
            <summary>
            Should the name returned by Name property be mangled with [`arity] suffix in order to get metadata name.
            Must return False for a type with Arity == 0.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.MemberNames">
            <summary>
            Collection of names of members declared within this type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Used to implement visitor pattern.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetEarlyAttributeDecodingMembers">
            <summary>
            During early attribute decoding, we consider a safe subset of all members that will not
            cause cyclic dependencies.  Get all such members for this symbol.
            </summary>
            <remarks>
            Never returns null (empty instead).
            Expected implementations: for source, return type and field members; for metadata, return all members.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetEarlyAttributeDecodingMembers(System.String)">
            <summary>
            During early attribute decoding, we consider a safe subset of all members that will not
            cause cyclic dependencies.  Get all such members for this symbol that have a particular name.
            </summary>
            <remarks>
            Never returns null (empty instead).
            Expected implementations: for source, return type and field members; for metadata, return all members.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Equals(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Compares this type to another type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.EqualsComplicatedCases(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Helper for more complicated cases of Equals like when we have generic instantiations or types nested within them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Construct(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol[])">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Construct(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments">The immediate type arguments to be replaced for type
            parameters in the type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Construct(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Returns a constructed type given its type arguments.
            </summary>
            <param name="typeArguments"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.ConstructUnboundGenericType">
            <summary>
            Returns an unbound generic type of this named type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsGenericType">
            <summary>
            True if this type or some containing type has type parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsUnboundGenericType">
            <summary>
            True if this is a reference to an <em>unbound</em> generic type.  These occur only
            within a <code>typeof</code> expression.  A generic type is considered <em>unbound</em>
            if all of the type argument lists in its fully qualified name are empty.
            Note that the type arguments of an unbound generic type will be returned as error
            types because they do not really have type arguments.  An unbound generic type
            yields null for its BaseType and an empty result for its Interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.TypeSubstitution">
            <summary>
            Returns the map from type parameters to type arguments.
            If this is not a generic type instantiation, returns null.
            The map targets the original definition of the type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsComImport">
            <summary>
            Returns a flag indicating whether this symbol is ComImport.
            </summary>
            <remarks>
            A type can me marked as a ComImport type in source by applying the <see cref="T:System.Runtime.InteropServices.ComImportAttribute"/>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsWindowsRuntimeImport">
            <summary>
            True if the type is a Windows runtime type.
            </summary>
            <remarks>
            A type can me marked as a Windows runtime type in source by applying the WindowsRuntimeImportAttribute.
            WindowsRuntimeImportAttribute is a pseudo custom attribute defined as an internal class in System.Runtime.InteropServices.WindowsRuntime namespace.
            This is needed to mark Windows runtime types which are redefined in mscorlib.dll and System.Runtime.WindowsRuntime.dll.
            These two assemblies are special as they implement the CLR's support for WinRT.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.ShouldAddWinRTMembers">
            <summary>
            True if the type should have its WinRT interfaces projected onto .NET types and
            have missing .NET interface members added to the type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsConditional">
            <summary>
            Returns a flag indicating whether this symbol has at least one applied/inherited conditional attribute.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsSerializable">
            <summary>
            True if the type is serializable (has Serializable metadata flag).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.Layout">
            <summary>
            Type layout information (ClassLayout metadata and layout kind flags).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.DefaultMarshallingCharSet">
            <summary>
            The default charset used for type marshalling. 
            Can be changed via <see cref="T:System.Runtime.InteropServices.DefaultCharSetAttribute"/> applied on the containing module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.MarshallingCharSet">
            <summary>
            Marshalling charset of string data fields within the type (string formatting flags in metadata).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.HasDeclarativeSecurity">
            <summary>
            True if the type has declarative security information (HasSecurity flags).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetSecurityInformation">
            <summary>
            Declaration security information associated with this type, or null if there is none.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.GetAppliedConditionalSymbols">
            <summary>
            Returns a sequence of preprocessor symbols specified in <see cref="T:System.Diagnostics.ConditionalAttribute"/> applied on this symbol, or null if there are none.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.ComImportCoClass">
            <summary>
            If <see cref="T:System.Runtime.InteropServices.CoClassAttribute"/> was applied to the type and the attribute argument is a valid named type argument, i.e. accessible class type, then it returns the type symbol for the argument.
            Otherwise, returns null.
            </summary>
            <remarks>
            <para>
            This property invokes force completion of attributes. If you are accessing this property
            from the binder, make sure that we are not binding within an Attribute context.
            This could lead to a possible cycle in attribute binding.
            We can avoid this cycle by first checking if we are within the context of an Attribute argument,
            i.e. if(!binder.InAttributeArgument) { ...  namedType.ComImportCoClass ... }
            </para>
            <para>
            CONSIDER: We can remove the above restriction and possibility of cycle if we do an
            early binding of some well known attributes.
            </para>
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.FixedElementField">
            <summary>
            If class represents fixed buffer, this property returns the FixedElementField
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol.IsInterface">
            <summary>
            Requires less computation than <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.TypeKind"/> == <see cref="F:Microsoft.CodeAnalysis.TypeKind.Interface"/>.
            </summary>
            <remarks>
            Metadata types need to compute their base types in order to know their TypeKinds, and that can lead
            to cycles if base types are already being computed.
            </remarks>
            <returns>True if this is an interface type.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol">
            <summary>
            Represents a namespace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.GetNamespaceMembers">
            <summary>
            Get all the members of this symbol that are namespaces.
            </summary>
            <returns>An IEnumerable containing all the namespaces that are members of this symbol.
            If this symbol has no namespace members, returns an empty IEnumerable. Never returns
            null.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.IsGlobalNamespace">
            <summary>
            Returns whether this namespace is the unnamed, global namespace that is 
            at the root of all namespaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.NamespaceKind">
            <summary>
            The kind of namespace: Module, Assembly or Compilation.
            Module namespaces contain only members from the containing module that share the same namespace name.
            Assembly namespaces contain members for all modules in the containing assembly that share the same namespace name.
            Compilation namespaces contain all members, from source or referenced metadata (assemblies and modules) that share the same namespace name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.ContainingCompilation">
            <summary>
            The containing compilation for compilation namespaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.ConstituentNamespaces">
            <summary>
            If a namespace has Assembly or Compilation extent, it may be composed of multiple
            namespaces that are merged together. If so, ConstituentNamespaces returns
            all the namespaces that were merged. If this namespace was not merged, returns
            an array containing only this namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.ContainingAssembly">
            <summary>
            Containing assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.ImplicitType">
            <summary>
            Returns an implicit type symbol for this namespace or null if there is none. This type
            wraps misplaced global code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.LookupNestedNamespace(System.Collections.Immutable.ImmutableArray{System.String})">
            <summary>
            Lookup a nested namespace.
            </summary>
            <param name="names">
            Sequence of names for nested child namespaces.
            </param>
            <returns>
            Symbol for the most nested namespace, if found. Nothing 
            if namespace or any part of it can not be found.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol.GetExtensionMethods(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol},System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.LookupOptions)">
            <summary>
            Add all extension methods in this namespace to the given list. If name or arity
            or both are provided, only those extension methods that match are included.
            </summary>
            <param name="methods">Methods list</param>
            <param name="nameOpt">Optional method name</param>
            <param name="arity">Method arity</param>
            <param name="options">Lookup options</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol">
            <summary>
            Represents a parameter of a method or indexer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.Microsoft#Cci#IParameterDefinition#GetDefaultValue(Microsoft.CodeAnalysis.Emit.EmitContext)">
            <summary>
            Gets constant value to be stored in metadata Constant table.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.Type">
            <summary>
            Gets the type of the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.RefKind">
            <summary>
            Determines if the parameter ref, out or neither.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.MarshallingInformation">
            <summary>
            Describes how the parameter is marshalled when passed to native code.
            Null if no specific marshalling information is available for the parameter.
            </summary>
            <remarks>PE symbols don't provide this information and always return null.</remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.MarshallingType">
            <summary>
            Returns the marshalling type of this parameter, or 0 if marshalling information isn't available.
            </summary>
            <remarks>
            By default this information is extracted from <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.MarshallingInformation"/> if available. 
            Since the compiler does only need to know the marshalling type of symbols that aren't emitted 
            PE symbols just decode the type from metadata and don't provide full marshalling information.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.Ordinal">
            <summary>
            Gets the ordinal position of the parameter. The first parameter has ordinal zero.
            The "'this' parameter has ordinal -1.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsParams">
            <summary>
            Returns true if the parameter was declared as a parameter array. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsOptional">
            <summary>
            Returns true if the parameter is semantically optional.
            </summary>
            <remarks>
            True iff the parameter has a default argument syntax, 
            or the parameter is not a params-array and Optional metadata flag is set.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsMetadataOptional">
            <summary>
            True if Optional flag is set in metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsMetadataIn">
            <summary>
            True if In flag is set in metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsMetadataOut">
            <summary>
            True if Out flag is set in metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.HasExplicitDefaultValue">
            <summary>
            Returns true if the parameter explicitly specifies a default value to be passed
            when no value is provided as an argument to a call. 
            </summary>
            <remarks>
            True if the parameter has a default argument syntax, 
            or the parameter is from source and <see cref="T:System.Runtime.InteropServices.DefaultParameterValueAttribute"/> is applied, 
            or the parameter is from metadata and HasDefault metadata flag is set. See
            <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsOptional"/> to determine if the parameter will be considered optional by
            overload resolution.
            
            The default value can be obtained with <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.ExplicitDefaultValue"/> property.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.ExplicitDefaultValue">
            <summary>
            Returns the default value of the parameter. If <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.HasExplicitDefaultValue"/>
            returns false then DefaultValue throws an InvalidOperationException.
            </summary>
            <remarks>
            If the parameter type is a struct and the default value of the parameter
            is the default value of the struct type or of type parameter type which is 
            not known to be a referenced type, then this property will return null.
            </remarks>
            <exception cref="T:System.InvalidOperationException">The parameter has no default value.</exception>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.ExplicitDefaultConstantValue">
            <summary>
            Returns the default value constant of the parameter, 
            or null if the parameter doesn't have a default value or 
            the parameter type is a struct and the default value of the parameter
            is the default value of the struct type or of type parameter type which is 
            not known to be a referenced type.
            </summary>
            <remarks>
            This is used for emitting.  It does not reflect the language semantics
            (i.e. even non-optional parameters can have default values).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the "virtual" modifier. Does not return true for
            members declared as abstract or override.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the "override" modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            "extern" modifier. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.IsThis">
            <summary>
            Returns true if the parameter is the hidden 'this' parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol.HasByRefBeforeCustomModifiers">
            <summary>
            The CLI spec says that custom modifiers must precede the ByRef type code in the encoding of a parameter.
            Unfortunately, the managed C++ compiler emits them in the reverse order.  In order to avoid breaking
            interop scenarios, we need to support such signatures.  When this flag is set, we need to reverse the
            emit order.
            </summary>
            <remarks>
            We support before (correct) and after (incorrect, but works), but not in between.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol">
            <summary>
            Represents a pointer type such as "int *". Pointer types
            are used only in unsafe code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Create a new PointerTypeSymbol.
            </summary>
            <param name="pointedAtType">The type being pointed at.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier})">
            <summary>
            Create a new PointerTypeSymbol.
            </summary>
            <param name="pointedAtType">The type being pointed at.</param>
            <param name="customModifiers">Custom modifiers for the element type of this array type.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol.CustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the pointer type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol.PointedAtType">
            <summary>
            Gets the type of the storage location that an instance of the pointer type points to.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol">
            <summary>
            Represents a property or indexer.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol._lazyParameterSignature">
            <summary>
            As a performance optimization, cache parameter types and refkinds - overload resolution uses them a lot.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.Type">
            <summary>
            The type of the property. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.TypeCustomModifiers">
            <summary>
            The list of custom modifiers, if any, associated with the type of the property. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.Parameters">
            <summary>
            The parameters of this property. If this property has no parameters, returns
            an empty list. Parameters are only present on indexers, or on some properties
            imported from a COM interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.ParameterCount">
            <summary>
            Optimization: in many cases, the parameter count (fast) is sufficient and we
            don't need the actual parameter symbols (slow).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsIndexer">
            <summary>
            Returns whether the property is really an indexer.
            </summary>
            <remarks>
            In source, we regard a property as an indexer if it is declared with an IndexerDeclarationSyntax.
            From metadata, we regard a property if it has parameters and is a default member of the containing
            type.
            CAVEAT: To ensure that this property (and indexer Names) roundtrip, source properties are not
            indexers if they are explicit interface implementations (since they will not be marked as default
            members in metadata).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsIndexedProperty">
            <summary>
            True if this an indexed property; that is, a property with parameters
            within a [ComImport] type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsReadOnly">
            <summary>
            True if this is a read-only property; that is, a property with no set accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsWriteOnly">
            <summary>
            True if this is a write-only property; that is, a property with no get accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.HasSpecialName">
            <summary>
            True if this symbol has a special name (metadata flag SpecialName is set).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.GetMethod">
            <summary>
            The 'get' accessor of the property, or null if the property is write-only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.SetMethod">
            <summary>
            The 'set' accessor of the property, or null if the property is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.OverriddenProperty">
            <summary>
            Returns the overridden property, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.IsExplicitInterfaceImplementation">
            <summary>
            Source: Was the member name qualified with a type name?
            Metadata: Is the member an explicit implementation?
            </summary>
            <remarks>
            Will not always agree with ExplicitInterfaceImplementations.Any()
            (e.g. if binding of the type part of the name fails).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Returns interface properties explicitly implemented by this property.
            </summary>
            <remarks>
            Properties imported from metadata can explicitly implement more than one property.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol">
            <summary>
            Represents a type parameter in a generic type or generic method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.ReducedFrom">
            <summary>
            If this is a type parameter of a reduced extension method, gets the type parameter definition that
            this type parameter was reduced from. Otherwise, returns Nothing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.Ordinal">
            <summary>
            The ordinal position of the type parameter in the parameter list which declares
            it. The first type parameter has ordinal zero.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.ConstraintTypes">
            <summary>
            The types that were directly specified as constraints on the type parameter.
            Duplicates and cycles are removed, although the collection may include
            redundant constraints where one constraint is a base type of another.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.HasConstructorConstraint">
            <summary>
            True if the parameterless constructor constraint was specified for the type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.TypeParameterKind">
            <summary>
            The type parameter kind of this type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.DeclaringMethod">
            <summary>
            The method that declared this type parameter, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.DeclaringType">
            <summary>
            The type that declared this type parameter, or null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.EffectiveBaseClassNoUseSiteDiagnostics">
            <summary>
            The effective base class of the type parameter (spec 10.1.5). If the deduced
            base type is a reference type, the effective base type will be the same as
            the deduced base type. Otherwise if the deduced base type is a value type,
            the effective base type will be the most derived reference type from which
            deduced base type is derived.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.EffectiveInterfacesNoUseSiteDiagnostics">
            <summary>
            The effective interface set (spec 10.1.5).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.DeducedBaseTypeNoUseSiteDiagnostics">
            <summary>
            The most encompassed type (spec 6.4.2) from the constraints.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.AllEffectiveInterfacesNoUseSiteDiagnostics">
            <summary>
            The effective interface set and any base interfaces of those
            interfaces. This is AllInterfaces excluding interfaces that are
            only implemented by the effective base type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.EnsureAllConstraintsAreResolved">
            <summary>
            Called by <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.ConstraintTypesNoUseSiteDiagnostics"/>, <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.InterfacesNoUseSiteDiagnostics(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol})"/>, <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.EffectiveBaseClass(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)"/>, and <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.DeducedBaseType(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)"/>.
            to allow derived classes to ensure constraints within the containing
            type or method are resolved in a consistent order, regardless of the
            order the callers query individual type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.EnsureAllConstraintsAreResolved(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol})">
            <summary>
            Helper method to force type parameter constraints to be resolved.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedStateMachineProperty">
            <summary>
            State machine interface property implementation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedMethodBaseSymbol">
            <summary>
            A base method symbol used as a base class for lambda method symbol and base method wrapper symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap">
            <summary>
            Abstract base class for mutable and immutable type maps.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteMemberType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Substitute for a type declaration.  May use alpha renaming if the container is substituted.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            SubstType, but for NamedTypeSymbols only.  This is used for concrete types, so no alpha substitution appears in the result.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Perform the substitution on the given type.  Each occurrence of the type parameter is
            replaced with its corresponding type argument from the map.
            </summary>
            <param name="previous">The type to be rewritten.</param>
            <returns>The type with type parameters replaced with the type arguments.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteTypesDistinct(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Substitute types, and return the results without duplicates, preserving the original order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteNamedTypes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol})">
            <summary>
            Like SubstTypes, but for NamedTypeSymbols.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol">
            <summary>
            Symbol representing a using alias appearing in a compilation unit or within a namespace
            declaration. Generally speaking, these symbols do not appear in the set of symbols reachable
            from the unnamed namespace declaration.  In other words, when a using alias is used in a
            program, it acts as a transparent alias, and the symbol to which it is an alias is used in
            the symbol table.  For example, in the source code
            <pre>
            namespace NS
            {
                using o = System.Object;
                partial class C : o {}
                partial class C : object {}
                partial class C : System.Object {}
            }
            </pre>
            all three declarations for class C are equivalent and result in the same symbol table object
            for C. However, these using alias symbols do appear in the results of certain SemanticModel
            APIs. Specifically, for the base clause of the first of C's class declarations, the
            following APIs may produce a result that contains an AliasSymbol:
            <pre>
                SemanticInfo SemanticModel.GetSemanticInfo(ExpressionSyntax expression);
                SemanticInfo SemanticModel.BindExpression(CSharpSyntaxNode location, ExpressionSyntax expression);
                SemanticInfo SemanticModel.BindType(CSharpSyntaxNode location, ExpressionSyntax type);
                SemanticInfo SemanticModel.BindNamespaceOrType(CSharpSyntaxNode location, ExpressionSyntax type);
            </pre>
            Also, the following are affected if container==null (and, for the latter, when arity==null
            or arity==0):
            <pre>
                IList&lt;string&gt; SemanticModel.LookupNames(CSharpSyntaxNode location, NamespaceOrTypeSymbol container = null, LookupOptions options = LookupOptions.Default, List&lt;string> result = null);
                IList&lt;Symbol&gt; SemanticModel.LookupSymbols(CSharpSyntaxNode location, NamespaceOrTypeSymbol container = null, string name = null, int? arity = null, LookupOptions options = LookupOptions.Default, List&lt;Symbol> results = null);
            </pre>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol.Target">
            <summary>
            Gets the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol"/> for the
            namespace or type referenced by the alias.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol.ContainingSymbol">
            <summary>
            Using aliases in C# are always contained within a namespace declaration, or at the top
            level within a compilation unit, within the implicit unnamed namespace declaration.  We
            return that as the "containing" symbol, even though the alias isn't a member of the
            namespace as such.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor">
            <summary>
            Describes anonymous type in terms of fields
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.Location">
            <summary> Anonymous type location </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.Fields">
            <summary> Anonymous type fields </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.Key">
            <summary>
            Anonymous type descriptor Key 
            
            The key is to be used to separate anonymous type templates in an anonymous type symbol cache. 
            The type descriptors with the same keys are supposed to map to 'the same' anonymous type 
            template in terms of the same generic type being used for their implementation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.Equals(Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor,System.Boolean,System.Boolean)">
            <summary>
            Compares two anonymous type descriptors, takes into account fields names and types, not locations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.Equals(System.Object)">
            <summary>
            Compares two anonymous type descriptorss, takes into account fields names and types, not locations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeDescriptor.WithNewFieldsTypes(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Creates a new anonymous type descriptor based on 'this' one, 
            but having field types passed as an argument.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeField">
            <summary>
            Describes anonymous type field in terms of its name, type and other attributes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeField.Name">
            <summary>Anonymous type field name, not nothing and not empty</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeField.Location">
            <summary>Anonymous type field location</summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AnonymousTypeField.Type">
            <summary>Anonymous type field type</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol">
            <summary>
            Represents a .NET assembly, consisting of one or more modules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol._corLibrary">
            <summary>
            The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. 
            The value is provided by ReferenceManager and must not be modified. For SourceAssemblySymbol, non-missing 
            coreLibrary must match one of the referenced assemblies returned by GetReferencedAssemblySymbols() method of 
            the main module. If there is no existing assembly that can be used as a source for the primitive types, 
            the value is a Compilation.MissingCorLibrary. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.CorLibrary">
            <summary>
            The system assembly, which provides primitive types like Object, String, etc., e.g. mscorlib.dll. 
            The value is MissingAssemblySymbol if none of the referenced assemblies can be used as a source for the 
            primitive types and the owning assembly cannot be used as the source too. Otherwise, it is one of 
            the referenced assemblies returned by GetReferencedAssemblySymbols() method or the owning assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.SetCorLibrary(Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <summary>
            A helper method for ReferenceManager to set the system assembly, which provides primitive 
            types like Object, String, etc., e.g. mscorlib.dll. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Name">
            <summary>
            Simple name the assembly.
            </summary>
            <remarks>
            This is equivalent to <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Identity"/>.<see cref="P:Microsoft.CodeAnalysis.AssemblyIdentity.Name"/>, but may be 
            much faster to retrieve for source code assemblies, since it does not require binding
            the assembly-level attributes that contain the version number and other assembly
            information.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Identity">
            <summary>
            Gets the identity of this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Machine">
            <summary>
            Target architecture of the machine.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Bit32Required">
            <summary>
            Indicates that this PE file makes Win32 calls. See CorPEKind.pe32BitRequired for more information (http://msdn.microsoft.com/en-us/library/ms230275.aspx).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GlobalNamespace">
            <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetAssemblyNamespace(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol)">
            <summary>
            Given a namespace symbol, returns the corresponding assembly specific namespace symbol
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.Modules">
            <summary>
            Gets a read-only list of all the modules in this assembly. (There must be at least one.) The first one is the main module
            that holds the assembly manifest.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.IsMissing">
            <summary>
            Does this symbol represent a missing assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.IsInteractive">
            <summary>
            True if the assembly contains interactive code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name with generic name mangling.
            </param>
            <param name="digThroughForwardedTypes">
            Take forwarded types into account.
            </param>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.LookupTopLevelMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol},System.Boolean)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.  Detect cycles during lookup.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <param name="visitedAssemblies">
            List of assemblies lookup has already visited (since type forwarding can introduce cycles).
            </param>
            <param name="digThroughForwardedTypes">
            Take forwarded types into account.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.ResolveForwardedType(System.String)">
            <summary>
            Returns the type symbol for a forwarded type based its canonical CLR metadata name.
            The name should refer to a non-nested type. If type with this name is not forwarded,
            null is returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.TryLookupForwardedMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Look up the given metadata type, if it is forwarded.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.TryLookupForwardedMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol})">
            <summary>
            Look up the given metadata type, if it is forwarded.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.RegisterDeclaredSpecialType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Register declaration of predefined CorLib type in this Assembly.
            </summary>
            <param name="corType"></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.KeepLookingForDeclaredSpecialTypes">
            <summary>
            Continue looking for declaration of predefined CorLib type in this Assembly
            while symbols for new type declarations are constructed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetNoPiaResolutionAssemblies">
            <summary>
            Return an array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by previous compilation referencing this assembly.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetLinkedReferencedAssemblies">
            <summary>
            Return an array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.IsLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetGuidString(System.String@)">
            <summary>
            Returns true and a string from the first GuidAttribute on the assembly, 
            the string might be null or an invalid guid representation. False, 
            if there is no GuidAttribute with string argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.TypeNames">
            <summary>
            Gets the set of type identifiers from this assembly.
            </summary>
            <remarks>
            These names are the simple identifiers for the type, and do not include namespaces,
            outer type names, or type parameters.
            
            This functionality can be used for features that want to quickly know if a name could be
            a type for performance reasons.  For example, classification does not want to incur an
            expensive binding call cost if it knows that there is no type with the name that they
            are looking at.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.NamespaceNames">
            <summary>
            Gets the set of namespace names from this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.MightContainExtensionMethods">
            <summary>
            Returns true if this assembly might contain extension methods. If this property
            returns false, there are no extension methods in this assembly.
            </summary>
            <remarks>
            This property allows the search for extension methods to be narrowed quickly.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Gets the symbol for the pre-defined type from core library associated with this assembly.
            </summary>
            <returns>The symbol for the pre-defined type or null if the type is not defined in the core library.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.ObjectType">
            <summary>
            The NamedTypeSymbol for the .NET System.Object type, which could have a TypeKind of
            Error if there was no COR Library in a compilation using the assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetPrimitiveType(Microsoft.Cci.PrimitiveTypeCode)">
            <summary>
            Get symbol for predefined type from Cor Library used by this assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetTypeByMetadataName(System.String)">
            <summary>
            Lookup a type within the assembly using the canonical CLR metadata name of the type.
            </summary>
            <param name="fullyQualifiedMetadataName">Type name.</param>
            <returns>Symbol for the type or null if type cannot be found or is ambiguous. </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetTypeByMetadataName(System.String,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Lookup a type within the assembly using its canonical CLR metadata name.
            </summary>
            <param name="metadataName"></param>
            <param name="includeReferences">
            If search within assembly fails, lookup in assemblies referenced by the primary module.
            For source assembly, this is equivalent to all assembly references given to compilation.
            </param>
            <param name="isWellKnownType">
            Extra restrictions apply when searching for a well-known type.  In particular, the type must be public.
            </param>
            <param name="useCLSCompliantNameArityEncoding">
            While resolving the name, consider only types following CLS-compliant generic type names and arity encoding (ECMA-335, section 10.7.2).
            I.e. arity is inferred from the name and matching type must have the same emitted name and arity.
            </param>
            <param name="warnings">
            A diagnostic bag to receive warnings if we should allow multiple definitions and pick one.
            </param>
            <returns>Null if the type can't be found.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetTypeByReflectionType(System.Type,System.Boolean)">
            <summary>
            Resolves <see cref="T:System.Type"/> to a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol"/> available in this assembly
            its referenced assemblies.
            </summary>
            <param name="type">The type to resolve.</param>
            <param name="includeReferences">Use referenced assemblies for resolution.</param>
            <returns>The resolved symbol if successful or null on failure.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetUnaliasedReferencedAssemblies">
            <summary>
            Return a list of assembly symbols than can be accessed without using an alias.
            For example:
              1) /r:A.dll /r:B.dll -> A, B
              2) /r:Foo=A.dll /r:B.dll -> B
              3) /r:Foo=A.dll /r:A.dll -> A
              
            Note that it only makes sense to call this method on a SourceAssemblySymbol since
            alias information is per-compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetDeclaredSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
            assembly is the Cor Library
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol.GetSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type used by this Assembly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAttributeData">
            <summary>
            Represents a PE custom attribute
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAttributeData.IsTargetAttribute(System.String,System.String)">
            <summary>
            Matches an attribute by metadata namespace, metadata type name. Does not load the type symbol for
            the attribute.
            </summary>
            <param name="namespaceName"></param>
            <param name="typeName"></param>
            <returns>True if the attribute data matches.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAttributeData.GetTargetAttributeSignatureIndex(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Matches an attribute by metadata namespace, metadata type name and metadata signature. Does not load the
            type symbol for the attribute.
            </summary>
            <param name="targetSymbol">Target symbol.</param>
            <param name="description">Attribute to match.</param>
            <returns>
            An index of the target constructor signature in
            signatures array, -1 if
            this is not the target attribute.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder">
            <summary>
            Decodes <see cref="T:System.Runtime.CompilerServices.DynamicAttribute"/> applied to a specified metadata symbol and
            transforms the specified metadata type, using the decoded dynamic transforms attribute argument,
            by replacing each occurrence of <see cref="T:System.Object"/> type with dynamic type.
            </summary>
            <remarks>
            This is a port of TypeManager::ImportDynamicTransformType from the native compiler.
            Comments from the C# design document for Dynamic:
            SPEC:   To represent the dynamic type in metadata, any indexer, field or return value typed as dynamic or known to be a constructed type
            SPEC:   containing dynamic will have each occurrence of dynamic erased to object and will be annotated with a [DynamicAttribute].
            SPEC:   If the relevant type is a constructed type, the attribute’s constructor is passed a bool array.
            SPEC:   This array represents a preorder traversal of each “node” in the constructed type’s “tree of types”,
            SPEC:   with true set for each “node” that is dynamic, and false set for all other types.
            SPEC:   When dynamic occurs as part of the base type of a type, the applicable [DynamicAttribute] is applied to the type itself.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder._index">
            <remarks>
            Should be accessed through <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.HasFlag"/>, <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.PeekFlag"/>, and <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.ConsumeFlag"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.DynamicTypeDecoder.TransformType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Int32,System.Reflection.Metadata.EntityHandle,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol,Microsoft.CodeAnalysis.RefKind)">
            <summary>
            Decodes the attributes applied to the given <see paramref="targetSymbol"/> from metadata and checks if <see cref="T:System.Runtime.CompilerServices.DynamicAttribute"/> is applied.
            If so, it transforms the given <see paramref="metadataType"/>, using the decoded dynamic transforms attribute argument,
            by replacing each occurrence of <see cref="T:System.Object"/> type with dynamic type.
            If no <see cref="T:System.Runtime.CompilerServices.DynamicAttribute"/> is applied or the decoded dynamic transforms attribute argument is errorneous,
            returns the unchanged <see paramref="metadataType"/>.
            </summary>
            <remarks>This method is a port of TypeManager::ImportDynamicTransformType from the native compiler.</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder">
            <summary>
            This subclass of MetadataDecoder is specifically for finding
            method symbols corresponding to method MemberRefs.  The parent 
            implementation is unsuitable because it requires a PEMethodSymbol
            for context when decoding method type parameters and no such
            context is available because it is precisely what we are trying
            to find.  Since we know in advance that there will be no context
            and that signatures decoded with this class will only be used
            for comparison (when searching through the methods of a known
            TypeSymbol), we can return indexed type parameters instead.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder._containingType">
            <summary>
            Type context for resolving generic type arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder.GetGenericMethodTypeParamSymbol(System.Int32)">
            <summary>
            We know that we'll never have a method context because that's what we're
            trying to find.  Instead, just return an indexed type parameter that will
            make comparison easier.
            </summary>
            <param name="position"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder.GetGenericTypeParamSymbol(System.Int32)">
            <summary>
            This override changes two things:
                1) Return type arguments instead of type parameters.
                2) Handle non-PE types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MemberRefMetadataDecoder.FindMember(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Reflection.Metadata.MemberReferenceHandle,System.Boolean)">
            <summary>
            Search through the members of a given type symbol to find the method that matches a particular
            signature.
            </summary>
            <param name="targetTypeSymbol">Type containing the desired method symbol.</param>
            <param name="memberRef">A MemberRef handle that can be used to obtain the name and signature of the method</param>
            <param name="methodsOnly">True to only return a method.</param>
            <returns>The matching method symbol, or null if the inputs do not correspond to a valid method.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder">
            <summary>
            Helper class to resolve metadata tokens and signatures.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder._typeContextOpt">
            <summary>
            Type context for resolving generic type arguments.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder._methodContextOpt">
            <summary>
            Method context for resolving generic method type arguments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.Int32,Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a type defined in referenced assembly.
            </summary>
            <param name="referencedAssemblyIndex"></param>
            <param name="emittedName"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(System.String,Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean@)">
            <summary>
            Lookup a type defined in a module of a multi-module assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder.LookupTopLevelTypeDefSymbol(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean@)">
            <summary>
            Lookup a type defined in this module.
            This method will be called only if the type we are
            looking for hasn't been loaded yet. Otherwise, MetadataDecoder
            would have found the type in TypeDefRowIdToTypeMap based on its 
            TypeDef row id. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder.IsOrClosedOverATypeFromAssemblies(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol})">
            <summary>
            Perform a check whether the type or at least one of its generic arguments 
            is defined in the specified assemblies. The check is performed recursively. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder.SubstituteNoPiaLocalType(Microsoft.CodeAnalysis.MetadataTypeName@,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.String,System.String,System.String,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <summary>
            Find canonical type for NoPia embedded type.
            </summary>
            <returns>
            Symbol for the canonical type or an ErrorTypeSymbol. Never returns null.
            </returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol">
            <summary>
            Represents an assembly imported from a PE.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._assembly">
            <summary>
            An Assembly object providing metadata for the assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._documentationProvider">
            <summary>
            A DocumentationProvider that provides XML documentation comments for this assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._modules">
            <summary>
            The list of contained PEModuleSymbol objects.
            The list doesn't use type ReadOnlyCollection(Of PEModuleSymbol) so that we
            can return it from Modules property as is.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._noPiaResolutionAssemblies">
            <summary>
            An array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by a compilation referencing this assembly.
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._linkedReferencedAssemblies">
            <summary>
            An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._isLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol._lazyCustomAttributes">
            <summary>
            Assembly's custom attributes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEAssemblySymbol.LookupAssemblyForForwardedMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Look up the assembly to which the given metadata type is forwarded.
            </summary>
            <param name="emittedName"></param>
            <returns>
            The assembly to which the given type is forwarded or null, if there isn't one.
            </returns>
            <remarks>
            The returned assembly may also forward the type.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEEventSymbol">
            <summary>
            The class to represent all events imported from a PE/module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEEventSymbol.GetAssociatedField(Roslyn.Utilities.MultiDictionary{System.String,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEFieldSymbol},System.Boolean)">
            <summary>
            Look for a field with the same name and an appropriate type (i.e. the same type, except in WinRT).
            If one is found, the caller will assume that this event was originally field-like and associate
            the two symbols.
            </summary>
            <remarks>
            Perf impact: If we find a field with the same name, we will eagerly evaluate its type.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEEventSymbol.ExplicitInterfaceImplementations">
            <summary>
            Intended behavior: this event, E, explicitly implements an interface event, IE, 
            if E.add explicitly implements IE.add and E.remove explicitly implements IE.remove.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEFieldSymbol">
            <summary>
            The class to represent all fields imported from a PE/module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEFieldSymbol.SetAssociatedEvent(Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEEventSymbol)">
            <summary>
            Mark this field as the backing field of a field-like event.
            The caller will also ensure that it is excluded from the member list of
            the containing type (as it would be in source).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEGlobalNamespaceSymbol._moduleSymbol">
            <summary>
            The module containing the namespace.
            </summary>
            <remarks></remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol">
            <summary>
            The class to represent all methods imported from a PE/module.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol.UncommonFields">
            <summary>
            Holds infrequently accessed fields. See <seealso cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields"/> for an explanation.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields">
            <summary>
            A single field to hold optional auxiliary data.
            In many scenarios it is possible to avoid allocating this, thus saving total space in <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol"/>.
            Even for lazily-computed values, it may be possible to avoid allocating <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields"/> if
            the computed value is a well-known "empty" value. In this case, bits in <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol._packedFlags"/> are used
            to indicate that the lazy values have been computed and, if <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol._uncommonFields"/> is null, then
            the "empty" value should be inferred.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol.SetAssociatedProperty(Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol,Microsoft.CodeAnalysis.MethodKind)">
            <summary>
            Associate the method with a particular property. Returns
            false if the method is already associated with a property or event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEMethodSymbol.SetAssociatedEvent(Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEEventSymbol,Microsoft.CodeAnalysis.MethodKind)">
            <summary>
            Associate the method with a particular event. Returns
            false if the method is already associated with a property or event.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol">
            <summary>
            Represents a net-module imported from a PE. Can be a primary module of an assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._assemblySymbol">
            <summary>
            Owning AssemblySymbol. This can be a PEAssemblySymbol or a SourceAssemblySymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._module">
            <summary>
            A Module object providing metadata.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._globalNamespace">
            <summary>
            Global namespace.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._lazySystemTypeSymbol">
            <summary>
            Cache the symbol for well-known type System.Type because we use it frequently
            (for attributes).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.DefaultTypeMapCapacity">
            <summary>
            The same value as ConcurrentDictionary.DEFAULT_CAPACITY
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.TypeHandleToTypeMap">
            <summary>
            This is a map from TypeDef handle to the target <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol"/>. 
            It is used by <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder"/> to speed up type reference resolution
            for metadata coming from this module. The map is lazily populated
            as we load types from the module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.TypeRefHandleToTypeMap">
            <summary>
            This is a map from TypeRef row id to the target <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol"/>. 
            It is used by <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder"/> to speed up type reference resolution
            for metadata coming from this module. The map is lazily populated
            by <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.MetadataDecoder"/> as we resolve TypeRefs from the module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._lazyCustomAttributes">
            <summary>
            Module's custom attributes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol._lazyAssemblyAttributes">
            <summary>
            Module's assembly attributes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.GetCustomAttributesForToken(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.CustomAttributeHandle@,Microsoft.CodeAnalysis.AttributeDescription,System.Reflection.Metadata.CustomAttributeHandle@,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            Returns a possibly ExtensionAttribute filtered roArray of attributes. If
            filterExtensionAttributes is set to true, the method will remove all ExtensionAttributes
            from the returned array. If it is false, the parameter foundExtension will always be set to
            false and can be safely ignored.
            
            The paramArrayAttribute parameter is similar to the foundExtension parameter, but instead
            of just indicating if the attribute was found, the parameter is set to the attribute handle
            for the ParamArrayAttribute if any is found and is null otherwise. This allows NoPia to filter
            the attribute out for the symbol but still cache it separately for emit.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.GetCustomAttributesForToken(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.CustomAttributeHandle@)">
            <summary>
            Get the custom attributes, but filter out any ParamArrayAttributes.
            </summary>
            <param name="token">The parameter token handle.</param>
            <param name="paramArrayAttribute">Set to a ParamArrayAttribute</param>
            CustomAttributeHandle if any are found. Nil token otherwise.
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.GetCustomAttributesFilterExtensions(System.Reflection.Metadata.EntityHandle,System.Boolean@)">
            <summary>
            Filters extension attributes from the attribute results.
            </summary>
            <param name="token"></param>
            <param name="foundExtension">True if we found an extension method, false otherwise.</param>
            <returns>The attributes on the token, minus any ExtensionAttributes.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol.GetAssemblyForForwardedType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            If this module forwards the given type to another assembly, return that assembly;
            otherwise, return null.
            </summary>
            <param name="fullName">Type to look up.</param>
            <returns>Assembly symbol or null.</returns>
            <remarks>
            The returned assembly may also forward the type.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol">
            <summary>
            The class to represent all types imported from a PE/module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol._lazyMemberNames">
            <summary>
            A set of all the names of the members in this type.
            We can get names without getting members (which is a more expensive operation)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol._lazyMembersInDeclarationOrder">
            <summary>
            We used to sort symbols on demand and relied on row ids to figure out the order between symbols of the same kind.
            However, that was fragile because, when map tables are used in metadata, row ids in the map table define the order
            and we don't have them.
            Members are grouped by kind. First we store fields, then methods, then properties, then events and finally nested types.
            Within groups, members are sorted based on declaration order.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol._lazyMembersByName">
            <summary>
            A map of members immediately contained within this type 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol._lazyNestedTypes">
            <summary>
            A map of types immediately contained within this type 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol._lazyKind">
            <summary>
            Lazily initialized by TypeKind property.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.UncommonProperties.lazyInstanceEnumFields">
            <summary>
            Need to import them for an enum from a linked assembly, when we are embedding it. These symbols are not included into lazyMembersInDeclarationOrder.  
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.GetIndexOfFirstMember(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.SymbolKind)">
            <summary>
            Returns the index of the first member of the specific kind.
            Returns the number of members if not found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.GetMembers``1(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.SymbolKind,System.Int32)">
            <summary>
            Returns all members of the specific kind, starting at the optional offset.
            Members of the same kind are assumed to be contiguous.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.PENamedTypeSymbolNonGeneric">
            <summary>
            Specialized PENamedTypeSymbol for types with no type parameters in
            metadata (no type parameters on this type and all containing types).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.PENamedTypeSymbolGeneric">
            <summary>
            Specialized PENamedTypeSymbol for types with type parameters in metadata.
            NOTE: the type may have Arity == 0 if it has same metadata arity as the metadata arity of the containing type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamedTypeSymbol.PENamedTypeSymbolGeneric.MatchesContainingTypeParameters">
            <summary>
            Return true if the type parameters specified on the nested type (this),
            that represent the corresponding type parameters on the containing
            types, in fact match the actual type parameters on the containing types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol">
            <summary>
            The base class to represent a namespace imported from a PE/module. Namespaces that differ
            only by casing in name are not merged.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.lazyNamespaces">
            <summary>
            A map of namespaces immediately contained within this namespace 
            mapped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.lazyTypes">
            <summary>
            A map of types immediately contained within this namespace 
            grouped by their name (case-sensitively).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol._lazyNoPiaLocalTypes">
            <summary>
            A map of NoPia local types immediately contained in this assembly.
            Maps type name (non-qualified) to the row id. Note, for VB we should use
            full name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol._lazyFlattenedTypes">
            <summary>
            All type members in a flat array
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.ContainingPEModule">
            <summary>
            Returns PEModuleSymbol containing the namespace.
            </summary>
            <returns>PEModuleSymbol containing the namespace.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.LoadAllMembers(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}})">
            <summary>
            Initializes namespaces and types maps with information about 
            namespaces and types immediately contained within this namespace.
            </summary>
            <param name="typesByNS">
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids must be grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups must be sorted by
            their key in case-sensitive manner. Empty string must be used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            must be in several first IGroupings.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.LazyInitializeNamespaces(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}}}})">
            <summary>
            Create symbols for nested namespaces and initialize namespaces map.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol.LazyInitializeTypes(System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}})">
            <summary>
            Create symbols for nested types and initialize types map.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENestedNamespaceSymbol">
            <summary>
            The class to represent all, but Global, namespaces imported from a PE/module.
            Namespaces that differ only by casing in name are not merged.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENestedNamespaceSymbol._containingNamespaceSymbol">
            <summary>
            The parent namespace. There is always one, Global namespace contains all
            top level namespaces. 
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENestedNamespaceSymbol._name">
            <summary>
            The name of the namespace.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENestedNamespaceSymbol._typesByNS">
            <summary>
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids are grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups are sorted by their 
            key in case-sensitive manner. Empty string is used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            will be in several first IGroupings.
            
            This member is initialized by constructor and is cleared in EnsureAllMembersLoaded 
            as soon as symbols for children are created.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENestedNamespaceSymbol.#ctor(System.String,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PENamespaceSymbol,System.Collections.Generic.IEnumerable{System.Linq.IGrouping{System.String,System.Reflection.Metadata.TypeDefinitionHandle}})">
            <summary>
            Constructor.
            </summary>
            <param name="name">
            Name of the namespace, must be not empty.
            </param>
            <param name="containingNamespace">
            Containing namespace.
            </param>
            <param name="typesByNS">
            The sequence of groups of TypeDef row ids for types contained within the namespace, 
            recursively including those from nested namespaces. The row ids are grouped by the 
            fully-qualified namespace name case-sensitively. There could be multiple groups 
            for each fully-qualified namespace name. The groups are sorted by their 
            key in case-sensitive manner. Empty string is used as namespace name for types 
            immediately contained within Global namespace. Therefore, all types in this namespace, if any, 
            will be in several first IGroupings.
            </param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol">
            <summary>
            The class to represent all method parameters imported from a PE/module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol._lazyHiddenAttributes">
            <summary>
            Attributes filtered out from m_lazyCustomAttributes, ParamArray, etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol,System.Int32,System.Reflection.Metadata.ParameterHandle,Microsoft.CodeAnalysis.ParamInfo{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},System.Boolean@)">
            <summary>
            Construct a parameter symbol for a property loaded from metadata.
            </summary>
            <param name="moduleSymbol"></param>
            <param name="containingSymbol"></param>
            <param name="ordinal"></param>
            <param name="handle">The property parameter doesn't have a name in metadata,
            so this is the handle of a corresponding accessor parameter, if there is one,
            or of the ParamInfo passed in, otherwise).</param>
            <param name="isBad" />
            <param name="parameter"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol.ImportConstantValue(System.Boolean)">
            <remarks>
            Internal for testing.  Non-test code should use <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEParameterSymbol.ExplicitDefaultConstantValue"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol">
            <summary>
            The class to represent all properties imported from a PE/module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol.Name">
            <remarks>
            To facilitate lookup, all indexer symbols have the same name.
            Check the MetadataName property to find the name we imported.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol.IsIndexer">
            <remarks>
            This property can return true for bogus indexers.
            Rationale: If a type in metadata has a single, bogus indexer
            and a source method tries to invoke it, then Dev10 reports a bogus
            indexer rather than lack of an indexer.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEPropertySymbol.ExplicitInterfaceImplementations">
            <summary>
            Intended behavior: this property, P, explicitly implements an interface property, IP, 
            if any of the following is true:
            
            1) P.get explicitly implements IP.get and P.set explicitly implements IP.set
            2) P.get explicitly implements IP.get and there is no IP.set
            3) P.set explicitly implements IP.set and there is no IP.get
            
            Extra or missing accessors will not result in errors, P will simply not report that
            it explicitly implements IP.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PETypeParameterSymbol">
            <summary>
            The class to represent all generic type parameters imported from a PE/module.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PETypeParameterSymbol._lazyBoundsErrorInfo">
            <summary>
            First error calculating bounds.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAttributeData">
            <summary>
            Represents a retargeting custom attribute
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAttributeData.GetSystemType(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Gets the retargeted System.Type type symbol.
            </summary>
            <param name="targetSymbol">Target symbol on which this attribute is applied.</param>
            <returns>Retargeted System.Type type symbol.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol">
            <summary>
            Essentially this is a wrapper around another AssemblySymbol that is responsible for retargeting
            symbols from one assembly to another. It can retarget symbols for multiple assemblies at the same time. 
            
            For example, compilation C1 references v1 of Lib.dll and compilation C2 references C1 and v2 of Lib.dll. 
            In this case, in context of C2, all types from v1 of Lib.dll leaking through C1 (through method 
            signatures, etc.) must be retargeted to the types from v2 of Lib.dll. This is what 
            RetargetingAssemblySymbol is responsible for. In the example above, modules in C2 do not 
            reference C1.m_AssemblySymbol, but reference a special RetargetingAssemblySymbol created for 
            C1 by ReferenceManager.
            
            Here is how retargeting is implemented in general:
            - Symbols from underlying assembly are substituted with retargeting symbols.
            - Symbols from referenced assemblies that can be reused as is (i.e. doesn't have to be retargeted) are
              used as is.
            - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._underlyingAssembly">
            <summary>
            The underlying AssemblySymbol, it leaks symbols that should be retargeted.
            This cannot be an instance of RetargetingAssemblySymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._modules">
            <summary>
            The list of contained ModuleSymbol objects. First item in the list
            is RetargetingModuleSymbol that wraps corresponding SourceModuleSymbol 
            from underlyingAssembly.Modules list, the rest are PEModuleSymbols for 
            added modules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._noPiaResolutionAssemblies">
            <summary>
            An array of assemblies involved in canonical type resolution of
            NoPia local types defined within this assembly. In other words, all 
            references used by a compilation referencing this assembly.
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._linkedReferencedAssemblies">
            <summary>
            An array of assemblies referenced by this assembly, which are linked (/l-ed) by 
            each compilation that is using this AssemblySymbol as a reference. 
            If this AssemblySymbol is linked too, it will be in this array too.
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._noPiaUnificationMap">
            <summary>
            Backing field for the map from a local NoPia type to corresponding canonical type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol.NoPiaUnificationMap">
            <summary>
            A map from a local NoPia type to corresponding canonical type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._isLinked">
            <summary>
            Assembly is /l-ed by compilation that is using it as a reference.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol,System.Boolean)">
            <summary>
            Constructor.
            </summary>
            <param name="underlyingAssembly">
            The underlying AssemblySymbol, cannot be an instance of RetargetingAssemblySymbol.
            </param>
            <param name="isLinked">
            Assembly is /l-ed by compilation that is using it as a reference.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol.UnderlyingAssembly">
            <summary>
            The underlying AssemblySymbol.
            This cannot be an instance of RetargetingAssemblySymbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Lookup declaration for FX type in this Assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingEventSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingEventSymbol._underlyingEvent">
            <summary>
            The underlying EventSymbol, cannot be another RetargetingEventSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingFieldSymbol">
            <summary>
            Represents a field in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another FieldSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingFieldSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingFieldSymbol._underlyingField">
            <summary>
            The underlying FieldSymbol, cannot be another RetargetingFieldSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingFieldSymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol">
            <summary>
            Represents a method in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another MethodSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol._underlyingMethod">
            <summary>
            The underlying MethodSymbol, cannot be another RetargetingMethodSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodSymbol._lazyReturnTypeCustomAttributes">
            <summary>
            Retargeted return type custom attributes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol">
            <summary>
            Represents a primary module of a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol"/>. Essentially this is a wrapper around 
            another <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol"/> that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            
            Here is how retargeting is implemented in general:
            - Symbols from underlying module are substituted with retargeting symbols.
            - Symbols from referenced assemblies that can be reused as is (i.e. don't have to be retargeted) are
              used as is.
            - Symbols from referenced assemblies that must be retargeted are substituted with result of retargeting.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol._retargetingAssembly">
            <summary>
            Owning <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol._underlyingModule">
            <summary>
            The underlying <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol"/>, cannot be another <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol._retargetingAssemblyMap">
            <summary>
            The map that captures information about what assembly should be retargeted 
            to what assembly. Key is the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> referenced by the underlying module,
            value is the corresponding <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> referenced by this module, and corresponding
            retargeting map for symbols.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingAssemblySymbol,Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol)">
            <summary>
            Constructor.
            </summary>
            <param name="retargetingAssembly">
            Owning assembly.
            </param>
            <param name="underlyingModule">
            The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.UnderlyingModule">
            <summary>
            The underlying ModuleSymbol, cannot be another RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.SetReferences(Microsoft.CodeAnalysis.ModuleReferences{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol},Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol)">
            <summary>
            A helper method for ReferenceManager to set AssemblySymbols for assemblies 
            referenced by this module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol._symbolMap">
            <summary>
            Retargeting map from underlying module to this one.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.SymbolMap">
            <summary>
            Retargeting map from underlying module to the retargeting module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.RetargetingAssembly">
            <summary>
            RetargetingAssemblySymbol owning retargetingModule.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.UnderlyingModule">
            <summary>
            The underlying ModuleSymbol for retargetingModule.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.RetargetingAssemblyMap">
            <summary>
            The map that captures information about what assembly should be retargeted 
            to what assembly. Key is the AssemblySymbol referenced by the underlying module,
            value is the corresponding AssemblySymbol referenced by the reatergeting module, and 
            corresponding retargeting map for symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingModuleSymbol.RetargetingSymbolTranslator.IsOrClosedOverAnExplicitLocalType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Perform a check whether the type or at least one of its generic arguments 
            is an explicitly defined local type. The check is performed recursively. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamedTypeSymbol">
            <summary>
            Represents a type of a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another NamedTypeSymbol that is responsible for retargeting referenced symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamedTypeSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamedTypeSymbol._underlyingType">
            <summary>
            The underlying NamedTypeSymbol, cannot be another RetargetingNamedTypeSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamespaceSymbol">
            <summary>
            Represents a namespace of a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another NamespaceSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamespaceSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingNamespaceSymbol._underlyingNamespace">
            <summary>
            The underlying NamespaceSymbol, cannot be another RetargetingNamespaceSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingParameterSymbol">
            <summary>
            Represents a parameter of a RetargetingMethodSymbol. Essentially this is a wrapper around 
            another ParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingParameterSymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingMethodParameterSymbol._retargetingMethod">
            <summary>
            Owning RetargetingMethodSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingPropertyParameterSymbol._retargetingProperty">
            <summary>
            Owning RetargetingPropertySymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingPropertySymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingPropertySymbol._underlyingProperty">
            <summary>
            The underlying PropertySymbol, cannot be another RetargetingPropertySymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingPropertySymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingTypeParameterSymbol">
            <summary>
            Represents a type parameter in a RetargetingModuleSymbol. Essentially this is a wrapper around 
            another TypeParameterSymbol that is responsible for retargeting symbols from one assembly to another. 
            It can retarget symbols for multiple assemblies at the same time.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingTypeParameterSymbol._retargetingModule">
            <summary>
            Owning RetargetingModuleSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingTypeParameterSymbol._underlyingTypeParameter">
            <summary>
            The underlying TypeParameterSymbol, cannot be another RetargetingTypeParameterSymbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.Retargeting.RetargetingTypeParameterSymbol._lazyCustomAttributes">
            <summary>
            Retargeted custom attributes
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAttributeData">
            <summary>
            Represents a Source custom attribute specification
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAttributeData.ConstructorArgumentsSourceIndices">
            <summary>
            If the <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData.ConstructorArguments"/> contains any named constructor arguments or default value arguments,
            it returns an array representing each argument's source argument index. A value of -1 indicates default value argument.
            Otherwise, returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAttributeData.GetTargetAttributeSignatureIndex(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.AttributeDescription)">
            <summary>
            This method finds an attribute by metadata name and signature. The algorithm for signature matching is similar to the one
            in Module.GetTargetAttributeSignatureIndex. Note, the signature matching is limited to primitive types
            and System.Type.  It will not match an arbitrary signature but it is sufficient to match the signatures of the current set of
            well known attributes.
            </summary>
            <param name="targetSymbol">The symbol which is the target of the attribute</param>
            <param name="description">The attribute to match.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAttributeData.GetSystemType(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Gets the System.Type type symbol from targetSymbol's containing assembly.
            </summary>
            <param name="targetSymbol">Target symbol on which this attribute is applied.</param>
            <returns>System.Type type symbol.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterEarlyWellKnownAttributeData">
            <summary>
            Information early-decoded from well-known custom attributes applied on a parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.PropertyEarlyWellKnownAttributeData">
            <summary>
            Information decoded from early well-known custom attributes applied on a property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeWellKnownAttributeData">
            <summary>
            Information decoded from well-known custom attributes applied on a type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.BaseTypeAnalysis.IsManagedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            IsManagedType is simple for most named types:
                enums are not managed;
                non-enum, non-struct named types are managed;
                generic types and their nested types are managed;
                type parameters are managed;
                all special types have spec'd values (basically, (non-string) primitives) are not managed;
            
            Only structs are complicated, because the definition is recursive.  A struct type is managed
            if one of its instance fields is managed.  Unfortunately, this can result in infinite recursion.
            If the closure is finite, and we don't find anything definitely managed, then we return true.
            If the closure is infinite, we disregard all but a representative of any expanding cycle.
            
            Intuitively, this will only return true if there's a specific type we can point to that is would
            be managed even if it had no fields.  e.g. struct S { S s; } is not managed, but struct S { S s; object o; }
            is because we can point to object.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.BaseTypeAnalysis.IsManagedTypeHelper(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Returns a boolean value if we can determine whether the type is managed
            without looking at its fields and Unset otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ByRefReturnErrorTypeSymbol">
            <summary>
            An error type, used to represent a byref return in a metadata signature.
            </summary>
            <remarks>
            If we ever decide to support by-ref returns, don't just make this a non-error
            type.  For consistency with parameters and locals, we should have a bit on the
            signature (i.e. on the MethodSymbol).
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.CompletionPart">
            <summary>
            This enum describes the types of components that could give
            us diagnostics.  We shouldn't read the list of diagnostics
            until all of these types are accounted for.
            </summary>
            <remarks>
            PEParameterSymbol reserves all completion part bits and uses them to track the completion state and
            presence of well known attributes.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterDiagnosticInfo">
            <summary>
            A tuple of TypeParameterSymbol and DiagnosticInfo, created for errors
            reported from ConstraintsHelper rather than creating Diagnostics directly.
            This decouples constraints checking from syntax and Locations, and supports
            callers that may want to create Location instances lazily or not at all.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper">
            <summary>
            Helper methods for generic type parameter constraints. There are two sets of methods: one
            set for resolving constraint "bounds" (that is, determining the effective base type, interface set,
            etc.), and another set for checking for constraint violations in type and method references.
            
            Bounds are resolved by calling one of the ResolveBounds overloads. Typically bounds are
            resolved by each TypeParameterSymbol at, or before, one of the corresponding properties
            (BaseType, Interfaces, etc.) is accessed. Resolving bounds may result in errors (cycles,
            inconsistent constraints, etc.) and it is the responsibility of the caller to report any such
            errors as declaration errors or use-site errors (depending on whether the type parameter
            was from source or metadata) and to ensure bounds are resolved for source type parameters
            even if the corresponding properties are never accessed directly.
            
            Constraints are checked by calling one of the CheckConstraints or CheckAllConstraints
            overloads for any generic type or method reference from source. In some circumstances,
            references are checked at the time the generic type or generic method is bound and constructed
            by the Binder. In those case, it is sufficient to call one of the CheckConstraints overloads
            since compound types (such as A&lt;T&gt;.B&lt;U&gt; or A&lt;B&lt;T&gt;&gt;) are checked
            incrementally as each part is bound. In other cases however, constraint checking needs to be
            delayed to prevent cycles where checking constraints requires binding the syntax that is currently
            being bound (such as the constraint in class C&lt;T&gt; where T : C&lt;T&gt;). In those cases,
            the caller must lazily check constraints, and since the types may be compound types, it is
            necessary to call CheckAllConstraints.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper.ResolveBounds(Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},System.Boolean,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Determine the effective base type, effective interface set, and set of type
            parameters (excluding cycles) from the type parameter constraints. Conflicts
            within the constraints and constraint types are returned as diagnostics.
            'inherited' should be true if the type parameters are from an overridden
            generic method. In those cases, additional constraint checks are applied.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper.CheckAllConstraints(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.ConversionsBase,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Check all generic constraints on the given type and any containing types
            (such as A&lt;T&gt; in A&lt;T&gt;.B&lt;U&gt;). This includes checking constraints
            on generic types within the type (such as B&lt;T&gt; in A&lt;B&lt;T&gt;[]&gt;).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper.CheckConstraints(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.ConversionsBase,Microsoft.CodeAnalysis.CSharp.Symbols.TypeMap,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.Compilation,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterDiagnosticInfo},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterDiagnosticInfo}@,Microsoft.CodeAnalysis.BitVector)">
            <summary>
            Check type parameter constraints for the containing type or method symbol.
            </summary>
            <param name="containingSymbol">The generic type or method.</param>
            <param name="conversions">Conversions instance.</param>
            <param name="substitution">The map from type parameters to type arguments.</param>
            <param name="typeParameters">Containing symbol type parameters.</param>
            <param name="typeArguments">Containing symbol type arguments.</param>
            <param name="currentCompilation">Improves error message detail.</param>
            <param name="diagnosticsBuilder">Diagnostics.</param>
            <param name="skipParameters">Parameters to skip.</param>
            <param name="useSiteDiagnosticsBuilder"/>
            <returns>True if the constraints were satisfied, false otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper.HasPublicParameterlessConstructor(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Return true if the class type has a public parameterless constructor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstraintsHelper.IsEncompassedBy(Microsoft.CodeAnalysis.CSharp.ConversionsBase,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Returns true if type a is encompassed by type b (spec 6.4.3),
            and returns false otherwise.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedNestedTypeSymbol">
            <summary>
            A named type symbol that results from substituting a new owner for a type declaration.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ConstructedNamedTypeSymbol">
            <summary>
            A generic named type symbol that has been constructed with type arguments distinct from its own type parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.DynamicTypeEraser">
            <summary>
            Substitutes all occurrences of dynamic type with Object type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorPropertySymbol">
            <summary>
            When indexer overload resolution fails, we have two options:
              1) Create a BoundBadExpression with the candidates as child nodes;
              2) Create a BoundIndexerAccess with the error flag set.
              
            Option 2 is preferable, because it retains information about the arguments
            (names, ref kind, etc), and results in better output from flow analysis.
            However, we can't create a BoundIndexerAccess with a null indexer symbol,
            so we create an ErrorPropertySymbol to fill the gap.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol">
            <summary>
            An ErrorSymbol is used when the compiler cannot determine a symbol object to return because
            of an error. For example, if a field is declared "Foo x;", and the type "Foo" cannot be
            found, an ErrorSymbol is returned when asking the field "x" what it's type is.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.ErrorInfo">
            <summary>
            The underlying error.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.ResultKind">
            <summary>
            Summary of the reason why the type is bad.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Substitute(Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap)">
            <summary>
            Called by <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.AbstractTypeMap.SubstituteType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)"/> to perform substitution
            on types with TypeKind ErrorType.  The general pattern is to use the type map
            to perform substitution on the wrapped type, if any, and then construct a new
            error type symbol from the result (if there was a change).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.CandidateSymbols">
            <summary>
            When constructing this ErrorTypeSymbol, there may have been symbols that seemed to
            be what the user intended, but were unsuitable. For example, a type might have been
            inaccessible, or ambiguous. This property returns the possible symbols that the user
            might have intended. It will return no symbols if no possible symbols were found.
            See the CandidateReason property to understand why the symbols were unsuitable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.CandidateReason">
            <summary>
             If CandidateSymbols returns one or more symbols, returns the reason that those
             symbols were not chosen. Otherwise, returns None.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.MemberNames">
            <summary>
            Collection of names of members declared within this type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ImmutableArray. Never returns Null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ImmutableArray. Never returns Null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Kind">
            <summary>
            Gets the kind of this symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.TypeKind">
            <summary>
            Gets the kind of this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.ContainingSymbol">
            <summary>
            Get the symbol that logically contains this symbol. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Locations">
            <summary>
            Gets the locations where this symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Arity">
            <summary>
            Returns the arity of this type, or the number of type parameters it takes.
            A non-generic type has zero arity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Name">
            <summary>
            Gets the name of this symbol. Symbols without a name return the empty string; null is
            never returned.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.TypeArgumentsNoUseSiteDiagnostics">
            <summary>
            Returns the type arguments that have been substituted for the type parameters. 
            If nothing has been substituted for a give type parameters,
            then the type parameter itself is consider the type argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.TypeParameters">
            <summary>
            Returns the type parameters that this type has. If this is a non-generic type,
            returns an empty ImmutableArray.  
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.ConstructedFrom">
            <summary>
            Returns the type symbol that this type was constructed from. This type symbol
            has the same containing type (if any), but has type arguments that are the same
            as the type parameters (although its containing type might not).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.Accept``2(Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor{``0,``1},``0)">
            <summary>
            Implements visitor pattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.DeclaredAccessibility">
            <summary>
            Get this accessibility that was declared on this symbol. For symbols that do not have
            accessibility declared on them, returns NotApplicable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.IsStatic">
            <summary>
            Returns true if this symbol is "static"; i.e., declared with the "static" modifier or
            implicitly static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.IsAbstract">
            <summary>
            Returns true if this symbol was declared as requiring an override; i.e., declared with
            the "abstract" modifier. Also returns true on a type declared as "abstract", all
            interface types, and members of interface types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol.IsSealed">
            <summary>
            Returns true if this symbol was declared to override a base class member and was also
            sealed from further overriding; i.e., declared with the "sealed" modifier.  Also set for
            types that do not allow a derived class (declared with "sealed" or "static" or "struct"
            or "enum" or "delegate").
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ExtendedErrorTypeSymbol">
            <summary>
            An error type, used to represent the type of a type binding
            operation when binding fails.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ExtendedErrorTypeSymbol.ExtractNonErrorType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            If (we believe) we know which symbol the user intended, then we should retain that information
            in the corresponding error symbol - it can be useful for deciding how to handle the error.
            For example, we might want to know whether (we believe) the error type was supposed to be an
            interface, so that we can put it in a derived type's interface list, rather than in the base
            type slot.
            
            Sometimes we will return the original definition of the intended symbol.  For example, if we see 
            <![CDATA[IFoo<int>]]> and we have an IFoo with a different arity or accessibility 
            (e.g. <![CDATA[IFoo<int>]]> was constructed from an error symbol based on <![CDATA[IFoo<T>]]>), 
            then we'll return <![CDATA[IFoo<T>]]>, rather than trying to construct a corresponding closed
            type (which may not be difficult/possible in the case of nested types or mismatched arities).
            
            NOTE: Any non-null type symbol returned is guaranteed not to be an error type.
            </summary>
            <remarks>
            TypeSymbolExtensions.GetNonErrorGuess is a more discoverable version of this functionality.
            However, the real definition is in this class so that it can access the private field 
            nonErrorGuessType.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer">
            <summary>
            Represents a field initializer, a property initializer, or a global statement in script code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer.FieldOpt">
            <summary>
            The field being initialized (possibly a backing field of a property), or null if this is a top-level statement in script code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer.Syntax">
            <summary>
            A reference to <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax"/> or top-level <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax"/> in script code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.FieldOrPropertyInitializer.PrecedingInitializersLength">
            <summary>
            A sum of widths of spans of all preceding initializers 
            (instance and static initializers are summed separately, and trivias are not counted).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol">
            <summary>
            Represents a label in method body
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.Name">
            <summary>
            Gets the name of this label
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsExtern">
            <summary>
            Returns false because label can't be defined externally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsSealed">
            <summary>
            Returns false because label can't be sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsAbstract">
            <summary>
            Returns false because label can't be abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsOverride">
            <summary>
            Returns false because label can't be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsVirtual">
            <summary>
            Returns false because label can't be virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.IsStatic">
            <summary>
            Returns false because label can't be static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable' because label can't be used outside the member body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.Locations">
            <summary>
            Gets the locations where the symbol was originally defined, either in source or
            metadata. Some symbols (for example, partial classes) may be defined in more than one
            location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.ContainingMethod">
            <summary>
            Gets the immediately containing symbol of the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol"/>.
            It should be the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/> containing the label in its body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.ContainingSymbol">
            <summary>
            Gets the immediately containing symbol of the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol"/>.
            It should be the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/> containing the label in its body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol.Kind">
            <summary>
            Returns value 'Label' of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey">
            <summary>
            A structure used to lexically order symbols. For performance, it's important that this be 
            a STRUCTURE, and be able to be returned from a symbol without doing any additional allocations (even
            if nothing is cached yet.)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey.Compare(Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey,Microsoft.CodeAnalysis.CSharp.Symbols.LexicalSortKey)">
            <summary>
            Compare two lexical sort keys in a compilation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind">
            <summary>
            Specifies the syntax that a user defined variable comes from.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.None">
            <summary>
            The local is not user defined nor it is a copy of a user defined local (e.g. with a substituted type).
            Check the value of <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.SynthesizedKind"/> for the kind of synthesized variable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.RegularVariable">
            <summary>
            User defined local variable declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.Constant">
            <summary>
            User defined local constant declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.FixedVariable">
            <summary>
            User defined local variable declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax"/> in <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.UsingVariable">
            <summary>
            User defined local variable declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax"/> in <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.CatchVariable">
            <summary>
            User defined local variable declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.ForInitializerVariable">
            <summary>
            User defined local variable declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax"/> in <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.ForEachIterationVariable">
            <summary>
            User defined local variable declared by <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol">
            <summary>
            Represents a local variable in a method body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.Type">
            <summary>
            Gets the type of this local.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsPinned">
            <summary>
            WARN WARN WARN: If you access this via the semantic model, things will break (since the initializer may not have been bound).
            
            Whether or not this local is pinned (i.e. the type will be emitted with the "pinned" modifier).
            </summary>
            <remarks>
            Superficially, it seems as though this should always be the same as DeclarationKind == LocalDeclarationKind.Fixed.
            Unfortunately, when we fix a string expression, it is not the declared local (e.g. char*) but a synthesized temp (string)
            that is pinned.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsExtern">
            <summary>
            Returns false because local variable can't be defined externally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsSealed">
            <summary>
            Returns false because local variable can't be sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsAbstract">
            <summary>
            Returns false because local variable can't be abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsOverride">
            <summary>
            Returns false because local variable can't be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsVirtual">
            <summary>
            Returns false because local variable can't be virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsStatic">
            <summary>
            Returns false because local variable can't be declared as static in C#.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable' because local variable can't be used outside the member body..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.Kind">
            <summary>
            Returns value 'Local' of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsCatch">
            <summary>
            Returns true if this local variable was declared in a catch clause. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsConst">
            <summary>
            Returns true if this local variable was declared as "const" (i.e. is a constant declaration).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsUsing">
            <summary>
            Returns true if the local variable is declared in resource-acquisition of a 'using statement';
            otherwise false
            </summary>
            <exmaple>
            <code>
                using (var localVariable = new StreamReader("C:\\Temp\\MyFile.txt")) { ... } 
            </code>
            </exmaple>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsFixed">
            <summary>
            Returns true if the local variable is declared in fixed-pointer-initializer (in unsafe context)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsFor">
            <summary>
            Returns true if this local variable is declared in for-initializer
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsForEach">
            <summary>
            Returns true if this local variable is declared as iteration variable
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.GetDeclaratorSyntax">
            <summary>
            Returns the syntax node that declares the variable.
            </summary>
            <remarks>
            All user-defined and long-lived synthesized variables must return a reference to a node that is 
            tracked by the EnC diffing algorithm. For example, for <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.LocalDeclarationKind.CatchVariable"/> variable
            the declarator is the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax"/> node.
            
            The location of the declarator is used to calculate <see cref="F:Microsoft.CodeAnalysis.CodeGen.LocalDebugId.SyntaxOffset"/> during emit.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.HasConstantValue">
            <summary>
            Returns false if the field wasn't declared as "const", or constant value was omitted or erroneous.
            True otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.ConstantValue">
            <summary>
            If IsConst returns true, then returns the constant value of the field or enum member. If IsConst returns
            false, then returns null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol.IsCompilerGenerated">
            <summary>
            Returns true if the local symbol was compiler generated.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer">
            <summary>
            <para>
            C# 4.0 §10.6: The name, the type parameter list and the formal parameter list of a method define
            the signature (§3.6) of the method. Specifically, the signature of a method consists of its
            name, the number of type parameters and the number, modifiers, and types of its formal
            parameters. For these purposes, any type parameter of the method that occurs in the type of
            a formal parameter is identified not by its name, but by its ordinal position in the type
            argument list of the method. The return type is not part of a method’s signature, nor are
            the names of the type parameters or the formal parameters.
            </para>
            <para>
            C# 4.0 §3.6: For the purposes of signatures, the types object and dynamic are considered the
            same. 
            </para>
            <para>
            C# 4.0 §3.6: We implement the rules for ref/out by mapping both to ref. The caller (i.e.
            checking for proper overrides or partial methods, etc) should check that ref/out are
            consistent.
            </para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.ExplicitImplementationComparer">
            <summary>
            This instance is used when trying to determine if one member explicitly implements another,
            according the C# definition.
            The member signatures are compared without regard to name (including the interface part, if any)
            and the return types must match.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpImplicitImplementationComparer">
            <summary>
            This instance is used when trying to determine if one member implicitly implements another,
            according to the C# definition.
            The member names, parameters, and (return) types must match. Custom modifiers are ignored.
            </summary>
            <remarks>
            One would expect this comparer to have requireSourceMethod = true, but it doesn't because (for source types)
            we allow inexact matching of custom modifiers when computing implicit member implementations. Consider the
            following scenario: interface I has a method M with custom modifiers C1, source type ST includes I in its
            interface list but has no method M, and metadata type MT has a method M with custom modifiers C2.
            In this scenario, we want to compare I.M to MT.M without regard to custom modifiers, because if C1 != C2,
            we can just synthesize an explicit implementation of I.M in ST that calls MT.M.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpCloseImplicitImplementationComparer">
            <summary>
            This instance is used as a fallback when it is determined that one member does not implicitly implement
            another. It applies a looser check to determine whether the proposed implementation should be reported
            as "close".
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.DuplicateSourceComparer">
            <summary>
            This instance is used to determine if two C# member declarations in source conflict with each other.
            Names, arities, and parameter types are considered.
            Return types, type parameter constraints, custom modifiers, and parameter ref kinds, etc are ignored.
            </summary>
            <remarks>
            This does the same comparison that MethodSignature used to do.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpOverrideComparer">
            <summary>
            This instance is used to check whether one member overrides another, according to the C# definition.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpAccessorOverrideComparer">
            <summary>
            This instance is used to check whether one property or event overrides another, according to the C# definition.
            <para>NOTE: C# ignores accessor member names.</para>
            <para>CAVEAT: considers return types so that getters and setters will be treated the same.</para>
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpCustomModifierOverrideComparer">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpOverrideComparer"/> except that it pays attention to custom modifiers and return type.  
            Normally, the return type isn't considered during overriding, but this comparer is actually used to find
            exact matches (i.e. before tie-breaking takes place amongst close matches).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.SloppyOverrideComparer">
            <summary>
            If this returns false, then the real override comparer (whichever one is appropriate for the scenario)
            will also return false.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RuntimeSignatureComparer">
            <summary>
            This instance is intended to reflect the definition of signature equality used by the runtime 
            (<a href="http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-335.pdf">ECMA-335</a>, Partition I, §8.6.1.6 Signature Matching).
            It considers return type, name, parameters, calling convention, and custom modifiers, but ignores
            the difference between <see cref="F:Microsoft.CodeAnalysis.RefKind.Out"/> and <see cref="F:Microsoft.CodeAnalysis.RefKind.Ref"/>.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RuntimePlusRefOutSignatureComparer">
            <summary>
            Same as <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RuntimeSignatureComparer"/>, but distinguishes between <c>ref</c> and <c>out</c>. During override resolution,
            if we find two methods that match except for <c>ref</c>/<c>out</c>, we want to prefer the one that matches, even
            if the runtime doesn't.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RuntimeImplicitImplementationComparer">
            <summary>
            This instance is the same as RuntimeSignatureComparer.
            CONSIDER: just use RuntimeSignatureComparer?
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CSharpSignatureAndConstraintsAndReturnTypeComparer">
            <summary>
            This instance is used to search for members that have the same name, parameters, (return) type, and constraints (if any)
            according to the C# definition. Custom modifiers are ignored.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.RetargetedExplicitImplementationComparer">
            <summary>
            This instance is used to search for members that have identical signatures in every regard.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.CrefComparer">
            <summary>
            This instance is used for performing approximate overload resolution of documentation
            comment <c>cref</c> attributes. It ignores the name, because the candidates were all found by lookup.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.LambdaReturnInferenceCacheComparer">
            <summary>
            This instance is used as a key in the lambda return type inference.
            We basically only interested in parameters since inference will set the return type to null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MemberSignatureComparer.AreConstraintTypesSubset(System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol},Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol)">
            <summary>
            Returns true if the first set of constraint types
            is a subset of the second set.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions">
            <summary>
            SymbolExtensions for member symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetParameters(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Get the parameters of a member symbol.  Should be a method, property, or event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetParameterTypes(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Get the types of the parameters of a member symbol.  Should be a method, property, or event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetParameterRefKinds(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Get the ref kinds of the parameters of a member symbol.  Should be a method, property, or event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.CustomModifierCount(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Count the number of custom modifiers in/on the return type
            and parameters of the specified method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.CustomModifierCount(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol)">
            <summary>
            Count the number of custom modifiers in/on the type
            and parameters (for indexers) of the specified property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.HasCustomModifiers(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Count the number of custom modifiers in/on the return type
            and parameters of the specified method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetMemberArity(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Return the arity of a member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsParameterlessConstructor(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            NOTE: every struct has a public parameterless constructor either used-defined or default one
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsDefaultValueTypeConstructor(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            default zero-init constructor symbol is added to a struct when it does not define 
            its own parameterless public constructor.
            We do not emit this constructor and do not call it 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetOwnOrInheritedAddMethod(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol)">
            <summary>
            If the event has a AddMethod, return that.  Otherwise check the overridden
            event, if any.  Repeat for each overridden event.
            </summary>
            <remarks>
            This method exists to mimic the behavior of GetOwnOrInheritedGetMethod, but it
            should only ever look at the overridden event in error scenarios.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.GetOwnOrInheritedRemoveMethod(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol)">
            <summary>
            If the event has a RemoveMethod, return that.  Otherwise check the overridden
            event, if any.  Repeat for each overridden event.
            </summary>
            <remarks>
            This method exists to mimic the behavior of GetOwnOrInheritedSetMethod, but it
            should only ever look at the overridden event in error scenarios.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsCompilationOutputWinMdObj(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Does the compilation this symbol belongs to output to a winmdobj?
            </summary>
            <param name="symbol"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.ConstructIfGeneric(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Returns a constructed named type symbol if 'type' is generic, otherwise just returns 'type'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsAccessibleViaInheritance(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Returns true if the members of superType are accessible from subType due to inheritance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.ContainingNamespaceOrType(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            The immediately containing namespace or named type, or null
            if the containing symbol is neither a namespace or named type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsContainingSymbolOfAllTypeParameters(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Returns true if all type parameter references within the given
            type belong to containingSymbol or its containing types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolExtensions.IsContainingSymbolOfAllTypeParameters(Microsoft.CodeAnalysis.CSharp.Symbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Returns true if all type parameter references within the given
            types belong to containingSymbol or its containing types.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MergedNamespaceSymbol">
            <summary>
            A MergedNamespaceSymbol represents a namespace that merges the contents of two or more other
            namespaces. Any sub-namespaces with the same names are also merged if they have two or more
            instances.
            
            Merged namespaces are used to merged the symbols from multiple metadata modules and the
            source "module" into a single symbol tree that represents all the available symbols. The
            compiler resolves names against this merged set of symbols.
            
            Typically there will not be very many merged namespaces in a Compilation: only the root
            namespaces and namespaces that are used in multiple referenced modules. (Microsoft, System,
            System.Xml, System.Diagnostics, System.Threading, ...)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MergedNamespaceSymbol.Create(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent,Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol},System.String)">
            <summary>
            Create a possibly merged namespace symbol. If only a single namespace is passed it, it
            is just returned directly. If two or more namespaces are passed in, then a new merged
            namespace is created with the given extent and container.
            </summary>
            <param name="extent">The namespace extent to use, IF a merged namespace is created.</param>
            <param name="containingNamespace">The containing namespace to used, IF a merged
            namespace is created.</param>
            <param name="namespacesToMerge">One or more namespaces to merged. If just one, then it
            is returned. The merged namespace symbol may hold onto the array.</param>
            <param name="nameOpt">An optional name to give the resulting namespace.</param>
            <returns>A namespace symbol representing the merged namespace.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MergedNamespaceSymbol.SlowGetChildrenOfName(System.String)">
            <summary>
            Method that is called from the CachingLookup to lookup the children of a given name.
            Looks in all the constituent namespaces.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MergedNamespaceSymbol.SlowGetChildNames(System.Collections.Generic.IEqualityComparer{System.String})">
            <summary>
            Method that is called from the CachingLookup to get all child names. Looks in all
            constituent namespaces.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol">
            <summary>
            Represents source or metadata assembly.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol._lazySpecialTypes">
            <summary>
            An array of cached Cor types defined in this assembly.
            Lazily filled by GetSpecialType method.
            </summary>
            <remarks></remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol._cachedSpecialTypes">
            <summary>
            How many Cor types have we cached so far.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly.
            </summary>
            <param name="type"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol.RegisterDeclaredSpecialType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Register declaration of predefined CorLib type in this Assembly.
            </summary>
            <param name="corType"></param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol.KeepLookingForDeclaredSpecialTypes">
            <summary>
            Continue looking for declaration of predefined CorLib type in this Assembly
            while symbols for new type declarations are constructed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol._lazySpecialTypeMembers">
            <summary>
            Not yet known value is represented by ErrorTypeSymbol.UnknownResultType
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol.GetDeclaredSpecialTypeMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Lookup member declaration in predefined CorLib type in this Assembly. Only valid if this 
            assembly is the Cor Library
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MetadataOrSourceAssemblySymbol.MakeFinalIVTDetermination(Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <summary>
            Determine whether this assembly has been granted access to <paramref name="potentialGiverOfAccess"></paramref>.
            Assumes that the public key has been determined. The result will be cached.
            </summary>
            <param name="potentialGiverOfAccess"></param>
            <returns></returns>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.InferExtensionMethodTypeArguments(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.Compilation,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            If the extension method is applicable based on the "this" argument type, return
            the method constructed with the inferred type arguments. If the method is not an
            unconstructed generic method, type inference is skipped. If the method is not
            applicable, or if constraints when inferring type parameters from the "this" type
            are not satisfied, the return value is null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.IsRuntimeFinalizer(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean)">
            <summary>
            The runtime considers a method to be a finalizer (i.e. a method that should be invoked
            by the garbage collector) if it (directly or indirectly) overrides System.Object.Finalize.
            </summary>
            <remarks>
            As an optimization, return true immediately for metadata methods with MethodKind
            Destructor - they are guaranteed to be finalizers.
            </remarks>
            <param name="method">Method to inspect.</param>
            <param name="skipFirstMethodKindCheck">This method is used to determine the method kind of
            a PEMethodSymbol, so we may need to avoid using MethodKind until we move on to a different
            MethodSymbol.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.ConstructIfGeneric(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol})">
            <summary>
            Returns a constructed method symbol if 'method' is generic, otherwise just returns 'method'
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.CanBeHiddenByMemberKind(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.SymbolKind)">
            <summary>
            Some kinds of methods are not considered to be hideable by certain kinds of members.
            Specifically, methods, properties, and types cannot hide constructors, destructors,
            operators, conversions, or accessors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.CanBeHiddenByMethodPropertyOrType(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Some kinds of methods are never considered hidden by methods, properties, or types
            (constructors, destructors, operators, conversions, and accessors).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.IsVoidReturningAsync(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Returns whether this method is async and returns void.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.IsTaskReturningAsync(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Returns whether this method is async and returns a task.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbolExtensions.IsGenericTaskReturningAsync(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Returns whether this method is async and returns a generic task.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingAssemblySymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingAssemblySymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> that represents
            an assembly that couldn't be found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingCorLibrarySymbol">
            <summary>
            AssemblySymbol to represent missing, for whatever reason, CorLibrary.
            The symbol is created by ReferenceManager on as needed basis and is shared by all compilations
            with missing CorLibraries.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MissingCorLibrarySymbol._lazySpecialTypes">
            <summary>
            An array of cached Cor types defined in this assembly.
            Lazily filled by GetDeclaredSpecialType method.
            </summary>
            <remarks></remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.MissingCorLibrarySymbol.GetDeclaredSpecialType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Lookup declaration for predefined CorLib type in this Assembly. Only should be
            called if it is know that this is the Cor Library (mscorlib).
            </summary>
            <param name="type"></param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol"/> that represents
            a type symbol that was attempted to be read from metadata, but couldn't be
            found, because:
              a) The metadata file it lives in wasn't referenced
              b) The metadata file was referenced, but didn't contain the type
              c) The metadata file was referenced, contained the correct outer type, but
                 didn't contains a nested type in that outer type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.Arity">
            <summary>
            Get the arity of the missing type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.TopLevel">
            <summary>
            Represents not nested missing type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.TopLevel._lazyTypeId">
            <summary>
            Either <see cref="P:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.TopLevel.SpecialType"/>, <see cref="T:Microsoft.CodeAnalysis.WellKnownType"/>, or -1 if not initialized.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.TopLevel.NamespaceName">
            <summary>
            This is the FULL namespace name (e.g., "System.Collections.Generic")
            of the type that couldn't be found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingMetadataTypeSymbol.Nested">
            <summary>
            Represents nested missing type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingModuleSymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingModuleSymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol"/> that represents
            a module that couldn't be found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingNamespaceSymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MissingNamespaceSymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol"/> that represents
            a namespace that couldn't be found.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol">
            <summary>
            Represents a module within an assembly. Every assembly contains one or more modules.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GlobalNamespace">
            <summary>
            Returns a NamespaceSymbol representing the global (root) namespace, with
            module extent, that can be used to browse all of the symbols defined in this module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.ContainingAssembly">
            <summary>
            Returns the containing assembly. Modules are always directly contained by an assembly,
            so this property always returns the same as ContainingSymbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.Kind">
            <summary>
            Returns value 'NetModule' of the <see cref="T:Microsoft.CodeAnalysis.SymbolKind"/>
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.Ordinal">
            <summary>
            Module's ordinal within containing assembly's Modules array.
            0 - for a source module, etc.
            -1 - for a module that doesn't have containing assembly, or has it, but is not part of Modules array. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.Machine">
            <summary>
            Target architecture of the machine.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.Bit32Required">
            <summary>
            Indicates that this PE file makes Win32 calls. See CorPEKind.pe32BitRequired for more information (http://msdn.microsoft.com/en-us/library/ms230275.aspx).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsMissing">
            <summary>
            Does this symbol represent a missing module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.DeclaredAccessibility">
            <summary>
            Returns 'NotApplicable'
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsStatic">
            <summary>
            Returns false because module can't be declared as 'static'.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsVirtual">
            <summary>
            Returns false because module can't be virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsOverride">
            <summary>
            Returns false because module can't be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsAbstract">
            <summary>
            Returns false because module can't be abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsSealed">
            <summary>
            Returns false because module can't be sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.IsExtern">
            <summary>
            Returns false because module can't be defined externally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.ReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from ReferencedAssemblies and from ReferencedAssemblySymbols 
            correspond to each other.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GetReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
            should correspond to each other.
            
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.ReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from ReferencedAssemblies and 
            from ReferencedAssemblySymbols correspond to each other.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GetReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from GetReferencedAssemblies and 
            from GetReferencedAssemblySymbols should correspond to each other. If reference is 
            not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
            correspnding item.
            
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.SetReferences(Microsoft.CodeAnalysis.ModuleReferences{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol},Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol)">
            <summary>
            A helper method for ReferenceManager to set assembly identities for assemblies 
            referenced by this module and corresponding AssemblySymbols.
            </summary>
            <param name="moduleReferences">A description of the assemblies referenced by this module.</param>
            <param name="originatingSourceAssemblyDebugOnly">
            Source assembly that triggered creation of this module symbol.
            For debug purposes only, this assembly symbol should not be persisted within
            this module symbol because the module can be shared across multiple source 
            assemblies. This method will only be called for the first one.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.HasUnifiedReferences">
            <summary>
            True if this module has any unified references.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GetUnificationUseSiteDiagnostic(Microsoft.CodeAnalysis.DiagnosticInfo@,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary> 
            Returns a unification use-site error (if any) for a symbol contained in this module 
            that is referring to a specified <paramref name="dependentType"/>.
            </summary> 
            <remarks> 
            If an assembly referenced by this module isn't exactly matching any reference given to compilation 
            the Assembly Manager might decide to use another reference if it matches except for version 
            (it unifies the version with the existing reference).  
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.HasAssemblyCompilationRelaxationsAttribute">
            <summary>
            Returns true if there is any applied CompilationRelaxationsAttribute assembly attribute for this module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.HasAssemblyRuntimeCompatibilityAttribute">
            <summary>
            Returns true if there is any applied RuntimeCompatibilityAttribute assembly attribute for this module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.DefaultMarshallingCharSet">
            <summary>
            Default char set for contained types, or null if not specified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol.GetModuleNamespace(Microsoft.CodeAnalysis.INamespaceSymbol)">
            <summary>
            Given a namespace symbol, returns the corresponding module specific namespace symbol
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.MutableTypeMap">
            <summary>
            Utility class for substituting actual type arguments for formal generic type parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent">
            <summary>
            A NamespaceExtent represents whether a namespace contains types and sub-namespaces from a
            particular module, assembly, or merged across all modules (source and metadata) in a
            particular compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.Kind">
            <summary>
            Returns what kind of extent: Module, Assembly, or Compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.Module">
            <summary>
            If the Kind is ExtendKind.Module, returns the module symbol that this namespace
            encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.Assembly">
            <summary>
            If the Kind is ExtendKind.Assembly, returns the assembly symbol that this namespace
            encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.Compilation">
            <summary>
            If the Kind is ExtendKind.Compilation, returns the compilation symbol that this
            namespace encompasses. Otherwise throws InvalidOperationException.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol)">
            <summary>
            Create a NamespaceExtent that represents a given ModuleSymbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <summary>
            Create a NamespaceExtent that represents a given AssemblySymbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceExtent.#ctor(Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Create a NamespaceExtent that represents a given Compilation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol">
            <summary>
            Represents either a namespace or a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.IsNamespace">
            <summary>
            Returns true if this symbol is a namespace. If it is not a namespace, it must be a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.IsType">
            <summary>
            Returns true if this symbols is a type. Equivalent to !IsNamespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.IsVirtual">
            <summary>
            Returns true if this symbol is "virtual", has an implementation, and does not override a
            base class member; i.e., declared with the "virtual" modifier. Does not return true for
            members declared as abstract or override.
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.IsOverride">
            <summary>
            Returns true if this symbol was declared to override a base class member; i.e., declared
            with the "override" modifier. Still returns true if member was declared to override
            something, but (erroneously) no member to override exists.
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.IsExtern">
            <summary>
            Returns true if this symbol has external implementation; i.e., declared with the 
            "extern" modifier. 
            </summary>
            <returns>
            Always returns false.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetMembers">
            <summary>
            Get all the members of this symbol.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetMembersUnordered">
            <summary>
            Get all the members of this symbol. The members may not be in a particular order, and the order
            may not be stable from call-to-call.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol. If this symbol has no members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetMembers(System.String)">
            <summary>
            Get all the members of this symbol that have a particular name.
            </summary>
            <returns>An ImmutableArray containing all the members of this symbol with the given name. If there are
            no members with this name, returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetTypeMembersUnordered">
            <summary>
            Get all the members of this symbol that are types. The members may not be in a particular order, and the order
            may not be stable from call-to-call.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetTypeMembers">
            <summary>
            Get all the members of this symbol that are types.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol. If this symbol has no type members,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetTypeMembers(System.String)">
            <summary>
            Get all the members of this symbol that are types that have a particular name, of any arity.
            </summary>
            <returns>An ImmutableArray containing all the types that are members of this symbol with the given name.
            If this symbol has no type members with this name,
            returns an empty ImmutableArray. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetTypeMembers(System.String,System.Int32)">
            <summary>
            Get all the members of this symbol that are types that have a particular name and arity
            </summary>
            <returns>An IEnumerable containing all the types that are members of this symbol with the given name and arity.
            If this symbol has no type members with this name and arity,
            returns an empty IEnumerable. Never returns null.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetSourceTypeMember(Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax)">
            <summary>
            Get a source type symbol for the given declaration syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetSourceTypeMember(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax)">
            <summary>
            Get a source type symbol for the given declaration syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetSourceTypeMember(System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Get a source type symbol of given name, arity and kind.  If a tree and syntax are provided, restrict the results
            to those that are declared within the given syntax.
            </summary>
            <returns>Null if there is no matching declaration.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.LookupMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup an immediately nested type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedTypeName">
            Simple type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetNamespaceOrTypeByQualifiedName(System.Collections.Generic.IEnumerable{System.String})">
            <summary>
            Finds types or namespaces described by a qualified name.
            </summary>
            <param name="qualifiedName">Sequence of simple plain names.</param>
            <returns>
            A set of namespace or type symbols with given qualified name (might comprise of types with multiple generic arities), 
            or an empty set if the member can't be found (the qualified name is ambiguous or the symbol doesn't exist).
            </returns>
            <remarks>
            "C.D" matches C.D, C{T}.D, C{S,T}.D{U}, etc.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> that represents
            an assembly that is not missing, i.e. the "real" thing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol._emittedNameToTypeMap">
            <summary>
            This is a cache similar to the one used by MetaImport::GetTypeByName
            in native compiler. The difference is that native compiler pre-populates 
            the cache when it loads types. Here we are populating the cache only
            with things we looked for, so that next time we are looking for the same 
            thing, the lookup is fast. This cache also takes care of TypeForwarders. 
            Gives about 8% win on subsequent lookups in some scenarios.     
            </summary>
            <remarks></remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol.IsMissing">
            <summary>
            Does this symbol represent a missing assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol.GlobalNamespace">
            <summary>
            Gets the merged root namespace that contains all namespaces and types defined in the modules
            of this assembly. If there is just one module in this assembly, this property just returns the 
            GlobalNamespace of that module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol.LookupTopLevelMetadataTypeWithCycleDetection(Microsoft.CodeAnalysis.MetadataTypeName@,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol},System.Boolean)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.  Detect cycles during lookup.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <param name="visitedAssemblies">
            List of assemblies lookup has already visited (since type forwarding can introduce cycles).
            </param>
            <param name="digThroughForwardedTypes">
            Take forwarded types into account.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol.CachedTypeByEmittedName(System.String)">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingAssemblySymbol.EmittedNameToTypeMapCount">
            <summary>
            For test purposes only.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol">
            <summary>
            A <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol"/> is a special kind of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol"/> that represents
            a module that is not missing, i.e. the "real" thing.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol._moduleReferences">
            <summary>
            An array of <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol"/> objects corresponding to assemblies directly referenced by this module.
            </summary>
            <remarks>
            The contents are provided by ReferenceManager and may not be modified.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol.IsMissing">
            <summary>
            Does this symbol represent a missing module.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol.GetReferencedAssemblies">
            <summary>
            Returns an array of assembly identities for assemblies referenced by this module.
            Items at the same position from GetReferencedAssemblies and from GetReferencedAssemblySymbols 
            should correspond to each other.
            
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol.GetReferencedAssemblySymbols">
            <summary>
            Returns an array of AssemblySymbol objects corresponding to assemblies referenced 
            by this module. Items at the same position from GetReferencedAssemblies and 
            from GetReferencedAssemblySymbols should correspond to each other. If reference is 
            not resolved by compiler, GetReferencedAssemblySymbols returns MissingAssemblySymbol in the
            correspnding item.
            
            The array and its content is provided by ReferenceManager and must not be modified.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol.SetReferences(Microsoft.CodeAnalysis.ModuleReferences{Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol},Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol)">
            <summary>
            A helper method for ReferenceManager to set assembly identities for assemblies 
            referenced by this module and corresponding AssemblySymbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.NonMissingModuleSymbol.LookupTopLevelMetadataType(Microsoft.CodeAnalysis.MetadataTypeName@)">
            <summary>
            Lookup a top level type referenced from metadata, names should be
            compared case-sensitively.
            </summary>
            <param name="emittedName">
            Full type name, possibly with generic name mangling.
            </param>
            <returns>
            Symbol for the type, or MissingMetadataSymbol if the type isn't found.
            </returns>
            <remarks></remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NoPiaAmbiguousCanonicalTypeSymbol">
            <summary>
            A NoPiaAmbiguousCanonicalTypeSymbol is a special kind of ErrorSymbol that represents a NoPia
            embedded type symbol that was attempted to be substituted with canonical type, but the
            canonocal type was ambiguous.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NoPiaIllegalGenericInstantiationSymbol">
            <summary>
            A NoPiaIllegalGenericInstantiationSymbol is a special kind of ErrorSymbol that represents a
            generic type instantiation that cannot cross assembly boundaries according to NoPia rules.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.NoPiaMissingCanonicalTypeSymbol">
            <summary>
            A NoPiaMissingCanonicalTypeSymbol is a special kind of ErrorSymbol that represents a NoPia
            embedded type symbol that was attempted to be substituted with canonical type, but the
            canonocal type couldn't be found.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ObsoleteAttributeHelpers.InitializeObsoleteDataFromMetadata(Microsoft.CodeAnalysis.ObsoleteAttributeData@,System.Reflection.Metadata.EntityHandle,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol)">
            <summary>
            Initialize the ObsoleteAttributeData by fetching attributes and decoding ObsoleteAttributeData. This can be 
            done for Metadata symbol easily whereas trying to do this for source symbols could result in cycles.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ObsoleteAttributeHelpers.GetObsoleteDataFromMetadata(System.Reflection.Metadata.EntityHandle,Microsoft.CodeAnalysis.CSharp.Symbols.Metadata.PE.PEModuleSymbol)">
            <summary>
            Get the ObsoleteAttributeData by fetching attributes and decoding ObsoleteAttributeData. This can be 
            done for Metadata symbol easily whereas trying to do this for source symbols could result in cycles.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ObsoleteAttributeHelpers.GetObsoleteContextState(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean)">
            <summary>
            This method checks to see if the given symbol is Obsolete or if any symbol in the parent hierarchy is Obsolete.
            </summary>
            <returns>
            True if some symbol in the parent hierarchy is known to be Obsolete. Unknown if any
            symbol's Obsoleteness is Unknown. False, if we are certain that no symbol in the parent
            hierarchy is Obsolete.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ObsoleteAttributeHelpers.CreateObsoleteDiagnostic(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BinderFlags)">
            <summary>
            Create a diagnostic for the given symbol. This could be an error or a warning based on
            the ObsoleteAttribute's arguments.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers">
            <summary>
            Encapsulates the MakeOverriddenOrHiddenMembers functionality for methods, properties (including indexers), 
            and events.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.MakeOverriddenOrHiddenMembersWorker(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Walk up the type hierarchy from ContainingType and list members that this
            member either overrides (accessible members with the same signature, if this
            member is declared "override") or hides (accessible members with the same name
            but different kinds, plus members that would be in the overrides list if
            this member were not declared "override").
            
            Members in the overridden list may be non-virtual or may have different
            accessibilities, types, accessors, etc.  They are really candidates to be
            overridden.
            
            Members in the hidden list are definitely hidden.
            
            Members in the runtime overridden list are indistinguishable from the members
            in the overridden list from the point of view of the runtime (see
            FindOtherOverriddenMethodsInContainingType for details).
            </summary>
            <remarks>
            In the presence of non-C# types, the meaning of "same signature" is rather
            complicated.  If this member isn't from source, then it refers to the runtime's
            notion of signature (i.e. including return type, custom modifiers, etc).
            If this member is from source, then the process is (conceptually) as follows.
            
            1) Walk up the type hierarchy, recording all matching members with the same
               signature, ignoring custom modifiers and return type.  Stop if a hidden
               member is encountered.
            2) Apply the following "tie-breaker" rules until you have at most one member,
               a) Prefer members in more derived types.
               b) Prefer an exact custom modifier match (i.e. none, for a source member).
               c) Prefer fewer custom modifiers (values/positions don't matter, just count).
               d) Prefer earlier in GetMembers order (within the same type).
            3) If a member remains, search its containing type for other members that
               have the same C# signature (overridden members) or runtime signature
               (runtime overridden members).
            
            In metadata, properties participate in overriding only through their accessors.
            That is, property/event accessors may implicitly or explicitly override other methods
            and a property/event can be considered to override another property/event if its accessors
            override those of the other property/event.
            This implementation (like Dev10) will not follow that approach.  Instead, it is
            based on spec section 10.7.5, which treats properties as entities in their own
            right.  If all property/event accessors have conventional names in metadata and nothing
            "unusual" is done with explicit overriding, this approach should produce the same
            results as an implementation based on accessor overriding.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.MakePropertyAccessorOverriddenOrHiddenMembers(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol)">
            <summary>
            In the CLI, accessors are just regular methods and their overriding/hiding rules are the same as for
            regular methods.  In C#, however, accessors are intimately connected with their corresponding properties.
            Rather than walking up the type hierarchy from the containing type of this accessor, looking for members
            with the same name, MakePropertyAccessorOverriddenOrHiddenMembers delegates to the associated property.
            For an accessor to hide a member, the hidden member must be a corresponding accessor on a property hidden
            by the associated property.  For an accessor to override a member, the overridden member must be a
            corresponding accessor on a property (directly or indirectly) overridden by the associated property.
            
            Example 1:
            
            public class A { public virtual int P { get; set; } }
            public class B : A { public override int P { get { return 1; } } } //get only
            public class C : B { public override int P { set { } } } // set only
            
            C.P.set overrides A.P.set because C.P.set is the setter of C.P, which overrides B.P,
            which overrides A.P, which has A.P.set as a setter.
            
            Example 2:
            
            public class A { public virtual int P { get; set; } }
            public class B : A { public new virtual int P { get { return 1; } } } //get only
            public class C : B { public override int P { set { } } } // set only
            
            C.P.set does not override any method because C.P overrides B.P, which has no setter
            and does not override a property.
            </summary>
            <param name="accessor">This accessor.</param>
            <param name="associatedProperty">The property associated with this accessor.</param>
            <returns>Members overridden or hidden by this accessor.</returns>
            <remarks>
            This method is intended to return values consistent with the definition of C#, which
            may differ from the actual meaning at runtime.
            
            Note: we don't need a different path for interfaces - Property.OverriddenOrHiddenMembers handles that.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.MakeEventAccessorOverriddenOrHiddenMembers(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol)">
            <summary>
            In the CLI, accessors are just regular methods and their overriding/hiding rules are the same as for
            regular methods.  In C#, however, accessors are intimately connected with their corresponding events.
            Rather than walking up the type hierarchy from the containing type of this accessor, looking for members
            with the same name, MakeEventAccessorOverriddenOrHiddenMembers delegates to the associated event.
            For an accessor to hide a member, the hidden member must be a corresponding accessor on a event hidden
            by the associated event.  For an accessor to override a member, the overridden member must be a
            corresponding accessor on a event (directly or indirectly) overridden by the associated event.
            </summary>
            <param name="accessor">This accessor.</param>
            <param name="associatedEvent">The event associated with this accessor.</param>
            <returns>Members overridden or hidden by this accessor.</returns>
            <remarks>
            This method is intended to return values consistent with the definition of C#, which
            may differ from the actual meaning at runtime.
            
            Note: we don't need a different path for interfaces - Event.OverriddenOrHiddenMembers handles that.
            
            CONSIDER: It is an error for an event to have only one accessor.  Currently, we mimic the behavior for
            properties, for consistency, but an alternative approach would be to say that nothing is overridden.
            
            CONSIDER: is there a way to share code with MakePropertyAccessorOverriddenOrHiddenMembers?
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.MakeInterfaceOverriddenOrHiddenMembers(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean)">
            <summary>
            There are two key reasons why interface overriding/hiding is different from class overriding/hiding:
              1) interface members never override other members; and
              2) interfaces can extend multiple interfaces.
            The first difference doesn't require any special handling - as long as the members have IsOverride=false,
            the code for class overriding/hiding does the right thing.
            The second difference is more problematic.  For one thing, an interface member can hide a different member in
            each base interface.  We only report the first one, but we need to expose all of them in the API.  More importantly,
            multiple inheritance raises the possibility of diamond inheritance.  Spec section 13.2.5, Interface member access,
            says: "The intuitive rule for hiding in multiple-inheritance interfaces is simply this: If a member is hidden in any
            access path, it is hidden in all access paths."  For example, consider the following interfaces:
            
            interface I0 { void M(); }
            interface I1 : I0 { void M(); }
            interface I2 : I0, I1 { void M(); }
            
            I2.M does not hide I0.M, because it is already hidden by I1.M.  To make this work, we need to traverse the graph
            of ancestor interfaces in topological order and flag ones later in the enumeration that are hidden along some path.
            </summary>
            <remarks>
            See SymbolPreparer::checkIfaceHiding.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.FindOverriddenOrHiddenMembersInType(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol@,System.Boolean@,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol}@)">
            <summary>
            Look for overridden or hidden members in a specific type.
            </summary>
            <param name="member">Member that is hiding or overriding.</param>
            <param name="memberIsFromSomeCompilation">True if member is from the current compilation.</param>
            <param name="memberContainingType">The type that contains member (member.ContainingType).</param>
            <param name="currType">The type to search.</param>
            <param name="currTypeBestMatch">
            A member with the same signature if currTypeHasExactMatch is true,
            a member with (a minimal number of) different custom modifiers if there is one,
            and null otherwise.</param>
            <param name="currTypeHasSameKindNonMatch">True if there's a member with the same name and kind that is not a match.</param>
            <param name="hiddenBuilder">Hidden members (same name, different kind) will be added to this builder.</param>
            <remarks>
            There is some similarity between this member and TypeSymbol.FindPotentialImplicitImplementationMethodDeclaredInType.
            When making changes to this member, think about whether or not they should also be applied in TypeSymbol.
            
            In incorrect or imported code, it is possible that both currTypeBestMatch and hiddenBuilder will be populated.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.FindRelatedMembers(System.Boolean,System.Boolean,Microsoft.CodeAnalysis.SymbolKind,Microsoft.CodeAnalysis.CSharp.Symbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol}@,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol}@)">
            <summary>
            If representative member is non-null and is contained in a constructed type, then find
            other members in the same type with the same signature.  If this is an override member,
            add them to the overridden and runtime overridden lists.  Otherwise, add them to the
            hidden list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.AddHiddenMemberIfApplicable(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol}@,Microsoft.CodeAnalysis.SymbolKind,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Some kinds of methods are not considered to be hideable by certain kinds of members.
            Specifically, methods, properties, and types cannot hide constructors, destructors,
            operators, conversions, or accessors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.FindOtherOverriddenMethodsInContainingType(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Having found the best member to override, we want to find members with the same signature on the
            best member's containing type.
            </summary>
            <param name="representativeMember">
            The member that we consider to be overridden (may have different custom modifiers from the overriding member).
            Assumed to already be in the overridden and runtime overridden lists.
            </param>
            <param name="overridingMemberIsFromSomeCompilation">
            If the best match was based on the custom modifier count, rather than the custom modifiers themselves 
            (because the overriding member is in the current compilation), then we should use the count when determining
            whether the override is ambiguous.
            </param>
            <param name="overriddenBuilder">
            If the declaring type is constructed, it's possible that two (or more) members have the same signature
            (including custom modifiers).  Return a list of such members so that we can report the ambiguity.
            </param>
            <param name="runtimeOverriddenBuilder">
            If the declaring type is constructed, it's possible that two (or more) members have the same signature
            (including custom modifiers) in metadata (no ref/out distinction).  Return a list of such members so
            that we can report the ambiguity.
            
            Even in a non-generic type, it's possible for two indexers to have the same signature.  For example,
            this would be the case if the default member of a type is "get_Item" and indexers "A" and "B", 
            with the same signature, both have an indexer called "get_Item".
            
            From: SymbolPreparer.cpp
            DevDiv Bugs 115384: Both out and ref parameters are implemented as references. In addition, out parameters are 
            decorated with OutAttribute. In CLR when a signature is looked up in virtual dispatch, CLR does not distinguish
            between these to parameter types. The choice is the last method in the vtable. Therefore we check and warn if 
            there would potentially be a mismatch in CLRs and C#s choice of the overriden method. Unfortunately we have no 
            way of communicating to CLR which method is the overriden one. We only run into this problem when the 
            parameters are generic.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.FindOtherHiddenMembersInContainingType(Microsoft.CodeAnalysis.SymbolKind,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol}@)">
            <summary>
            Having found that we are hiding a method with exactly the same signature
            (including custom modifiers), we want to find methods with the same signature
            on the declaring type because they will also be hidden.
            (If the declaring type is constructed, it's possible that two or more
            methods have the same signature (including custom modifiers).)
            (If the representative member is an indexer, it's possible that two or more
            properties have the same signature (including custom modifiers, even in a
            non-generic type).
            </summary>
            <param name="hidingMemberKind">
            This kind of the hiding member.
            </param>
            <param name="representativeMember">
            The member that we consider to be hidden (must have exactly the same custom modifiers as the hiding member).
            Assumed to already be in hiddenBuilder.
            </param>
            <param name="hiddenBuilder">
            Will have all other members with the same signature (including custom modifiers) as 
            representativeMember added.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.GetFirstRuntimeOverriddenMethodIgnoringNewSlot(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean)">
            <summary>
            Given a method, find a method that it overrides from the perspective of the CLI.
            Key differences from C#: non-virtual methods are ignored, the RuntimeSignatureComparer
            is used (i.e. consider return types, ignore ref/out distinction).
            </summary>
            <remarks>
            WARN: Must not check method.MethodKind - PEMethodSymbol.ComputeMethodKind uses this method.
            NOTE: Does not check whether the given method will be marked "newslot" in metadata (which
            would indicate that it does not override anything).
            WARN: If the method may override a source method and declaration diagnostics have yet to
            be computed, then it is important to pass ignoreInterfaceImplementationChanges: true
            (see MethodSymbol.IsMetadataVirtual for details).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersHelpers.IsOverriddenSymbolAccessible(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <remarks>
            Note that the access check is done using the original definitions.  This is because we want to avoid
            reductions in accessibility that result from type argument substitution (e.g. if an inaccessible type
            has been passed as a type argument).
            See DevDiv #11967 for an example.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenOrHiddenMembersResult">
            <summary>
            Groups the information computed by MakeOverriddenOrHiddenMembers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.PreprocessingSymbol">
            <summary>
            Represents a preprocessing conditional compilation symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.PEPropertyOrEventHelpers">
            <summary>
            Helper methods that exist to share code between properties and events.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbolExtensions.GetOwnOrInheritedGetMethod(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol)">
            <summary>
            If the property has a GetMethod, return that.  Otherwise check the overridden
            property, if any.  Repeat for each overridden property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbolExtensions.GetOwnOrInheritedSetMethod(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol)">
            <summary>
            If the property has a SetMethod, return that.  Otherwise check the overridden
            property, if any.  Repeat for each overridden property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.RangeVariableSymbol">
            <summary>
            A RangeVariableSymbol represents an identifier introduced in a query expression as the
            identifier of a "from" clause, an "into" query continuation, a "let" clause, or a "join" clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.RangeVariableSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ReducedExtensionMethodSymbol">
            <summary>
            An extension method with the "this" parameter removed.
            Used for the public binding API only, not for compilation.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ReducedExtensionMethodSymbol.Create(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.Compilation)">
            <summary>
            Return the extension method in reduced form if the extension method
            is applicable, and satisfies type parameter constraints, based on the
            "this" argument type. Otherwise, returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyMethodSymbol">
            <summary>
            A representation of a method symbol that is intended only to be used for comparison purposes
            (esp in MethodSignatureComparer).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyParameterSymbol">
            <summary>
            Intended to be used to create ParameterSymbols for a SignatureOnlyMethodSymbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SignatureOnlyPropertySymbol">
            <summary>
            A representation of a property symbol that is intended only to be used for comparison purposes
            (esp in PropertySignatureComparer).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.OrderAllDependencies(Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.FieldInfo},System.Boolean)">
            <summary>
            Generate a list containing the given field and all dependencies
            of that field that require evaluation. The list is ordered by
            dependencies, with fields with no dependencies first. Cycles are
            broken at the first field lexically in the cycle. If multiple threads
            call this method with the same field, the order of the fields
            returned should be the same, although some fields may be missing
            from the lists in some threads as other threads evaluate fields.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.Node`1.Dependencies">
            <summary>
            The set of fields on which the field depends.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.Node`1.DependedOnBy">
            <summary>
            The set of fields that depend on the field.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.CreateGraph(System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference,Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.Node{Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference}},Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference,System.Boolean)">
            <summary>
            Build a dependency graph (a map from
            field to dependencies).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.OrderCompilations(System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference,Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.Node{Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference}},System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.Compilation,System.Int32})">
            <summary>
            Return an ordering of the compilations referenced in the graph.
            The actual ordering is not important, but we need some ordering
            to compare source locations across different compilations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.GetMemberOfCycle(System.Collections.Generic.Dictionary{Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference,Microsoft.CodeAnalysis.CSharp.Symbols.ConstantEvaluationHelpers.Node{Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference}})">
            <summary>
            Return one member from one cycle in the graph.
            (There must be at least one cycle. In fact, there
            shouldn't be any fields without dependencies.)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.CrefTypeParameterSymbol">
            <summary>
            Type parameters in documentation comments are complicated since they sort of act as declarations,
            rather than references.  Consider the following example:
            
            <![CDATA[
            /// <summary>See <see cref="B{U}.M(U)" />.</summary>
            class B<T> { void M(T t) { } }
            ]]>
            
            We make some key observations:
              1) The type parameter name in the cref is not tied to the type parameter name in the type declaration.
              2) A relationship exists between the two occurrences of "U" in the cref: they both refer to (or define)
                   the same symbol.
            
            In Roslyn, we've decided on the following representation: within the (entire) scope of a cref, the names
            of all type parameters "declared" in the cref are in scope and bind to the corresponding type parameters.
            This representation has one major advantage: as long as the appropriate binder (i.e. the one that knows
            about the implicitly-declared type parameters) is used, TypeSyntaxes within the cref can be bound by
            calling BindType.  In addition to eliminating the necessity for custom binding code in the batch case,
            this reduces the problem of exposing such nodes in the SemanticModel to one of ensuring that the right
            enclosing binder is chosen.  That is, new code will have to be written to handle CrefSyntaxes, but the
            existing code for TypeSyntaxes should just work!
            
            In the example above, this means that, between the cref quotation marks, the name "U" binds to an
            implicitly declared type parameter, whether it is in "B{U}", "M{U}", or "M{List{U[]}}".
            
            Of course, it's not all gravy.  One thing we're giving up by using this representation is the ability to
            distinguish between "declared" type parameters with the same name.  Consider the following example:
            
            <![CDATA[
            <summary>See <see cref=""A{T, T}.M(T)""/>.</summary>
            class A<T, U>
            {
                void M(T t) { }
                void M(U u) { }
            }
            ]]>
            </summary>
            
            The native compiler interprets this in the same way as it would interpret A{T1, T2}.M(T2) and unambiguously
            (i.e. without a warning) binds to A{T, U}.M(U).  Since Roslyn does not distinguish between the T's, Roslyn
            reports an ambiguity warning and picks the first method.  Furthermore, renaming one 'T' will rename all of
            them.
            
            This class represents such an implicitly declared type parameter.  The declaring syntax is expected to be
            an IdentifierNameSyntax in the type argument list of a QualifiedNameSyntax.
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CustomModifierUtils.CopyMethodCustomModifiers(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CustomModifier}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol}@,System.Boolean)">
            <remarks>
            Out params are updated by assignment.  If you require thread-safety, pass temps and then
            CompareExchange them back into shared memory.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.CustomModifierUtils.CopyTypeCustomModifiers(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol)">
            <param name="sourceType">Type that already has custom modifiers.</param>
            <param name="destinationType">Same as <paramref name="sourceType"/>, but without custom modifiers.  May differ in object/dynamic.</param>
            <param name="refKind"><see cref="T:Microsoft.CodeAnalysis.RefKind"/> of the parameter of which this is the type (or <see cref="F:Microsoft.CodeAnalysis.RefKind.None"/> for a return type.</param>
            <param name="containingAssembly">The assembly containing the signature referring to the destination type.</param>
            <returns><paramref name="destinationType"/> with custom modifiers copied from <paramref name="sourceType"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.ExplicitInterfaceHelpers.FindExplicitImplementationCollisions(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Given a member, look for other members contained in the same type with signatures that will
            not be distinguishable by the runtime.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol">
            <summary>
            Implemented by symbols that can be targetted by an attribute declaration (i.e. source symbols).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AttributesOwner">
            <summary>
            Returns the owner of attributes that apply to this symbol.
            </summary>
            <remarks>
            Attributes for this symbol might be retrieved from attribute list of another (owning) symbol.
            In that case this property returns that owning symbol, otherwise it returns "this".
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.AllowedAttributeLocations">
            <summary>
            Returns a bit set of attribute locations applicable to this symbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.IAttributeTargetSymbol.DefaultAttributeLocation">
            <summary>
            Attribute location corresponding to this symbol.
            </summary>
            <remarks>
            Location of an attribute if an explicit location is not specified via attribute target specification syntax.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.ImplicitNamedTypeSymbol">
            <summary>
            Represents implicit, script and submission classes.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.IndexedTypeParameterSymbol">
            <summary>
            Indexed type parameters are used in place of type parameters for method signatures.  There is
            a unique mapping from index to a single IndexedTypeParameterSymbol.  
            
            They don't have a containing symbol or locations.
            
            They do not have constraints, variance, or attributes. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.IndexedTypeParameterSymbol.Take(System.Int32)">
            <summary>
            Create a vector of n dummy type parameters.  Always reuses the same type parameter symbol
            for the same position.
            </summary>
            <param name="count"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol">
            <summary>
            Represents an assembly built by compiler.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._compilation">
            <summary>
            A Compilation the assembly is created for.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.lazyAssemblyIdentity">
            <summary>
            Assembly's identity.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._modules">
            <summary>
            A list of modules the assembly consists of. 
            The first (index=0) module is a SourceModuleSymbol, which is a primary module, the rest are net-modules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._lazySourceAttributesBag">
            <summary>
            Bag of assembly's custom attributes and decoded well-known attribute data from source.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._lazyNetModuleAttributesBag">
            <summary>
            Bag of assembly's custom attributes and decoded well-known attribute data from added netmodules.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._lazyOmittedAttributeIndices">
            <summary>
            Indices of attributes that will not be emitted for one of two reasons:
            - They are duplicates of another attribute (i.e. attributes that bind to the same constructor and have identical arguments)
            - They are InternalsVisibleToAttributes with invalid assembly identities
            </summary>
            <remarks>
            These indices correspond to the merged assembly attributes from source and added net modules, i.e. attributes returned by <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetAttributes"/> method.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._unassignedFieldsMap">
            <summary>
            Map for storing effectively private or effectively internal fields declared in this assembly but never initialized nor assigned.
            Each {symbol, bool} key-value pair in this map indicates the following:
             (a) Key: Unassigned field symbol.
             (b) Value: True if the unassigned field is effectively internal, false otherwise.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._unreadFields">
            <summary>
            private fields declared in this assembly but never read
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.TypesReferencedInExternalMethods">
            <summary>
            We imitate the native compiler's policy of not warning about unused fields
            when the enclosing type is used by an extern method for a ref argument.
            Here we keep track of those types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol._unusedFieldWarnings">
            <summary>
            The warnings for unused fields.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.DeclaringCompilation">
            <remarks>
            This override is essential - it's a base case of the recursive definition.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.Flags">
            <summary>
            This represents what the user claimed in source through the AssemblyFlagsAttribute.
            It may be modified as emitted due to presence or absence of the public key.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.ReportDiagnosticsForSynthesizedAttributes(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            We're going to synthesize some well-known attributes for this assembly symbol.  However, at synthesis time, it is
            too late to report diagnostics or cancel the emit.  Instead, we check for use site errors on the types and members
            we know we'll need at synthesis time.
            </summary>
            <remarks>
            As in Dev10, we won't report anything if the attribute TYPES are missing (note: missing, not erroneous) because we won't
            synthesize anything in that case.  We'll only report diagnostics if the attribute TYPES are present and either they or 
            the attribute CONSTRUCTORS have errors.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.ReportDiagnosticsForUnsafeSynthesizedAttributes(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            If this compilation allows unsafe code (note: allows, not contains), then when we actually emit the assembly/module, 
            we're going to synthesize SecurityPermissionAttribute/UnverifiableCodeAttribute.  However, at synthesis time, it is
            too late to report diagnostics or cancel the emit.  Instead, we check for use site errors on the types and members
            we know we'll need at synthesis time.
            </summary>
            <remarks>
            As in Dev10, we won't report anything if the attribute TYPES are missing (note: missing, not erroneous) because we won't
            synthesize anything in that case.  We'll only report diagnostics if the attribute TYPES are present and either they or 
            the attribute CONSTRUCTORS have errors.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.InternalsAreVisible">
            <summary>
            True if internals are exposed at all.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            This property shouldn't be accessed during binding as it can lead to attribute binding cycle.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetUniqueSourceAssemblyAttributes">
            <summary>
            Gets unique source assembly attributes that should be emitted,
            i.e. filters out attributes with errors and duplicate attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetSourceAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetSourceAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.IsIndexOfOmittedAssemblyAttribute(System.Int32)">
            <summary>
            Returns true if the assembly attribute at the given index is a duplicate assembly attribute that must not be emitted.
            Duplicate assembly attributes are attributes that bind to the same constructor and have identical arguments.
            </summary>
            <remarks>
            This method must be invoked only after all the assembly attributes have been bound.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetSourceDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from source assembly attributes or null if there are none.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            TODO: We should replace methods GetSourceDecodedWellKnownAttributeData and GetNetModuleDecodedWellKnownAttributeData with
            a single method GetDecodedWellKnownAttributeData, which merges DecodedWellKnownAttributeData from source and netmodule attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.ContainsExtensionMethods">
            <summary>
            Returns true if and only if at least one type within the assembly contains
            extension methods. Note, this method is expensive since it potentially
            inspects all types within the assembly. The expectation is that this method is
            only called at emit time, when all types have been or will be traversed anyway.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol.GetUnusedFieldWarnings(System.Threading.CancellationToken)">
            <summary>
            Get the warnings for unused fields.  This should only be fetched when all method bodies have been compiled.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceClonedParameterSymbol">
            <summary>
            Represents a source parameter cloned from another <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol"/>, when they must share attribute data and default constant value.
            For example, parameters on a property symbol are cloned to generate parameters on accessors.
            Similarly parameters on delegate invoke method are cloned to delegate begin/end invoke methods.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbol">
            <summary>
            A source parameter, potentially with a default value, attributes, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbol.BoundAttributesSource">
            <summary>
            Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source parameter symbols.
            </summary>
            <remarks>
            Used for parameters of partial implementation. We bind the attributes only on the definition
            part and copy them over to the implementation.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbol.GetAttributeDeclarations">
            <summary>
            Gets the syntax list of custom attributes that declares attributes for this parameter symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbol.VerifyParamDefaultValueMatchesAttributeIfAny(Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Verify the default value matches the default value from any earlier attribute
            (DefaultParameterValueAttribute, DateTimeConstantAttribute or DecimalConstantAttribute).
            If not, report ERR_ParamDefaultValueDiffersFromAttribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbol.IsOnPartialImplementation(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>
            Is the attribute syntax appearing on a parameter of a partial method implementation part?
            Since attributes are merged between the parts of a partial, we need to look at the syntax where the
            attribute appeared in the source to see if it corresponds to a partial method implementation part.
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbol.HasDefaultArgumentSyntax">
            <summary>
            True if the parameter has default argument syntax.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceComplexParameterSymbol.HasOptionalAttribute">
            <summary>
            True if the parameter is marked by <see cref="T:System.Runtime.InteropServices.OptionalAttribute"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventAccessorSymbol">
            <summary>
            This class represents an event accessor declared in source 
            (i.e. not one synthesized for a field-like event).
            </summary>
            <remarks>
            The accessors are associated with <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol">
            <summary>
            This class represents an event declared in source with explicit accessors
            (i.e. not a field-like event).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEnumConstantSymbol">
            <summary>
            Represents a constant field of an enum.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventAccessorSymbol">
            <summary>
            Base class for event accessors - synthesized and user defined.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventFieldSymbol">
            <summary>
            A delegate field associated with a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol"/>.
            </summary>
            <remarks>
            SourceFieldSymbol takes care of the initializer (plus "var" in the interactive case).
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol">
            <summary>
            This class represents an event declared in source.  It may be either
            field-like (see <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol"/>) or property-like (see
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceCustomEventSymbol"/>).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.AttributeDeclarationSyntaxList">
            <summary>
            Gets the syntax list of custom attributes applied on the event symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol">
            <summary>
            This class represents an event declared in source without explicit accessors.
            It implicitly has thread safe accessors and an associated field (of the same
            name), unless it does not have an initializer and is either extern or inside
            an interface, in which case it only has accessors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol.AssociatedField">
            <summary>
            Backing field for field-like event. Will be null if the event
            has no initializer and is either extern or inside an interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbol.AttributeDeclarationSyntaxList">
            <summary>
            Gets the syntax list of custom attributes applied on the symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbol.VerifyConstantValueMatches(Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.DecodeWellKnownAttributeArguments{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData,Microsoft.CodeAnalysis.CSharp.Symbols.AttributeLocation}@)">
            <summary>
            Verify the constant value matches the default value from any earlier attribute
            (DateTimeConstantAttribute or DecimalConstantAttribute).
            If not, report ERR_FieldHasMultipleDistinctConstantValues.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldSymbolWithSyntaxReference.GetConstantValueDependencies(System.Boolean)">
            <summary>
            Return the constant value dependencies. Compute the dependencies
            if necessary by evaluating the constant value but only persist the
            constant value if there were no dependencies. (If there are dependencies,
            the constant value will be re-evaluated after evaluating dependencies.)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLabelSymbol._switchCaseLabelConstant">
            <summary>
            Switch case labels have a constant expression associated with them.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLabelSymbol.SwitchCaseLabelConstant">
            <summary>
            If the label is a switch case label, returns the associated constant value with
            case expression, otherwise returns null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol">
            <summary>
            Represents a local variable in a method body.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol._containingSymbol">
            <summary>
            Might not be a method symbol.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol._isSpecificallyNotPinned">
            <summary>
            There are three ways to initialize a fixed statement local:
              1) with an address;
              2) with an array (or fixed-size buffer); or
              3) with a string.
            
            In the first two cases, the resulting local will be emitted with a "pinned" modifier.
            In the third case, it is not the fixed statement local but a synthesized temp that is pinned.  
            Unfortunately, we can't distinguish these cases when the local is declared; we only know
            once we have bound the initializer.
            </summary>
            <remarks>
            CompareExchange doesn't support bool, so use an int.  First bit is true/false, second bit 
            is read/unread (debug-only).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.Name">
            <summary>
            Gets the name of the local variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.Locations">
            <summary>
            Gets the locations where the local symbol was originally defined in source.
            There should not be local symbols from metadata, and there should be only one local variable declared.
            TODO: check if there are multiple same name local variables - error symbol or local symbol?
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.LocalWithInitializer._constantTuple">
            <summary>
            Store the constant value and the corresponding diagnostics together
            to avoid having the former set by one thread and the latter set by
            another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceLocalSymbol.LocalWithInitializer.MakeConstantTuple(Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Determine the constant value of this local and the corresponding diagnostics.
            Set both to constantTuple in a single operation for thread safety.
            </summary>
            <param name="inProgress">Null for the initial call, non-null if we are in the process of evaluating a constant.</param>
            <param name="boundInitValue">If we already have the bound node for the initial value, pass it in to avoid recomputing it.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol">
            <summary>
            Represents a named type symbol whose members are declared in source.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.EffectiveAccessibility">
            <summary>
            Compute the "effective accessibility" of the current class for the purpose of warnings about unused fields.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.MembersAndInitializers">
            <summary>
            Encapsulates information about the non-type members of a (i.e. this) type.
              1) For non-initializers, symbols are created and stored in a list.
              2) For fields and properties, the symbols are stored in (1) and their initializers are
                 stored with other initialized fields and properties from the same syntax tree with
                 the same static-ness.
              3) For indexers, syntax (weak) references are stored for later binding.
            </summary>
            <remarks>
            CONSIDER: most types won't have indexers, so we could move the indexer list
            into a subclass to spare most instances the space required for the field.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.TryCalculateSyntaxOffsetOfPositionInInitializer(System.Int32,Microsoft.CodeAnalysis.SyntaxTree,System.Boolean,System.Int32,System.Int32@)">
            <summary>
            Calculates a syntax offset of a syntax position that is contained in a property or field initializer (if it is in fact contained in one).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetEarlyAttributeDecodingMembers">
            <summary>
            During early attribute decoding, we consider a safe subset of all members that will not
            cause cyclic dependencies.  Get all such members for this symbol.
            
            In particular, this method will return nested types and fields (other than auto-property
            backing fields).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetEarlyAttributeDecodingMembers(System.String)">
            <summary>
            During early attribute decoding, we consider a safe subset of all members that will not
            cause cyclic dependencies.  Get all such members for this symbol that have a particular name.
            
            In particular, this method will return nested types and fields (other than auto-property
            backing fields).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.MergeIndexersAndNonIndexers(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Merge (already ordered) non-type, non-indexer members with (already ordered) indexer members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.FixPartialMember(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol)">
            <summary>
            Fix up a partial method by combining its defining and implementing declarations, updating the array of symbols (by name),
            and returning the combined symbol.
            </summary>
            <param name="symbols">The symbols array containing both the latent and implementing declaration</param>
            <param name="part1">One of the two declarations</param>
            <param name="part2">The other declaration</param>
            <returns>An updated symbols array containing only one method symbol representing the two parts</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckForMemberConflictWithPropertyAccessor(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Report an error if a member (other than a method) exists with the same name
            as the property accessor, or if a method exists with the same name and signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckForMemberConflictWithEventAccessor(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Report an error if a member (other than a method) exists with the same name
            as the event accessor, or if a method exists with the same name and signature.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetAccessorOrPropertyLocation(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,System.Boolean)">
            <summary>
            Return the location of the accessor, or if no accessor, the location of the property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetAccessorOrEventLocation(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,System.Boolean)">
            <summary>
            Return the location of the accessor, or if no accessor, the location of the event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ParametersMatchPropertyAccessor(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol})">
            <summary>
            Return true if the method parameters match the parameters of the
            property accessor, including the value parameter for the setter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ParametersMatchEventAccessor(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol})">
            <summary>
            Return true if the method parameters match the parameters of the
            event accessor, including the value parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.GetSynthesizedExplicitImplementations(System.Threading.CancellationToken)">
            <summary>
            In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a 
            base type from another assembly) it is necessary for the compiler to generate explicit implementations for
            some interface methods.  They don't go in the symbol table, but if we are emitting, then we should
            generate code for them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.ReportAccessorOfInterfacePropertyOrEvent(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            It's not interesting to report diagnostics on implementation of interface accessors
            if the corresponding events or properties are not implemented (i.e. we want to suppress
            cascading diagnostics).
            Caveat: Indexed property accessors are always interesting.
            Caveat: It's also uninteresting if a WinRT event is implemented by a non-WinRT event,
            or vice versa.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.AddHidingAbstractDiagnostic(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@)">
            <summary>
            If necessary, report a diagnostic for a hidden abstract member.
            </summary>
            <returns>True if a diagnostic was reported.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.CheckInterfaceUnification(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            It is invalid for a type to directly (vs through a base class) implement two interfaces that
            unify (i.e. are the same for some substitution of type parameters).
            </summary>
            <remarks>
            CONSIDER: check this while building up InterfacesAndTheirBaseInterfaces (only in the SourceNamedTypeSymbol case).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.SynthesizeInterfaceMemberImplementation(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.SymbolAndDiagnostics,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Though there is a method that C# considers to be an implementation of the interface method, that
            method may not be considered an implementation by the CLR.  In particular, implicit implementation
            methods that are non-virtual or that have different (usually fewer) custom modifiers than the
            interface method, will not be considered CLR overrides.  To address this problem, we either make
            them virtual (in metadata, not in C#), or we introduce an explicit interface implementation that
            delegates to the implicit implementation.
            </summary>
            <param name="implementingMemberAndDiagnostics">Returned from FindImplementationForInterfaceMemberWithDiagnostics.</param>
            <param name="interfaceMember">The interface method or property that is being implemented.</param>
            <returns>Synthesized implementation or null if not needed.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.IsPossibleImplementationUnderRuntimeRules(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            The CLR will only look for an implementation of an interface method in a type that
              1) declares that it implements that interface; or
              2) is a base class of a type that declares that it implements the interface but not
                   a subtype of a class that declares that it implements the interface.
                   
            For example,
            
              interface I
              class A
              class B : A, I
              class C : B
              class D : C, I
            
            Suppose the runtime is looking for D's implementation of a member of I.  It will look in 
            D because of (1), will not look in C, will look in B because of (1), and will look in A
            because of (2).
            
            The key point is that it does not look in C, which C# *does*.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol.IsOverrideOfPossibleImplementationUnderRuntimeRules(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            If C# picks a different implementation than the CLR (see IsPossibleImplementationUnderClrRules), then we might
            still be okay, but dynamic dispath might result in C#'s choice getting called anyway.
            </summary>
            <remarks>
            This is based on SymbolPreparer::IsCLRMethodImplSame in the native compiler.
            
            ACASEY: What the native compiler actually does is compute the C# answer, compute the CLR answer,
            and then confirm that they override the same method.  What I've done here is check for the situations
            where the answers could disagree.  I believe the results will be equivalent.  If in doubt, a more conservative
            check would be implementingMethod.ContainingType.InterfacesAndTheirBaseInterfaces.Contains(@interface).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol._lazyTypeParameterConstraints">
            <summary>
            A collection of type parameter constraints, populated when
            constraints for the first type parameter is requested.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol._otherPartOfPartial">
            <summary>
            If this symbol represents a partial method definition or implementation part, its other part (if any).
            This should be set, if at all, before this symbol appears among the members of its owner.  
            The implementation part is not listed among the "members" of the enclosing type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol._constraintClauseBinder">
            <summary>
            A binder to use for binding generic constraints. The field is only non-null while the .ctor
            is executing, and allows constraints to be bound before the method is added to the
            containing type. (Until the method symbol has been added to the container, we cannot
            get a binder for the method without triggering a recursive attempt to bind the method.)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.OtherPartOfPartial">
            <summary>
            If this is a partial implementation part returns the definition part and vice versa.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.IsPartialDefinition">
            <summary>
            Returns true if this symbol represents a partial method definition (the part that specifies a signature but no body).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.IsPartialImplementation">
            <summary>
            Returns true if this symbol represents a partial method implementation (the part that specifies both signature and body).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.IsPartialWithoutImplementation">
            <summary>
            True if this is a partial method that doesn't have an implementation part.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.SourcePartialDefinition">
            <summary>
            Returns the implementation part of a partial method definition, 
            or null if this is not a partial method or it is the definition part.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.SourcePartialImplementation">
            <summary>
            Returns the definition part of a partial method implementation, 
            or null if this is not a partial method or it is the implementation part.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.PartialMethodChecks(Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Report differences between the defining and implementing
            parts of a partial method. Diagnostics are reported on the
            implementing part, matching Dev10 behavior.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol.HaveSameConstraints(Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol)">
            <summary>
            Returns true if the two partial methods have the same constraints.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.MethodChecks(Microsoft.CodeAnalysis.DiagnosticBag)">
            <remarks>
            Implementers should assume that a lock has been taken on MethodChecksLockObject.
            In particular, it should not (generally) be necessary to use CompareExchange to
            protect assignments to fields.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.MethodChecksLockObject">
            <summary>
            We can usually lock on the syntax reference of this method, but it turns
            out that some synthesized methods (e.g. field-like event accessors) also
            need to do method checks.  This property allows such methods to supply
            their own lock objects, so that we don't have to add a new field to every
            SourceMethodSymbol.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.Locations">
            <summary>
            Overridden by <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberMethodSymbol"/>, 
            which might return locations of partial methods.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.BoundAttributesSource">
            <summary>
            Symbol to copy bound attributes from, or null if the attributes are not shared among multiple source method symbols.
            </summary>
            <remarks>
            Used for example for event accessors. The "remove" method delegates attribute binding to the "add" method. 
            The bound attribute data are then applied to both accessors.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.GetAttributeDeclarations">
            <summary>
            Gets the syntax list of custom attributes that declares attributes for this method symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.GetReturnTypeAttributeDeclarations">
            <summary>
            Gets the syntax list of custom attributes that declares attributes for return type of this method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.GetDecodedReturnTypeWellKnownAttributeData">
            <summary>
            Returns information retrieved from custom attributes on return type in source, or null if the symbol is not source symbol or there are none.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.GetReturnTypeAttributesBag">
            <summary>
            Returns a bag of custom attributes applied on the method return value and data decoded from well-known attributes. Returns null if there are no attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.GetReturnTypeAttributes">
            <summary>
            Gets the attributes applied on the return value of this method symbol.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.CheckModifiersForBody(Microsoft.CodeAnalysis.Location,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Checks to see if a body is legal given the current modifiers.
            If it is not, a diagnostic is added with the current type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol.IsExpressionBodied">
            <summary>
            Returns true if the method body is an expression, as expressed
            by the <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax"/> syntax. False
            otherwise.
            </summary>
            <remarks>
            If the method has both block body and an expression body
            present, this is not treated as expression-bodied.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol">
            <summary>
            Represents the primary module of an assembly being built by compiler.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol._assemblySymbol">
            <summary>
            Owning assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol._sources">
            <summary>
            The declarations corresponding to the source files of this module.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol._name">
            <summary>
            The name (contains extension)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.DeclaringCompilation">
            <remarks>
            This override is essential - it's a base case of the recursive definition.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceModuleSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol._lazyTypeParameterConstraints">
            <summary>
            A collection of type parameter constraints, populated when
            constraints for the first type parameter are requested.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.AddSynthesizedAttributes(Microsoft.CodeAnalysis.CSharp.ModuleCompilationState,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData}@)">
            <remarks>
            These won't be returned by GetAttributes on source methods, but they
            will be returned by GetAttributes on metadata symbols.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.BaseTypeNoUseSiteDiagnostics">
            <summary>
            Gets the BaseType of this type. If the base type could not be determined, then 
            an instance of ErrorType is returned. If this kind of type does not have a base type
            (for example, interfaces), null is returned. Also the special class System.Object
            always has a BaseType of null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.InterfacesNoUseSiteDiagnostics(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            Gets the set of interfaces that this type directly implements. This set does not include
            interfaces that are base interfaces of directly implemented interfaces.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.IsRestrictedBaseType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Returns true if the type cannot be used as an explicit base class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.EnumUnderlyingType">
            <summary>
            For enum types, gets the underlying type. Returns null on all other
            kinds of types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamedTypeSymbol.EnumValueField">
            <summary>
            For enum types, returns the synthesized instance field used
            for generating metadata. Returns null for non-enum types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceNamespaceSymbol.RegisterDeclaredCorTypes">
            <summary>
            Register COR types declared in this namespace, if any, in the COR types cache.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol">
            <summary>
            Base class for parameters can be referred to from source code.
            </summary>
            <remarks>
            These parameters can potentially be targetted by an attribute specified in source code. 
            As an optimization we distinguish simple parameters (no attributes, no modifiers, etc.) and complex parameters.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol.HasOptionalAttribute">
            <summary>
            True if the parameter is marked by <see cref="T:System.Runtime.InteropServices.OptionalAttribute"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol.HasDefaultArgumentSyntax">
            <summary>
            True if the parameter has default argument syntax.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceParameterSymbolBase">
            <summary>
            Base class for all parameters that are emitted.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol.LocalAccessibility">
            <summary>
            Return Accessibility declared locally on the accessor, or
            NotApplicable if no accessibility was declared explicitly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol.GetAccessorName(System.String,System.Boolean,System.Boolean)">
            <summary>
            If we are outputing a .winmdobj then the setter name is put_, not set_.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertyAccessorSymbol.GetSyntax">
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax"/> or <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax"/>
            </returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol._sourceName">
            <summary>
            Set in constructor, might be changed while decoding <see cref="T:System.Runtime.CompilerServices.IndexerNameAttribute"/>.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.Name">
            <remarks>
            To facilitate lookup, all indexer symbols have the same name.
            Check the MetadataName property to find the name that will be
            emitted (based on IndexerNameAttribute, or the default "Item").
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.IsIndexer">
            <remarks>
            Even though it is declared with an IndexerDeclarationSyntax, an explicit
            interface implementation is not an indexer because it will not cause the
            containing type to be emitted with a DefaultMemberAttribute (and even if
            there is another indexer, the name of the explicit implementation won't
            match).  This is important for roundtripping.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.BackingField">
            <summary>
            Backing field for automatically implemented property, or
            for a property with an initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.IsAccessibilityMoreRestrictive(Microsoft.CodeAnalysis.Accessibility,Microsoft.CodeAnalysis.Accessibility)">
            <summary>
            Return true if the accessor accessibility is more restrictive
            than the property accessibility, otherwise false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.SynthesizedSealedAccessorOpt">
            <summary>
            If this property is sealed, then we have to emit both accessors - regardless of whether
            they are present in the source - so that they can be marked final. (i.e. sealed).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.MakeSynthesizedSealedAccessor">
            <remarks>
            Only non-null for sealed properties without both accessors.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.GetAttributesBag">
            <summary>
            Returns a bag of applied custom attributes and data decoded from well-known attributes. Returns null if there are no attributes applied on the symbol.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.GetDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.GetEarlyDecodedWellKnownAttributeData">
            <summary>
            Returns data decoded from special early bound well-known attributes applied to the symbol or null if there are no applied attributes.
            </summary>
            <remarks>
            Forces binding and decoding of attributes.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourcePropertySymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceSimpleParameterSymbol">
            <summary>
            A source parameter that has no default value, no attributes,
            and is not params.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbolBase">
            <summary>
            Base class for type and method type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbolBase.GetAttributes">
            <summary>
            Gets the attributes applied on this symbol.
            Returns an empty array if there are no attributes.
            </summary>
            <remarks>
            NOTE: This method should always be kept as a sealed override.
            If you want to override attribute binding logic for a sub-class, then override <see cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbolBase.GetAttributesBag"/> method.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SourceTypeParameterSymbolBase.CheckConstraintTypeConstraints(Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Check constraints of generic types referenced in constraint types. For instance,
            with "interface I&lt;T&gt; where T : I&lt;T&gt; {}", check T satisfies constraints
            on I&lt;T&gt;. Those constraints are not checked when binding ConstraintTypes
            since ConstraintTypes has not been set on I&lt;T&gt; at that point.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.OverriddenMethodTypeParameterMapBase">
            <summary>
            A map shared by all type parameters for an overriding method or a method
            that explicitly implements an interface. The map caches the overridden method
            and a type map from overridden type parameters to overriding type parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOverridingMethodTypeParameterSymbol">
            <summary>
            A type parameter for a method that either overrides a base
            type method or explicitly implements an interface method.
            </summary>
            <remarks>
            Exists to copy constraints from the corresponding type parameter of an overridden method.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SourceOverridingMethodTypeParameterSymbol.OverriddenTypeParameter">
            <summary>
            The type parameter to use for determining constraints. If there is a base
            method that the owner method is overriding, the corresponding type
            parameter on that method is used. Otherwise, the result is null.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAttributeData">
            <summary>
            Class to represent a synthesized attribute
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBuilder">
            <summary>
            A context for binding type parameter symbols.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterConstraintClause">
            <summary>
            A simple representation of a type parameter constraint clause
            as a set of constraint bits and a set of constraint types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SpecialTypeExtensions.IsIntegralType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            Checks if a type is considered a "built-in integral" by CLR.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SpecialTypeExtensions.IsIntrinsicType(Microsoft.CodeAnalysis.SpecialType)">
            <summary>
            The type is one of the simple types defined in Dev10 C#, see "predeftype.h"/simple
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SubstitutedNamedTypeSymbol">
            <summary>
            Either a SubstitutedNestedTypeSymbol or a ConstructedNamedTypeSymbol, which share in common that they
            have type parameters substituted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolCompletionState._completeParts">
            <summary>
            This field keeps track of the <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.CompletionPart"/>s for which we already retrieved
            diagnostics. We shouldn't return from ForceComplete (i.e. indicate that diagnostics are
            available) until this is equal to <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.CompletionPart.All"/>, except that when completing
            with a given position, we might not complete <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.CompletionPart"/>.Member*.
            
            Since completeParts is used as a flag indicating completion of other assignments 
            it must be volatile to ensure the read is not reordered/optimized to happen 
            before the writes.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolCompletionState.DefaultForceComplete(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Used to force (source) symbols to a given state of completion.
            </summary>
            <param name="symbol">The owning source symbol.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SymbolCompletionState.HasAtMostOneBitSet(System.Int32)">
            <remarks>
            Since this formula is rather opaque, a demonstration of its correctness is
            provided in Roslyn.Compilers.CSharp.UnitTests.CompletionTests.TestHasAtMostOneBitSet.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedAccessorValueParameterSymbol">
            <summary>
            Represents the compiler generated value parameter for property/event accessor.
            This parameter has no source location/syntax, but may have attributes.
            Attributes with 'param' target specifier on the accessor must be applied to the this parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedBackingFieldSymbol">
            <summary>
            Represents a compiler generated backing field for an automatically implemented property.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedContainer">
            <summary>
            A container synthesized for a lambda, iterator method, async method, or dynamic-sites.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEntryPointSymbol">
            <summary>
            Represents an interactive code entry point that is inserted into the compilation if there is not an existing one. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedEnumValueFieldSymbol">
            <summary>
            Represents __value field of an enum.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedFieldLikeEventAccessorSymbol">
            <summary>
            Event accessor that has been synthesized for a field-like event declared in source.
            </summary>
            <remarks>
            Associated with <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.SourceFieldLikeEventSymbol"/>.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedFieldSymbol">
            <summary>
            Represents a compiler generated field.
            </summary>
            <summary>
            Represents a compiler generated field of given type and name.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedFieldSymbolBase">
            <summary>
            Represents a compiler generated field.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedGlobalMethodSymbol">
            <summary>
            Represents a compiler generated synthesized method symbol
            that must be emitted in the compiler generated
            PrivateImplementationDetails class
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedGlobalMethodSymbol.ContainingSymbol">
            <summary>
            Synthesized methods that must be emitted in the compiler generated
            PrivateImplementationDetails class have null containing type symbol.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedInstanceMethodSymbol">
            <summary>
            A base class for synthesized methods that want a this parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedInstanceMethodSymbol.ObsoleteAttributeData">
            <summary>
            Returns data decoded from Obsolete attribute or null if there is no Obsolete attribute.
            This property returns ObsoleteAttributeData.Uninitialized if attribute arguments haven't been decoded yet.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedLocal">
            <summary>
            A synthesized local variable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedParameterSymbol">
            <summary>
            Represents a simple compiler generated parameter of a given type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedParameterSymbol.DeriveParameters(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            For each parameter of a source method, construct a corresponding synthesized parameter
            for a destination method.
            </summary>
            <param name="sourceMethod">Has parameters.</param>
            <param name="destinationMethod">Needs parameters.</param>
            <returns>Synthesized parameters to add to destination method.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.SynthesizedSubstitutedTypeParameterSymbol">
            <summary>
            A type parameter for a synthesized class or method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeMap">
            <summary>
            Utility class for substituting actual type arguments for formal generic type parameters.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds">
            <summary>
            The effective "bounds" of a type parameter: the constraint types, effective
            interface set, and effective base type, determined from the declared
            constraints, with any cycles removed. The fields are exposed by the
            TypeParameterSymbol as ConstraintTypes, Interfaces, and BaseType.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds.ConstraintTypes">
            <summary>
            The type parameters, classes, and interfaces explicitly declared as
            constraint types on the containing type parameter, with cycles removed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds.Interfaces">
            <summary>
            The set of interfaces explicitly declared on the containing type
            parameter and any type parameters on which the containing
            type parameter depends, with duplicates removed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds.EffectiveBaseClass">
            <summary>
            As defined in 10.1.5 of the specification.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterBounds.DeducedBaseType">
            <summary>
            The "exact" effective base type. 
            In the definition of effective base type we abstract some concrete types to their base classes:
             * For each constraint of T that is a struct-type, R contains System.ValueType.
             * For each constraint of T that is an enumeration type, R contains System.Enum.
             * For each constraint of T that is a delegate type, R contains System.Delegate.
             * For each constraint of T that is an array type, R contains System.Array.
             * For each constraint of T that is a class-type C, R contains type C' which is constructed 
               from C by replacing all occurrences of dynamic with object.
            The reason is that the CLR doesn't support operations on generic parameters that would be needed 
            to work with these types. For example, ldelem instruction requires the receiver to be a specific array, 
            not a type parameter constrained to be an array.
            
            When computing the deduced type we don't perform this abstraction. We keep the original constraint T.
            Deduced base type is used to check that consistency rules are satisfied.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol">
            <summary>
            A TypeSymbol is a base class for all the symbols that represent a type
            in C#.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.EqualsIgnoringDynamicComparer">
            <summary>
            A comparator that treats dynamic and object as "the same" types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.OriginalDefinition">
            <summary>
            The original definition of this symbol. If this symbol is constructed from another
            symbol by type substitution then OriginalDefinition gets the original symbol as it was defined in
            source or metadata.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.BaseType">
            <summary>
            Gets the BaseType of this type. If the base type could not be determined, then 
            an instance of ErrorType is returned. If this kind of type does not have a base type
            (for example, interfaces), null is returned. Also the special class System.Object
            always has a BaseType of null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.Interfaces">
            <summary>
            Gets the set of interfaces that this type directly implements. This set does not include
            interfaces that are base interfaces of directly implemented interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.AllInterfaces">
            <summary>
            The list of all interfaces of which this type is a declared subtype, excluding this type
            itself. This includes all declared base interfaces, all declared base interfaces of base
            types, and all declared base interfaces of those results (recursively).  Each result
            appears exactly once in the list. This list is topologically sorted by the inheritance
            relationship: if interface type A extends interface type B, then A precedes B in the
            list. This is not quite the same as "all interfaces of which this type is a proper
            subtype" because it does not take into account variance: AllInterfaces for
            IEnumerable&lt;string&gt; will not include IEnumerable&lt;object&gt;
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.EffectiveTypeNoUseSiteDiagnostics">
            <summary>
            If this is a type parameter returns its effective base class, otherwise returns this type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsDerivedFrom(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Returns true if this type derives from a given type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsEqualToOrDerivedFrom(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo}@)">
            <summary>
            Returns true if this type si equal or derives from a given type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.Equals(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Determines if this type symbol represent the same type as another, according to the language
            semantics.
            </summary>
            <param name="t2">The other type.</param>
            <param name="ignoreCustomModifiers">True to compare without regard to custom modifiers, false by default.</param>
            <param name="ignoreDynamic">True to ignore the distinction between object and dynamic, false by default.</param>
            <returns>True if the types are equivalent.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.GetHashCode">
            <summary>
            We ignore custom modifiers, and the distinction between dynamic and object, when computing a type's hash code.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.MakeAllInterfaces">
            Produce all implemented interfaces in topologically sorted order. We use
            TypeSymbol.Interfaces as the source of edge data, which has had cycles and infinitely
            long dependency cycles removed. Consequently, it is possible (and we do) use the
            simplest version of Tarjan's topological sorting algorithm.
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.InterfacesAndTheirBaseInterfacesNoUseSiteDiagnostics">
            <summary>
            Gets the set of interfaces that this type directly implements, plus the base interfaces
            of all such types.
            </summary>
            <remarks>
            CONSIDER: it probably isn't truly necessary to cache this.  If space gets tight, consider
            alternative approaches (recompute every time, cache on the side, only store on some types,
            etc).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.FindImplementationForInterfaceMember(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Returns the corresponding symbol in this type or a base type that implements 
            interfaceMember (either implicitly or explicitly), or null if no such symbol exists
            (which might be either because this type doesn't implement the container of
            interfaceMember, or this type doesn't supply a member that successfully implements
            interfaceMember).
            </summary>
            <param name="interfaceMember">
            Must be a non-null interface property, method, or event.
            </param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsReferenceType">
            <summary>
            Returns true if this type is known to be a reference type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsValueType">
            <summary>
            Returns true if this type is known to be a value type. It is never the case that
            IsReferenceType and IsValueType both return true. However, for an unconstrained type
            parameter, IsReferenceType and IsValueType will both return false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.TypeKind">
            <summary>
            Gets the kind of this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.SpecialType">
            <summary>
            Gets corresponding special TypeId of this type.
            </summary>
            <remarks>
            Not preserved in types constructed from this one.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.PrimitiveTypeCode">
            <summary>
            Gets corresponding primitive type code for this type declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.HighestPriorityUseSiteError">
            <summary>
            Return error code that has highest priority while calculating use site error for this symbol. 
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsAnonymousType">
            <summary>
            Is this a symbol for an anonymous type (including delegate).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsManagedType">
            <summary>
            Is this type a managed type (false for everything but enum, pointer, and
            some struct types).
            </summary>
            <remarks>
            See Type::computeManagedType.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.ComputeImplementationForInterfaceMember(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Performs interface mapping (spec 13.4.4).
            </summary>
            <remarks>
            CONSIDER: we could probably do less work in the metadata and retargeting cases - we won't use the diagnostics.
            </remarks>
            <param name="interfaceMember">A non-null property on an interface type.</param>
            <param name="implementingType">The type implementing the interface property (usually "this").</param>
            <param name="diagnostics">Bag to which to add diagnostics.</param>
            <returns>The implementing property or null, if there isn't one.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsExplicitlyImplementedViaAccessors(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol@)">
            <summary>
            Since dev11 didn't expose a symbol API, it had the luxury of being able to accept a base class's claim that 
            it implements an interface.  Roslyn, on the other hand, needs to be able to point to an implementing symbol
            for each interface member.
            
            DevDiv #718115 was triggered by some unusual metadata in a Microsoft reference assembly (Silverlight System.Windows.dll).
            The issue was that a type explicitly implemented the accessors of an interface event, but did not tie them together with
            an event declaration.  To make matters worse, it declared its own protected event with the same name as the interface
            event (presumably to back the explicit implementation).  As a result, when Roslyn was asked to find the implementing member
            for the interface event, it found the protected event and reported an appropriate diagnostic.  Would it should have done
            (and does do now) is recognize that no event associated with the accessors explicitly implementing the interface accessors
            and returned null.
            
            We resolved this issue by introducing a new step into the interface mapping algorithm: after failing to find an explicit
            implementation in a type, but before searching for an implicit implementation in that type, check for an explicit implementation
            of an associated accessor.  If there is such an implementation, then immediately return the associated property or event,
            even if it is null.  That is, never attempt to find an implicit implementation for an interface property or event with an
            explicitly implemented accessor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.CheckForImplementationOfCorrespondingPropertyOrEvent(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbol@)">
            <summary>
            If we were looking for an accessor, then look for an accessor on the implementation of the
            corresponding interface property/event.  If it is valid as an implementation (ignoring the name),
            then prefer it to our current result if:
              1) our current result is null; or
              2) our current result is on the same type.
              
            If there is no corresponding accessor on the implementation of the corresponding interface
            property/event and we found an accessor, then the accessor we found is invalid, so clear it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.ReportImplicitImplementationMatchDiagnostics(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            These diagnostics are for members that do implicitly implement an interface member, but do so
            in an undesirable way.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.ReportImplicitImplementationMismatchDiagnostics(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            These diagnostics are for members that almost, but not actually, implicitly implement an interface member.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.FindPotentialImplicitImplementationMemberDeclaredInType(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbol@,Microsoft.CodeAnalysis.CSharp.Symbol@)">
            <summary>
            Search the declared members of a type for one that could be an implementation
            of a given interface member (depending on interface declarations).
            </summary>
            <param name="interfaceMember">The interface member being implemented.</param>
            <param name="implementingTypeIsFromSomeCompilation">True if the implementing type is from some compilation (i.e. not from metadata).</param>
            <param name="currType">The type on which we are looking for a declared implementation of the interface member.</param>
            <param name="implicitImpl">A member on currType that could implement the interface, or null.</param>
            <param name="closeMismatch">A member on currType that could have been an attempt to implement the interface, or null.</param>
            <remarks>
            There is some similarity between this member and MemberSymbol.FindOverriddenOrHiddenMembersInType.
            When making changes to this member, think about whether or not they should also be applied in MemberSymbol.
            One key difference is that custom modifiers are considered when looking up overridden members, but
            not when looking up implicit implementations.  We're preserving this behavior from Dev10.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.IsInterfaceMemberImplementation(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean)">
             <summary>
             To implement an interface member, a candidate member must be public, non-static, and have
             the same signature.  "Have the same signature" has a looser definition if the type implementing
             the interface is from source.
             </summary>
             <remarks>
             PROPERTIES:
             NOTE: we're not checking whether this property has at least the accessors
             declared in the interface.  Dev10 considers it a match either way and,
             reports failure to implement accessors separately.
            
             If the implementing type (i.e. the type with the interface in its interface
             list) is in source, then we can ignore custom modifiers in/on the property
             type because they will be copied into the bridge property that explicitly
             implements the interface property (or they would be, if we created such
             a bridge property).  Bridge *methods* (not properties) are inserted in 
             SourceNamedTypeSymbol.ImplementInterfaceMember.
            
             CONSIDER: The spec for interface mapping (13.4.4) could be interpreted to mean that this
             property is not an implementation unless it has an accessor for each accessor of the
             interface property.  For now, we prefer to represent that case as having an implemented
             property and an unimplemented accessor because it makes finding accessor implementations
             much easier.  If we decide that we want the API to report the property as unimplemented,
             then it might be appropriate to keep current result internally and just check the accessors
             before returning the value from the public API (similar to the way MethodSymbol.OverriddenMethod
             filters MethodSymbol.OverriddenOrHiddenMembers.
             </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.AbstractMembers">
            <summary>
            The set of abstract members in declared in this type or declared in a base type and not overridden.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol.SymbolAndDiagnostics">
            <summary>
            Represents the method by which this type implements a given interface type
            and/or the corresponding diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsValidAttributeParameterType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Determines if the given type is a valid attribute parameter type.
            </summary>
            <param name="type">Type to validated</param>
            <param name="compilation">compilation</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetAttributeParameterTypedConstantKind(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Gets the typed constant kind for the given attribute parameter type.
            </summary>
            <param name="type">Type to validated</param>
            <param name="compilation">compilation</param>
            <returns>TypedConstantKind for the attribute parameter type.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsExpressionTree(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            return true if the type is constructed from System.Linq.Expressions.Expression`1
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsPossibleArrayGenericInterface(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            return true if the type is constructed from a generic interface that 
            might be implemented by an array.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetDefaultValue(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return the default value constant for the given type,
            or null if the default value is not a constant.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.VisitType``1(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Func{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,``0,System.Boolean,System.Boolean},``0)">
            <summary>
            Visit the given type and, in the case of compound types, visit all "sub type"
            (such as A in A[], or { A&lt;T&gt;, T, U } in A&lt;T&gt;.B&lt;U&gt;) invoking 'predicate'
            with the type and 'arg' at each sub type. If the predicate returns true for any type,
            traversal stops and that type is returned from this method. Otherwise if traversal
            completes without the predicate returning true for any type, this method returns null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.ContainsTypeParameter(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol)">
            <summary>
            (null TypeParameterSymbol "parameter"): Checks if the given type is a type parameter 
            or its referent type is a type parameter (array/pointer) or contains a type parameter (aggregate type)
            (non-null TypeParameterSymbol "parameter"): above + also checks if the type parameter
            is the same as "parameter"
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.ContainsDynamic(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return true if the type contains any dynamic type reference.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetNonErrorGuess(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Guess the non-error type that the given type was intended to represent.
            If the type itself is not an error type, then it will be returned.
            Otherwise, the underlying type (if any) of the error type will be
            returned.
            </summary>
            <remarks>
            Any non-null type symbol returned is guaranteed not to be an error type.
            
            It is possible to pass in a constructed type and received back an 
            unconstructed type.  This can occur when the type passed in was
            constructed from an error type - the underlying definition will be
            available, but there won't be a good way to "re-substitute" back up
            to the level of the specified type.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetNonErrorTypeKindGuess(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Guess the non-error typekind that the given type was intended to represent,
            if possible. If not, return TypeKind.Error.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsValidSwitchGoverningType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Returns true if the type is a valid switch expression type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsRestrictedType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Returns true if the type is one of the restricted types, namely: <see cref="T:System.TypedReference"/>, 
            <see cref="T:System.ArgIterator"/>, or <see cref="T:System.RuntimeArgumentHandle"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.MarkCheckedIfNecessary(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol}@)">
            <summary>
            Add this instance to the set of checked types. Returns true
            if this was added, false if the type was already in the set.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsPrimitiveRecursiveStruct(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            These special types are structs that contain fields of the same type
            (e.g. <see cref="T:System.Int32"/> contains an instance field of type <see cref="T:System.Int32"/>).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.ComputeHashCode(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Compute a hash code for the constructed type. The return value will be
            non-zero so callers can used zero to represent an uninitialized value.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.AsDynamicIfNoPia(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            If we are in a COM PIA with embedInteropTypes enabled we should turn properties and methods 
            that have the type and return type of object, respectively, into type dynamic. If the requisite conditions 
            are fulfilled, this method returns a dynamic type. If not, it returns the original type.
            </summary>
            <param name="type">A property type or method return type to be checked for dynamification.</param>
            <param name="containingType">Containing type.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsVerifierReference(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Type variables are never considered reference types by the verifier.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.IsVerifierValue(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Type variables are never considered value types by the verifier.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetAllTypeParameters(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Return all of the type parameters in this type and enclosing types,
            from outer-most to inner-most type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetAllTypeParameters(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol})">
            <summary>
            Return all of the type parameters in this type and enclosing types,
            from outer-most to inner-most type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.FindEnclosingTypeParameter(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.String)">
            <summary>
            Return the nearest type parameter with the given name in
            this type or any enclosing type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.HasNameQualifier(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.String)">
            <summary>
            Return true if the fully qualified name of the type's containing symbol
            matches the given name. This method avoids string concatenations
            in the common case where the type is a top-level type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.CustomModifierCount(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Count the custom modifiers within the specified TypeSymbol.
            Potentially non-zero for arrays, pointers, and generic instantiations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.HasCustomModifiers(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Check for custom modifiers within the specified TypeSymbol.
            Potentially true for arrays, pointers, and generic instantiations.
            </summary>
            <remarks>
            A much less efficient implementation would be CustomModifierCount() == 0.
            CONSIDER: Could share a backing method with CustomModifierCount.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.CanUnifyWith(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Return true if this type can unify with the specified type
            (i.e. is the same for some substitution of type parameters).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbolExtensions.GetNextBaseTypeNoUseSiteDiagnostics(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbol},Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.Collections.PooledHashSet{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol}@)">
            <summary>
            Used when iterating through base types in contexts in which the caller needs to avoid cycles and can't use BaseType
            (perhaps because BaseType is in the process of being computed)
            </summary>
            <param name="type"></param>
            <param name="basesBeingResolved"></param>
            <param name="compilation"></param>
            <param name="visited"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety">
            <summary>
            This class groups together all of the functionality needed to check for error CS1961, ERR_UnexpectedVariance.
            Its functionality is accessible through the NamedTypeSymbol extension method CheckInterfaceVarianceSafety and
            the MethodSymbol extension method CheckMethodVarianceSafety (for checking delegate Invoke).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckInterfaceVarianceSafety(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckDelegateVarianceSafety(Microsoft.CodeAnalysis.CSharp.Symbols.SourceDelegateMethodSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of a delegate.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckMethodVarianceSafety(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckPropertyVarianceSafety(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface property.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckEventVarianceSafety(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckParametersVarianceSafety(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol},Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface method/property parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.CheckTypeParametersVarianceSafety(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol},Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Accumulate diagnostics related to the variance safety of an interface method type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.IsVarianceUnsafe``1(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.LocationProvider{``0},``0,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Returns true if the type is output-unsafe or input-unsafe, as defined in the C# spec.
            Roughly, a type is output-unsafe if it could not be the return type of a method and
            input-unsafe if it could not be a parameter type of a method.
            </summary>
            <remarks>
            This method is intended to match spec section 13.1.3.1 as closely as possible 
            (except that the output-unsafe and input-unsafe checks are merged).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.IsVarianceUnsafe``1(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.LocationProvider{``0},``0,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            3) T is an interface, class, struct, enum, or delegate type <![CDATA[S<A_1, ..., A_k>]]> constructed
            from a generic type <![CDATA[S<X_1, ..., X_k>]]> where for at least one A_i one
            of the following holds:
                a) X_i is covariant or invariant and A_i is output-unsafe [input-unsafe]
                b) X_i is contravariant or invariant and A_i is input-unsafe [output-unsafe] (note: spec has "input-safe", but it's a typo)
            </summary>
            <remarks>
            Slight rewrite to make it more idiomatic for C#:
                a) X_i is covariant and A_i is input-unsafe
                b) X_i is contravariant and A_i is output-unsafe
                c) X_i is invariant and A_i is input-unsafe or output-unsafe
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.AddVarianceError``1(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.VarianceSafety.LocationProvider{``0},``0,Microsoft.CodeAnalysis.CSharp.MessageID)">
            <summary>
            Add an ERR_UnexpectedVariance diagnostic to the diagnostic bag.
            </summary>
            <param name="diagnostics">Diagnostic bag.</param>
            <param name="unsafeTypeParameter">Type parameter that is not variance safe.</param>
            <param name="context">Context in which type is not variance safe (e.g. method).</param>
            <param name="locationProvider">Callback to provide location.</param>
            <param name="locationArg">Callback argument.</param>
            <param name="expectedVariance">Desired variance of type.</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker">
            <summary>
            Traverses the symbol table checking for CLS compliance.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.CheckCompliance(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.DiagnosticBag,System.Threading.CancellationToken,Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Traverses the symbol table checking for CLS compliance.
            </summary>
            <param name="compilation">Compilation that owns the symbol table.</param>
            <param name="diagnostics">Will be supplemented with documentation comment diagnostics.</param>
            <param name="cancellationToken">To stop traversing the symbol table early.</param>
            <param name="filterTree">Only report diagnostics from this syntax tree, if non-null.</param>
            <param name="filterSpanWithinTree">If <paramref name="filterTree"/> and <paramref name="filterSpanWithinTree"/> is non-null, report diagnostics within this span in the <paramref name="filterTree"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.VisitTypeOrMember(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.Compliance)">
            <returns>False if no further checks are required (because they would be cascading).</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.CheckForAttributeWithArrayArgumentInternal(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.CSharpAttributeData})">
            <remarks>
            BREAK: Dev11 reports WRN_CLS_ArrayArgumentToAttribute on all symbols, whereas roslyn reports it only
            on accessible symbols.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.CheckForDeclarationWithoutAssemblyDeclaration(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.Compliance)">
            <returns>True if the symbol is okay (i.e. no warnings).</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.CheckSymbolDistinctness(Microsoft.CodeAnalysis.CSharp.Symbol,System.String,Roslyn.Utilities.MultiDictionary{System.String,Microsoft.CodeAnalysis.CSharp.Symbol}.ValueSet)">
            <remarks>
            NOTE: Dev11 behavior - First, it ignores arity,
            which seems like a good way to disambiguate symbols (in particular,
            CLS Rule 43 says that the name includes backtick-arity).  Second, it
            does not consider two members with identical names (i.e. not differing
            in case) to collide.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.IsInaccessibleBecauseOfConstruction(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <remarks>
            This check (the only one that uses the "context" parameter is based on CLS Rule 46,
            as implemented by LangCompiler::IsCLSAccessible.  The idea is that C&lt;int&gt; and C&lt;char&gt;
            are separate types in CLS, so they can't touch eachother's protected members.
            TODO: This should really have a separate error code - it's logically separate and requires explanation.
            </remarks>
            <param name="type">Check the accessibility of this type (probably a parameter or return type).</param>
            <param name="context">Context for the accessibility check (e.g. containing type of method with <paramref name="type"/> as a parameter type.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.GetDeclaredCompliance(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.Location@)">
            <remarks>
            As in dev11, we ignore the fact that CLSCompliantAttribute is inherited (i.e. from the base type)
            (see CSemanticChecker::CheckSymForCLS).  This should only affect types where the syntactic parent
            and the inheritance parent disagree.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ClsComplianceChecker.TryGetCollisionErrorCode(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.ErrorCode@)">
            <remarks>
            Based on CompilationPass::CLSReduceSignature.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler">
            <summary>
            Traverses the symbol table processing XML documentation comments and optionally writing them to
            a provided stream.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.WriteDocumentationCommentXml(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.String,System.IO.Stream,Microsoft.CodeAnalysis.DiagnosticBag,System.Threading.CancellationToken,Microsoft.CodeAnalysis.SyntaxTree,System.Nullable{Microsoft.CodeAnalysis.Text.TextSpan})">
            <summary>
            Traverses the symbol table processing XML documentation comments and optionally writing them to
            a provided stream.
            </summary>
            <param name="compilation">Compilation that owns the symbol table.</param>
            <param name="assemblyName">Assembly name override, if specified. Otherwise the <see cref="P:Microsoft.CodeAnalysis.ISymbol.Name"/> of the source assembly is used.</param>
            <param name="xmlDocStream">Stream to which XML will be written, if specified.</param>
            <param name="diagnostics">Will be supplemented with documentation comment diagnostics.</param>
            <param name="cancellationToken">To stop traversing the symbol table early.</param>
            <param name="filterTree">Only report diagnostics from this syntax tree, if non-null.</param>
            <param name="filterSpanWithinTree">If <paramref name="filterTree"/> and filterSpanWithinTree is non-null, report diagnostics within this span in the <paramref name="filterTree"/>.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetDocumentationCommentXml(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,System.Threading.CancellationToken)">
            <summary>
            Gets the XML that would be written to the documentation comment file for this assembly.
            </summary>
            <param name="symbol">The symbol for which to retrieve documentation comments.</param>
            <param name="processIncludes">True to treat includes as semantically meaningful (pull in contents from other files and bind crefs, etc).</param>
            <param name="cancellationToken">To stop traversing the symbol table early.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.VisitNamespace(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol)">
            <summary>
            Write header, descend into members, and write footer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.VisitNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Write own documentation comments and then descend into members.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Compile documentation comments on the symbol and write them to the stream if one is provided.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.TryProcessDocumentationCommentTriviaNodes(Microsoft.CodeAnalysis.CSharp.Symbol,System.Boolean,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax},System.Boolean,System.String@,System.Boolean@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode}@)">
            <summary>
            Loop over the DocumentationCommentTriviaSyntaxes.  Gather
              1) concatenated XML, as a string;
              2) whether or not the XML is valid;
              3) set of type parameters covered by &lt;typeparam&gt; elements;
              4) set of parameters covered by &lt;param&gt; elements;
              5) list of &lt;include&gt; elements, as SyntaxNodes.
            </summary>
            <returns>True, if at least one documentation comment was processed; false, otherwise.</returns>
            <remarks>This was factored out for clarity, not because it's reusable.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetParameters(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            Similar to SymbolExtensions.GetParameters, but returns empty for unsupported symbols
            and handles delegates.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetTypeParameters(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            Similar to SymbolExtensions.GetMemberTypeParameters, but returns empty for unsupported symbols.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.RequiresDocumentationComment(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            A symbol requires a documentation comment if it was explicitly declared and
            will be visible outside the current assembly (ignoring InternalsVisibleTo).
            Exception: accessors do not require doc comments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.TryGetDocumentationCommentNodes(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.DocumentationMode@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax}@)">
            <summary>
            Get all of the DocumentationCommentTriviaSyntax associated with any declaring syntax of the
            given symbol (except for partial methods, which only consider the part with the body).
            </summary>
            <returns>True if the nodes are all valid XML.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.FormatComment(System.String)">
            <summary>
            Given the full text of a documentation comment, strip off the comment punctuation (///, /**, etc)
            and add appropriate indentations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetIndexOfFirstNonWhitespaceChar(System.String)">
            <summary>
            Given a string, find the index of the first non-whitespace char.
            </summary>
            <param name="str">The string to search</param>
            <returns>The index of the first non-whitespace char in the string</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetIndexOfFirstNonWhitespaceChar(System.String,System.Int32,System.Int32)">
            <summary>
            Find the first non-whitespace character in a given substring.
            </summary>
            <param name="str">The string to search</param>
            <param name="start">The start index</param>
            <param name="end">The last index (non-inclusive)</param>
            <returns>The index of the first non-whitespace char after index start in the string up to, but not including the end index</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.TrimmedStringStartsWith(System.String,System.String)">
            <summary>
            Determine if the given string starts with the given prefix if whitespace
            is first trimmed from the beginning.
            </summary>
            <param name="str">The string to search</param>
            <param name="prefix">The prefix</param>
            <returns>true if str.TrimStart().StartsWith(prefix)</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.IndexOfNewLine(System.String,System.Int32,System.Int32@)">
            <summary>
            Given a string which may contain newline sequences, get the index of the first newline
            sequence beginning at the given starting index.
            </summary>
            <param name="str">The string to split.</param>
            <param name="start">The starting index within the string.</param>
            <param name="newLineLength">The length of the newline sequence discovered. 0 if the end of the string was reached, otherwise either 1 or 2 chars</param>
            <returns>The index of the start of the first newline sequence following the start index</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.WriteFormattedSingleLineComment(System.String)">
            <summary>
            Given the full text of a single-line style documentation comment, for each line, strip off
            the comment punctuation (///) and add appropriate indentations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.WriteFormattedMultiLineComment(System.String[],System.Int32)">
            <summary>
            Given the full text of a multi-line style documentation comment, broken into lines, strip off
            the comment punctuation (/**, */, etc) and add appropriate indentations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.TrimEndOfMultiLineComment(System.String)">
            <summary>
            Remove "*/" and any following text, if it is present.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.FindMultiLineCommentPattern(System.String)">
            <summary>
            Return the longest prefix matching [whitespace]*[*][whitespace]*.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.LongestCommonPrefix(System.String,System.String)">
            <summary>
            Return the longest common prefix of two strings
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetDocumentationCommentId(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Bind a CrefSyntax and unwrap the result if it's an alias.
            </summary>
            <remarks>
            Does not respect DocumentationMode, so use a temporary bag if diagnostics are not desired.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.ToBadCrefString(Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax)">
            <summary>
            Given a cref syntax that cannot be resolved, get the string that will be written to
            the documentation file in place of a documentation comment ID.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.BindName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax,Microsoft.CodeAnalysis.CSharp.Binder,Microsoft.CodeAnalysis.CSharp.Symbol,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol}@,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Bind an XmlNameAttributeSyntax and update the sets of documented parameters and type parameters.
            </summary>
            <remarks>
            Does not respect DocumentationMode, so do not call unless diagnostics are desired.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.GetDescription(System.Xml.XmlException)">
            <remarks>
            WORKAROUND:
            We're taking a dependency on the location and structure of a framework assembly resource.  This is not a robust solution.
            
            Possible alternatives:
            1) Polish our XML parser until it matches MSXML.  We don't want to reinvent the wheel.
            2) Build a map that lets us go from XML string positions back to source positions.  
            This is what the native compiler did, and it was a lot of work.  We'd also still need to modify the message.
            3) Do not report a diagnostic.  This is very unhelpful.
            4) Report a vague diagnostic (i.e. there's a problem somewhere in this doc comment).  This is relatively unhelpful.
            5) Always report the message in English, so that we can pull it apart without needing to consume resource files.
            This engenders a lot of ill will.
            6) Report the exception message without modification and (optionally) include the text with respect to which the
            position is specified.  This would not look sufficiently polished.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.DocumentationCommentWalker">
            <summary>
            Walks a DocumentationCommentTriviaSyntax, binding the semantically meaningful parts 
            to produce diagnostics and to replace source crefs with documentation comment IDs.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.DocumentationCommentWalker.GetSubstitutedText(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol}@,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol}@)">
            <summary>
            Given a DocumentationCommentTriviaSyntax, return the full text, but with
            documentation comment IDs substituted into crefs.
            </summary>
            <remarks>
            Still has all of the comment punctuation (///, /**, etc).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.IncludeElementExpander.RewriteMany(System.Xml.Linq.XNode[],System.String,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <remarks>
            Rewrites nodes in <paramref name="nodes"/>, which is a snapshot of nodes from the original document.
            We're mutating the tree as we rewrite, so it's important to grab a snapshot of the
            nodes that we're going to reparent before we enumerate them.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.IncludeElementExpander.RewriteIncludeElement(System.Xml.Linq.XElement,System.String,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.String@)">
            <remarks>
            This method boils down to Rewrite(XDocument.Load(fileAttrValue).XPathSelectElements(pathAttrValue)).  
            Everything else is error handling.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.IncludeElementExpander.RecordSyntaxDiagnostics(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.Location)">
            <remarks>
            Respects the DocumentationMode at the source location.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DocumentationCommentCompiler.IncludeElementExpander.RecordBindingDiagnostics(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.Location)">
            <remarks>
            Respects the DocumentationMode at the source location.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodCompiler.CompileSynthesizedExplicitImplementations(Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol,Microsoft.CodeAnalysis.CSharp.TypeCompilationState)">
            <summary>
            In some circumstances (e.g. implicit implementation of an interface method by a non-virtual method in a 
            base type from another assembly) it is necessary for the compiler to generate explicit implementations for
            some interface methods.  They don't go in the symbol table, but if we are emitting, then we should
            generate code for them.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodCompiler.ChainImplicitStructConstructor(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberContainerTypeSymbol)">
            <summary>
            Synthesized parameterlesss constructors in structs chain to the "default" constructor
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodCompiler.BindConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Bind the (implicit or explicit) constructor initializer of a constructor symbol.
            </summary>
            <param name="constructor">Constructor method.</param>
            <param name="diagnostics">Accumulates errors (e.g. access "this" in constructor initializer).</param>
            <param name="compilation">Used to retrieve binder.</param>
            <returns>A bound expression for the constructor initializer call.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodCompiler.HasThisConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Returns true if the method is a constructor and has a this() constructor initializer.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer">
            <summary>
            Contains methods related to synthesizing bound nodes in initial binding 
            form that needs lowering, primarily method bodies for compiler-generated methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.MakeSubmissionInitialization(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <summary>
            Generates a submission initialization part of a Script type constructor that represents an interactive submission.
            </summary>
            <remarks>
            The constructor takes a parameter of type Microsoft.CodeAnalysis.Scripting.Session - the session reference.
            It adds the object being constructed into the session by calling Microsoft.CSharp.RuntimeHelpers.SessionHelpers.SetSubmission,
            and retrieves strongly typed references on all previous submission script classes whose members are referenced by this submission.
            The references are stored to fields of the submission (<paramref name="synthesizedFields"/>).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.ConstructAutoPropertyAccessorBody(Microsoft.CodeAnalysis.CSharp.Symbols.SourceMethodSymbol)">
            <summary>
            Construct a body for an auto-property accessor (updating or returning the backing field).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.ConstructFieldLikeEventAccessorBody(Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generate an accessor for a field-like event.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.ConstructFieldLikeEventAccessorBody_WinRT(Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generate a thread-safe accessor for a WinRT field-like event.
            
            Add:
              return EventRegistrationTokenTable&lt;Event&gt;.GetOrCreateEventRegistrationTokenTable(ref _tokenTable).AddEventHandler(value);
            
            Remove:
              EventRegistrationTokenTable&lt;Event&gt;.GetOrCreateEventRegistrationTokenTable(ref _tokenTable).RemoveEventHandler(value);
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.ConstructFieldLikeEventAccessorBody_Regular(Microsoft.CodeAnalysis.CSharp.Symbols.SourceEventSymbol,System.Boolean,Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Generate a thread-safe accessor for a regular field-like event.
            
            DelegateType tmp0 = _event; //backing field
            DelegateType tmp1;
            DelegateType tmp2;
            do {
                tmp1 = tmp0;
                tmp2 = (DelegateType)Delegate.Combine(tmp1, value); //Remove for -=
                tmp0 = Interlocked.CompareExchange&lt;DelegateType&gt;(ref _event, tmp2, tmp1);
            } while ((object)tmp0 != (object)tmp1);
            
            Note, if System.Threading.Interlocked.CompareExchange&lt;T&gt; is not available,
            we emit the following code and mark the method Synchronized (unless it is a struct).
            
            _event = (DelegateType)Delegate.Combine(_event, value); //Remove for -=
            
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodBodySynthesizer.GetBaseTypeFinalizeMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Look for a base type method named "Finalize" that is protected (or protected internal), has no parameters, 
            and returns void.  It doesn't need to be virtual or a destructor.
            </summary>
            <remarks>
            You may assume that this would share code and logic with PEMethodSymbol.OverridesRuntimeFinalizer, 
            but FUNCBRECCS::bindDestructor has its own loop that performs these checks (differently).
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedMetadataCompiler">
            <summary>
            When compiling in metadata-only mode, <see cref="T:Microsoft.CodeAnalysis.CSharp.MethodCompiler"/> is not run. This is problematic because 
            <see cref="T:Microsoft.CodeAnalysis.CSharp.MethodCompiler"/> adds synthesized explicit implementations to the list of synthesized definitions.
            In lieu of running <see cref="T:Microsoft.CodeAnalysis.CSharp.MethodCompiler"/>, this class performs a quick 
            traversal of the symbol table and performs processing of synthesized symbols if necessary
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SynthesizedMetadataCompiler.ProcessSynthesizedMembers(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder,System.Threading.CancellationToken)">
            <summary>
            Traverse the symbol table and call Module.AddSynthesizedDefinition for each
            synthesized explicit implementation stub that has been generated (e.g. when the real
            implementation doesn't have the appropriate custom modifiers).
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TypeCompilationState">
            <summary>
            Represents the state of compilation of one particular type.
            This includes, for example, a collection of synthesized methods created during lowering. 
            </summary>
            <remarks>
            WARNING: Note that the collection class is not thread-safe and will 
            need to be revised if emit phase is changed to support multithreading when
            translating a particular type.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.MethodWithBody">
            <summary> Synthesized method info </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.TypeCompilationState._synthesizedMethods">
            <summary> Flat array of created methods, non-empty if not-null </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.TypeCompilationState._wrappers">
            <summary> 
            Map of wrapper methods created for base access of base type virtual methods from 
            other classes (like those created for lambdas...); actually each method symbol will 
            only need one wrapper to call it non-virtually.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.TypeCompilationState._typeOpt">
            <summary>
            Type symbol being compiled, or null if we compile a synthesized type that doesn't have a symbol (e.g. PrivateImplementationDetails).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.ModuleBuilderOpt">
            <summary>
            The builder for generating code, or null if not in emit phase.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.CurrentImportChain">
            <summary>
            Any generated methods that don't suppress debug info will use this
            list of debug imports.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.TypeCompilationState._constructorInitializers">
            <summary>
            A graph of method->method references for this(...) constructor initializers.
            Used to detect and report initializer cycles.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.Type">
            <summary>
            The type for which this compilation state is being used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.DynamicOperationContextType">
            <summary>
            The type passed to the runtime binder as context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.HasSynthesizedMethods">
            <summary> 
            Add a 'regular' synthesized method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.AddMethodWrapper(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary> 
            Add a 'wrapper' synthesized method and map it to the original one so it can be reused. 
            </summary>
            <remarks>
            Wrapper methods are created for base access of base type virtual methods from 
            other classes (like those created for lambdas...).
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.NextWrapperMethodIndex">
            <summary> The index of the next wrapped method to be used </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.GetMethodWrapper(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary> 
            Get a 'wrapper' method for the original one. 
            </summary>
            <remarks>
            Wrapper methods are created for base access of base type virtual methods from 
            other classes (like those created for lambdas...).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.Free">
            <summary> Free resources allocated for this method collection </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.ReportCtorInitializerCycles(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Report an error if adding the edge (method1, method2) to the ctor-initializer
            graph would add a new cycle to that graph.
            </summary>
            <param name="method1">a calling ctor</param>
            <param name="method2">the chained-to ctor</param>
            <param name="syntax">where to report a cyclic error if needed</param>
            <param name="diagnostics">a diagnostic bag for receiving the diagnostic</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions">
            <summary>
            Represents various options that affect compilation, such as 
            whether to emit an executable or a library, whether to optimize
            generated code, and so on.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions.AllowUnsafe">
            <summary>
            Allow unsafe regions (i.e. unsafe modifiers on members and unsafe blocks).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpCompilationOptions.Usings">
            <summary>
            Global namespace usings.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.Insert(Microsoft.CodeAnalysis.SyntaxTokenList,System.Int32,Microsoft.CodeAnalysis.SyntaxToken[])">
            <summary>
            Insert one or more tokens in the list at the specified index.
            </summary>
            <returns>A new list with the tokens inserted.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a new token with the specified old trivia replaced with computed new trivia.
            </summary>
            <param name="token"></param>
            <param name="trivia">The trivia to be replaced; descendants of the root token.</param>
            <param name="computeReplacementTrivia">A function that computes a replacement trivia for
            the argument trivia. The first argument is the original trivia. The second argument is
            the same trivia rewritten with replaced structure.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ReplaceTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTrivia,Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a new token with the specified old trivia replaced with a new trivia. The old trivia may appear in
            the token's leading or trailing trivia.
            </summary>
            <param name="token"></param>
            <param name="oldTrivia">The trivia to be replaced.</param>
            <param name="newTrivia">The new trivia to use in the new tree in place of the old
            trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AsSeparatedList``1(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Returns this list as a <see cref="T:Microsoft.CodeAnalysis.SeparatedSyntaxList`1"/>.
            </summary>
            <typeparam name="TOther">The type of the list elements in the separated list.</typeparam>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetFirstDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})">
            <summary>
            Gets the first directive of the tree rooted by this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetLastDirective(Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})">
            <summary>
            Gets the last directive of the tree rooted by this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information for an ordering clause in an orderby query clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a select or group clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given expression syntax bound to in the program.
            
            An AliasSymbol will never be returned by this method. What the alias refers to will be
            returned instead. To get information about aliases, call GetAliasInfo.
            
            If binding the type name C in the expression "new C(...)" the actual constructor bound to
            will be returned (or all constructor if overload resolution failed). This occurs as long as C
            unambiguously binds to a single type that has a constructor. If C ambiguously binds to multiple
            types, or C binds to a static class, then type(s) are returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetCollectionInitializerSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what 'Add' method symbol(s), if any, corresponds to the given expression syntax 
            within <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.Initializer"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given constructor initializer syntax bound to in the program.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns what symbol(s), if any, the given attribute syntax bound to in the program.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a documentation comment cref.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the CrefSyntax expression in the context of the specified location and gets symbol information.
            This method is used to get symbol information about an expression that did not actually
            appear in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>
            Bind the attribute in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about an attribute
            that did not actually appear in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeSymbolInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)">
            <summary>
            Bind the constructor initializer in the context of the specified location and get semantic information
            such as type, symbols and diagnostics. This method is used to get semantic information about a constructor
            initializer that did not actually appear in the source code.
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about a constructor initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about an expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetTypeInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets type information about an attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeTypeInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the expression in the context of the specified location and gets type information.
            This method is used to get type information about an expression that did not actually
            appear in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetIndexerGroup(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Returns the list of accessible, non-hidden indexers that could be invoked with the given expression as receiver.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetQueryClauseInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Gets the semantic information associated with a query clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetAliasInfo(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,System.Threading.CancellationToken)">
            <summary>
            If <paramref name="nameSyntax"/> resolves to an alias name, return the AliasSymbol corresponding
            to A. Otherwise return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetSpeculativeAliasInfo(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Binds the name in the context of the specified location and sees if it resolves to an
            alias name. If it does, return the AliasSymbol corresponding to it. Otherwise, return null.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeControlFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze control-flow within a part of a method body. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Analyze data-flow within an expression. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.AnalyzeDataFlow(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>
            Analyze data-flow within a part of a method body. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position"/> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModelForMethodBody(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a method body that did not appear in this source code.
            Given <paramref name="position"/> must lie within an existing method body of the Root syntax node for this SemanticModel.
            Locals and labels declared within this existing method body are not considered to be in scope of the speculated method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SemanticModel@,Microsoft.CodeAnalysis.SpeculativeBindingOption)">
            <summary>
            Get a SemanticModel object that is associated with a type syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a type syntax that did not appear in source code. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a cref syntax node that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a cref syntax that did not appear in source code. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a statement that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a statement that did not appear in source code. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a field initializer or default parameter value that did not appear in source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an expression body that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an expression body that did not appear in source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with a constructor initializer that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of a constructor initializer that did not appear in source code. 
            
            NOTE: This will only work in locations where there is already a constructor initializer.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.TryGetSpeculativeSemanticModel(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax,Microsoft.CodeAnalysis.SemanticModel@)">
            <summary>
            Get a SemanticModel object that is associated with an attribute that did not appear in
            this source code. This can be used to get detailed semantic information about sub-parts
            of an attribute that did not appear in source code. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.ClassifyConversion(Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.ITypeSymbol,System.Boolean)">
            <summary>
            Determines what type of conversion, if any, would be used if a given expression was
            converted to a given type.  If isExplicitInSource is true, the conversion produced is
            that which would be used if the conversion were done for a cast expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a member declaration syntax, get the corresponding symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a namespace declaration syntax node, get the corresponding namespace symbol for
            the declaration assembly.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type declaration, get the corresponding type symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a delegate declaration, get the corresponding type symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a enum member declaration, get the corresponding field symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a base method declaration syntax, get the corresponding method symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, indexer or an event, get the corresponding declared symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property, get the corresponding declared symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares an indexer, get the corresponding declared symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a (custom) event, get the corresponding event symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of anonymous object creation initializer, get the anonymous object property symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node of anonymous object creation expression, get the anonymous object type symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a syntax node that declares a property or member accessor, get the corresponding symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a variable declarator syntax, get the corresponding symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a labeled statement syntax, get the corresponding label symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a switch label syntax, get the corresponding label symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a using declaration get the corresponding symbol for the using alias that was introduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax,System.Threading.CancellationToken)">
            <summary>
            Given an extern alias declaration get the corresponding symbol for the alias that was introduced.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a parameter declaration syntax node, get the corresponding symbol.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a type parameter declaration (field or method), get the corresponding symbol
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a foreach statement, get the symbol for the iteration variable
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,System.Threading.CancellationToken)">
            <summary>
            Given a catch declaration, get the symbol for the exception variable
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the query range variable declared in a join into clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpExtensions.GetDeclaredSymbol(Microsoft.CodeAnalysis.SemanticModel,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax,System.Threading.CancellationToken)">
            <summary>
            Get the query range variable declared in a query continuation clause.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpFileSystemExtensions.Emit(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,System.String,System.String,System.String,System.String,System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.ResourceDescription},System.Threading.CancellationToken)">
            <summary>
            Emit the IL for the compilation into the specified stream.
            </summary>
            <param name="compilation">Compilation.</param>
            <param name="outputPath">Path of the file to which the PE image will be written.</param>
            <param name="pdbPath">Path of the file to which the compilation's debug info will be written.
            Also embedded in the output file.  Null to forego PDB generation.
            </param>
            <param name="xmlDocumentationPath">Path of the file to which the compilation's XML documentation will be written.  Null to forego XML generation.</param>
            <param name="win32ResourcesPath">Path of the file from which the compilation's Win32 resources will be read (in RES format).  
            Null to indicate that there are none.</param>
            <param name="manifestResources">List of the compilation's managed resources.  Null to indicate that there are none.</param>
            <param name="cancellationToken">To cancel the emit process.</param>
            <exception cref="T:System.ArgumentNullException">Compilation or path is null.</exception>
            <exception cref="T:System.ArgumentException">Path is empty or invalid.</exception>
            <exception cref="T:System.IO.IOException">An error occurred while reading or writing a file.</exception>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions">
            <summary>
            This class stores several source parsing related options and offers access to their values.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.Default">
            <summary>
            The default parse options.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.LanguageVersion">
            <summary>
            Gets the language version.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.PreprocessorSymbolNames">
            <summary>
            Gets the names of defined preprocessor symbols.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpParseOptions.WithFeatures(System.Collections.Generic.IEnumerable{System.Collections.Generic.KeyValuePair{System.String,System.String}})">
            <summary>
            Enable some experimental language features for testing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.CantReferenceCompilationOf">
            <summary>
              Looks up a localized string similar to Can&apos;t reference compilation of type &apos;{0}&apos; from {1} compilation..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ChainingSpeculativeModelIsNotSupported">
            <summary>
              Looks up a localized string similar to Chaining speculative semantic model is not supported. You should create a speculative model from the non-speculative ParentModel..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.CompilationC">
            <summary>
              Looks up a localized string similar to Compilation (C#): .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ElementIsExpected">
            <summary>
              Looks up a localized string similar to element is expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ElementsCannotBeNull">
            <summary>
              Looks up a localized string similar to Elements cannot be null..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractAndExtern">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot be both extern and abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractAndSealed">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot be both abstract and sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractAttributeClass">
            <summary>
              Looks up a localized string similar to Cannot apply attribute class &apos;{0}&apos; because it is abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractBaseCall">
            <summary>
              Looks up a localized string similar to Cannot call an abstract base member: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractEventInitializer">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: abstract event cannot have initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractField">
            <summary>
              Looks up a localized string similar to The modifier &apos;abstract&apos; is not valid on fields. Try using a property instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractHasBody">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot declare a body because it is marked abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractInConcreteClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is abstract but it is contained in non-abstract class &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractNotVirtual">
            <summary>
              Looks up a localized string similar to The abstract method &apos;{0}&apos; cannot be marked virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AbstractSealedStatic">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: an abstract class cannot be sealed or static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AccessModMissingAccessor">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: accessibility modifiers on accessors may only be used if the property or indexer has both a get and a set accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AccessorImplementingMethod">
            <summary>
              Looks up a localized string similar to Accessor &apos;{0}&apos; cannot implement interface member &apos;{1}&apos; for type &apos;{2}&apos;. Use an explicit interface implementation..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AccessorListAndExpressionBody">
            <summary>
              Looks up a localized string similar to Properties cannot combine accessor lists with expression bodies..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AddModuleAssembly">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot be added to this assembly because it already is an assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AddOrRemoveExpected">
            <summary>
              Looks up a localized string similar to An add or remove accessor expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AddRemoveMustHaveBody">
            <summary>
              Looks up a localized string similar to An add or remove accessor must have a body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AddrOnReadOnlyLocal">
            <summary>
              Looks up a localized string similar to Cannot take the address of a read-only local variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AgnosticToMachineModule">
            <summary>
              Looks up a localized string similar to Agnostic assembly cannot have a processor specific module &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AliasMissingFile">
            <summary>
              Looks up a localized string similar to Invalid reference alias option: &apos;{0}=&apos; -- missing filename.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AliasNotFound">
            <summary>
              Looks up a localized string similar to Alias &apos;{0}&apos; not found.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AliasQualAsExpression">
            <summary>
              Looks up a localized string similar to The namespace alias qualifier &apos;::&apos; always resolves to a type or namespace so is illegal here. Consider using &apos;.&apos; instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AliasQualifiedNameNotAnExpression">
            <summary>
              Looks up a localized string similar to An alias-qualified name is not an expression..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigBinaryOps">
            <summary>
              Looks up a localized string similar to Operator &apos;{0}&apos; is ambiguous on operands of type &apos;{1}&apos; and &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigCall">
            <summary>
              Looks up a localized string similar to The call is ambiguous between the following methods or properties: &apos;{0}&apos; and &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigContext">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is an ambiguous reference between &apos;{1}&apos; and &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigMember">
            <summary>
              Looks up a localized string similar to Ambiguity between &apos;{0}&apos; and &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigousAttribute">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is ambiguous between &apos;{1}&apos; and &apos;{2}&apos;; use either &apos;@{0}&apos; or &apos;{0}Attribute&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigOverride">
            <summary>
              Looks up a localized string similar to The inherited members &apos;{0}&apos; and &apos;{1}&apos; have the same signature in type &apos;{2}&apos;, so they cannot be overridden.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigQM">
            <summary>
              Looks up a localized string similar to Type of conditional expression cannot be determined because &apos;{0}&apos; and &apos;{1}&apos; implicitly convert to one another.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigUDConv">
            <summary>
              Looks up a localized string similar to Ambiguous user defined conversions &apos;{0}&apos; and &apos;{1}&apos; when converting from &apos;{2}&apos; to &apos;{3}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AmbigUnaryOp">
            <summary>
              Looks up a localized string similar to Operator &apos;{0}&apos; is ambiguous on an operand of type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonDelegateCantUse">
            <summary>
              Looks up a localized string similar to Cannot use ref or out parameter &apos;{0}&apos; inside an anonymous method, lambda expression, or query expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonMethGrpInForEach">
            <summary>
              Looks up a localized string similar to Foreach cannot operate on a &apos;{0}&apos;. Did you intend to invoke the &apos;{0}&apos;?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonMethToNonDel">
            <summary>
              Looks up a localized string similar to Cannot convert {0} to type &apos;{1}&apos; because it is not a delegate type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonymousMethodToExpressionTree">
            <summary>
              Looks up a localized string similar to An anonymous method expression cannot be converted to an expression tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonymousReturnExpected">
            <summary>
              Looks up a localized string similar to Not all code paths return a value in {0} of type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonymousTypeDuplicatePropertyName">
            <summary>
              Looks up a localized string similar to An anonymous type cannot have multiple properties with the same name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonymousTypeNotAvailable">
            <summary>
              Looks up a localized string similar to Cannot use anonymous type in a constant expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AnonymousTypePropertyAssignedBadValue">
            <summary>
              Looks up a localized string similar to Cannot assign {0} to anonymous type property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArgsInvalid">
            <summary>
              Looks up a localized string similar to The __arglist construct is valid only within a variable argument method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayElementCantBeRefAny">
            <summary>
              Looks up a localized string similar to Array elements cannot be of type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayInitializerExpected">
            <summary>
              Looks up a localized string similar to A nested array initializer is expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayInitializerIncorrectLength">
            <summary>
              Looks up a localized string similar to An array initializer of length &apos;{0}&apos; is expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayInitInBadPlace">
            <summary>
              Looks up a localized string similar to Array initializers can only be used in a variable or field initializer. Try using a new expression instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayInitToNonArrayType">
            <summary>
              Looks up a localized string similar to Can only use array initializer expressions to assign to array types. Try using a new expression instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArrayOfStaticClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: array elements cannot be of static type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ArraySizeInDeclaration">
            <summary>
              Looks up a localized string similar to Array size cannot be specified in a variable declaration (try initializing with a &apos;new&apos; expression).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AsMustHaveReferenceType">
            <summary>
              Looks up a localized string similar to The as operator must be used with a reference type or nullable type (&apos;{0}&apos; is a non-nullable value type).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssemblyMatchBadVersion">
            <summary>
              Looks up a localized string similar to Assembly &apos;{0}&apos; with identity &apos;{1}&apos; uses &apos;{2}&apos; which has a higher version than referenced assembly &apos;{3}&apos; with identity &apos;{4}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssemblyNameOnNonModule">
            <summary>
              Looks up a localized string similar to The /moduleassemblyname option may only be specified when building a target type of &apos;module&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssemblySpecifiedForLinkAndRef">
            <summary>
              Looks up a localized string similar to Assemblies &apos;{0}&apos; and &apos;{1}&apos; refer to the same metadata but only one is a linked reference (specified using /link option); consider removing one of the references..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgLvalueExpected">
            <summary>
              Looks up a localized string similar to The left-hand side of an assignment must be a variable, property or indexer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonly">
            <summary>
              Looks up a localized string similar to A readonly field cannot be assigned to (except in a constructor or a variable initializer).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonly2">
            <summary>
              Looks up a localized string similar to Members of readonly field &apos;{0}&apos; cannot be modified (except in a constructor or a variable initializer).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyLocal">
            <summary>
              Looks up a localized string similar to Cannot assign to &apos;{0}&apos; because it is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyLocal2Cause">
            <summary>
              Looks up a localized string similar to Cannot modify members of &apos;{0}&apos; because it is a &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyLocalCause">
            <summary>
              Looks up a localized string similar to Cannot assign to &apos;{0}&apos; because it is a &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyProp">
            <summary>
              Looks up a localized string similar to Property or indexer &apos;{0}&apos; cannot be assigned to -- it is read only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyStatic">
            <summary>
              Looks up a localized string similar to A static readonly field cannot be assigned to (except in a static constructor or a variable initializer).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AssgReadonlyStatic2">
            <summary>
              Looks up a localized string similar to Fields of static readonly field &apos;{0}&apos; cannot be assigned to (except in a static constructor or a variable initializer).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AsWithTypeVar">
            <summary>
              Looks up a localized string similar to The type parameter &apos;{0}&apos; cannot be used with the &apos;as&apos; operator because it does not have a class type constraint nor a &apos;class&apos; constraint.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttrArgWithTypeVars">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: an attribute argument cannot use type parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeCantBeGeneric">
            <summary>
              Looks up a localized string similar to Cannot apply attribute class &apos;{0}&apos; because it is generic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeNotOnAccessor">
            <summary>
              Looks up a localized string similar to Attribute &apos;{0}&apos; is not valid on property or event accessors. It is only valid on &apos;{1}&apos; declarations..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeOnBadSymbolType">
            <summary>
              Looks up a localized string similar to Attribute &apos;{0}&apos; is not valid on this declaration type. It is only valid on &apos;{1}&apos; declarations..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeParameterRequired1">
            <summary>
              Looks up a localized string similar to Attribute parameter &apos;{0}&apos; must be specified..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeParameterRequired2">
            <summary>
              Looks up a localized string similar to Attribute parameter &apos;{0}&apos; or &apos;{1}&apos; must be specified..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributesNotAllowed">
            <summary>
              Looks up a localized string similar to Attributes are not valid in this context..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AttributeUsageOnNonAttributeClass">
            <summary>
              Looks up a localized string similar to Attribute &apos;{0}&apos; is only valid on classes derived from System.Attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AutoPropertyInitializerInInterface">
            <summary>
              Looks up a localized string similar to Auto-implemented properties inside interfaces cannot have initializers..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AutoPropertyMustHaveGetAccessor">
            <summary>
              Looks up a localized string similar to Auto-implemented properties must have get accessors..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AutoPropertyMustOverrideSet">
            <summary>
              Looks up a localized string similar to Auto-implemented properties must override all accessors of the overridden property..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_AwaitInUnsafeContext">
            <summary>
              Looks up a localized string similar to Cannot await in an unsafe context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAccess">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is inaccessible due to its protection level.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAppConfigPath">
            <summary>
              Looks up a localized string similar to AppConfigPath must be absolute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgCount">
            <summary>
              Looks up a localized string similar to No overload for method &apos;{0}&apos; takes {1} arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgExtraRef">
            <summary>
              Looks up a localized string similar to Argument {0} should not be passed with the &apos;{1}&apos; keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgRef">
            <summary>
              Looks up a localized string similar to Argument {0} must be passed with the &apos;{1}&apos; keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgType">
            <summary>
              Looks up a localized string similar to Argument {0}: cannot convert from &apos;{1}&apos; to &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgTypeDynamicExtension">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; has no applicable method named &apos;{1}&apos; but appears to have an extension method by that name. Extension methods cannot be dynamically dispatched. Consider casting the dynamic arguments or calling the extension method without the extension method syntax..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgTypesForCollectionAdd">
            <summary>
              Looks up a localized string similar to The best overloaded Add method &apos;{0}&apos; for the collection initializer has some invalid arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArgumentToAttribute">
            <summary>
              Looks up a localized string similar to The argument to the &apos;{0}&apos; attribute must be a valid identifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArity">
            <summary>
              Looks up a localized string similar to Using the generic {1} &apos;{0}&apos; requires {2} type arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadArraySyntax">
            <summary>
              Looks up a localized string similar to Array type specifier, [], must appear before parameter name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncArgType">
            <summary>
              Looks up a localized string similar to Async methods cannot have ref or out parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncExpressionTree">
            <summary>
              Looks up a localized string similar to Async lambda expressions cannot be converted to expression trees.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncLacksBody">
            <summary>
              Looks up a localized string similar to The &apos;async&apos; modifier can only be used in methods that have a statement body..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncReturn">
            <summary>
              Looks up a localized string similar to The return type of an async method must be void, Task or Task&lt;T&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAsyncReturnExpression">
            <summary>
              Looks up a localized string similar to Since this is an async method, the return expression must be of type &apos;{0}&apos; rather than &apos;Task&lt;{0}&gt;&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAttributeArgument">
            <summary>
              Looks up a localized string similar to An attribute argument must be a constant expression, typeof expression or array creation expression of an attribute parameter type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAttributeParamDefaultArgument">
            <summary>
              Looks up a localized string similar to Attribute constructor parameter &apos;{0}&apos; is optional, but no default parameter value was specified..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAttributeParamType">
            <summary>
              Looks up a localized string similar to Attribute constructor parameter &apos;{0}&apos; has type &apos;{1}&apos;, which is not a valid attribute parameter type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitArg">
            <summary>
              Looks up a localized string similar to &apos;await&apos; requires that the type {0} have a suitable GetAwaiter method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitArg_NeedSystem">
            <summary>
              Looks up a localized string similar to &apos;await&apos; requires that the type &apos;{0}&apos; have a suitable GetAwaiter method. Are you missing a using directive for &apos;System&apos;?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitArgIntrinsic">
            <summary>
              Looks up a localized string similar to Cannot await &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitArgVoidCall">
            <summary>
              Looks up a localized string similar to Cannot await &apos;void&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitAsIdentifier">
            <summary>
              Looks up a localized string similar to &apos;await&apos; cannot be used as an identifier within an async method or lambda expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaiterPattern">
            <summary>
              Looks up a localized string similar to &apos;await&apos; requires that the return type &apos;{0}&apos; of &apos;{1}.GetAwaiter()&apos; have suitable IsCompleted, OnCompleted, and GetResult members, and implement INotifyCompletion or ICriticalNotifyCompletion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitInCatch">
            <summary>
              Looks up a localized string similar to Cannot await in a catch clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitInCatchFilter">
            <summary>
              Looks up a localized string similar to Cannot await in the filter expression of a catch clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitInFinally">
            <summary>
              Looks up a localized string similar to Cannot await in the body of a finally clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitInLock">
            <summary>
              Looks up a localized string similar to Cannot await in the body of a lock statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitInQuery">
            <summary>
              Looks up a localized string similar to The &apos;await&apos; operator may only be used in a query expression within the first collection expression of the initial &apos;from&apos; clause or within the collection expression of a &apos;join&apos; clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitWithoutAsync">
            <summary>
              Looks up a localized string similar to The &apos;await&apos; operator can only be used when contained within a method or lambda expression marked with the &apos;async&apos; modifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitWithoutAsyncLambda">
            <summary>
              Looks up a localized string similar to The &apos;await&apos; operator can only be used within an async {0}. Consider marking this {0} with the &apos;async&apos; modifier..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitWithoutAsyncMethod">
            <summary>
              Looks up a localized string similar to The &apos;await&apos; operator can only be used within an async method. Consider marking this method with the &apos;async&apos; modifier and changing its return type to &apos;Task&lt;{0}&gt;&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadAwaitWithoutVoidAsyncMethod">
            <summary>
              Looks up a localized string similar to The &apos;await&apos; operator can only be used within an async method. Consider marking this method with the &apos;async&apos; modifier and changing its return type to &apos;Task&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBaseNumber">
            <summary>
              Looks up a localized string similar to Invalid image base number &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBaseType">
            <summary>
              Looks up a localized string similar to Invalid base type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBinaryOperatorSignature">
            <summary>
              Looks up a localized string similar to One of the parameters of a binary operator must be the containing type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBinaryOps">
            <summary>
              Looks up a localized string similar to Operator &apos;{0}&apos; cannot be applied to operands of type &apos;{1}&apos; and &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBinOpArgs">
            <summary>
              Looks up a localized string similar to Overloaded binary operator &apos;{0}&apos; takes two parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBoolOp">
            <summary>
              Looks up a localized string similar to In order to be applicable as a short circuit operator a user-defined logical operator (&apos;{0}&apos;) must have the same return type and parameter types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadBoundType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a valid constraint. A type used as a constraint must be an interface, a non-sealed class or a type parameter..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCallerFilePathParamWithoutDefaultValue">
            <summary>
              Looks up a localized string similar to The CallerFilePathAttribute may only be applied to parameters with default values.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCallerLineNumberParamWithoutDefaultValue">
            <summary>
              Looks up a localized string similar to The CallerLineNumberAttribute may only be applied to parameters with default values.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCallerMemberNameParamWithoutDefaultValue">
            <summary>
              Looks up a localized string similar to The CallerMemberNameAttribute may only be applied to parameters with default values.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCastInFixed">
            <summary>
              Looks up a localized string similar to The right hand side of a fixed statement assignment may not be a cast expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCoClassSig">
            <summary>
              Looks up a localized string similar to The managed coclass wrapper class signature &apos;{0}&apos; for interface &apos;{1}&apos; is not a valid class name signature.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCompatMode">
            <summary>
              Looks up a localized string similar to Invalid option &apos;{0}&apos; for /langversion; must be ISO-1, ISO-2, Default or an integer in range 1 to 6..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCompilationOption">
            <summary>
              Looks up a localized string similar to {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCompilationOptionValue">
            <summary>
              Looks up a localized string similar to Invalid &apos;{0}&apos; value: &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadConstraintType">
            <summary>
              Looks up a localized string similar to Invalid constraint type. A type used as a constraint must be an interface, a non-sealed class or a type parameter..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadConstType">
            <summary>
              Looks up a localized string similar to The type &apos;{0}&apos; cannot be declared const.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadCtorArgCount">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not contain a constructor that takes {1} arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDebugType">
            <summary>
              Looks up a localized string similar to Invalid option &apos;{0}&apos; for /debug; must be full or pdbonly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDelArgCount">
            <summary>
              Looks up a localized string similar to Delegate &apos;{0}&apos; does not take {1} arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDelegateConstructor">
            <summary>
              Looks up a localized string similar to The delegate &apos;{0}&apos; does not have a valid constructor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDelegateLeave">
            <summary>
              Looks up a localized string similar to Control cannot leave the body of an anonymous method or lambda expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDestructorName">
            <summary>
              Looks up a localized string similar to Name of destructor must match name of class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDirectivePlacement">
            <summary>
              Looks up a localized string similar to Preprocessor directives must appear as the first non-whitespace character on a line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicConversion">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: user-defined conversions to or from the dynamic type are not allowed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicMethodArg">
            <summary>
              Looks up a localized string similar to Cannot use an expression of type &apos;{0}&apos; as an argument to a dynamically dispatched operation..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicMethodArgLambda">
            <summary>
              Looks up a localized string similar to Cannot use a lambda expression as an argument to a dynamically dispatched operation without first casting it to a delegate or expression tree type..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicMethodArgMemgrp">
            <summary>
              Looks up a localized string similar to Cannot use a method group as an argument to a dynamically dispatched operation. Did you intend to invoke the method?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicQuery">
            <summary>
              Looks up a localized string similar to Query expressions over source type &apos;dynamic&apos; or with a join sequence of type &apos;dynamic&apos; are not allowed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadDynamicTypeof">
            <summary>
              Looks up a localized string similar to The typeof operator cannot be used on the dynamic type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadEmbeddedStmt">
            <summary>
              Looks up a localized string similar to Embedded statement cannot be a declaration or labeled statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadEmptyThrow">
            <summary>
              Looks up a localized string similar to A throw statement with no arguments is not allowed outside of a catch clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadEmptyThrowInFinally">
            <summary>
              Looks up a localized string similar to A throw statement with no arguments is not allowed in a finally clause that is nested inside the nearest enclosing catch clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadEventUsage">
            <summary>
              Looks up a localized string similar to The event &apos;{0}&apos; can only appear on the left hand side of += or -= (except when used from within the type &apos;{1}&apos;).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadEventUsageNoField">
            <summary>
              Looks up a localized string similar to The event &apos;{0}&apos; can only appear on the left hand side of += or -=.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadExceptionType">
            <summary>
              Looks up a localized string similar to The type caught or thrown must be derived from System.Exception.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadExtensionAgg">
            <summary>
              Looks up a localized string similar to Extension method must be defined in a non-generic static class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadExtensionArgTypes">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not contain a definition for &apos;{1}&apos; and the best extension method overload &apos;{2}&apos; has some invalid arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadExtensionMeth">
            <summary>
              Looks up a localized string similar to Extension method must be static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadExternAlias">
            <summary>
              Looks up a localized string similar to The extern alias &apos;{0}&apos; was not specified in a /reference option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadExternIdentifier">
            <summary>
              Looks up a localized string similar to Invalid extern alias for &apos;/reference&apos;; &apos;{0}&apos; is not a valid identifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadFinallyLeave">
            <summary>
              Looks up a localized string similar to Control cannot leave the body of a finally clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadFixedInitType">
            <summary>
              Looks up a localized string similar to The type of a local declared in a fixed statement must be a pointer type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadForeachDecl">
            <summary>
              Looks up a localized string similar to Type and identifier are both required in a foreach statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadGetEnumerator">
            <summary>
              Looks up a localized string similar to foreach requires that the return type &apos;{0}&apos; of &apos;{1}&apos; must have a suitable public MoveNext method and public Current property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIncDecRetType">
            <summary>
              Looks up a localized string similar to The return type for ++ or -- operator must match the parameter type or be derived from the parameter type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIncDecSignature">
            <summary>
              Looks up a localized string similar to The parameter type for ++ or -- operator must be the containing type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIndexCount">
            <summary>
              Looks up a localized string similar to Wrong number of indices inside []; expected {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIndexerNameAttr">
            <summary>
              Looks up a localized string similar to The &apos;{0}&apos; attribute is valid only on an indexer that is not an explicit interface member declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIndexLHS">
            <summary>
              Looks up a localized string similar to Cannot apply indexing with [] to an expression of type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadInstanceArgType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not contain a definition for &apos;{1}&apos; and the best extension method overload &apos;{2}&apos; requires a receiver of type &apos;{3}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIteratorArgType">
            <summary>
              Looks up a localized string similar to Iterators cannot have ref or out parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadIteratorReturn">
            <summary>
              Looks up a localized string similar to The body of &apos;{0}&apos; cannot be an iterator block because &apos;{1}&apos; is not an iterator interface type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadMemberFlag">
            <summary>
              Looks up a localized string similar to The modifier &apos;{0}&apos; is not valid for this item.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadMemberProtection">
            <summary>
              Looks up a localized string similar to More than one protection modifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadModifierLocation">
            <summary>
              Looks up a localized string similar to Member modifier &apos;{0}&apos; must precede the member type and name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadModifiersOnNamespace">
            <summary>
              Looks up a localized string similar to A namespace declaration cannot have modifiers or attributes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNamedArgument">
            <summary>
              Looks up a localized string similar to The best overload for &apos;{0}&apos; does not have a parameter named &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNamedArgumentForDelegateInvoke">
            <summary>
              Looks up a localized string similar to The delegate &apos;{0}&apos; does not have a parameter named &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNamedAttributeArgument">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a valid named attribute argument. Named attribute arguments must be fields which are not readonly, static, or const, or read-write properties which are public and not static..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNamedAttributeArgumentType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a valid named attribute argument because it is not a valid attribute parameter type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadNewExpr">
            <summary>
              Looks up a localized string similar to A new expression requires (), [], or {} after type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadOperatorSyntax">
            <summary>
              Looks up a localized string similar to Declaration is not valid; use &apos;{0} operator &lt;dest-type&gt; (...&apos; instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadOutWithThis">
            <summary>
              Looks up a localized string similar to  The parameter modifier &apos;out&apos; cannot be used with &apos;this&apos; .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadParamExtraRef">
            <summary>
              Looks up a localized string similar to Parameter {0} should not be declared with the &apos;{1}&apos; keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadParamModThis">
            <summary>
              Looks up a localized string similar to A parameter array cannot be used with &apos;this&apos; modifier on an extension method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadParamRef">
            <summary>
              Looks up a localized string similar to Parameter {0} must be declared with the &apos;{1}&apos; keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadParamType">
            <summary>
              Looks up a localized string similar to Parameter {0} is declared as type &apos;{1}{2}&apos; but should be &apos;{3}{4}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadPdbData">
            <summary>
              Looks up a localized string similar to Error reading debug information for &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadPlatformType">
            <summary>
              Looks up a localized string similar to Invalid option &apos;{0}&apos; for /platform; must be anycpu, x86, Itanium or x64.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadPrefer32OnLib">
            <summary>
              Looks up a localized string similar to /platform:anycpu32bitpreferred can only be used with /t:exe, /t:winexe and /t:appcontainerexe.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadProtectedAccess">
            <summary>
              Looks up a localized string similar to Cannot access protected member &apos;{0}&apos; via a qualifier of type &apos;{1}&apos;; the qualifier must be of type &apos;{2}&apos; (or derived from it).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadRefWithThis">
            <summary>
              Looks up a localized string similar to  The parameter modifier &apos;ref&apos; cannot be used with &apos;this&apos; .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadResourceVis">
            <summary>
              Looks up a localized string similar to Invalid option &apos;{0}&apos;; Resource visibility must be either &apos;public&apos; or &apos;private&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadRetType">
            <summary>
              Looks up a localized string similar to &apos;{1} {0}&apos; has the wrong return type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadShiftOperatorSignature">
            <summary>
              Looks up a localized string similar to The first operand of an overloaded shift operator must have the same type as the containing type, and the type of the second operand must be int.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadSKknown">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is a {1} but is used like a {2}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadSKunknown">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is a {1}, which is not valid in the given context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadSpecialByRefLocal">
            <summary>
              Looks up a localized string similar to Parameters or locals of type &apos;{0}&apos; cannot be declared in async methods or lambda expressions..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadStackAllocExpr">
            <summary>
              Looks up a localized string similar to A stackalloc expression requires [] after type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadSwitch">
            <summary>
              Looks up a localized string similar to Unrecognized option: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadThisParam">
            <summary>
              Looks up a localized string similar to Method &apos;{0}&apos; has a parameter modifier &apos;this&apos; which is not on the first parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadTypeArgument">
            <summary>
              Looks up a localized string similar to The type &apos;{0}&apos; may not be used as a type argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadTypeforThis">
            <summary>
              Looks up a localized string similar to The first parameter of an extension method cannot be of type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadTypeReference">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot reference a type through an expression; try &apos;{1}&apos; instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadUnaryOp">
            <summary>
              Looks up a localized string similar to Operator &apos;{0}&apos; cannot be applied to operand of type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadUnaryOperatorSignature">
            <summary>
              Looks up a localized string similar to The parameter of a unary operator must be the containing type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadUnOpArgs">
            <summary>
              Looks up a localized string similar to Overloaded unary operator &apos;{0}&apos; takes one parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadUsingNamespace">
            <summary>
              Looks up a localized string similar to A &apos;using namespace&apos; directive can only be applied to namespaces; &apos;{0}&apos; is a type not a namespace. Consider a &apos;using static&apos; directive instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadUsingType">
            <summary>
              Looks up a localized string similar to A &apos;using static&apos; directive can only be applied to types; &apos;{0}&apos; is a namespace not a type. Consider a &apos;using namespace&apos; directive instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVarargs">
            <summary>
              Looks up a localized string similar to A method with vararg cannot be generic, be in a generic type, or have a params parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVarDecl">
            <summary>
              Looks up a localized string similar to Expected ; or = (cannot specify constructor arguments in declaration).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisBaseClass">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: base class &apos;{1}&apos; is less accessible than class &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisBaseInterface">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: base interface &apos;{1}&apos; is less accessible than interface &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisBound">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: constraint type &apos;{1}&apos; is less accessible than &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisDelegateParam">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: parameter type &apos;{1}&apos; is less accessible than delegate &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisDelegateReturn">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: return type &apos;{1}&apos; is less accessible than delegate &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisEventType">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: event type &apos;{1}&apos; is less accessible than event &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisFieldType">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: field type &apos;{1}&apos; is less accessible than field &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisIndexerParam">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: parameter type &apos;{1}&apos; is less accessible than indexer &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisIndexerReturn">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: indexer return type &apos;{1}&apos; is less accessible than indexer &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisOpParam">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: parameter type &apos;{1}&apos; is less accessible than operator &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisOpReturn">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: return type &apos;{1}&apos; is less accessible than operator &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisParamType">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: parameter type &apos;{1}&apos; is less accessible than method &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisPropertyType">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: property type &apos;{1}&apos; is less accessible than property &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadVisReturnType">
            <summary>
              Looks up a localized string similar to Inconsistent accessibility: return type &apos;{1}&apos; is less accessible than method &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadWarningLevel">
            <summary>
              Looks up a localized string similar to Warning level must be in the range 0-4.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadWin32Res">
            <summary>
              Looks up a localized string similar to Error reading Win32 resources -- {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadYieldInCatch">
            <summary>
              Looks up a localized string similar to Cannot yield a value in the body of a catch clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadYieldInFinally">
            <summary>
              Looks up a localized string similar to Cannot yield in the body of a finally clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BadYieldInTryOfCatch">
            <summary>
              Looks up a localized string similar to Cannot yield a value in the body of a try block with a catch clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BaseClassMustBeFirst">
            <summary>
              Looks up a localized string similar to Base class &apos;{0}&apos; must come before any interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BaseConstraintConflict">
            <summary>
              Looks up a localized string similar to Type parameter &apos;{0}&apos; inherits conflicting constraints &apos;{1}&apos; and &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BaseIllegal">
            <summary>
              Looks up a localized string similar to Use of keyword &apos;base&apos; is not valid in this context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BaseInBadContext">
            <summary>
              Looks up a localized string similar to Keyword &apos;base&apos; is not available in the current context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BaseInStaticMeth">
            <summary>
              Looks up a localized string similar to Keyword &apos;base&apos; is not available in a static method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BinaryFile">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is a binary file instead of a text file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BindToBogus">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not supported by the language.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BindToBogusProp1">
            <summary>
              Looks up a localized string similar to Property, indexer, or event &apos;{0}&apos; is not supported by the language; try directly calling accessor method &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BindToBogusProp2">
            <summary>
              Looks up a localized string similar to Property, indexer, or event &apos;{0}&apos; is not supported by the language; try directly calling accessor methods &apos;{1}&apos; or &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BlockBodyAndExpressionBody">
            <summary>
              Looks up a localized string similar to Methods cannot combine block bodies with expression bodies..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BogusExplicitImpl">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot implement &apos;{1}&apos; because it is not supported by the language.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_BogusType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is a type not supported by the language.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ByRefParameterInExpressionTree">
            <summary>
              Looks up a localized string similar to An expression tree lambda may not contain an out or ref parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ByRefReturnUnsupported">
            <summary>
              Looks up a localized string similar to By-reference return type &apos;ref {0}&apos; is not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ByRefTypeAndAwait">
            <summary>
              Looks up a localized string similar to &apos;await&apos; cannot be used in an expression containing the type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CallingBaseFinalizeDeprecated">
            <summary>
              Looks up a localized string similar to Do not directly call your base class Finalize method. It is called automatically from your destructor..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CallingFinalizeDeprecated">
            <summary>
              Looks up a localized string similar to Destructors and object.Finalize cannot be called directly. Consider calling IDisposable.Dispose if available..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CannotPassNullForFriendAssembly">
            <summary>
              Looks up a localized string similar to Cannot pass null for friend assembly name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantCallSpecialMethod">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot explicitly call operator or accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantChangeAccessOnOverride">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot change access modifiers when overriding &apos;{1}&apos; inherited member &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantChangeReturnTypeOnOverride">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: return type must be &apos;{2}&apos; to match overridden member &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantChangeTypeOnOverride">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: type must be &apos;{2}&apos; to match overridden member &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantConvAnonMethNoParams">
            <summary>
              Looks up a localized string similar to Cannot convert anonymous method block without a parameter list to delegate type &apos;{0}&apos; because it has one or more out parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantConvAnonMethParams">
            <summary>
              Looks up a localized string similar to Cannot convert {0} to delegate type &apos;{1}&apos; because the parameter types do not match the delegate parameter types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantConvAnonMethReturns">
            <summary>
              Looks up a localized string similar to Cannot convert {0} to intended delegate type because some of the return types in the block are not implicitly convertible to the delegate return type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantConvAsyncAnonFuncReturns">
            <summary>
              Looks up a localized string similar to Cannot convert async {0} to delegate type &apos;{1}&apos;. An async {0} may return void, Task or Task&lt;T&gt;, none of which are convertible to &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantDeriveFromSealedType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot derive from sealed type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantHaveWin32ResAndIcon">
            <summary>
              Looks up a localized string similar to Conflicting options specified: Win32 resource file; Win32 icon.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantHaveWin32ResAndManifest">
            <summary>
              Looks up a localized string similar to Conflicting options specified: Win32 resource file; Win32 manifest.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantInferMethTypeArgs">
            <summary>
              Looks up a localized string similar to The type arguments for method &apos;{0}&apos; cannot be inferred from the usage. Try specifying the type arguments explicitly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantMakeTempFile">
            <summary>
              Looks up a localized string similar to Cannot create temporary file -- {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOpenFileWrite">
            <summary>
              Looks up a localized string similar to Cannot open &apos;{0}&apos; for writing -- &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOpenIcon">
            <summary>
              Looks up a localized string similar to Error opening icon file {0} -- {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOpenWin32Manifest">
            <summary>
              Looks up a localized string similar to Error opening Win32 manifest file {0} -- {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOpenWin32Res">
            <summary>
              Looks up a localized string similar to Error opening Win32 resource file &apos;{0}&apos; -- &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideBogusMethod">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot override &apos;{1}&apos; because it is not supported by the language.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideNonEvent">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot override; &apos;{1}&apos; is not an event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideNonFunction">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot override because &apos;{1}&apos; is not a function.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideNonProperty">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot override because &apos;{1}&apos; is not a property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideNonVirtual">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot override inherited member &apos;{1}&apos; because it is not marked virtual, abstract, or override.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantOverrideSealed">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot override inherited member &apos;{1}&apos; because it is sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantReadConfigFile">
            <summary>
              Looks up a localized string similar to Cannot read config file &apos;{0}&apos; -- &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantReadResource">
            <summary>
              Looks up a localized string similar to Error reading resource &apos;{0}&apos; -- &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantReadRulesetFile">
            <summary>
              Looks up a localized string similar to Error reading ruleset file {0} - {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantRefResource">
            <summary>
              Looks up a localized string similar to Cannot link resource files when building a module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantReturnVoid">
            <summary>
              Looks up a localized string similar to Cannot return an expression of type &apos;void&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantSetWin32Manifest">
            <summary>
              Looks up a localized string similar to Error reading Win32 manifest file &apos;{0}&apos; -- &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CantUseRequiredAttribute">
            <summary>
              Looks up a localized string similar to The RequiredAttribute attribute is not permitted on C# types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CheckedOverflow">
            <summary>
              Looks up a localized string similar to The operation overflows at compile time in checked mode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CircConstValue">
            <summary>
              Looks up a localized string similar to The evaluation of the constant value for &apos;{0}&apos; involves a circular definition.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CircularBase">
            <summary>
              Looks up a localized string similar to Circular base class dependency involving &apos;{0}&apos; and &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CircularConstraint">
            <summary>
              Looks up a localized string similar to Circular constraint dependency involving &apos;{0}&apos; and &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ClassBoundNotFirst">
            <summary>
              Looks up a localized string similar to The class type constraint &apos;{0}&apos; must come before any other constraints.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ClassDoesntImplementInterface">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: containing type does not implement interface &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ClassTypeExpected">
            <summary>
              Looks up a localized string similar to An object, string, or class type expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloseParenExpected">
            <summary>
              Looks up a localized string similar to ) expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloseUnimplementedInterfaceMemberNotPublic">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not implement interface member &apos;{1}&apos;. &apos;{2}&apos; cannot implement an interface member because it is not public..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloseUnimplementedInterfaceMemberStatic">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not implement interface member &apos;{1}&apos;. &apos;{2}&apos; cannot implement an interface member because it is static..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CloseUnimplementedInterfaceMemberWrongReturnType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not implement interface member &apos;{1}&apos;. &apos;{2}&apos; cannot implement &apos;{1}&apos; because it does not have the matching return type of &apos;{3}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CmdOptionConflictsSource">
            <summary>
              Looks up a localized string similar to Attribute &apos;{0}&apos; given in a source file conflicts with option &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ColColWithTypeAlias">
            <summary>
              Looks up a localized string similar to Cannot use alias &apos;{0}&apos; with &apos;::&apos; since the alias references a type. Use &apos;.&apos; instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CollectionInitRequiresIEnumerable">
            <summary>
              Looks up a localized string similar to Cannot initialize type &apos;{0}&apos; with a collection initializer because it does not implement &apos;System.Collections.IEnumerable&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComImportWithBase">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: a class with the ComImport attribute cannot specify a base class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComImportWithImpl">
            <summary>
              Looks up a localized string similar to Since &apos;{1}&apos; has the ComImport attribute, &apos;{0}&apos; must be extern or abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComImportWithInitializers">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: a class with the ComImport attribute cannot specify field initializers..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComImportWithoutUuidAttribute">
            <summary>
              Looks up a localized string similar to The Guid attribute must be specified with the ComImport attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComImportWithUserCtor">
            <summary>
              Looks up a localized string similar to A class with the ComImport attribute cannot have a user-defined constructor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CompileCancelled">
            <summary>
              Looks up a localized string similar to Compilation cancelled by user.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ComRefCallInExpressionTree">
            <summary>
              Looks up a localized string similar to An expression tree lambda may not contain a COM call with ref omitted on arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConcreteMissingBody">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; must declare a body because it is not marked abstract, extern, or partial.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalMustReturnVoid">
            <summary>
              Looks up a localized string similar to The Conditional attribute is not valid on &apos;{0}&apos; because its return type is not void.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalOnInterfaceMethod">
            <summary>
              Looks up a localized string similar to The Conditional attribute is not valid on interface members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalOnNonAttributeClass">
            <summary>
              Looks up a localized string similar to Attribute &apos;{0}&apos; is only valid on methods or attribute classes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalOnOverride">
            <summary>
              Looks up a localized string similar to The Conditional attribute is not valid on &apos;{0}&apos; because it is an override method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalOnSpecialMethod">
            <summary>
              Looks up a localized string similar to The Conditional attribute is not valid on &apos;{0}&apos; because it is a constructor, destructor, operator, or explicit interface implementation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConditionalWithOutParam">
            <summary>
              Looks up a localized string similar to Conditional member &apos;{0}&apos; cannot have an out parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConflictAliasAndMember">
            <summary>
              Looks up a localized string similar to Namespace &apos;{1}&apos; contains a definition conflicting with alias &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConflictingAliasAndDefinition">
            <summary>
              Looks up a localized string similar to Alias &apos;{0}&apos; conflicts with {1} definition.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConflictingMachineModule">
            <summary>
              Looks up a localized string similar to Assembly and module &apos;{0}&apos; cannot target different processors..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstantExpected">
            <summary>
              Looks up a localized string similar to A constant value is expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstantStringTooLong">
            <summary>
              Looks up a localized string similar to Length of String constant exceeds current memory limit.  Try splitting the string into multiple constants..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstOutOfRange">
            <summary>
              Looks up a localized string similar to Constant value &apos;{0}&apos; cannot be converted to a &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstOutOfRangeChecked">
            <summary>
              Looks up a localized string similar to Constant value &apos;{0}&apos; cannot be converted to a &apos;{1}&apos; (use &apos;unchecked&apos; syntax to override).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstraintIsStaticClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: static classes cannot be used as constraints.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstraintOnlyAllowedOnGenericDecl">
            <summary>
              Looks up a localized string similar to Constraints are not allowed on non-generic declarations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstructedDynamicTypeAsBound">
            <summary>
              Looks up a localized string similar to Constraint cannot be a dynamic type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstructorInStaticClass">
            <summary>
              Looks up a localized string similar to Static classes cannot have instance constructors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConstValueRequired">
            <summary>
              Looks up a localized string similar to A const field requires a value to be provided.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConversionNotInvolvingContainedType">
            <summary>
              Looks up a localized string similar to User-defined conversion must convert to or from the enclosing type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConversionWithBase">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: user-defined conversions to or from a base class are not allowed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConversionWithDerived">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: user-defined conversions to or from a derived class are not allowed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConversionWithInterface">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: user-defined conversions to or from an interface are not allowed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConvertToStaticClass">
            <summary>
              Looks up a localized string similar to Cannot convert to static type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ConWithValCon">
            <summary>
              Looks up a localized string similar to Type parameter &apos;{1}&apos; has the &apos;struct&apos; constraint so &apos;{1}&apos; cannot be used as a constraint for &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CryptoHashFailed">
            <summary>
              Looks up a localized string similar to Cryptographic failure while creating hashes..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CStyleArray">
            <summary>
              Looks up a localized string similar to Bad array declarator: To declare a managed array the rank specifier precedes the variable&apos;s identifier. To declare a fixed size buffer field, use the fixed keyword before the field type..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CycleInInterfaceInheritance">
            <summary>
              Looks up a localized string similar to Inherited interface &apos;{1}&apos; causes a cycle in the interface hierarchy of &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_CycleInTypeForwarder">
            <summary>
              Looks up a localized string similar to The type forwarder for type &apos;{0}&apos; in assembly &apos;{1}&apos; causes a cycle.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DecConstError">
            <summary>
              Looks up a localized string similar to Evaluation of the decimal constant expression failed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultMemberOnIndexedType">
            <summary>
              Looks up a localized string similar to Cannot specify the DefaultMember attribute on a type containing an indexer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueBadValueType">
            <summary>
              Looks up a localized string similar to Argument of type &apos;{0}&apos; is not applicable for the DefaultParameterValue attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueBeforeRequiredValue">
            <summary>
              Looks up a localized string similar to Optional parameters must appear after all required parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueForExtensionParameter">
            <summary>
              Looks up a localized string similar to Cannot specify a default value for the &apos;this&apos; parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueForParamsParameter">
            <summary>
              Looks up a localized string similar to Cannot specify a default value for a parameter array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueMustBeConstant">
            <summary>
              Looks up a localized string similar to Default parameter value for &apos;{0}&apos; must be a compile-time constant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueNotAllowed">
            <summary>
              Looks up a localized string similar to Default values are not valid in this context..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueTypeMustMatch">
            <summary>
              Looks up a localized string similar to The type of the argument to the DefaultParameterValue attribute must match the parameter type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DefaultValueUsedWithAttributes">
            <summary>
              Looks up a localized string similar to Cannot specify default parameter value in conjunction with DefaultParameterAttribute or OptionalAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DelegateOnConditional">
            <summary>
              Looks up a localized string similar to Cannot create delegate with &apos;{0}&apos; because it or a method it overrides has a Conditional attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DelegateOnNullable">
            <summary>
              Looks up a localized string similar to Cannot bind delegate to &apos;{0}&apos; because it is a member of &apos;System.Nullable&lt;T&gt;&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeprecatedCollectionInitAddStr">
            <summary>
              Looks up a localized string similar to The best overloaded Add method &apos;{0}&apos; for the collection initializer element is obsolete. {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeprecatedSymbolStr">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is obsolete: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeriveFromConstructedDynamic">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot implement a dynamic interface &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeriveFromDynamic">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot derive from the dynamic type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DeriveFromEnumOrValueType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot derive from special class &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DerivingFromATyVar">
            <summary>
              Looks up a localized string similar to Cannot derive from &apos;{0}&apos; because it is a type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DestructorInStaticClass">
            <summary>
              Looks up a localized string similar to Static classes cannot contain destructors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DictionaryInitializerInExpressionTree">
            <summary>
              Looks up a localized string similar to An expression tree lambda may not contain a dictionary initializer..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DllImportOnGenericMethod">
            <summary>
              Looks up a localized string similar to The DllImport attribute cannot be applied to a method that is generic or contained in a generic type..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DllImportOnInvalidMethod">
            <summary>
              Looks up a localized string similar to The DllImport attribute must be specified on a method marked &apos;static&apos; and &apos;extern&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DoesntImplementAwaitInterface">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not implement &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DoNotUseFixedBufferAttr">
            <summary>
              Looks up a localized string similar to Do not use &apos;System.Runtime.CompilerServices.FixedBuffer&apos; attribute. Use the &apos;fixed&apos; field modifier instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DottedTypeNameNotFoundInAgg">
            <summary>
              Looks up a localized string similar to The type name &apos;{0}&apos; does not exist in the type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DottedTypeNameNotFoundInNS">
            <summary>
              Looks up a localized string similar to The type or namespace name &apos;{0}&apos; does not exist in the namespace &apos;{1}&apos; (are you missing an assembly reference?).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DottedTypeNameNotFoundInNSFwd">
            <summary>
              Looks up a localized string similar to The type name &apos;{0}&apos; could not be found in the namespace &apos;{1}&apos;. This type has been forwarded to assembly &apos;{2}&apos; Consider adding a reference to that assembly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateAccessor">
            <summary>
              Looks up a localized string similar to Property accessor already defined.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateAlias">
            <summary>
              Looks up a localized string similar to The using alias &apos;{0}&apos; appeared previously in this namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateAttribute">
            <summary>
              Looks up a localized string similar to Duplicate &apos;{0}&apos; attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateAttributeInNetModule">
            <summary>
              Looks up a localized string similar to Duplicate &apos;{0}&apos; attribute in &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateBound">
            <summary>
              Looks up a localized string similar to Duplicate constraint &apos;{0}&apos; for type parameter &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateCaseLabel">
            <summary>
              Looks up a localized string similar to The switch statement contains multiple cases with the label value &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateConstraintClause">
            <summary>
              Looks up a localized string similar to A constraint clause has already been specified for type parameter &apos;{0}&apos;. All of the constraints for a type parameter must be specified in a single where clause..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateConversionInClass">
            <summary>
              Looks up a localized string similar to Duplicate user-defined conversion in type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateGeneratedName">
            <summary>
              Looks up a localized string similar to The parameter name &apos;{0}&apos; conflicts with an automatically-generated parameter name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateImport">
            <summary>
              Looks up a localized string similar to Multiple assemblies with equivalent identity have been imported: &apos;{0}&apos; and &apos;{1}&apos;. Remove one of the duplicate references..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateImportSimple">
            <summary>
              Looks up a localized string similar to An assembly with the same simple name &apos;{0}&apos; has already been imported. Try removing one of the references (e.g. &apos;{1}&apos;) or sign them to enable side-by-side..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateInterfaceInBaseList">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is already listed in interface list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateLabel">
            <summary>
              Looks up a localized string similar to The label &apos;{0}&apos; is a duplicate.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateModifier">
            <summary>
              Looks up a localized string similar to Duplicate &apos;{0}&apos; modifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateNamedArgument">
            <summary>
              Looks up a localized string similar to Named argument &apos;{0}&apos; cannot be specified multiple times.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateNamedAttributeArgument">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; duplicate named attribute argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateNameInClass">
            <summary>
              Looks up a localized string similar to The type &apos;{0}&apos; already contains a definition for &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateNameInNS">
            <summary>
              Looks up a localized string similar to The namespace &apos;{1}&apos; already contains a definition for &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateParamName">
            <summary>
              Looks up a localized string similar to The parameter name &apos;{0}&apos; is a duplicate.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicatePropertyAccessMods">
            <summary>
              Looks up a localized string similar to Cannot specify accessibility modifiers for both accessors of the property or indexer &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateTypeForwarder">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; duplicate TypeForwardedToAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DuplicateTypeParameter">
            <summary>
              Looks up a localized string similar to Duplicate type parameter &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DupParamMod">
            <summary>
              Looks up a localized string similar to A parameter can only have one &apos;{0}&apos; modifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DynamicAttributeMissing">
            <summary>
              Looks up a localized string similar to Cannot define a class or member that utilizes &apos;dynamic&apos; because the compiler required type &apos;{0}&apos; cannot be found. Are you missing a reference?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DynamicRequiredTypesMissing">
            <summary>
              Looks up a localized string similar to One or more types required to compile a dynamic expression cannot be found. Are you missing a reference?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_DynamicTypeAsBound">
            <summary>
              Looks up a localized string similar to Constraint cannot be the dynamic type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EmptyCharConst">
            <summary>
              Looks up a localized string similar to Empty character literal.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EmptyElementInitializer">
            <summary>
              Looks up a localized string similar to Element initializer cannot be empty.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EmptyFormatSpecifier">
            <summary>
              Looks up a localized string similar to Empty format specifier..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EmptyYield">
            <summary>
              Looks up a localized string similar to Expression expected after yield return.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EncNoPIAReference">
            <summary>
              Looks up a localized string similar to Cannot continue since the edit includes a reference to an embedded type: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EncodinglessSyntaxTree">
            <summary>
              Looks up a localized string similar to Cannot emit debug information for a source text without encoding..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EncReferenceToAddedMember">
            <summary>
              Looks up a localized string similar to Member &apos;{0}&apos; added during the current debug session can only be accessed from within its declaring assembly &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EndifDirectiveExpected">
            <summary>
              Looks up a localized string similar to #endif directive expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EndOfPPLineExpected">
            <summary>
              Looks up a localized string similar to Single-line comment or end-of-line expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EndRegionDirectiveExpected">
            <summary>
              Looks up a localized string similar to #endregion directive expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EnumeratorOverflow">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: the enumerator value is too large to fit in its type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EnumsCantContainDefaultConstructor">
            <summary>
              Looks up a localized string similar to Enums cannot contain explicit parameterless constructors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EOFExpected">
            <summary>
              Looks up a localized string similar to Type or namespace definition, or end-of-file expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ErrorBuildingWin32Resources">
            <summary>
              Looks up a localized string similar to Error building Win32 resources -- {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ErrorDirective">
            <summary>
              Looks up a localized string similar to #error: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ErrorInReferencedAssembly">
            <summary>
              Looks up a localized string similar to There is an error in a referenced assembly &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EscapedCurly">
            <summary>
              Looks up a localized string similar to A &apos;{0}&apos; character may only be escaped by doubling &apos;{0}{0}&apos; in an interpolated string..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EventNeedsBothAccessors">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: event property must have both add and remove accessors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EventNotDelegate">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: event must be of a delegate type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_EventPropertyInInterface">
            <summary>
              Looks up a localized string similar to An event in an interface cannot have add or remove accessors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedContextualKeywordBy">
            <summary>
              Looks up a localized string similar to Expected contextual keyword &apos;by&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedContextualKeywordEquals">
            <summary>
              Looks up a localized string similar to Expected contextual keyword &apos;equals&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedContextualKeywordOn">
            <summary>
              Looks up a localized string similar to Expected contextual keyword &apos;on&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedEndTry">
            <summary>
              Looks up a localized string similar to Expected catch or finally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedPPFile">
            <summary>
              Looks up a localized string similar to Quoted file name expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedSelectOrGroup">
            <summary>
              Looks up a localized string similar to A query body must end with a select clause or a group clause.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpectedVerbatimLiteral">
            <summary>
              Looks up a localized string similar to Keyword, identifier, or string expected after verbatim specifier: @.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitDynamicAttr">
            <summary>
              Looks up a localized string similar to Do not use &apos;System.Runtime.CompilerServices.DynamicAttribute&apos;. Use the &apos;dynamic&apos; keyword instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitEventFieldImpl">
            <summary>
              Looks up a localized string similar to An explicit interface implementation of an event must use event accessor syntax.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitExtension">
            <summary>
              Looks up a localized string similar to Do not use &apos;System.Runtime.CompilerServices.ExtensionAttribute&apos;. Use the &apos;this&apos; keyword instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitImplCollisionOnRefOut">
            <summary>
              Looks up a localized string similar to Cannot inherit interface &apos;{0}&apos; with the specified type parameters because it causes method &apos;{1}&apos; to contain overloads which differ only on ref and out.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitImplParams">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; should not have a params parameter since &apos;{1}&apos; does not.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitInterfaceImplementationInNonClassOrStruct">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: explicit interface declaration can only be declared in a class or struct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitInterfaceImplementationNotInterface">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; in explicit interface declaration is not an interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitLayoutAndAutoImplementedProperty">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: Auto-implemented properties cannot be used inside a type marked with StructLayout(LayoutKind.Explicit).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitMethodImplAccessor">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; explicit method implementation cannot implement &apos;{1}&apos; because it is an accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitParamArray">
            <summary>
              Looks up a localized string similar to Do not use &apos;System.ParamArrayAttribute&apos;. Use the &apos;params&apos; keyword instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitPropertyAddingAccessor">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; adds an accessor not found in interface member &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExplicitPropertyMissingAccessor">
            <summary>
              Looks up a localized string similar to Explicit interface implementation &apos;{0}&apos; is missing accessor &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExportedTypeConflictsWithDeclaration">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; exported from module &apos;{1}&apos; conflicts with type declared in primary module of this assembly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExportedTypesConflict">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; exported from module &apos;{1}&apos; conflicts with type &apos;{2}&apos; exported from module &apos;{3}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionExpected">
            <summary>
              Looks up a localized string similar to Expected expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionHasNoName">
            <summary>
              Looks up a localized string similar to Expression does not have a name..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionOrDeclarationExpected">
            <summary>
              Looks up a localized string similar to Expression or declaration statement expected..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsAnonymousMethod">
            <summary>
              Looks up a localized string similar to An expression tree may not contain an anonymous method expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsAssignment">
            <summary>
              Looks up a localized string similar to An expression tree may not contain an assignment operator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsBadCoalesce">
            <summary>
              Looks up a localized string similar to An expression tree lambda may not contain a coalescing operator with a null literal left-hand side.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsBaseAccess">
            <summary>
              Looks up a localized string similar to An expression tree may not contain a base access.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsDynamicOperation">
            <summary>
              Looks up a localized string similar to An expression tree may not contain a dynamic operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsIndexedProperty">
            <summary>
              Looks up a localized string similar to An expression tree may not contain an indexed property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsMultiDimensionalArrayInitializer">
            <summary>
              Looks up a localized string similar to An expression tree may not contain a multidimensional array initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsNamedArgument">
            <summary>
              Looks up a localized string similar to An expression tree may not contain a named argument specification.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsOptionalArgument">
            <summary>
              Looks up a localized string similar to An expression tree may not contain a call or invocation that uses optional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeContainsPointerOp">
            <summary>
              Looks up a localized string similar to An expression tree may not contain an unsafe pointer operation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExpressionTreeMustHaveDelegate">
            <summary>
              Looks up a localized string similar to Cannot convert lambda to an expression tree whose type argument &apos;{0}&apos; is not a delegate type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExtensionAttrNotFound">
            <summary>
              Looks up a localized string similar to Cannot define a new extension method because the compiler required type &apos;{0}&apos; cannot be found. Are you missing a reference to System.Core.dll?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExtensionCollectionElementInitializerInExpressionTree">
            <summary>
              Looks up a localized string similar to An extension Add method is not supported for a collection initializer in an expression lambda..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExtensionMethodsDecl">
            <summary>
              Looks up a localized string similar to Extension methods must be defined in a top level static class; {0} is a nested class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExternAfterElements">
            <summary>
              Looks up a localized string similar to An extern alias declaration must precede all other elements defined in the namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExternAliasNotAllowed">
            <summary>
              Looks up a localized string similar to &apos;extern alias&apos; is not valid in this context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExternHasBody">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot be extern and declare a body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ExternHasConstructorInitializer">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot be extern and have a constructor initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureIsExperimental">
            <summary>
              Looks up a localized string similar to Feature &apos;{0}&apos; is only available in &apos;experimental&apos; language version..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion1">
            <summary>
              Looks up a localized string similar to Feature &apos;{0}&apos; is not available in C# 1.  Please use language version {1} or greater..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion2">
            <summary>
              Looks up a localized string similar to Feature &apos;{0}&apos; is not available in C# 2.  Please use language version {1} or greater..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion3">
            <summary>
              Looks up a localized string similar to Feature &apos;{0}&apos; is not available in C# 3.  Please use language version {1} or greater..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion4">
            <summary>
              Looks up a localized string similar to Feature &apos;{0}&apos; is not available in C# 4.  Please use language version {1} or greater..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion5">
            <summary>
              Looks up a localized string similar to Feature &apos;{0}&apos; is not available in C# 5.  Please use language version {1} or greater..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotAvailableInVersion6">
            <summary>
              Looks up a localized string similar to Feature &apos;{0}&apos; is not available in C# 6.  Please use language version {1} or greater..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FeatureNotValidInExpressionTree">
            <summary>
              Looks up a localized string similar to An expression tree may not contain &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldCantBeRefAny">
            <summary>
              Looks up a localized string similar to Field or property cannot be of type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldCantHaveVoidType">
            <summary>
              Looks up a localized string similar to Field cannot have void type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldHasMultipleDistinctConstantValues">
            <summary>
              Looks up a localized string similar to The field has multiple distinct constant values..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldInitializerInStruct">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot have instance property or field initializers in structs.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FieldInitRefNonstatic">
            <summary>
              Looks up a localized string similar to A field initializer cannot reference the non-static field, method, or property &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FileNotFound">
            <summary>
              Looks up a localized string similar to Source file &apos;{0}&apos; could not be found..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedBufferNotFixed">
            <summary>
              Looks up a localized string similar to You cannot use fixed size buffers contained in unfixed expressions. Try using the fixed statement..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedBufferTooManyDimensions">
            <summary>
              Looks up a localized string similar to A fixed buffer may only have one dimension..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedDimsRequired">
            <summary>
              Looks up a localized string similar to A fixed size buffer field must have the array size specifier after the field name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedLocalInLambda">
            <summary>
              Looks up a localized string similar to Cannot use fixed local &apos;{0}&apos; inside an anonymous method, lambda expression, or query expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedMustInit">
            <summary>
              Looks up a localized string similar to You must provide an initializer in a fixed or using statement declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedNeeded">
            <summary>
              Looks up a localized string similar to You can only take the address of an unfixed expression inside of a fixed statement initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedNeedsLvalue">
            <summary>
              Looks up a localized string similar to Fixed size buffers can only be accessed through locals or fields.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedNotInStruct">
            <summary>
              Looks up a localized string similar to Fixed size buffer fields may only be members of structs.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedNotNeeded">
            <summary>
              Looks up a localized string similar to You cannot use the fixed statement to take the address of an already fixed expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FixedOverflow">
            <summary>
              Looks up a localized string similar to Fixed size buffer of length {0} and type &apos;{1}&apos; is too big.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FloatOverflow">
            <summary>
              Looks up a localized string similar to Floating-point constant is outside the range of type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForEachMissingMember">
            <summary>
              Looks up a localized string similar to foreach statement cannot operate on variables of type &apos;{0}&apos; because &apos;{0}&apos; does not contain a public definition for &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForwardedTypeConflictsWithDeclaration">
            <summary>
              Looks up a localized string similar to Forwarded type &apos;{0}&apos; conflicts with type declared in primary module of this assembly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForwardedTypeConflictsWithExportedType">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; forwarded to assembly &apos;{1}&apos; conflicts with type &apos;{2}&apos; exported from module &apos;{3}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForwardedTypeInThisAssembly">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; is defined in this assembly, but a type forwarder is specified for it.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForwardedTypeIsNested">
            <summary>
              Looks up a localized string similar to Cannot forward type &apos;{0}&apos; because it is a nested type of &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ForwardedTypesConflict">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; forwarded to assembly &apos;{1}&apos; conflicts with type &apos;{2}&apos; forwarded to assembly &apos;{3}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FriendAssemblyBadArgs">
            <summary>
              Looks up a localized string similar to Friend assembly reference &apos;{0}&apos; is invalid. InternalsVisibleTo declarations cannot have a version, culture, public key token, or processor architecture specified..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FriendAssemblySNReq">
            <summary>
              Looks up a localized string similar to Friend assembly reference &apos;{0}&apos; is invalid. Strong-name signed assemblies must specify a public key in their InternalsVisibleTo declarations..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FriendRefNotEqualToThis">
            <summary>
              Looks up a localized string similar to Friend access was granted by &apos;{0}&apos;, but the public key of the output assembly does not match that specified by the attribute in the granting assembly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_FriendRefSigningMismatch">
            <summary>
              Looks up a localized string similar to Friend access was granted by &apos;{0}&apos;, but the strong name signing state of the output assembly does not match that of the granting assembly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericArgIsStaticClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: static types cannot be used as type arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericConstraintNotSatisfiedNullableEnum">
            <summary>
              Looks up a localized string similar to The type &apos;{3}&apos; cannot be used as type parameter &apos;{2}&apos; in the generic type or method &apos;{0}&apos;. The nullable type &apos;{3}&apos; does not satisfy the constraint of &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericConstraintNotSatisfiedNullableInterface">
            <summary>
              Looks up a localized string similar to The type &apos;{3}&apos; cannot be used as type parameter &apos;{2}&apos; in the generic type or method &apos;{0}&apos;. The nullable type &apos;{3}&apos; does not satisfy the constraint of &apos;{1}&apos;. Nullable types can not satisfy any interface constraints..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericConstraintNotSatisfiedRefType">
            <summary>
              Looks up a localized string similar to The type &apos;{3}&apos; cannot be used as type parameter &apos;{2}&apos; in the generic type or method &apos;{0}&apos;. There is no implicit reference conversion from &apos;{3}&apos; to &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericConstraintNotSatisfiedTyVar">
            <summary>
              Looks up a localized string similar to The type &apos;{3}&apos; cannot be used as type parameter &apos;{2}&apos; in the generic type or method &apos;{0}&apos;. There is no boxing conversion or type parameter conversion from &apos;{3}&apos; to &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericConstraintNotSatisfiedValType">
            <summary>
              Looks up a localized string similar to The type &apos;{3}&apos; cannot be used as type parameter &apos;{2}&apos; in the generic type or method &apos;{0}&apos;. There is no boxing conversion from &apos;{3}&apos; to &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericDerivingFromAttribute">
            <summary>
              Looks up a localized string similar to A generic type cannot derive from &apos;{0}&apos; because it is an attribute class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericsUsedAcrossAssemblies">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; from assembly &apos;{1}&apos; cannot be used across assembly boundaries because it has a generic type parameter that is an embedded interop type..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GenericsUsedInNoPIAType">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; cannot be embedded because it has a generic argument. Consider setting the &apos;Embed Interop Types&apos; property to false..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GetOrSetExpected">
            <summary>
              Looks up a localized string similar to A get or set accessor expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalAttributesNotAllowed">
            <summary>
              Looks up a localized string similar to Assembly and module attributes are not allowed in this context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalAttributesNotFirst">
            <summary>
              Looks up a localized string similar to Assembly and module attributes must precede all other elements defined in a file except using clauses and extern alias declarations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalDefinitionOrStatementExpected">
            <summary>
              Looks up a localized string similar to Member definition, statement, or end-of-file expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalExternAlias">
            <summary>
              Looks up a localized string similar to You cannot redefine the global extern alias.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalSingleTypeNameNotFound">
            <summary>
              Looks up a localized string similar to The type or namespace name &apos;{0}&apos; could not be found in the global namespace (are you missing an assembly reference?).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalSingleTypeNameNotFoundFwd">
            <summary>
              Looks up a localized string similar to The type name &apos;{0}&apos; could not be found in the global namespace. This type has been forwarded to assembly &apos;{1}&apos; Consider adding a reference to that assembly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_GlobalStatement">
            <summary>
              Looks up a localized string similar to Expressions and statements can only occur in a method body.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_HasNoTypeVars">
            <summary>
              Looks up a localized string similar to The non-generic {1} &apos;{0}&apos; cannot be used with type arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_HidingAbstractMethod">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; hides inherited abstract member &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IdentifierExpected">
            <summary>
              Looks up a localized string similar to Identifier expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IdentifierExpectedKW">
            <summary>
              Looks up a localized string similar to Identifier expected; &apos;{1}&apos; is a keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IdentityConversion">
            <summary>
              Looks up a localized string similar to User-defined operator cannot take an object of the enclosing type and convert to an object of the enclosing type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalArglist">
            <summary>
              Looks up a localized string similar to An __arglist expression may only appear inside of a call or new expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalEscape">
            <summary>
              Looks up a localized string similar to Unrecognized escape sequence.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalFixedType">
            <summary>
              Looks up a localized string similar to Fixed size buffer type must be one of the following: bool, byte, short, int, long, char, sbyte, ushort, uint, ulong, float or double.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalInnerUnsafe">
            <summary>
              Looks up a localized string similar to Unsafe code may not appear in iterators.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalParams">
            <summary>
              Looks up a localized string similar to params is not valid in this context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalRefParam">
            <summary>
              Looks up a localized string similar to ref and out are not valid in this context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalStatement">
            <summary>
              Looks up a localized string similar to Only assignment, call, increment, decrement, and new object expressions can be used as a statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalUnsafe">
            <summary>
              Looks up a localized string similar to Unsafe code may only appear if compiling with /unsafe.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalVarArgs">
            <summary>
              Looks up a localized string similar to __arglist is not valid in this context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IllegalVarianceSyntax">
            <summary>
              Looks up a localized string similar to Invalid variance modifier. Only interface and delegate type parameters can be specified as variant..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplBadConstraints">
            <summary>
              Looks up a localized string similar to The constraints for type parameter &apos;{0}&apos; of method &apos;{1}&apos; must match the constraints for type parameter &apos;{2}&apos; of interface method &apos;{3}&apos;. Consider using an explicit interface implementation instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedArrayNoBestType">
            <summary>
              Looks up a localized string similar to No best type found for implicitly-typed array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedLocalCannotBeFixed">
            <summary>
              Looks up a localized string similar to Implicitly-typed local variables cannot be fixed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedVariableAssignedArrayInitializer">
            <summary>
              Looks up a localized string similar to Cannot initialize an implicitly-typed variable with an array initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedVariableAssignedBadValue">
            <summary>
              Looks up a localized string similar to Cannot assign {0} to an implicitly-typed variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedVariableCannotBeConst">
            <summary>
              Looks up a localized string similar to Implicitly-typed variables cannot be constant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedVariableMultipleDeclarator">
            <summary>
              Looks up a localized string similar to Implicitly-typed variables cannot have multiple declarators.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImplicitlyTypedVariableWithNoInitializer">
            <summary>
              Looks up a localized string similar to Implicitly-typed variables must be initialized.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImportedCircularBase">
            <summary>
              Looks up a localized string similar to Imported type &apos;{0}&apos; is invalid. It contains a circular base class dependency..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ImportNonAssembly">
            <summary>
              Looks up a localized string similar to The referenced file &apos;{0}&apos; is not an assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InaccessibleGetter">
            <summary>
              Looks up a localized string similar to The property or indexer &apos;{0}&apos; cannot be used in this context because the get accessor is inaccessible.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InaccessibleSetter">
            <summary>
              Looks up a localized string similar to The property or indexer &apos;{0}&apos; cannot be used in this context because the set accessor is inaccessible.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InAttrOnOutParam">
            <summary>
              Looks up a localized string similar to An out parameter cannot have the In attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InconsistentIndexerNames">
            <summary>
              Looks up a localized string similar to Two indexers have different names; the IndexerName attribute must be used with the same name on every indexer within a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InconsistentLambdaParameterUsage">
            <summary>
              Looks up a localized string similar to Inconsistent lambda parameter usage; parameter types must be all explicit or all implicit.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IncrementLvalueExpected">
            <summary>
              Looks up a localized string similar to The operand of an increment or decrement operator must be a variable, property or indexer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndexedPropertyMustHaveAllOptionalParams">
            <summary>
              Looks up a localized string similar to Indexed property &apos;{0}&apos; must have all arguments optional.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndexedPropertyRequiresParams">
            <summary>
              Looks up a localized string similar to Indexed property &apos;{0}&apos; has non-optional arguments which must be provided.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndexerCantHaveVoidType">
            <summary>
              Looks up a localized string similar to Indexers cannot have void type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndexerInStaticClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot declare indexers in a static class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndexerNeedsParam">
            <summary>
              Looks up a localized string similar to Indexers must have at least one parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IndirectRecursiveConstructorCall">
            <summary>
              Looks up a localized string similar to Constructor &apos;{0}&apos; cannot call itself through another constructor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InExpected">
            <summary>
              Looks up a localized string similar to &apos;in&apos; expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InitializerAddHasParamModifiers">
            <summary>
              Looks up a localized string similar to The best overloaded method match &apos;{0}&apos; for the collection initializer element cannot be used. Collection initializer &apos;Add&apos; methods cannot have ref or out parameters..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InitializerAddHasWrongSignature">
            <summary>
              Looks up a localized string similar to The best overloaded method match for &apos;{0}&apos; has wrong signature for the initializer element. The initializable Add must be an accessible instance method..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InitializerInStructWithoutExplicitConstructor">
            <summary>
              Looks up a localized string similar to Structs without explicit constructors cannot contain members with initializers..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InitializerOnNonAutoProperty">
            <summary>
              Looks up a localized string similar to Only auto-implemented properties can have initializers..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InstanceMemberInStaticClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot declare instance members in a static class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InstantiatingStaticClass">
            <summary>
              Looks up a localized string similar to Cannot create an instance of the static class &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InsufficientStack">
            <summary>
              Looks up a localized string similar to An expression is too long or complex to compile.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IntDivByZero">
            <summary>
              Looks up a localized string similar to Division by constant zero.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IntegralTypeExpected">
            <summary>
              Looks up a localized string similar to Type byte, sbyte, short, ushort, int, uint, long, or ulong expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IntegralTypeValueExpected">
            <summary>
              Looks up a localized string similar to A value of an integral type expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfaceEventInitializer">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: event in interface cannot have initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfaceImplementedByConditional">
            <summary>
              Looks up a localized string similar to Conditional member &apos;{0}&apos; cannot implement interface member &apos;{1}&apos; in type &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfaceMemberHasBody">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: interface members cannot have a definition.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfaceMemberNotFound">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; in explicit interface declaration is not a member of interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfacesCannotContainTypes">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: interfaces cannot declare types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfacesCantContainConstructors">
            <summary>
              Looks up a localized string similar to Interfaces cannot contain constructors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfacesCantContainFields">
            <summary>
              Looks up a localized string similar to Interfaces cannot contain fields.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InterfacesCantContainOperators">
            <summary>
              Looks up a localized string similar to Interfaces cannot contain operators.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InteropMethodWithBody">
            <summary>
              Looks up a localized string similar to Embedded interop method &apos;{0}&apos; contains a body..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InteropStructContainsMethods">
            <summary>
              Looks up a localized string similar to Embedded interop struct &apos;{0}&apos; can contain only public instance fields..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InteropTypeMissingAttribute">
            <summary>
              Looks up a localized string similar to Interop type &apos;{0}&apos; cannot be embedded because it is missing the required &apos;{1}&apos; attribute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InteropTypesWithSameNameAndGuid">
            <summary>
              Looks up a localized string similar to Cannot embed interop type &apos;{0}&apos; found in both assembly &apos;{1}&apos; and &apos;{2}&apos;. Consider setting the &apos;Embed Interop Types&apos; property to false..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IntOverflow">
            <summary>
              Looks up a localized string similar to Integral constant is too large.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAddrOp">
            <summary>
              Looks up a localized string similar to Cannot take the address of the given expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAnonymousTypeMemberDeclarator">
            <summary>
              Looks up a localized string similar to Invalid anonymous type member declarator. Anonymous type members must be declared with a member assignment, simple name or member access..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidArray">
            <summary>
              Looks up a localized string similar to Invalid rank specifier: expected &apos;,&apos; or &apos;]&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAssemblyCulture">
            <summary>
              Looks up a localized string similar to Assembly culture strings may not contain embedded NUL characters..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAssemblyCultureForExe">
            <summary>
              Looks up a localized string similar to Executables cannot be satellite assemblies; culture should always be empty.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAssemblyName">
            <summary>
              Looks up a localized string similar to Assembly reference &apos;{0}&apos; is invalid and cannot be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidAttributeArgument">
            <summary>
              Looks up a localized string similar to Invalid value for argument to &apos;{0}&apos; attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidConstantDeclarationType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is of type &apos;{1}&apos;. The type specified in a constant declaration must be sbyte, byte, short, ushort, int, uint, long, ulong, char, float, double, decimal, bool, string, an enum-type, or a reference-type..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidDebugInformationFormat">
            <summary>
              Looks up a localized string similar to Invalid debug information format: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidDelegateType">
            <summary>
              Looks up a localized string similar to Delegate &apos;{0}&apos; has no invoke method or an invoke method with a return type or parameter types that are not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidDynamicCondition">
            <summary>
              Looks up a localized string similar to Expression must be implicitly convertible to Boolean or its type &apos;{0}&apos; must define operator &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidExprTerm">
            <summary>
              Looks up a localized string similar to Invalid expression term &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidFileAlignment">
            <summary>
              Looks up a localized string similar to Invalid file section alignment &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidFixedArraySize">
            <summary>
              Looks up a localized string similar to Fixed size buffers must have a length greater than zero.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidFormatForGuidForOption">
            <summary>
              Looks up a localized string similar to Command-line syntax error: Invalid Guid format &apos;{0}&apos; for option &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidFwdType">
            <summary>
              Looks up a localized string similar to Invalid type specified as an argument for TypeForwardedTo attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidGotoCase">
            <summary>
              Looks up a localized string similar to A goto case is only valid inside a switch statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidInitializerElementInitializer">
            <summary>
              Looks up a localized string similar to Invalid initializer member declarator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidLineNumber">
            <summary>
              Looks up a localized string similar to The line number specified for #line directive is missing or invalid.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidMemberDecl">
            <summary>
              Looks up a localized string similar to Invalid token &apos;{0}&apos; in class, struct, or interface member declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidNamedArgument">
            <summary>
              Looks up a localized string similar to Invalid value for named attribute argument &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidNumber">
            <summary>
              Looks up a localized string similar to Invalid number.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidOutputName">
            <summary>
              Looks up a localized string similar to Invalid output name: {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidPreprocExpr">
            <summary>
              Looks up a localized string similar to Invalid preprocessor expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidPropertyAccessMod">
            <summary>
              Looks up a localized string similar to The accessibility modifier of the &apos;{0}&apos; accessor must be more restrictive than the property or indexer &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidQM">
            <summary>
              Looks up a localized string similar to Type of conditional expression cannot be determined because there is no implicit conversion between &apos;{0}&apos; and &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidSignaturePublicKey">
            <summary>
              Looks up a localized string similar to Invalid signature public key specified in AssemblySignatureKeyAttribute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidSpecifier">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a valid format specifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidSubsystemVersion">
            <summary>
              Looks up a localized string similar to Invalid version {0} for /subsystemversion. The version must be 6.02 or greater for ARM or AppContainerExe, and 4.00 or greater otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidVersionFormat">
            <summary>
              Looks up a localized string similar to The specified version string does not conform to the required format - major[.minor[.build[.revision]]].
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_InvalidVersionFormat2">
            <summary>
              Looks up a localized string similar to The specified version string does not conform to the required format - major.minor.build.revision.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_IteratorInInteractive">
            <summary>
              Looks up a localized string similar to Yield statements may not appear at the top level in interactive code..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LabelNotFound">
            <summary>
              Looks up a localized string similar to No such label &apos;{0}&apos; within the scope of the goto statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LabelShadow">
            <summary>
              Looks up a localized string similar to The label &apos;{0}&apos; shadows another label by the same name in a contained scope.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LambdaInIsAs">
            <summary>
              Looks up a localized string similar to The first operand of an &apos;is&apos; or &apos;as&apos; operator may not be a lambda expression, anonymous method, or method group..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LbraceExpected">
            <summary>
              Looks up a localized string similar to { expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LegacyObjectIdSyntax">
            <summary>
              Looks up a localized string similar to &apos;id#&apos; syntax is no longer supported. Use &apos;$id&apos; instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LinkedNetmoduleMetadataMustProvideFullPEImage">
            <summary>
              Looks up a localized string similar to Linked netmodule metadata must provide a full PE image: &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LiteralDoubleCast">
            <summary>
              Looks up a localized string similar to Literal of type double cannot be implicitly converted to type &apos;{1}&apos;; use an &apos;{0}&apos; suffix to create a literal of this type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LocalCantBeFixedAndHoisted">
            <summary>
              Looks up a localized string similar to Local &apos;{0}&apos; or its members cannot have their address taken and be used inside an anonymous method or lambda expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LocalDuplicate">
            <summary>
              Looks up a localized string similar to A local variable named &apos;{0}&apos; is already defined in this scope.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LocalIllegallyOverrides">
            <summary>
              Looks up a localized string similar to A local or parameter named &apos;{0}&apos; cannot be declared in this scope because that name is used in an enclosing local scope to define a local or parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LocalSameNameAsTypeParam">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: a parameter or local variable cannot have the same name as a method type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LocalTypeNameClash">
            <summary>
              Looks up a localized string similar to Embedding the interop type &apos;{0}&apos; from assembly &apos;{1}&apos; causes a name clash in the current assembly. Consider setting the &apos;Embed Interop Types&apos; property to false..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LockNeedsReference">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a reference type as required by the lock statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_LookupInTypeVariable">
            <summary>
              Looks up a localized string similar to Cannot do member lookup in &apos;{0}&apos; because it is a type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MainCantBeAsync">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: an entry point cannot be marked with the &apos;async&apos; modifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MainClassIsImport">
            <summary>
              Looks up a localized string similar to Cannot use &apos;{0}&apos; for Main method because it is imported.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MainClassNotClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; specified for Main method must be a valid non-generic class or struct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MainClassNotFound">
            <summary>
              Looks up a localized string similar to Could not find &apos;{0}&apos; specified for Main method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ManagedAddr">
            <summary>
              Looks up a localized string similar to Cannot take the address of, get the size of, or declare a pointer to a managed type (&apos;{0}&apos;).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MarshalUnmanagedTypeNotValidForFields">
            <summary>
              Looks up a localized string similar to Unmanaged type &apos;{0}&apos; not valid for fields..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MarshalUnmanagedTypeOnlyValidForFields">
            <summary>
              Looks up a localized string similar to Unmanaged type &apos;{0}&apos; is only valid for fields..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberAlreadyExists">
            <summary>
              Looks up a localized string similar to Type &apos;{1}&apos; already defines a member called &apos;{0}&apos; with the same parameter types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberAlreadyInitialized">
            <summary>
              Looks up a localized string similar to Duplicate initialization of member &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberCannotBeInitialized">
            <summary>
              Looks up a localized string similar to Member &apos;{0}&apos; cannot be initialized. It is not a field or property..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberNameSameAsType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: member names cannot be the same as their enclosing type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberNeedsType">
            <summary>
              Looks up a localized string similar to Method must have a return type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemberReserved">
            <summary>
              Looks up a localized string similar to Type &apos;{1}&apos; already reserves a member called &apos;{0}&apos; with the same parameter types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MemGroupInExpressionTree">
            <summary>
              Looks up a localized string similar to An expression tree lambda may not contain a method group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MetadataNameTooLong">
            <summary>
              Looks up a localized string similar to Name &apos;{0}&apos; exceeds the maximum length allowed in metadata..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MetadataReferencesNotSupported">
            <summary>
              Looks up a localized string similar to Metadata references not supported..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethDelegateMismatch">
            <summary>
              Looks up a localized string similar to No overload for &apos;{0}&apos; matches delegate &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethGrpToNonDel">
            <summary>
              Looks up a localized string similar to Cannot convert method group &apos;{0}&apos; to non-delegate type &apos;{1}&apos;. Did you intend to invoke the method?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethodArgCantBeRefAny">
            <summary>
              Looks up a localized string similar to Cannot make reference to variable of type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethodImplementingAccessor">
            <summary>
              Looks up a localized string similar to Method &apos;{0}&apos; cannot implement interface accessor &apos;{1}&apos; for type &apos;{2}&apos;. Use an explicit interface implementation..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethodNameExpected">
            <summary>
              Looks up a localized string similar to Method name expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MethodReturnCantBeRefAny">
            <summary>
              Looks up a localized string similar to Method or delegate cannot return type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingArgument">
            <summary>
              Looks up a localized string similar to Argument missing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingArraySize">
            <summary>
              Looks up a localized string similar to Array creation must have array size or array initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingCoClass">
            <summary>
              Looks up a localized string similar to The managed coclass wrapper class &apos;{0}&apos; for interface &apos;{1}&apos; cannot be found (are you missing an assembly reference?).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingDebugSwitch">
            <summary>
              Looks up a localized string similar to The /pdb option requires that the /debug option also be used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingGuidForOption">
            <summary>
              Looks up a localized string similar to Command-line syntax error: Missing Guid for option &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingMethodOnSourceInterface">
            <summary>
              Looks up a localized string similar to Source interface &apos;{0}&apos; is missing method &apos;{1}&apos; which is required to embed event &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingNetModuleReference">
            <summary>
              Looks up a localized string similar to Reference to &apos;{0}&apos; netmodule missing..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingPartial">
            <summary>
              Looks up a localized string similar to Missing partial modifier on declaration of type &apos;{0}&apos;; another partial declaration of this type exists.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingPPFile">
            <summary>
              Looks up a localized string similar to Quoted file name, single-line comment or end-of-line expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingPredefinedMember">
            <summary>
              Looks up a localized string similar to Missing compiler required member &apos;{0}.{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingSourceInterface">
            <summary>
              Looks up a localized string similar to Interface &apos;{0}&apos; has an invalid source interface which is required to embed event &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingStructOffset">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: instance field types marked with StructLayout(LayoutKind.Explicit) must have a FieldOffset attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingTypeInAssembly">
            <summary>
              Looks up a localized string similar to Reference to type &apos;{0}&apos; claims it is defined in &apos;{1}&apos;, but it could not be found.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MissingTypeInSource">
            <summary>
              Looks up a localized string similar to Reference to type &apos;{0}&apos; claims it is defined in this assembly, but it is not defined in source or any added modules.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MixingWinRTEventWithRegular">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot implement &apos;{1}&apos; because &apos;{2}&apos; is a Windows Runtime event and &apos;{3}&apos; is a regular .NET event..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ModuleEmitFailure">
            <summary>
              Looks up a localized string similar to Failed to emit module &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultiParamMod">
            <summary>
              Looks up a localized string similar to A parameter cannot have all the specified modifiers; there are too many modifiers on the parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultipleEntryPoints">
            <summary>
              Looks up a localized string similar to Program has more than one entry point defined. Compile with /main to specify the type that contains the entry point..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultipleIEnumOfT">
            <summary>
              Looks up a localized string similar to foreach statement cannot operate on variables of type &apos;{0}&apos; because it implements multiple instantiations of &apos;{1}&apos;; try casting to a specific interface instantiation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MultiTypeInDeclaration">
            <summary>
              Looks up a localized string similar to Cannot use more than one type in a for, using, fixed, or declaration statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MustHaveOpTF">
            <summary>
              Looks up a localized string similar to In order for &apos;{0}&apos; to be applicable as a short circuit operator, its declaring type &apos;{1}&apos; must define operator true and operator false.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_MutuallyExclusiveOptions">
            <summary>
              Looks up a localized string similar to Compilation options &apos;{0}&apos; and &apos;{1}&apos; can&apos;t both be specified at the same time..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamedArgumentExpected">
            <summary>
              Looks up a localized string similar to Named attribute argument expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamedArgumentForArray">
            <summary>
              Looks up a localized string similar to An array access may not have a named argument specifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamedArgumentSpecificationBeforeFixedArgument">
            <summary>
              Looks up a localized string similar to Named argument specifications must appear after all fixed arguments have been specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamedArgumentUsedInPositional">
            <summary>
              Looks up a localized string similar to Named argument &apos;{0}&apos; specifies a parameter for which a positional argument has already been given.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NameNotInContext">
            <summary>
              Looks up a localized string similar to The name &apos;{0}&apos; does not exist in the current context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NameNotInContextPossibleMissingReference">
            <summary>
              Looks up a localized string similar to The name &apos;{0}&apos; does not exist in the current context (are you missing a reference to assembly &apos;{1}&apos;?).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NameofExtensionMethod">
            <summary>
              Looks up a localized string similar to Extension method groups are not allowed as an argument to &apos;nameof&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NameofMethodGroupWithTypeParameters">
            <summary>
              Looks up a localized string similar to Type parameters are not allowed on a method group as an argument to &apos;nameof&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamespaceNotAllowedInScript">
            <summary>
              Looks up a localized string similar to You cannot declare namespace in script code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NamespaceUnexpected">
            <summary>
              Looks up a localized string similar to A namespace cannot directly contain members such as fields or methods.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NegativeArraySize">
            <summary>
              Looks up a localized string similar to Cannot create an array with a negative size.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NegativeStackAllocSize">
            <summary>
              Looks up a localized string similar to Cannot use a negative size with stackalloc.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NetModuleNameMismatch">
            <summary>
              Looks up a localized string similar to Module name &apos;{0}&apos; stored in &apos;{1}&apos; must match its filename..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NetModuleNameMustBeUnique">
            <summary>
              Looks up a localized string similar to Module &apos;{0}&apos; is already defined in this assembly. Each module must have a unique filename..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewBoundMustBeLast">
            <summary>
              Looks up a localized string similar to The new() constraint must be the last constraint specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewBoundWithVal">
            <summary>
              Looks up a localized string similar to The &apos;new()&apos; constraint cannot be used with the &apos;struct&apos; constraint.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewCoClassOnLink">
            <summary>
              Looks up a localized string similar to Interop type &apos;{0}&apos; cannot be embedded. Use the applicable interface instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewConstraintNotSatisfied">
            <summary>
              Looks up a localized string similar to &apos;{2}&apos; must be a non-abstract type with a public parameterless constructor in order to use it as parameter &apos;{1}&apos; in the generic type or method &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewlineInConst">
            <summary>
              Looks up a localized string similar to Newline in constant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewTyvarWithArgs">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot provide arguments when creating an instance of a variable type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NewVirtualInSealed">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is a new virtual member in sealed class &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoAliasHere">
            <summary>
              Looks up a localized string similar to A &apos;using static&apos; directive cannot be used to declare an alias.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoBaseClass">
            <summary>
              Looks up a localized string similar to A base class is required for a &apos;base&apos; reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoBreakOrCont">
            <summary>
              Looks up a localized string similar to No enclosing loop out of which to break or continue.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoCanonicalView">
            <summary>
              Looks up a localized string similar to Cannot find the interop type that matches the embedded interop type &apos;{0}&apos;. Are you missing an assembly reference?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConstructors">
            <summary>
              Looks up a localized string similar to The type &apos;{0}&apos; has no constructors defined.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConversionForCallerFilePathParam">
            <summary>
              Looks up a localized string similar to CallerFilePathAttribute cannot be applied because there are no standard conversions from type &apos;{0}&apos; to type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConversionForCallerLineNumberParam">
            <summary>
              Looks up a localized string similar to CallerLineNumberAttribute cannot be applied because there are no standard conversions from type &apos;{0}&apos; to type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConversionForCallerMemberNameParam">
            <summary>
              Looks up a localized string similar to CallerMemberNameAttribute cannot be applied because there are no standard conversions from type &apos;{0}&apos; to type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConversionForDefaultParam">
            <summary>
              Looks up a localized string similar to A value of type &apos;{0}&apos; cannot be used as a default parameter because there are no standard conversions to type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConversionForNubDefaultParam">
            <summary>
              Looks up a localized string similar to A value of type &apos;{0}&apos; cannot be used as default parameter for nullable parameter &apos;{1}&apos; because &apos;{0}&apos; is not a simple type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoConvToIDisp">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: type used in a using statement must be implicitly convertible to &apos;System.IDisposable&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoCorrespondingArgument">
            <summary>
              Looks up a localized string similar to There is no argument given that corresponds to the required formal parameter &apos;{0}&apos; of &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoDynamicPhantomOnBase">
            <summary>
              Looks up a localized string similar to The call to method &apos;{0}&apos; needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoDynamicPhantomOnBaseCtor">
            <summary>
              Looks up a localized string similar to The constructor call needs to be dynamically dispatched, but cannot be because it is part of a constructor initializer. Consider casting the dynamic arguments..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoDynamicPhantomOnBaseIndexer">
            <summary>
              Looks up a localized string similar to The indexer access needs to be dynamically dispatched, but cannot be because it is part of a base access expression. Consider casting the dynamic arguments or eliminating the base access..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoEntryPoint">
            <summary>
              Looks up a localized string similar to Program does not contain a static &apos;Main&apos; method suitable for an entry point.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoExplicitBuiltinConv">
            <summary>
              Looks up a localized string similar to Cannot convert type &apos;{0}&apos; to &apos;{1}&apos; via a reference conversion, boxing conversion, unboxing conversion, wrapping conversion, or null type conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoExplicitConv">
            <summary>
              Looks up a localized string similar to Cannot convert type &apos;{0}&apos; to &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoFileSpec">
            <summary>
              Looks up a localized string similar to Missing file specification for &apos;{0}&apos; option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoGetToOverride">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot override because &apos;{1}&apos; does not have an overridable get accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoImplicitConv">
            <summary>
              Looks up a localized string similar to Cannot implicitly convert type &apos;{0}&apos; to &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoImplicitConvCast">
            <summary>
              Looks up a localized string similar to Cannot implicitly convert type &apos;{0}&apos; to &apos;{1}&apos;. An explicit conversion exists (are you missing a cast?).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoMainInClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not have a suitable static Main method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoMainOnDLL">
            <summary>
              Looks up a localized string similar to Cannot specify /main if building a module or library.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoMetadataFile">
            <summary>
              Looks up a localized string similar to Metadata file &apos;{0}&apos; could not be found.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoModifiersOnAccessor">
            <summary>
              Looks up a localized string similar to Modifiers cannot be placed on event accessor declarations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoMultipleInheritance">
            <summary>
              Looks up a localized string similar to Class &apos;{0}&apos; cannot have multiple base classes: &apos;{1}&apos; and &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoNamespacePrivate">
            <summary>
              Looks up a localized string similar to Elements defined in a namespace cannot be explicitly declared as private, protected, or protected internal.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoNewAbstract">
            <summary>
              Looks up a localized string similar to Cannot create an instance of the abstract class or interface &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoNewTyvar">
            <summary>
              Looks up a localized string similar to Cannot create an instance of the variable type &apos;{0}&apos; because it does not have the new() constraint.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NonInterfaceInInterfaceList">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; in interface list is not an interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NonInvocableMemberCalled">
            <summary>
              Looks up a localized string similar to Non-invocable member &apos;{0}&apos; cannot be used like a method..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoPIAAssemblyMissingAttribute">
            <summary>
              Looks up a localized string similar to Cannot embed interop types from assembly &apos;{0}&apos; because it is missing the &apos;{1}&apos; attribute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoPIAAssemblyMissingAttributes">
            <summary>
              Looks up a localized string similar to Cannot embed interop types from assembly &apos;{0}&apos; because it is missing either the &apos;{1}&apos; attribute or the &apos;{2}&apos; attribute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoPIANestedType">
            <summary>
              Looks up a localized string similar to Type &apos;{0}&apos; cannot be embedded because it is a nested type. Consider setting the &apos;Embed Interop Types&apos; property to false..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoScriptsSpecified">
            <summary>
              Looks up a localized string similar to Expected at least one script (.csx file) but none specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoSetToOverride">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot override because &apos;{1}&apos; does not have an overridable set accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoSourceFile">
            <summary>
              Looks up a localized string similar to Source file &apos;{0}&apos; could not be opened -- {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoSuchMember">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not contain a definition for &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoSuchMemberOrExtension">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not contain a definition for &apos;{1}&apos; and no extension method &apos;{1}&apos; accepting a first argument of type &apos;{0}&apos; could be found (are you missing a using directive or an assembly reference?).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoSuchMemberOrExtensionNeedUsing">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not contain a definition for &apos;{1}&apos; and no extension method &apos;{1}&apos; accepting a first argument of type &apos;{0}&apos; could be found (are you missing a using directive for &apos;{2}&apos;?).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotAnAttributeClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not an attribute class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotConstantExpression">
            <summary>
              Looks up a localized string similar to The expression being assigned to &apos;{0}&apos; must be constant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotNullConstRefField">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is of type &apos;{1}&apos;. A const field of a reference type other than string can only be initialized with null..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotNullRefDefaultParameter">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is of type &apos;{1}&apos;. A default parameter value of a reference type other than string can only be initialized with null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NotYetImplementedInRoslyn">
            <summary>
              Looks up a localized string similar to This language feature (&apos;{0}&apos;) is not yet implemented..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoTypeDef">
            <summary>
              Looks up a localized string similar to The type &apos;{0}&apos; is defined in an assembly that is not referenced. You must add a reference to assembly &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoTypeDefFromModule">
            <summary>
              Looks up a localized string similar to The type &apos;{0}&apos; is defined in a module that has not been added. You must add the module &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoVoidHere">
            <summary>
              Looks up a localized string similar to Keyword &apos;void&apos; cannot be used in this context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NoVoidParameter">
            <summary>
              Looks up a localized string similar to Invalid parameter type &apos;void&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NullNotValid">
            <summary>
              Looks up a localized string similar to Use of null is not valid in this context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_NullPropagatingOpInExpressionTree">
            <summary>
              Looks up a localized string similar to An expression tree lambda may not contain a null propagating operator..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ObjectCallingBaseConstructor">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; has no base class and cannot call a base constructor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ObjectCantHaveBases">
            <summary>
              Looks up a localized string similar to The class System.Object cannot have a base class or implement an interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ObjectOrCollectionInitializerWithDelegateCreation">
            <summary>
              Looks up a localized string similar to Object and collection initializer expressions may not be applied to a delegate creation expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ObjectProhibited">
            <summary>
              Looks up a localized string similar to Member &apos;{0}&apos; cannot be accessed with an instance reference; qualify it with a type name instead.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ObjectRequired">
            <summary>
              Looks up a localized string similar to An object reference is required for the non-static field, method, or property &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OneAliasPerReference">
            <summary>
              Looks up a localized string similar to A /reference option that declares an extern alias can only have one filename. To specify multiple aliases or filenames, use multiple /reference options..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OnlyClassesCanContainDestructors">
            <summary>
              Looks up a localized string similar to Only class types can contain destructors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OpenEndedComment">
            <summary>
              Looks up a localized string similar to End-of-file found, &apos;*/&apos; expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OpenResponseFile">
            <summary>
              Looks up a localized string similar to Error opening response file &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OperatorCantReturnVoid">
            <summary>
              Looks up a localized string similar to User-defined operators cannot return void.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OperatorInStaticClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: static classes cannot contain user-defined operators.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OperatorNeedsMatch">
            <summary>
              Looks up a localized string similar to The operator &apos;{0}&apos; requires a matching operator &apos;{1}&apos; to also be defined.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OperatorsMustBeStatic">
            <summary>
              Looks up a localized string similar to User-defined operator &apos;{0}&apos; must be declared static and public.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OpTFRetType">
            <summary>
              Looks up a localized string similar to The return type of operator True or False must be bool.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OutAttrOnRefParam">
            <summary>
              Looks up a localized string similar to Cannot specify only Out attribute on a ref parameter. Use both In and Out attributes, or neither..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OutputNeedsName">
            <summary>
              Looks up a localized string similar to Outputs without source must have the /out option specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OutputWriteFailed">
            <summary>
              Looks up a localized string similar to Could not write to output file &apos;{0}&apos; -- &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverloadRefOut">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot define overloaded methods that differ only on ref and out.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverloadRefOutCtor">
            <summary>
              Looks up a localized string similar to Cannot define overloaded constructor &apos;{0}&apos; because it differs from another constructor only on ref and out.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideFinalizeDeprecated">
            <summary>
              Looks up a localized string similar to Do not override object.Finalize. Instead, provide a destructor..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideNotExpected">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: no suitable method found to override.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideNotNew">
            <summary>
              Looks up a localized string similar to A member &apos;{0}&apos; marked as override cannot be marked as new or virtual.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OverrideWithConstraints">
            <summary>
              Looks up a localized string similar to Constraints for override and explicit interface implementation methods are inherited from the base method, so they cannot be specified directly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OvlBinaryOperatorExpected">
            <summary>
              Looks up a localized string similar to Overloadable binary operator expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OvlOperatorExpected">
            <summary>
              Looks up a localized string similar to Overloadable operator expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_OvlUnaryOperatorExpected">
            <summary>
              Looks up a localized string similar to Overloadable unary operator expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParamDefaultValueDiffersFromAttribute">
            <summary>
              Looks up a localized string similar to The parameter has multiple distinct default values..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParameterIsStaticClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: static types cannot be used as parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParameterNotValidForType">
            <summary>
              Looks up a localized string similar to Parameter not valid for the specified unmanaged type..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParamsCantBeRefOut">
            <summary>
              Looks up a localized string similar to The params parameter cannot be declared as ref or out.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParamsLast">
            <summary>
              Looks up a localized string similar to A params parameter must be the last parameter in a formal parameter list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParamsMustBeArray">
            <summary>
              Looks up a localized string similar to The params parameter must be a single dimensional array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ParamUnassigned">
            <summary>
              Looks up a localized string similar to The out parameter &apos;{0}&apos; must be assigned to before control leaves the current method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodCannotHaveOutParameters">
            <summary>
              Looks up a localized string similar to A partial method cannot have out parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodExtensionDifference">
            <summary>
              Looks up a localized string similar to Both partial method declarations must be extension methods or neither may be an extension method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodInconsistentConstraints">
            <summary>
              Looks up a localized string similar to Partial method declarations of &apos;{0}&apos; have inconsistent type parameter constraints.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodInExpressionTree">
            <summary>
              Looks up a localized string similar to Partial methods with only a defining declaration or removed conditional methods cannot be used in expression trees.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodInvalidModifier">
            <summary>
              Looks up a localized string similar to A partial method cannot have access modifiers or the virtual, abstract, override, new, sealed, or extern modifiers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodMustHaveLatent">
            <summary>
              Looks up a localized string similar to No defining declaration found for implementing declaration of partial method &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodMustReturnVoid">
            <summary>
              Looks up a localized string similar to Partial methods must have a void return type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodNotExplicit">
            <summary>
              Looks up a localized string similar to A partial method may not explicitly implement an interface method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodOnlyInPartialClass">
            <summary>
              Looks up a localized string similar to A partial method must be declared within a partial class or partial struct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodOnlyMethods">
            <summary>
              Looks up a localized string similar to Only methods, classes, structs, or interfaces may be partial.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodOnlyOneActual">
            <summary>
              Looks up a localized string similar to A partial method may not have multiple implementing declarations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodOnlyOneLatent">
            <summary>
              Looks up a localized string similar to A partial method may not have multiple defining declarations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodParamsDifference">
            <summary>
              Looks up a localized string similar to Both partial method declarations must use a params parameter or neither may use a params parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodStaticDifference">
            <summary>
              Looks up a localized string similar to Both partial method declarations must be static or neither may be static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodToDelegate">
            <summary>
              Looks up a localized string similar to Cannot create delegate from method &apos;{0}&apos; because it is a partial method without an implementing declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMethodUnsafeDifference">
            <summary>
              Looks up a localized string similar to Both partial method declarations must be unsafe or neither may be unsafe.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMisplaced">
            <summary>
              Looks up a localized string similar to The &apos;partial&apos; modifier can only appear immediately before &apos;class&apos;, &apos;struct&apos;, &apos;interface&apos;, or &apos;void&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialModifierConflict">
            <summary>
              Looks up a localized string similar to Partial declarations of &apos;{0}&apos; have conflicting accessibility modifiers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialMultipleBases">
            <summary>
              Looks up a localized string similar to Partial declarations of &apos;{0}&apos; must not specify different base classes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialTypeKindConflict">
            <summary>
              Looks up a localized string similar to Partial declarations of &apos;{0}&apos; must be all classes, all structs, or all interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialWrongConstraints">
            <summary>
              Looks up a localized string similar to Partial declarations of &apos;{0}&apos; have inconsistent constraints for type parameter &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialWrongTypeParams">
            <summary>
              Looks up a localized string similar to Partial declarations of &apos;{0}&apos; must have the same type parameter names in the same order.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PartialWrongTypeParamsVariance">
            <summary>
              Looks up a localized string similar to Partial declarations of &apos;{0}&apos; must have the same type parameter names and variance modifiers in the same order.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PermissionSetAttributeFileReadError">
            <summary>
              Looks up a localized string similar to Error reading file &apos;{0}&apos; specified for the named argument &apos;{1}&apos; for PermissionSet attribute: &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PermissionSetAttributeInvalidFile">
            <summary>
              Looks up a localized string similar to Unable to resolve file path &apos;{0}&apos; specified for the named argument &apos;{1}&apos; for PermissionSet attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PointerInAsOrIs">
            <summary>
              Looks up a localized string similar to Neither &apos;is&apos; nor &apos;as&apos; is valid on pointer types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PPDefFollowsToken">
            <summary>
              Looks up a localized string similar to Cannot define/undefine preprocessor symbols after first token in file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PPDirectiveExpected">
            <summary>
              Looks up a localized string similar to Preprocessor directive expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PPReferenceFollowsToken">
            <summary>
              Looks up a localized string similar to Cannot use #r after first token in file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PredefinedTypeNotFound">
            <summary>
              Looks up a localized string similar to Predefined type &apos;{0}&apos; is not defined or imported.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PrincipalPermissionInvalidAction">
            <summary>
              Looks up a localized string similar to SecurityAction value &apos;{0}&apos; is invalid for PrincipalPermission attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PrivateAbstractAccessor">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: abstract properties cannot have private accessors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PropertyAccessModInInterface">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: accessibility modifiers may not be used on accessors in an interface.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PropertyCantHaveVoidType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: property or indexer cannot have void type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PropertyLacksGet">
            <summary>
              Looks up a localized string similar to The property or indexer &apos;{0}&apos; cannot be used in this context because it lacks the get accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PropertyWithNoAccessors">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: property or indexer must have at least one accessor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ProtectedInStatic">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: static classes cannot contain protected members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ProtectedInStruct">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: new protected member declared in struct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PtrExpected">
            <summary>
              Looks up a localized string similar to The * or -&gt; operator must be applied to a pointer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PtrIndexSingle">
            <summary>
              Looks up a localized string similar to A pointer must be indexed by only one value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PublicKeyContainerFailure">
            <summary>
              Looks up a localized string similar to Error signing output with public key from container &apos;{0}&apos; -- {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_PublicKeyFileFailure">
            <summary>
              Looks up a localized string similar to Error signing output with public key from file &apos;{0}&apos; -- {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryDuplicateRangeVariable">
            <summary>
              Looks up a localized string similar to The range variable &apos;{0}&apos; has already been declared.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryInnerKey">
            <summary>
              Looks up a localized string similar to The name &apos;{0}&apos; is not in scope on the right side of &apos;equals&apos;.  Consider swapping the expressions on either side of &apos;equals&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryMultipleProviders">
            <summary>
              Looks up a localized string similar to Multiple implementations of the query pattern were found for source type &apos;{0}&apos;.  Ambiguous call to &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryNoProvider">
            <summary>
              Looks up a localized string similar to Could not find an implementation of the query pattern for source type &apos;{0}&apos;.  &apos;{1}&apos; not found..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryNoProviderCastable">
            <summary>
              Looks up a localized string similar to Could not find an implementation of the query pattern for source type &apos;{0}&apos;.  &apos;{1}&apos; not found.  Consider explicitly specifying the type of the range variable &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryNoProviderStandard">
            <summary>
              Looks up a localized string similar to Could not find an implementation of the query pattern for source type &apos;{0}&apos;.  &apos;{1}&apos; not found.  Are you missing a reference to &apos;System.Core.dll&apos; or a using directive for &apos;System.Linq&apos;?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryOuterKey">
            <summary>
              Looks up a localized string similar to The name &apos;{0}&apos; is not in scope on the left side of &apos;equals&apos;.  Consider swapping the expressions on either side of &apos;equals&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryOutRefRangeVariable">
            <summary>
              Looks up a localized string similar to Cannot pass the range variable &apos;{0}&apos; as an out or ref parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryRangeVariableAssignedBadValue">
            <summary>
              Looks up a localized string similar to Cannot assign {0} to a range variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryRangeVariableOverrides">
            <summary>
              Looks up a localized string similar to The range variable &apos;{0}&apos; conflicts with a previous declaration of &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryRangeVariableReadOnly">
            <summary>
              Looks up a localized string similar to Range variable &apos;{0}&apos; cannot be assigned to -- it is read only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryRangeVariableSameAsTypeParam">
            <summary>
              Looks up a localized string similar to The range variable &apos;{0}&apos; cannot have the same name as a method type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryTypeInferenceFailed">
            <summary>
              Looks up a localized string similar to The type of the expression in the {0} clause is incorrect.  Type inference failed in the call to &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryTypeInferenceFailedMulti">
            <summary>
              Looks up a localized string similar to The type of one of the expressions in the {0} clause is incorrect.  Type inference failed in the call to &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_QueryTypeInferenceFailedSelectMany">
            <summary>
              Looks up a localized string similar to An expression of type &apos;{0}&apos; is not allowed in a subsequent from clause in a query expression with source type &apos;{1}&apos;.  Type inference failed in the call to &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RbraceExpected">
            <summary>
              Looks up a localized string similar to } expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReadonlyValueTypeInObjectInitializer">
            <summary>
              Looks up a localized string similar to Members of readonly field &apos;{0}&apos; of type &apos;{1}&apos; cannot be assigned with an object initializer because it is of a value type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RecursiveConstructorCall">
            <summary>
              Looks up a localized string similar to Constructor &apos;{0}&apos; cannot call itself.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RecursivelyTypedVariable">
            <summary>
              Looks up a localized string similar to Type of &apos;{0}&apos; cannot be inferred since its initializer directly or indirectly refers to the definition..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefConstraintNotSatisfied">
            <summary>
              Looks up a localized string similar to The type &apos;{2}&apos; must be a reference type in order to use it as parameter &apos;{1}&apos; in the generic type or method &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReferenceDirectiveOnlyAllowedInScripts">
            <summary>
              Looks up a localized string similar to #r is only allowed in scripts.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefLvalueExpected">
            <summary>
              Looks up a localized string similar to A ref or out argument must be an assignable variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefOutDefaultValue">
            <summary>
              Looks up a localized string similar to A ref or out parameter cannot have a default value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefProperty">
            <summary>
              Looks up a localized string similar to A property or indexer may not be passed as an out or ref parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonly">
            <summary>
              Looks up a localized string similar to A readonly field cannot be passed ref or out (except in a constructor).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonly2">
            <summary>
              Looks up a localized string similar to Members of readonly field &apos;{0}&apos; cannot be passed ref or out (except in a constructor).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyLocal">
            <summary>
              Looks up a localized string similar to Cannot pass &apos;{0}&apos; as a ref or out argument because it is read-only.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyLocal2Cause">
            <summary>
              Looks up a localized string similar to Cannot pass fields of &apos;{0}&apos; as a ref or out argument because it is a &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyLocalCause">
            <summary>
              Looks up a localized string similar to Cannot pass &apos;{0}&apos; as a ref or out argument because it is a &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyStatic">
            <summary>
              Looks up a localized string similar to A static readonly field cannot be passed ref or out (except in a static constructor).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefReadonlyStatic2">
            <summary>
              Looks up a localized string similar to Fields of static readonly field &apos;{0}&apos; cannot be passed ref or out (except in a static constructor).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefValBoundMustBeFirst">
            <summary>
              Looks up a localized string similar to The &apos;class&apos; or &apos;struct&apos; constraint must come before any other constraints.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RefValBoundWithClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: cannot specify both a constraint class and the &apos;class&apos; or &apos;struct&apos; constraint.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReservedAssemblyName">
            <summary>
              Looks up a localized string similar to The assembly name &apos;{0}&apos; is reserved and cannot be used as a reference in an interactive session.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReservedEnumerator">
            <summary>
              Looks up a localized string similar to The enumerator name &apos;{0}&apos; is reserved and cannot be used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ResourceFileNameNotUnique">
            <summary>
              Looks up a localized string similar to Each linked resource and module must have a unique filename. Filename &apos;{0}&apos; is specified more than once in this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ResourceNotUnique">
            <summary>
              Looks up a localized string similar to Resource identifier &apos;{0}&apos; has already been used in this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RetNoObjectRequired">
            <summary>
              Looks up a localized string similar to Since &apos;{0}&apos; returns void, a return keyword must not be followed by an object expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RetNoObjectRequiredLambda">
            <summary>
              Looks up a localized string similar to Anonymous function converted to a void returning delegate cannot return a value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_RetObjectRequired">
            <summary>
              Looks up a localized string similar to An object of a type convertible to &apos;{0}&apos; is required.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReturnExpected">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: not all code paths return a value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReturnInIterator">
            <summary>
              Looks up a localized string similar to Cannot return a value from an iterator. Use the yield return statement to return a value, or yield break to end the iteration..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReturnNotAllowedInScript">
            <summary>
              Looks up a localized string similar to You cannot use &apos;return&apos; in top-level script code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReturnNotLValue">
            <summary>
              Looks up a localized string similar to Cannot modify the return value of &apos;{0}&apos; because it is not a variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ReturnTypeIsStaticClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: static types cannot be used as return types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SameFullNameAggAgg">
            <summary>
              Looks up a localized string similar to The type &apos;{1}&apos; exists in both &apos;{0}&apos; and &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SameFullNameNsAgg">
            <summary>
              Looks up a localized string similar to The namespace &apos;{1}&apos; in &apos;{0}&apos; conflicts with the type &apos;{3}&apos; in &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SameFullNameThisAggThisNs">
            <summary>
              Looks up a localized string similar to The type &apos;{1}&apos; in &apos;{0}&apos; conflicts with the namespace &apos;{3}&apos; in &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SealedNonOverride">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot be sealed because it is not an override.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SealedStaticClass">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: a class cannot be both static and sealed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityAttributeInvalidAction">
            <summary>
              Looks up a localized string similar to Security attribute &apos;{0}&apos; has an invalid SecurityAction value &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityAttributeInvalidActionAssembly">
            <summary>
              Looks up a localized string similar to SecurityAction value &apos;{0}&apos; is invalid for security attributes applied to an assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityAttributeInvalidActionTypeOrMethod">
            <summary>
              Looks up a localized string similar to SecurityAction value &apos;{0}&apos; is invalid for security attributes applied to a type or a method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityAttributeInvalidTarget">
            <summary>
              Looks up a localized string similar to Security attribute &apos;{0}&apos; is not valid on this declaration type. Security attributes are only valid on assembly, type and method declarations..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityAttributeMissingAction">
            <summary>
              Looks up a localized string similar to First argument to a security attribute must be a valid SecurityAction.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityCriticalOrSecuritySafeCriticalOnAsync">
            <summary>
              Looks up a localized string similar to Security attribute &apos;{0}&apos; cannot be applied to an Async method..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SecurityCriticalOrSecuritySafeCriticalOnAsyncInClassOrStruct">
            <summary>
              Looks up a localized string similar to Async methods are not allowed in an Interface, Class, or Structure which has the &apos;SecurityCritical&apos; or &apos;SecuritySafeCritical&apos; attribute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SemicolonExpected">
            <summary>
              Looks up a localized string similar to ; expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SemiOrLBraceExpected">
            <summary>
              Looks up a localized string similar to { or ; expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SignButNoPrivateKey">
            <summary>
              Looks up a localized string similar to Key file &apos;{0}&apos; is missing the private key needed for signing.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SingleLineCommentInExpressionHole">
            <summary>
              Looks up a localized string similar to A single-line comment may not be used in an interpolated string..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SingleTypeNameNotFound">
            <summary>
              Looks up a localized string similar to The type or namespace name &apos;{0}&apos; could not be found (are you missing a using directive or an assembly reference?).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SingleTypeNameNotFoundFwd">
            <summary>
              Looks up a localized string similar to The type name &apos;{0}&apos; could not be found. This type has been forwarded to assembly &apos;{1}&apos;. Consider adding a reference to that assembly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SizeofUnsafe">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not have a predefined size, therefore sizeof can only be used in an unsafe context (consider using System.Runtime.InteropServices.Marshal.SizeOf).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SpecialByRefInLambda">
            <summary>
              Looks up a localized string similar to Instance of type &apos;{0}&apos; cannot be used inside an anonymous function, query expression, iterator block or async method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SpecialTypeAsBound">
            <summary>
              Looks up a localized string similar to Constraint cannot be special class &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StackallocInCatchFinally">
            <summary>
              Looks up a localized string similar to stackalloc may not be used in a catch or finally block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StatementLambdaToExpressionTree">
            <summary>
              Looks up a localized string similar to A lambda expression with a statement body cannot be converted to an expression tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticBaseClass">
            <summary>
              Looks up a localized string similar to &apos;{1}&apos;: cannot derive from static class &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticClassInterfaceImpl">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: static classes cannot implement interfaces.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticConstant">
            <summary>
              Looks up a localized string similar to The constant &apos;{0}&apos; cannot be marked static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticConstParam">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: a static constructor must be parameterless.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticConstructorWithAccessModifiers">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: access modifiers are not allowed on static constructors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticConstructorWithExplicitConstructorCall">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: static constructor cannot have an explicit &apos;this&apos; or &apos;base&apos; constructor call.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticDerivedFromNonObject">
            <summary>
              Looks up a localized string similar to Static class &apos;{0}&apos; cannot derive from type &apos;{1}&apos;. Static classes must derive from object..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticInAsOrIs">
            <summary>
              Looks up a localized string similar to The second operand of an &apos;is&apos; or &apos;as&apos; operator may not be static type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticMemberInObjectInitializer">
            <summary>
              Looks up a localized string similar to Static field or property &apos;{0}&apos; cannot be assigned in an object initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StaticNotVirtual">
            <summary>
              Looks up a localized string similar to A static member &apos;{0}&apos; cannot be marked as override, virtual, or abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StructLayoutCycle">
            <summary>
              Looks up a localized string similar to Struct member &apos;{0}&apos; of type &apos;{1}&apos; causes a cycle in the struct layout.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StructOffsetOnBadField">
            <summary>
              Looks up a localized string similar to The FieldOffset attribute is not allowed on static or const fields.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StructOffsetOnBadStruct">
            <summary>
              Looks up a localized string similar to The FieldOffset attribute can only be placed on members of types marked with the StructLayout(LayoutKind.Explicit).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StructsCantContainDefaultConstructor">
            <summary>
              Looks up a localized string similar to Structs cannot contain explicit parameterless constructors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_StructWithBaseConstructorCall">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: structs cannot call base class constructors.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SubexpressionNotInNameof">
            <summary>
              Looks up a localized string similar to Sub-expression cannot be used in an argument to nameof..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchFallOut">
            <summary>
              Looks up a localized string similar to Control cannot fall out of switch from final case label (&apos;{0}&apos;).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchFallThrough">
            <summary>
              Looks up a localized string similar to Control cannot fall through from one case label (&apos;{0}&apos;) to another.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchGoverningTypeValueExpected">
            <summary>
              Looks up a localized string similar to A switch expression or case label must be a bool, char, string, integral, enum, or corresponding nullable type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchNeedsNumber">
            <summary>
              Looks up a localized string similar to Command-line syntax error: Missing &apos;:&lt;number&gt;&apos; for &apos;{0}&apos; option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SwitchNeedsString">
            <summary>
              Looks up a localized string similar to Command-line syntax error: Missing &apos;{0}&apos; for &apos;{1}&apos; option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SynchronizedAsyncMethod">
            <summary>
              Looks up a localized string similar to &apos;MethodImplOptions.Synchronized&apos; cannot be applied to an async method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SyntaxError">
            <summary>
              Looks up a localized string similar to Syntax error, &apos;{0}&apos; expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_SystemVoid">
            <summary>
              Looks up a localized string similar to System.Void cannot be used from C# -- use typeof(void) to get the void type object.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TaskRetNoObjectRequired">
            <summary>
              Looks up a localized string similar to Since &apos;{0}&apos; is an async method that returns &apos;Task&apos;, a return keyword must not be followed by an object expression. Did you intend to return &apos;Task&lt;T&gt;&apos;?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TaskRetNoObjectRequiredLambda">
            <summary>
              Looks up a localized string similar to Async lambda expression converted to a &apos;Task&apos; returning delegate cannot return a value. Did you intend to return &apos;Task&lt;T&gt;&apos;?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ThisInBadContext">
            <summary>
              Looks up a localized string similar to Keyword &apos;this&apos; is not available in the current context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ThisInStaticMeth">
            <summary>
              Looks up a localized string similar to Keyword &apos;this&apos; is not valid in a static property, static method, or static field initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ThisOrBaseExpected">
            <summary>
              Looks up a localized string similar to Keyword &apos;this&apos; or &apos;base&apos; expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ThisStructNotInAnonMeth">
            <summary>
              Looks up a localized string similar to Anonymous methods, lambda expressions, and query expressions inside structs cannot access instance members of &apos;this&apos;. Consider copying &apos;this&apos; to a local variable outside the anonymous method, lambda expression or query expression and using the local instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TooManyCatches">
            <summary>
              Looks up a localized string similar to Catch clauses cannot follow the general catch clause of a try statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TooManyCharsInConst">
            <summary>
              Looks up a localized string similar to Too many characters in character literal.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TooManyLocals">
            <summary>
              Looks up a localized string similar to Only 65534 locals, including those generated by the compiler, are allowed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TrailingWhitespaceInFormatSpecifier">
            <summary>
              Looks up a localized string similar to A format specifier may not contain trailing whitespace..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeArgsNotAllowed">
            <summary>
              Looks up a localized string similar to The {1} &apos;{0}&apos; cannot be used with type arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeExpected">
            <summary>
              Looks up a localized string similar to Type expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeParamMustBeIdentifier">
            <summary>
              Looks up a localized string similar to Type parameter declaration must be an identifier not a type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeVarCantBeNull">
            <summary>
              Looks up a localized string similar to Cannot convert null to type parameter &apos;{0}&apos; because it could be a non-nullable value type. Consider using &apos;default({0})&apos; instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeVariableSameAsParent">
            <summary>
              Looks up a localized string similar to Type parameter &apos;{0}&apos; has the same name as the containing type, or method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeVarNotFound">
            <summary>
              Looks up a localized string similar to The contextual keyword &apos;var&apos; may only appear within a local variable declaration or in script code.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TypeVarNotFoundRangeVariable">
            <summary>
              Looks up a localized string similar to The contextual keyword &apos;var&apos; cannot be used in a range variable declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_TyVarNotFoundInConstraint">
            <summary>
              Looks up a localized string similar to &apos;{1}&apos; does not define type parameter &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnassignedThis">
            <summary>
              Looks up a localized string similar to Field &apos;{0}&apos; must be fully assigned before control is returned to the caller.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnassignedThisAutoProperty">
            <summary>
              Looks up a localized string similar to Auto-implemented property property &apos;{0}&apos; must be fully assigned before control is returned to the caller..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnboxNotLValue">
            <summary>
              Looks up a localized string similar to Cannot modify the result of an unboxing conversion.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnclosedExpressionHole">
            <summary>
              Looks up a localized string similar to Missing close delimiter &apos;}&apos; for interpolated expression started with &apos;{&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnescapedCurly">
            <summary>
              Looks up a localized string similar to A &apos;{0}&apos; character must be escaped (by doubling) in an interpolated string..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedAliasedName">
            <summary>
              Looks up a localized string similar to Unexpected use of an aliased name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedBoundGenericName">
            <summary>
              Looks up a localized string similar to Type arguments are not allowed in the nameof operator..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedCharacter">
            <summary>
              Looks up a localized string similar to Unexpected character &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedDirective">
            <summary>
              Looks up a localized string similar to Unexpected preprocessor directive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedGenericName">
            <summary>
              Looks up a localized string similar to Unexpected use of a generic name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedSemicolon">
            <summary>
              Looks up a localized string similar to Semicolon after method or accessor block is not valid.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedToken">
            <summary>
              Looks up a localized string similar to Unexpected token &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedUnboundGenericName">
            <summary>
              Looks up a localized string similar to Unexpected use of an unbound generic name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnexpectedVariance">
            <summary>
              Looks up a localized string similar to Invalid variance: The type parameter &apos;{1}&apos; must be {3} valid on &apos;{0}&apos;. &apos;{1}&apos; is {2}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnifyingInterfaceInstantiations">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot implement both &apos;{1}&apos; and &apos;{2}&apos; because they may unify for some type parameter substitutions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnimplementedAbstractMethod">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not implement inherited abstract member &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnimplementedInterfaceAccessor">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not implement interface member &apos;{1}&apos;. &apos;{2}&apos; is not public..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnimplementedInterfaceMember">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not implement interface member &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnreachableCatch">
            <summary>
              Looks up a localized string similar to A previous catch clause already catches all exceptions of this or of a super type (&apos;{0}&apos;).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsafeAsyncArgType">
            <summary>
              Looks up a localized string similar to Async methods cannot have unsafe parameters or return types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsafeIteratorArgType">
            <summary>
              Looks up a localized string similar to Iterators cannot have unsafe parameters or yield types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsafeNeeded">
            <summary>
              Looks up a localized string similar to Pointers and fixed size buffers may only be used in an unsafe context.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsafeTypeInObjectCreation">
            <summary>
              Looks up a localized string similar to Unsafe type &apos;{0}&apos; cannot be used in object creation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnsupportedTransparentIdentifierAccess">
            <summary>
              Looks up a localized string similar to Transparent identifier member access failed for field &apos;{0}&apos; of &apos;{1}&apos;.  Does the data being queried implement the query pattern?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UnterminatedStringLit">
            <summary>
              Looks up a localized string similar to Unterminated string literal.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolation">
            <summary>
              Looks up a localized string similar to Use of unassigned local variable &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolationField">
            <summary>
              Looks up a localized string similar to Use of possibly unassigned field &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolationOut">
            <summary>
              Looks up a localized string similar to Use of unassigned out parameter &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolationProperty">
            <summary>
              Looks up a localized string similar to Use of possibly unassigned auto-implemented property &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UseDefViolationThis">
            <summary>
              Looks up a localized string similar to The &apos;this&apos; object cannot be used before all of its fields are assigned to.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_UsingAfterElements">
            <summary>
              Looks up a localized string similar to A using clause must precede all other elements defined in the namespace except extern alias declarations.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ValConstraintNotSatisfied">
            <summary>
              Looks up a localized string similar to The type &apos;{2}&apos; must be a non-nullable value type in order to use it as parameter &apos;{1}&apos; in the generic type or method &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ValueCantBeNull">
            <summary>
              Looks up a localized string similar to Cannot convert null to &apos;{0}&apos; because it is a non-nullable value type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ValueExpected">
            <summary>
              Looks up a localized string similar to Syntax error; value expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ValueTypeExtDelegate">
            <summary>
              Looks up a localized string similar to Extension method &apos;{0}&apos; defined on value type &apos;{1}&apos; cannot be used to create delegates.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_ValueTypePropertyInObjectInitializer">
            <summary>
              Looks up a localized string similar to Members of property &apos;{0}&apos; of type &apos;{1}&apos; cannot be assigned with an object initializer because it is of a value type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarargsAsync">
            <summary>
              Looks up a localized string similar to __arglist is not allowed in the parameter list of async methods.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarArgsInExpressionTree">
            <summary>
              Looks up a localized string similar to An expression tree lambda may not contain a method with variable arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarargsIterator">
            <summary>
              Looks up a localized string similar to __arglist is not allowed in the parameter list of iterators.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarargsLast">
            <summary>
              Looks up a localized string similar to An __arglist parameter must be the last parameter in a formal parameter list.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VarDeclIsStaticClass">
            <summary>
              Looks up a localized string similar to Cannot declare a variable of static type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VariableUsedBeforeDeclaration">
            <summary>
              Looks up a localized string similar to Cannot use local variable &apos;{0}&apos; before it is declared.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VariableUsedBeforeDeclarationAndHidesField">
            <summary>
              Looks up a localized string similar to Cannot use local variable &apos;{0}&apos; before it is declared. The declaration of the local variable hides the field &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VirtualPrivate">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: virtual or abstract members cannot be private.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VoidError">
            <summary>
              Looks up a localized string similar to The operation in question is undefined on void pointers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VolatileAndReadonly">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: a field cannot be both volatile and readonly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_VolatileStruct">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: a volatile field cannot be of the type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_WinRtEventPassedByRef">
            <summary>
              Looks up a localized string similar to A Windows Runtime event may not be passed as an out or ref parameter..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ERR_YieldInAnonMeth">
            <summary>
              Looks up a localized string similar to The yield statement cannot be used inside an anonymous method or lambda expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_BadChecksumAlgorithm">
            <summary>
              Looks up a localized string similar to Algorithm &apos;{0}&apos; is not supported.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_BadCodepage">
            <summary>
              Looks up a localized string similar to Code page &apos;{0}&apos; is invalid or not installed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_DebugEmitFailure">
            <summary>
              Looks up a localized string similar to Unexpected error writing debug information -- &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_InputFileNameTooLong">
            <summary>
              Looks up a localized string similar to File name &apos;{0}&apos; is empty, contains invalid characters, has a drive specification without an absolute path, or is too long.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_InvalidTarget">
            <summary>
              Looks up a localized string similar to Invalid target type for /target: must specify &apos;exe&apos;, &apos;winexe&apos;, &apos;library&apos;, or &apos;module&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_MetadataCantOpenFile">
            <summary>
              Looks up a localized string similar to Metadata file &apos;{0}&apos; could not be opened -- {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.FTL_OutputFileExists">
            <summary>
              Looks up a localized string similar to Cannot create short filename &apos;{0}&apos; when a long filename with the same short filename already exists.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.GenericParameterDefinition">
            <summary>
              Looks up a localized string similar to Generic parameter is definition when expected to be reference {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.HDN_UnusedExternAlias">
            <summary>
              Looks up a localized string similar to Unused extern alias..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.HDN_UnusedExternAlias_Title">
            <summary>
              Looks up a localized string similar to Unused extern alias.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.HDN_UnusedUsingDirective">
            <summary>
              Looks up a localized string similar to Unnecessary using directive..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.HDN_UnusedUsingDirective_Title">
            <summary>
              Looks up a localized string similar to Unnecessary using directive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_AnonMethod">
            <summary>
              Looks up a localized string similar to anonymous method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_AwaitInCatchAndFinally">
            <summary>
              Looks up a localized string similar to await in catch blocks and finally blocks.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Collection">
            <summary>
              Looks up a localized string similar to collection.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Contravariant">
            <summary>
              Looks up a localized string similar to contravariant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Contravariantly">
            <summary>
              Looks up a localized string similar to contravariantly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Covariant">
            <summary>
              Looks up a localized string similar to covariant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Covariantly">
            <summary>
              Looks up a localized string similar to covariantly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_CSCHelp">
             <summary>
               Looks up a localized string similar to 
                                          Visual C# Compiler Options
            
                                    - OUTPUT FILES -
             /out:&lt;file&gt;                   Specify output file name (default: base name of 
                                           file with main class or first file)
             /target:exe                   Build a console executable (default) (Short 
                                           form: /t:exe)
             /target:winexe                Build a Windows executable (Short form: 
                                           /t:winexe)
             /target:library     [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_DirectoryDoesNotExist">
            <summary>
              Looks up a localized string similar to directory does not exist.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_DirectoryHasInvalidPath">
            <summary>
              Looks up a localized string similar to path is too long or invalid.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAnonDelegates">
            <summary>
              Looks up a localized string similar to anonymous methods.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAnonymousTypes">
            <summary>
              Looks up a localized string similar to anonymous types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAsync">
            <summary>
              Looks up a localized string similar to async function.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAutoImplementedProperties">
            <summary>
              Looks up a localized string similar to automatically implemented properties.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureAutoPropertyInitializer">
            <summary>
              Looks up a localized string similar to auto property initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureCollectionInitializer">
            <summary>
              Looks up a localized string similar to collection initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDeclarationExpression">
            <summary>
              Looks up a localized string similar to declaration expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDefault">
            <summary>
              Looks up a localized string similar to default operator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDictionaryInitializer">
            <summary>
              Looks up a localized string similar to dictionary initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureDynamic">
            <summary>
              Looks up a localized string similar to dynamic.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExceptionFilter">
            <summary>
              Looks up a localized string similar to exception filter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExpressionBodiedIndexer">
            <summary>
              Looks up a localized string similar to expression-bodied indexer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExpressionBodiedMethod">
            <summary>
              Looks up a localized string similar to expression-bodied method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExpressionBodiedProperty">
            <summary>
              Looks up a localized string similar to expression-bodied property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExtensionMethod">
            <summary>
              Looks up a localized string similar to extension method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureExternAlias">
            <summary>
              Looks up a localized string similar to extern alias.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureFixedBuffer">
            <summary>
              Looks up a localized string similar to fixed size buffers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureGenerics">
            <summary>
              Looks up a localized string similar to generics.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureGlobalNamespace">
            <summary>
              Looks up a localized string similar to namespace alias qualifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureImplicitArray">
            <summary>
              Looks up a localized string similar to implicitly typed array.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureImplicitLocal">
            <summary>
              Looks up a localized string similar to implicitly typed local variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureInterpolatedStrings">
            <summary>
              Looks up a localized string similar to interpolated strings.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureIterators">
            <summary>
              Looks up a localized string similar to iterators.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureLambda">
            <summary>
              Looks up a localized string similar to lambda expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureModuleAttrLoc">
            <summary>
              Looks up a localized string similar to module as an attribute target specifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNamedArgument">
            <summary>
              Looks up a localized string similar to named argument.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNameof">
            <summary>
              Looks up a localized string similar to nameof operator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNullable">
            <summary>
              Looks up a localized string similar to nullable types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureNullPropagatingOperator">
            <summary>
              Looks up a localized string similar to null propagating operator.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureObjectInitializer">
            <summary>
              Looks up a localized string similar to object initializer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureOptionalParameter">
            <summary>
              Looks up a localized string similar to optional parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePartialMethod">
            <summary>
              Looks up a localized string similar to partial method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePartialTypes">
            <summary>
              Looks up a localized string similar to partial types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePragma">
            <summary>
              Looks up a localized string similar to #pragma.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeaturePropertyAccessorMods">
            <summary>
              Looks up a localized string similar to access modifiers on properties.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureQueryExpression">
            <summary>
              Looks up a localized string similar to query expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureStaticClasses">
            <summary>
              Looks up a localized string similar to static classes.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureSwitchOnBool">
            <summary>
              Looks up a localized string similar to switch on boolean type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureTypeVariance">
            <summary>
              Looks up a localized string similar to type variance.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FeatureUsingStatic">
            <summary>
              Looks up a localized string similar to using static.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FIXEDLOCAL">
            <summary>
              Looks up a localized string similar to fixed variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_FOREACHLOCAL">
            <summary>
              Looks up a localized string similar to foreach iteration variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_GlobalNamespace">
            <summary>
              Looks up a localized string similar to &lt;global namespace&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Invariantly">
            <summary>
              Looks up a localized string similar to invariantly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Lambda">
            <summary>
              Looks up a localized string similar to lambda expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_LIB_ENV">
            <summary>
              Looks up a localized string similar to LIB environment variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_LIB_OPTION">
            <summary>
              Looks up a localized string similar to /LIB option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_LogoLine1">
            <summary>
              Looks up a localized string similar to {0} version {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_LogoLine2">
            <summary>
              Looks up a localized string similar to Copyright (C) Microsoft Corporation. All rights reserved..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_MethodGroup">
            <summary>
              Looks up a localized string similar to method group.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Namespace1">
            <summary>
              Looks up a localized string similar to &lt;namespace&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_NULL">
            <summary>
              Looks up a localized string similar to &lt;null&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_OperationCausedStackOverflow">
            <summary>
              Looks up a localized string similar to Operation caused a stack overflow..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_PathList">
            <summary>
              Looks up a localized string similar to &lt;path list&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_REFERENCEPATH_OPTION">
            <summary>
              Looks up a localized string similar to /REFERENCEPATH option.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_RELATEDERROR">
            <summary>
              Looks up a localized string similar to (Location of symbol related to previous error).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_RELATEDWARNING">
            <summary>
              Looks up a localized string similar to (Location of symbol related to previous warning).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_ALIAS">
            <summary>
              Looks up a localized string similar to using alias.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_EVENT">
            <summary>
              Looks up a localized string similar to event.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_EXTERNALIAS">
            <summary>
              Looks up a localized string similar to extern alias.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_FIELD">
            <summary>
              Looks up a localized string similar to field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_LABEL">
            <summary>
              Looks up a localized string similar to label.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_METHOD">
            <summary>
              Looks up a localized string similar to method.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_NAMESPACE">
            <summary>
              Looks up a localized string similar to namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_PROPERTY">
            <summary>
              Looks up a localized string similar to property.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_TYPE">
            <summary>
              Looks up a localized string similar to type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_TYVAR">
            <summary>
              Looks up a localized string similar to type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_UNKNOWN">
            <summary>
              Looks up a localized string similar to element.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_SK_VARIABLE">
            <summary>
              Looks up a localized string similar to variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_Text">
            <summary>
              Looks up a localized string similar to &lt;text&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_ToolName">
            <summary>
              Looks up a localized string similar to Microsoft (R) Visual C# Compiler.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_USINGLOCAL">
            <summary>
              Looks up a localized string similar to using variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_VersionExperimental">
            <summary>
              Looks up a localized string similar to &apos;experimental&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLBADINCLUDE">
            <summary>
              Looks up a localized string similar to  Include tag is invalid .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLFAILEDINCLUDE">
            <summary>
              Looks up a localized string similar to  Failed to insert some or all of included XML .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLIGNORED">
            <summary>
              Looks up a localized string similar to &lt;!-- Badly formed XML comment ignored for member &quot;{0}&quot; --&gt;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLIGNORED2">
            <summary>
              Looks up a localized string similar to  Badly formed XML file &quot;{0}&quot; cannot be included .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLMISSINGINCLUDEFILE">
            <summary>
              Looks up a localized string similar to Missing file attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLMISSINGINCLUDEPATH">
            <summary>
              Looks up a localized string similar to Missing path attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.IDS_XMLNOINCLUDE">
            <summary>
              Looks up a localized string similar to  No matching elements were found for the following include tag .
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.INF_UnableToLoadSomeTypesInAnalyzer">
            <summary>
              Looks up a localized string similar to Skipping some types in analyzer assembly {0} due to a ReflectionTypeLoadException : {1}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.INF_UnableToLoadSomeTypesInAnalyzer_Title">
            <summary>
              Looks up a localized string similar to Skip loading types in analyzer assembly that fail due to a ReflectionTypeLoadException.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.InvalidGetDeclarationNameMultipleDeclarators">
            <summary>
              Looks up a localized string similar to Called GetDeclarationName for a declaration node that can possibly contain multiple variable declarators..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ItemsMustBeNonEmpty">
            <summary>
              Looks up a localized string similar to items: must be non-empty.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.LocationMustBeProvided">
            <summary>
              Looks up a localized string similar to Location must be provided in order to provide minimal type qualification..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.LookupOptionsHasInvalidCombo">
            <summary>
              Looks up a localized string similar to LookupOptions has an invalid combination of options.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.MustCallSetMethodTestData">
            <summary>
              Looks up a localized string similar to Must call SetMethodTestData(ConcurrentDictionary) before calling SetMethodTestData(MethodSymbol, ILBuilder).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.NameConflictForName">
            <summary>
              Looks up a localized string similar to Name conflict for name {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.NoNoneSearchCriteria">
            <summary>
              Looks up a localized string similar to SearchCriteria is expected..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.NotACSharpSymbol">
            <summary>
              Looks up a localized string similar to Not a C# symbol..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.PositionIsNotWithinSyntax">
            <summary>
              Looks up a localized string similar to Position is not within syntax tree with full span {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.PositionNotWithinTree">
            <summary>
              Looks up a localized string similar to Position must be within span of the syntax tree..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SeparatorIsExpected">
            <summary>
              Looks up a localized string similar to separator is expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SpeculatedSyntaxNodeCannotBelongToCurrentCompilation">
            <summary>
              Looks up a localized string similar to Syntax node to be speculated cannot belong to a syntax tree from the current compilation..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SubmissionCanHaveAtMostOne">
            <summary>
              Looks up a localized string similar to Submission can have at most one syntax tree..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SubmissionCanOnlyInclude">
            <summary>
              Looks up a localized string similar to Submission can only include script code..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SyntaxNodeIsNotWithinSynt">
            <summary>
              Looks up a localized string similar to Syntax node is not within syntax tree.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SyntaxTreeAlreadyPresent">
            <summary>
              Looks up a localized string similar to Syntax tree already present.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SyntaxTreeNotFoundTo">
            <summary>
              Looks up a localized string similar to SyntaxTree &apos;{0}&apos; not found to remove.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.SyntaxTreeSemanticModelMust">
            <summary>
              Looks up a localized string similar to SyntaxTreeSemanticModel must be provided in order to provide minimal type qualification..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.TheStreamCannotBeReadFrom">
            <summary>
              Looks up a localized string similar to The stream cannot be read from..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.TheStreamCannotBeWritten">
            <summary>
              Looks up a localized string similar to The stream cannot be written to..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ThisCompilationNotInteractive">
            <summary>
              Looks up a localized string similar to This compilation doesn&apos;t represent an interactive submission..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.ThisMethodCanOnlyBeUsedToCreateTokens">
            <summary>
              Looks up a localized string similar to This method can only be used to create tokens - {0} is not a token kind..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.TreeMustHaveARootNodeWith">
            <summary>
              Looks up a localized string similar to tree must have a root node with SyntaxKind.CompilationUnit.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.TreeNotPartOfCompilation">
            <summary>
              Looks up a localized string similar to tree not part of compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.Trees0">
            <summary>
              Looks up a localized string similar to trees[{0}].
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.TreesMustHaveRootNode">
            <summary>
              Looks up a localized string similar to trees[{0}] must have root node with SyntaxKind.CompilationUnit..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.TypeArgumentCannotBeNull">
            <summary>
              Looks up a localized string similar to Type argument cannot be null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.UseLiteralForNumeric">
            <summary>
              Looks up a localized string similar to Use Roslyn.Compilers.CSharp.Syntax.Literal to create numeric literal tokens..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.UseLiteralForTokens">
            <summary>
              Looks up a localized string similar to Use Roslyn.Compilers.CSharp.Syntax.Literal to create character literal tokens..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.UseVerbatimIdentifier">
            <summary>
              Looks up a localized string similar to Use Roslyn.Compilers.CSharp.Syntax.Identifier or Roslyn.Compilers.CSharp.Syntax.VerbatimIdentifier to create identifier tokens..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AlignmentMagnitude">
            <summary>
              Looks up a localized string similar to Alignment value {0} has a magnitude greater than {1} and may result in a large formatted string..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AlignmentMagnitude_Title">
            <summary>
              Looks up a localized string similar to Alignment value has a magnitude that may result in a large formatted string.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AlwaysNull">
            <summary>
              Looks up a localized string similar to The result of the expression is always &apos;null&apos; of type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AlwaysNull_Title">
            <summary>
              Looks up a localized string similar to The result of the expression is always &apos;null&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AmbiguousXMLReference">
            <summary>
              Looks up a localized string similar to Ambiguous reference in cref attribute: &apos;{0}&apos;. Assuming &apos;{1}&apos;, but could have also matched other overloads including &apos;{2}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AmbiguousXMLReference_Title">
            <summary>
              Looks up a localized string similar to Ambiguous reference in cref attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AnalyzerCannotBeCreated">
            <summary>
              Looks up a localized string similar to An instance of analyzer {0} cannot be created from {1} : {2}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AnalyzerCannotBeCreated_Title">
            <summary>
              Looks up a localized string similar to An analyzer instance cannot be created.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssemblyAttributeFromModuleIsOverridden">
            <summary>
              Looks up a localized string similar to Attribute &apos;{0}&apos; from module &apos;{1}&apos; will be ignored in favor of the instance appearing in source.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssemblyAttributeFromModuleIsOverridden_Title">
            <summary>
              Looks up a localized string similar to Attribute will be ignored in favor of the instance appearing in source.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssignmentToLockOrDispose">
            <summary>
              Looks up a localized string similar to Possibly incorrect assignment to local &apos;{0}&apos; which is the argument to a using or lock statement. The Dispose call or unlocking will happen on the original value of the local..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssignmentToLockOrDispose_Title">
            <summary>
              Looks up a localized string similar to Possibly incorrect assignment to local which is the argument to a using or lock statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssignmentToSelf">
            <summary>
              Looks up a localized string similar to Assignment made to same variable; did you mean to assign something else?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AssignmentToSelf_Title">
            <summary>
              Looks up a localized string similar to Assignment made to same variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AsyncLacksAwaits">
            <summary>
              Looks up a localized string similar to This async method lacks &apos;await&apos; operators and will run synchronously. Consider using the &apos;await&apos; operator to await non-blocking API calls, or &apos;await Task.Run(...)&apos; to do CPU-bound work on a background thread..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AsyncLacksAwaits_Title">
            <summary>
              Looks up a localized string similar to Async method lacks &apos;await&apos; operators and will run synchronously.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AttributeLocationOnBadDeclaration">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a valid attribute location for this declaration. Valid attribute locations for this declaration are &apos;{1}&apos;. All attributes in this block will be ignored..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_AttributeLocationOnBadDeclaration_Title">
            <summary>
              Looks up a localized string similar to Not a valid attribute location for this declaration.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRefCompareLeft">
            <summary>
              Looks up a localized string similar to Possible unintended reference comparison; to get a value comparison, cast the left hand side to type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRefCompareLeft_Title">
            <summary>
              Looks up a localized string similar to Possible unintended reference comparison; left hand side needs cast.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRefCompareRight">
            <summary>
              Looks up a localized string similar to Possible unintended reference comparison; to get a value comparison, cast the right hand side to type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRefCompareRight_Title">
            <summary>
              Looks up a localized string similar to Possible unintended reference comparison; right hand side needs cast.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRestoreNumber">
            <summary>
              Looks up a localized string similar to Cannot restore warning &apos;CS{0}&apos; because it was disabled globally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadRestoreNumber_Title">
            <summary>
              Looks up a localized string similar to Cannot restore warning because it was disabled globally.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadUILang">
            <summary>
              Looks up a localized string similar to The language name &apos;{0}&apos; is invalid..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadUILang_Title">
            <summary>
              Looks up a localized string similar to The language name is invalid.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadWarningNumber">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a valid warning number.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadWarningNumber_Description">
            <summary>
              Looks up a localized string similar to A number that was passed to the #pragma warning preprocessor directive was not a valid warning number. Verify that the number represents a warning, not an error..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadWarningNumber_Title">
            <summary>
              Looks up a localized string similar to Not a valid warning number.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRef">
            <summary>
              Looks up a localized string similar to XML comment has cref attribute &apos;{0}&apos; that could not be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRef_Title">
            <summary>
              Looks up a localized string similar to XML comment has cref attribute that could not be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefParamType">
            <summary>
              Looks up a localized string similar to Invalid type for parameter {0} in XML comment cref attribute: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefParamType_Title">
            <summary>
              Looks up a localized string similar to Invalid type for parameter in XML comment cref attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefReturnType">
            <summary>
              Looks up a localized string similar to Invalid return type in XML comment cref attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefReturnType_Title">
            <summary>
              Looks up a localized string similar to Invalid return type in XML comment cref attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefSyntax">
            <summary>
              Looks up a localized string similar to XML comment has syntactically incorrect cref attribute &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefSyntax_Title">
            <summary>
              Looks up a localized string similar to XML comment has syntactically incorrect cref attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefTypeVar">
            <summary>
              Looks up a localized string similar to XML comment has cref attribute &apos;{0}&apos; that refers to a type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BadXMLRefTypeVar_Title">
            <summary>
              Looks up a localized string similar to XML comment has cref attribute that refers to a type parameter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BitwiseOrSignExtend">
            <summary>
              Looks up a localized string similar to Bitwise-or operator used on a sign-extended operand; consider casting to a smaller unsigned type first.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BitwiseOrSignExtend_Description">
            <summary>
              Looks up a localized string similar to The compiler implicitly widened and sign-extended a variable, and then used the resulting value in a bitwise OR operation. This can result in unexpected behavior..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_BitwiseOrSignExtend_Title">
            <summary>
              Looks up a localized string similar to Bitwise-or operator used on a sign-extended operand.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ByRefNonAgileField">
            <summary>
              Looks up a localized string similar to Passing &apos;{0}&apos; as ref or out or taking its address may cause a runtime exception because it is a field of a marshal-by-reference class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ByRefNonAgileField_Title">
            <summary>
              Looks up a localized string similar to Passing a field of a marshal-by-reference class as ref or out or taking its address may cause a runtime exception.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2000_DisposeObjectsBeforeLosingScope1">
            <summary>
              Looks up a localized string similar to Call System.IDisposable.Dispose() on allocated instance of {0} before all references to it are out of scope..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2000_DisposeObjectsBeforeLosingScope1_Title">
            <summary>
              Looks up a localized string similar to Call System.IDisposable.Dispose() on allocated instance before all references to it are out of scope.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2000_DisposeObjectsBeforeLosingScope2">
            <summary>
              Looks up a localized string similar to Allocated instance of {0} is not disposed along all exception paths.  Call System.IDisposable.Dispose() before all references to it are out of scope..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2000_DisposeObjectsBeforeLosingScope2_Title">
            <summary>
              Looks up a localized string similar to Allocated instance is not disposed along all exception paths.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2202_DoNotDisposeObjectsMultipleTimes">
            <summary>
              Looks up a localized string similar to Object &apos;{0}&apos; can be disposed more than once..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CA2202_DoNotDisposeObjectsMultipleTimes_Title">
            <summary>
              Looks up a localized string similar to Object can be disposed more than once.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerFilePathParamForUnconsumedLocation">
            <summary>
              Looks up a localized string similar to The CalleFilePathAttribute applied to parameter &apos;{0}&apos; will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerFilePathParamForUnconsumedLocation_Title">
            <summary>
              Looks up a localized string similar to The CalleFilePathAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerFilePathPreferredOverCallerMemberName">
            <summary>
              Looks up a localized string similar to The CallerMemberNameAttribute applied to parameter &apos;{0}&apos; will have no effect. It is overridden by the CallerFilePathAttribute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerFilePathPreferredOverCallerMemberName_Title">
            <summary>
              Looks up a localized string similar to The CallerMemberNameAttribute will have no effect; it is overridden by the CallerFilePathAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberParamForUnconsumedLocation">
            <summary>
              Looks up a localized string similar to The CallerLineNumberAttribute applied to parameter &apos;{0}&apos; will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberParamForUnconsumedLocation_Title">
            <summary>
              Looks up a localized string similar to The CallerLineNumberAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberPreferredOverCallerFilePath">
            <summary>
              Looks up a localized string similar to The CallerFilePathAttribute applied to parameter &apos;{0}&apos; will have no effect. It is overridden by the CallerLineNumberAttribute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberPreferredOverCallerFilePath_Title">
            <summary>
              Looks up a localized string similar to The CallerFilePathAttribute will have no effect; it is overridden by the CallerLineNumberAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberPreferredOverCallerMemberName">
            <summary>
              Looks up a localized string similar to The CallerMemberNameAttribute applied to parameter &apos;{0}&apos; will have no effect. It is overridden by the CallerLineNumberAttribute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerLineNumberPreferredOverCallerMemberName_Title">
            <summary>
              Looks up a localized string similar to The CallerMemberNameAttribute will have no effect; it is overridden by the CallerLineNumberAttribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerMemberNameParamForUnconsumedLocation">
            <summary>
              Looks up a localized string similar to The CallerMemberNameAttribute applied to parameter &apos;{0}&apos; will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallerMemberNameParamForUnconsumedLocation_Title">
            <summary>
              Looks up a localized string similar to The CallerMemberNameAttribute will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallOnNonAgileField">
            <summary>
              Looks up a localized string similar to Accessing a member on &apos;{0}&apos; may cause a runtime exception because it is a field of a marshal-by-reference class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallOnNonAgileField_Description">
            <summary>
              Looks up a localized string similar to This warning occurs when you try to call a method, property, or indexer on a member of a class that derives from MarshalByRefObject, and the member is a value type. Objects that inherit from MarshalByRefObject are typically intended to be marshaled by reference across an application domain. If any code ever attempts to directly access the value-type member of such an object across an application domain, a runtime exception will occur. To resolve the warning, first copy the member into a local variable and c [rest of string was truncated]&quot;;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CallOnNonAgileField_Title">
            <summary>
              Looks up a localized string similar to Accessing a member on a field of a marshal-by-reference class may cause a runtime exception.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CantHaveManifestForModule">
            <summary>
              Looks up a localized string similar to Ignoring /win32manifest for module because it only applies to assemblies.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CantHaveManifestForModule_Title">
            <summary>
              Looks up a localized string similar to Ignoring /win32manifest for module because it only applies to assemblies.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_ArrayArgumentToAttribute">
            <summary>
              Looks up a localized string similar to Arrays as attribute arguments is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_ArrayArgumentToAttribute_Title">
            <summary>
              Looks up a localized string similar to Arrays as attribute arguments is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_AssemblyNotCLS">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_AssemblyNotCLS_Title">
            <summary>
              Looks up a localized string similar to Type or member cannot be marked as CLS-compliant because the assembly does not have a CLSCompliant attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_AssemblyNotCLS2">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_AssemblyNotCLS2_Title">
            <summary>
              Looks up a localized string similar to Type or member does not need a CLSCompliant attribute because the assembly does not have a CLSCompliant attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadArgType">
            <summary>
              Looks up a localized string similar to Argument type &apos;{0}&apos; is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadArgType_Title">
            <summary>
              Looks up a localized string similar to Argument type is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadAttributeType">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; has no accessible constructors which use only CLS-compliant types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadAttributeType_Title">
            <summary>
              Looks up a localized string similar to Type has no accessible constructors which use only CLS-compliant types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadBase">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: base type &apos;{1}&apos; is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadBase_Description">
            <summary>
              Looks up a localized string similar to A base type was marked as not having to be compliant with the Common Language Specification (CLS) in an assembly that was marked as being CLS compliant. Either remove the attribute that specifies the assembly is CLS compliant or remove the attribute that indicates the type is not CLS compliant..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadBase_Title">
            <summary>
              Looks up a localized string similar to Base type is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadFieldPropType">
            <summary>
              Looks up a localized string similar to Type of &apos;{0}&apos; is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadFieldPropType_Description">
            <summary>
              Looks up a localized string similar to A public, protected, or protected internal variable must be of a type that is compliant with the Common Language Specification (CLS)..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadFieldPropType_Title">
            <summary>
              Looks up a localized string similar to Type is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadIdentifier">
            <summary>
              Looks up a localized string similar to Identifier &apos;{0}&apos; is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadIdentifier_Title">
            <summary>
              Looks up a localized string similar to Identifier is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadIdentifierCase">
            <summary>
              Looks up a localized string similar to Identifier &apos;{0}&apos; differing only in case is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadIdentifierCase_Title">
            <summary>
              Looks up a localized string similar to Identifier differing only in case is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadInterface">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not CLS-compliant because base interface &apos;{1}&apos; is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadInterface_Title">
            <summary>
              Looks up a localized string similar to Type is not CLS-compliant because base interface is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadInterfaceMember">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: CLS-compliant interfaces must have only CLS-compliant members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadInterfaceMember_Title">
            <summary>
              Looks up a localized string similar to CLS-compliant interfaces must have only CLS-compliant members.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadReturnType">
            <summary>
              Looks up a localized string similar to Return type of &apos;{0}&apos; is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadReturnType_Title">
            <summary>
              Looks up a localized string similar to Return type is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadTypeVar">
            <summary>
              Looks up a localized string similar to Constraint type &apos;{0}&apos; is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_BadTypeVar_Title">
            <summary>
              Looks up a localized string similar to Constraint type is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_IllegalTrueInFalse">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_IllegalTrueInFalse_Title">
            <summary>
              Looks up a localized string similar to Type cannot be marked as CLS-compliant because it is a member of non-CLS-compliant type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnParam">
            <summary>
              Looks up a localized string similar to CLSCompliant attribute has no meaning when applied to parameters. Try putting it on the method instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnParam_Title">
            <summary>
              Looks up a localized string similar to CLSCompliant attribute has no meaning when applied to parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnPrivateType">
            <summary>
              Looks up a localized string similar to CLS compliance checking will not be performed on &apos;{0}&apos; because it is not visible from outside this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnPrivateType_Title">
            <summary>
              Looks up a localized string similar to CLS compliance checking will not be performed because it is not visible from outside this assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnReturn">
            <summary>
              Looks up a localized string similar to CLSCompliant attribute has no meaning when applied to return types. Try putting it on the method instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_MeaninglessOnReturn_Title">
            <summary>
              Looks up a localized string similar to CLSCompliant attribute has no meaning when applied to return types.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_ModuleMissingCLS">
            <summary>
              Looks up a localized string similar to Added modules must be marked with the CLSCompliant attribute to match the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_ModuleMissingCLS_Title">
            <summary>
              Looks up a localized string similar to Added modules must be marked with the CLSCompliant attribute to match the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NoAbstractMembers">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: only CLS-compliant members can be abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NoAbstractMembers_Title">
            <summary>
              Looks up a localized string similar to Only CLS-compliant members can be abstract.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NotOnModules">
            <summary>
              Looks up a localized string similar to You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NotOnModules_Title">
            <summary>
              Looks up a localized string similar to You must specify the CLSCompliant attribute on the assembly, not the module, to enable CLS compliance checking.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NotOnModules2">
            <summary>
              Looks up a localized string similar to You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NotOnModules2_Title">
            <summary>
              Looks up a localized string similar to You cannot specify the CLSCompliant attribute on a module that differs from the CLSCompliant attribute on the assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NoVarArgs">
            <summary>
              Looks up a localized string similar to Methods with variable arguments are not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_NoVarArgs_Title">
            <summary>
              Looks up a localized string similar to Methods with variable arguments are not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_OverloadRefOut">
            <summary>
              Looks up a localized string similar to Overloaded method &apos;{0}&apos; differing only in ref or out, or in array rank, is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_OverloadRefOut_Title">
            <summary>
              Looks up a localized string similar to Overloaded method differing only in ref or out, or in array rank, is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_OverloadUnnamed">
            <summary>
              Looks up a localized string similar to Overloaded method &apos;{0}&apos; differing only by unnamed array types is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_OverloadUnnamed_Description">
            <summary>
              Looks up a localized string similar to This error occurs if you have an overloaded method that takes a jagged array and the only difference between the method signatures is the element type of the array. To avoid this error, consider using a rectangular array rather than a jagged array; use an additional parameter to disambiguate the function call; rename one or more of the overloaded methods; or, if CLS Compliance is not needed, remove the CLSCompliantAttribute attribute..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_OverloadUnnamed_Title">
            <summary>
              Looks up a localized string similar to Overloaded method differing only by unnamed array types is not CLS-compliant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_VolatileField">
            <summary>
              Looks up a localized string similar to CLS-compliant field &apos;{0}&apos; cannot be volatile.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CLS_VolatileField_Title">
            <summary>
              Looks up a localized string similar to CLS-compliant field cannot be volatile.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CmdOptionConflictsSource">
            <summary>
              Looks up a localized string similar to Option &apos;{0}&apos; overrides attribute &apos;{1}&apos; given in a source file or added module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CmdOptionConflictsSource_Description">
            <summary>
              Looks up a localized string similar to This warning occurs if the assembly attributes AssemblyKeyFileAttribute or AssemblyKeyNameAttribute found in source conflict with the /keyfile or /keycontainer command line option or key file name or key container specified in the Project Properties..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CmdOptionConflictsSource_Title">
            <summary>
              Looks up a localized string similar to Option overrides attribute given in a source file or added module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CmpAlwaysFalse">
            <summary>
              Looks up a localized string similar to Comparing with null of type &apos;{0}&apos; always produces &apos;false&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CmpAlwaysFalse_Title">
            <summary>
              Looks up a localized string similar to Comparing with null of struct type always produces &apos;false&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CoClassWithoutComImport">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; interface marked with &apos;CoClassAttribute&apos; not marked with &apos;ComImportAttribute&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_CoClassWithoutComImport_Title">
            <summary>
              Looks up a localized string similar to Interface marked with &apos;CoClassAttribute&apos; not marked with &apos;ComImportAttribute&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ComparisonToSelf">
            <summary>
              Looks up a localized string similar to Comparison made to same variable; did you mean to compare something else?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ComparisonToSelf_Title">
            <summary>
              Looks up a localized string similar to Comparison made to same variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConflictingChecksum">
            <summary>
              Looks up a localized string similar to Different checksum values given for &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConflictingChecksum_Title">
            <summary>
              Looks up a localized string similar to Different #pragma checksum values given.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConflictingMachineAssembly">
            <summary>
              Looks up a localized string similar to Referenced assembly &apos;{0}&apos; targets a different processor..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ConflictingMachineAssembly_Title">
            <summary>
              Looks up a localized string similar to Referenced assembly targets a different processor.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DebugFullNameTooLong">
            <summary>
              Looks up a localized string similar to The fully qualified name for &apos;{0}&apos; is too long for debug information. Compile without &apos;/debug&apos; option..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DebugFullNameTooLong_Title">
            <summary>
              Looks up a localized string similar to Fully qualified name is too long for debug information.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DefaultValueForUnconsumedLocation">
            <summary>
              Looks up a localized string similar to The default value specified for parameter &apos;{0}&apos; will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DefaultValueForUnconsumedLocation_Title">
            <summary>
              Looks up a localized string similar to The default value specified will have no effect because it applies to a member that is used in contexts that do not allow optional arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DefineIdentifierRequired">
            <summary>
              Looks up a localized string similar to Invalid value for &apos;/define&apos;; &apos;{0}&apos; is not a valid identifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DefineIdentifierRequired_Title">
            <summary>
              Looks up a localized string similar to Invalid value for &apos;/define&apos;; not a valid identifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DelaySignButNoKey">
            <summary>
              Looks up a localized string similar to Delay signing was specified and requires a public key, but no public key was specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DelaySignButNoKey_Title">
            <summary>
              Looks up a localized string similar to Delay signing was specified and requires a public key, but no public key was specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedCollectionInitAdd">
            <summary>
              Looks up a localized string similar to The best overloaded Add method &apos;{0}&apos; for the collection initializer element is obsolete..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedCollectionInitAdd_Title">
            <summary>
              Looks up a localized string similar to The best overloaded Add method for the collection initializer element is obsolete.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedCollectionInitAddStr">
            <summary>
              Looks up a localized string similar to The best overloaded Add method &apos;{0}&apos; for the collection initializer element is obsolete. {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedCollectionInitAddStr_Title">
            <summary>
              Looks up a localized string similar to The best overloaded Add method for the collection initializer element is obsolete.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedSymbol">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is obsolete.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedSymbol_Title">
            <summary>
              Looks up a localized string similar to Type or member is obsolete.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedSymbolStr">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is obsolete: &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DeprecatedSymbolStr_Title">
            <summary>
              Looks up a localized string similar to Type or member is obsolete.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DotOnDefault">
            <summary>
              Looks up a localized string similar to Expression will always cause a System.NullReferenceException because the default value of &apos;{0}&apos; is null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DotOnDefault_Title">
            <summary>
              Looks up a localized string similar to Expression will always cause a System.NullReferenceException because the type&apos;s default value is null.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateParamTag">
            <summary>
              Looks up a localized string similar to XML comment has a duplicate param tag for &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateParamTag_Title">
            <summary>
              Looks up a localized string similar to XML comment has a duplicate param tag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateTypeParamTag">
            <summary>
              Looks up a localized string similar to XML comment has a duplicate typeparam tag for &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateTypeParamTag_Title">
            <summary>
              Looks up a localized string similar to XML comment has a duplicate typeparam tag.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateUsing">
            <summary>
              Looks up a localized string similar to The using directive for &apos;{0}&apos; appeared previously in this namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DuplicateUsing_Title">
            <summary>
              Looks up a localized string similar to Using directive appeared previously in this namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DynamicDispatchToConditionalMethod">
            <summary>
              Looks up a localized string similar to The dynamically dispatched call to method &apos;{0}&apos; may fail at runtime because one or more applicable overloads are conditional methods..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_DynamicDispatchToConditionalMethod_Title">
            <summary>
              Looks up a localized string similar to Dynamically dispatched call may fail at runtime because one or more applicable overloads are conditional methods.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EmptySwitch">
            <summary>
              Looks up a localized string similar to Empty switch block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EmptySwitch_Title">
            <summary>
              Looks up a localized string similar to Empty switch block.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EndOfPPLineExpected">
            <summary>
              Looks up a localized string similar to Single-line comment or end-of-line expected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EndOfPPLineExpected_Title">
            <summary>
              Looks up a localized string similar to Single-line comment or end-of-line expected after #pragma directive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualityOpWithoutEquals">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; defines operator == or operator != but does not override Object.Equals(object o).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualityOpWithoutEquals_Title">
            <summary>
              Looks up a localized string similar to Type defines operator == or operator != but does not override Object.Equals(object o).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualityOpWithoutGetHashCode">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; defines operator == or operator != but does not override Object.GetHashCode().
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualityOpWithoutGetHashCode_Title">
            <summary>
              Looks up a localized string similar to Type defines operator == or operator != but does not override Object.GetHashCode().
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualsWithoutGetHashCode">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; overrides Object.Equals(object o) but does not override Object.GetHashCode().
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_EqualsWithoutGetHashCode_Title">
            <summary>
              Looks up a localized string similar to Type overrides Object.Equals(object o) but does not override Object.GetHashCode().
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ErrorOverride">
            <summary>
              Looks up a localized string similar to {0}. See also error CS{1}..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ErrorOverride_Description">
            <summary>
              Looks up a localized string similar to The compiler emits this warning when it overrides an error with a warning. For information about the problem, search for the error code mentioned..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ErrorOverride_Title">
            <summary>
              Looks up a localized string similar to Warning is overriding an error.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExplicitImplCollision">
            <summary>
              Looks up a localized string similar to Explicit interface implementation &apos;{0}&apos; matches more than one interface member. Which interface member is actually chosen is implementation-dependent. Consider using a non-explicit implementation instead..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExplicitImplCollision_Title">
            <summary>
              Looks up a localized string similar to Explicit interface implementation matches more than one interface member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExternCtorNoImplementation">
            <summary>
              Looks up a localized string similar to Constructor &apos;{0}&apos; is marked external.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExternCtorNoImplementation_Title">
            <summary>
              Looks up a localized string similar to Constructor is marked external.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExternMethodNoImplementation">
            <summary>
              Looks up a localized string similar to Method, operator, or accessor &apos;{0}&apos; is marked external and has no attributes on it. Consider adding a DllImport attribute to specify the external implementation..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ExternMethodNoImplementation_Title">
            <summary>
              Looks up a localized string similar to Method, operator, or accessor is marked external and has no attributes on it.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FailedInclude">
            <summary>
              Looks up a localized string similar to Unable to include XML fragment &apos;{1}&apos; of file &apos;{0}&apos; -- {2}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FailedInclude_Title">
            <summary>
              Looks up a localized string similar to Unable to include XML fragment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FileAlreadyIncluded">
            <summary>
              Looks up a localized string similar to Source file &apos;{0}&apos; specified multiple times.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FileAlreadyIncluded_Title">
            <summary>
              Looks up a localized string similar to Source file specified multiple times.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FileNameTooLong">
            <summary>
              Looks up a localized string similar to Invalid filename specified for preprocessor directive. Filename is too long or not a valid filename..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FileNameTooLong_Title">
            <summary>
              Looks up a localized string similar to Invalid filename specified for preprocessor directive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FilterIsConstant">
            <summary>
              Looks up a localized string similar to Filter expression is a constant, consider removing the filter.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FilterIsConstant_Title">
            <summary>
              Looks up a localized string similar to Filter expression is a constant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FinalizeMethod">
            <summary>
              Looks up a localized string similar to Introducing a &apos;Finalize&apos; method can interfere with destructor invocation. Did you intend to declare a destructor?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FinalizeMethod_Description">
             <summary>
               Looks up a localized string similar to This warning occurs when you create a class with a method whose signature is public virtual void Finalize.
            
            If such a class is used as a base class and if the deriving class defines a destructor, the destructor will override the base class Finalize method, not Finalize..
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_FinalizeMethod_Title">
            <summary>
              Looks up a localized string similar to Introducing a &apos;Finalize&apos; method can interfere with destructor invocation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GlobalAliasDefn">
            <summary>
              Looks up a localized string similar to Defining an alias named &apos;global&apos; is ill-advised since &apos;global::&apos; always references the global namespace and not an alias.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GlobalAliasDefn_Title">
            <summary>
              Looks up a localized string similar to Defining an alias named &apos;global&apos; is ill-advised.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GotoCaseShouldConvert">
            <summary>
              Looks up a localized string similar to The &apos;goto case&apos; value is not implicitly convertible to type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_GotoCaseShouldConvert_Title">
            <summary>
              Looks up a localized string similar to The &apos;goto case&apos; value is not implicitly convertible to the switch type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IdentifierOrNumericLiteralExpected">
            <summary>
              Looks up a localized string similar to Expected identifier or numeric literal..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IdentifierOrNumericLiteralExpected_Title">
            <summary>
              Looks up a localized string similar to Expected identifier or numeric literal.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPPChecksum">
            <summary>
              Looks up a localized string similar to Invalid #pragma checksum syntax; should be #pragma checksum &quot;filename&quot; &quot;{XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX}&quot; &quot;XXXX...&quot;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPPChecksum_Title">
            <summary>
              Looks up a localized string similar to Invalid #pragma checksum syntax.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPPWarning">
            <summary>
              Looks up a localized string similar to Expected disable or restore.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPPWarning_Title">
            <summary>
              Looks up a localized string similar to Expected disable or restore after #pragma warning.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPragma">
            <summary>
              Looks up a localized string similar to Unrecognized #pragma directive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IllegalPragma_Title">
            <summary>
              Looks up a localized string similar to Unrecognized #pragma directive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IncorrectBooleanAssg">
            <summary>
              Looks up a localized string similar to Assignment in conditional expression is always constant; did you mean to use == instead of = ?.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IncorrectBooleanAssg_Title">
            <summary>
              Looks up a localized string similar to Assignment in conditional expression is always constant.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidAssemblyName">
            <summary>
              Looks up a localized string similar to Assembly reference &apos;{0}&apos; is invalid and cannot be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidAssemblyName_Description">
            <summary>
              Looks up a localized string similar to This warning indicates that an attribute, such as InternalsVisibleToAttribute, was not specified correctly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidAssemblyName_Title">
            <summary>
              Looks up a localized string similar to Assembly reference is invalid and cannot be resolved.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidAttributeLocation">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; is not a recognized attribute location. All attributes in this block will be ignored..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidAttributeLocation_Title">
            <summary>
              Looks up a localized string similar to Not a recognized attribute location.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidInclude">
            <summary>
              Looks up a localized string similar to Invalid XML include element -- {0}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidInclude_Title">
            <summary>
              Looks up a localized string similar to Invalid XML include element.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidMainSig">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; has the wrong signature to be an entry point.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidMainSig_Title">
            <summary>
              Looks up a localized string similar to Method has the wrong signature to be an entry point.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidNumber">
            <summary>
              Looks up a localized string similar to Invalid number.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidNumber_Title">
            <summary>
              Looks up a localized string similar to Invalid number.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidSearchPathDir">
            <summary>
              Looks up a localized string similar to Invalid search path &apos;{0}&apos; specified in &apos;{1}&apos; -- &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidSearchPathDir_Title">
            <summary>
              Looks up a localized string similar to Invalid search path specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidVersionFormat">
            <summary>
              Looks up a localized string similar to The specified version string does not conform to the recommended format - major.minor.build.revision.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_InvalidVersionFormat_Title">
            <summary>
              Looks up a localized string similar to The specified version string does not conform to the recommended format - major.minor.build.revision.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsAlwaysFalse">
            <summary>
              Looks up a localized string similar to The given expression is never of the provided (&apos;{0}&apos;) type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsAlwaysFalse_Title">
            <summary>
              Looks up a localized string similar to &apos;is&apos; expression&apos;s given expression is never of the provided type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsAlwaysTrue">
            <summary>
              Looks up a localized string similar to The given expression is always of the provided (&apos;{0}&apos;) type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsAlwaysTrue_Title">
            <summary>
              Looks up a localized string similar to &apos;is&apos; expression&apos;s given expression is always of the provided type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsDynamicIsConfusing">
            <summary>
              Looks up a localized string similar to Using &apos;{0}&apos; to test compatibility with &apos;{1}&apos; is essentially identical to testing compatibility with &apos;{2}&apos; and will succeed for all non-null values.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_IsDynamicIsConfusing_Title">
            <summary>
              Looks up a localized string similar to Using &apos;is&apos; to test compatibility with &apos;dynamic&apos; is essentially identical to testing compatibility with &apos;Object&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_LowercaseEllSuffix">
            <summary>
              Looks up a localized string similar to The &apos;l&apos; suffix is easily confused with the digit &apos;1&apos; -- use &apos;L&apos; for clarity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_LowercaseEllSuffix_Title">
            <summary>
              Looks up a localized string similar to The &apos;l&apos; suffix is easily confused with the digit &apos;1&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MainCantBeGeneric">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: an entry point cannot be generic or in a generic type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MainCantBeGeneric_Title">
            <summary>
              Looks up a localized string similar to An entry point cannot be generic or in a generic type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MainIgnored">
            <summary>
              Looks up a localized string similar to The entry point of the program is global script code; ignoring &apos;{0}&apos; entry point..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MainIgnored_Title">
            <summary>
              Looks up a localized string similar to The entry point of the program is global script code; ignoring entry point.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingParamTag">
            <summary>
              Looks up a localized string similar to Parameter &apos;{0}&apos; has no matching param tag in the XML comment for &apos;{1}&apos; (but other parameters do).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingParamTag_Title">
            <summary>
              Looks up a localized string similar to Parameter has no matching param tag in the XML comment (but other parameters do).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingTypeParamTag">
            <summary>
              Looks up a localized string similar to Type parameter &apos;{0}&apos; has no matching typeparam tag in the XML comment on &apos;{1}&apos; (but other type parameters do).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingTypeParamTag_Title">
            <summary>
              Looks up a localized string similar to Type parameter has no matching typeparam tag in the XML comment (but other type parameters do).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingXMLComment">
            <summary>
              Looks up a localized string similar to Missing XML comment for publicly visible type or member &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingXMLComment_Description">
            <summary>
              Looks up a localized string similar to The /doc compiler option was specified, but one or more constructs did not have comments..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MissingXMLComment_Title">
            <summary>
              Looks up a localized string similar to Missing XML comment for publicly visible type or member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultiplePredefTypes">
            <summary>
              Looks up a localized string similar to The predefined type &apos;{0}&apos; is defined in multiple assemblies in the global alias; using definition from &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultiplePredefTypes_Description">
            <summary>
              Looks up a localized string similar to This error occurs when a predefined system type such as System.Int32 is found in two assemblies. One way this can happen is if you are referencing mscorlib or System.Runtime.dll from two different places, such as trying to run two versions of the .NET Framework side-by-side..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultiplePredefTypes_Title">
            <summary>
              Looks up a localized string similar to Predefined type is defined in multiple assemblies in the global alias.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultipleRuntimeImplementationMatches">
            <summary>
              Looks up a localized string similar to Member &apos;{0}&apos; implements interface member &apos;{1}&apos; in type &apos;{2}&apos;. There are multiple matches for the interface member at run-time. It is implementation dependent which method will be called..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultipleRuntimeImplementationMatches_Description">
             <summary>
               Looks up a localized string similar to This warning can be generated when two interface methods are differentiated only by whether a particular parameter is marked with ref or with out. It is best to change your code to avoid this warning because it is not obvious or guaranteed which method is called at runtime.
            
            Although C# distinguishes between out and ref, the CLR sees them as the same. When deciding which method implements the interface, the CLR just picks one.
            
            Give the compiler some way to differentiate the methods. For example, you ca [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultipleRuntimeImplementationMatches_Title">
            <summary>
              Looks up a localized string similar to Member implements interface member with multiple matches at run-time.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultipleRuntimeOverrideMatches">
            <summary>
              Looks up a localized string similar to Member &apos;{1}&apos; overrides &apos;{0}&apos;. There are multiple override candidates at run-time. It is implementation dependent which method will be called..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_MultipleRuntimeOverrideMatches_Title">
            <summary>
              Looks up a localized string similar to Member overrides base member with multiple override candidates at run-time.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NegativeArrayIndex">
            <summary>
              Looks up a localized string similar to Indexing an array with a negative index (array indices always start at zero).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NegativeArrayIndex_Title">
            <summary>
              Looks up a localized string similar to Indexing an array with a negative index.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewNotRequired">
            <summary>
              Looks up a localized string similar to The member &apos;{0}&apos; does not hide an inherited member. The new keyword is not required..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewNotRequired_Title">
            <summary>
              Looks up a localized string similar to Member does not hide an inherited member; new keyword is not required.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewOrOverrideExpected">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; hides inherited member &apos;{1}&apos;. To make the current member override that implementation, add the override keyword. Otherwise add the new keyword..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewOrOverrideExpected_Title">
            <summary>
              Looks up a localized string similar to Member hides inherited member; missing override keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewRequired">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; hides inherited member &apos;{1}&apos;. Use the new keyword if hiding was intended..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewRequired_Description">
            <summary>
              Looks up a localized string similar to A variable was declared with the same name as a variable in a base class. However, the new keyword was not used. This warning informs you that you should use new; the variable is declared as if new had been used in the declaration..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NewRequired_Title">
            <summary>
              Looks up a localized string similar to Member hides inherited member; missing new keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoAnalyzerInAssembly">
            <summary>
              Looks up a localized string similar to The assembly {0} does not contain any analyzers..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoAnalyzerInAssembly_Title">
            <summary>
              Looks up a localized string similar to Assembly does not contain any analyzers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoConfigNotOnCommandLine">
            <summary>
              Looks up a localized string similar to Ignoring /noconfig option because it was specified in a response file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoConfigNotOnCommandLine_Title">
            <summary>
              Looks up a localized string similar to Ignoring /noconfig option because it was specified in a response file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NonECMAFeature">
            <summary>
              Looks up a localized string similar to Feature &apos;{0}&apos; is not part of the standardized ISO C# language specification, and may not be accepted by other compilers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NonECMAFeature_Title">
            <summary>
              Looks up a localized string similar to Feature is not part of the standardized ISO C# language specification, and may not be accepted by other compilers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NonObsoleteOverridingObsolete">
            <summary>
              Looks up a localized string similar to Member &apos;{0}&apos; overrides obsolete member &apos;{1}&apos;. Add the Obsolete attribute to &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NonObsoleteOverridingObsolete_Title">
            <summary>
              Looks up a localized string similar to Member overrides obsolete member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoRuntimeMetadataVersion">
            <summary>
              Looks up a localized string similar to No value for RuntimeMetadataVersion found. No assembly containing System.Object was found nor was a value for RuntimeMetadataVersion specified through options..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoRuntimeMetadataVersion_Title">
            <summary>
              Looks up a localized string similar to No value for RuntimeMetadataVersion found.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoSources">
            <summary>
              Looks up a localized string similar to No source files specified..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NoSources_Title">
            <summary>
              Looks up a localized string similar to No source files specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NubExprIsConstBool">
            <summary>
              Looks up a localized string similar to The result of the expression is always &apos;{0}&apos; since a value of type &apos;{1}&apos; is never equal to &apos;null&apos; of type &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NubExprIsConstBool_Title">
            <summary>
              Looks up a localized string similar to The result of the expression is always the same since a value of this type is never equal to &apos;null&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NubExprIsConstBool2">
            <summary>
              Looks up a localized string similar to The result of the expression is always &apos;{0}&apos; since a value of type &apos;{1}&apos; is never equal to &apos;null&apos; of type &apos;{2}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_NubExprIsConstBool2_Title">
            <summary>
              Looks up a localized string similar to The result of the expression is always the same since a value of this type is never equal to &apos;null&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ObsoleteOverridingNonObsolete">
            <summary>
              Looks up a localized string similar to Obsolete member &apos;{0}&apos; overrides non-obsolete member &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ObsoleteOverridingNonObsolete_Title">
            <summary>
              Looks up a localized string similar to Obsolete member overrides non-obsolete member.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternBadSignature">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not implement the &apos;{1}&apos; pattern. &apos;{2}&apos; has the wrong signature..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternBadSignature_Title">
            <summary>
              Looks up a localized string similar to Type does not implement the collection pattern; member has the wrong signature.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternIsAmbiguous">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not implement the &apos;{1}&apos; pattern. &apos;{2}&apos; is ambiguous with &apos;{3}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternIsAmbiguous_Title">
            <summary>
              Looks up a localized string similar to Type does not implement the collection pattern; members are ambiguous.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternStaticOrInaccessible">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos; does not implement the &apos;{1}&apos; pattern. &apos;{2}&apos; is either static or not public..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PatternStaticOrInaccessible_Title">
            <summary>
              Looks up a localized string similar to Type does not implement the collection pattern; member is either static or not public.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PdbLocalNameTooLong">
            <summary>
              Looks up a localized string similar to Local name &apos;{0}&apos; is too long for PDB.  Consider shortening or compiling without /debug..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PdbLocalNameTooLong_Title">
            <summary>
              Looks up a localized string similar to Local name is too long for PDB.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PossibleMistakenNullStatement">
            <summary>
              Looks up a localized string similar to Possible mistaken empty statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_PossibleMistakenNullStatement_Title">
            <summary>
              Looks up a localized string similar to Possible mistaken empty statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ProtectedInSealed">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: new protected member declared in sealed class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ProtectedInSealed_Title">
            <summary>
              Looks up a localized string similar to New protected member declared in sealed class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefCultureMismatch">
            <summary>
              Looks up a localized string similar to Referenced assembly &apos;{0}&apos; has different culture setting of &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_RefCultureMismatch_Title">
            <summary>
              Looks up a localized string similar to Referenced assembly has different culture setting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReferencedAssemblyDoesNotHaveStrongName">
            <summary>
              Looks up a localized string similar to Referenced assembly &apos;{0}&apos; does not have a strong name..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReferencedAssemblyDoesNotHaveStrongName_Title">
            <summary>
              Looks up a localized string similar to Referenced assembly does not have a strong name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReferencedAssemblyReferencesLinkedPIA">
            <summary>
              Looks up a localized string similar to A reference was created to embedded interop assembly &apos;{0}&apos; because of an indirect reference to that assembly created by assembly &apos;{1}&apos;. Consider changing the &apos;Embed Interop Types&apos; property on either assembly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReferencedAssemblyReferencesLinkedPIA_Description">
             <summary>
               Looks up a localized string similar to You have added a reference to an assembly using /link (Embed Interop Types property set to True). This instructs the compiler to embed interop type information from that assembly. However, the compiler cannot embed interop type information from that assembly because another assembly that you have referenced also references that assembly using /reference (Embed Interop Types property set to False).
            
            To embed interop type information for both assemblies, use /link for references to each assembly (set the Em [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_ReferencedAssemblyReferencesLinkedPIA_Title">
            <summary>
              Looks up a localized string similar to A reference was created to embedded interop assembly because of an indirect assembly reference.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisAggAgg">
            <summary>
              Looks up a localized string similar to The type &apos;{1}&apos; in &apos;{0}&apos; conflicts with the imported type &apos;{3}&apos; in &apos;{2}&apos;. Using the type defined in &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisAggAgg_Title">
            <summary>
              Looks up a localized string similar to Type conflicts with imported type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisAggNs">
            <summary>
              Looks up a localized string similar to The type &apos;{1}&apos; in &apos;{0}&apos; conflicts with the imported namespace &apos;{3}&apos; in &apos;{2}&apos;. Using the type defined in &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisAggNs_Title">
            <summary>
              Looks up a localized string similar to Type conflicts with imported namespace.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisNsAgg">
            <summary>
              Looks up a localized string similar to The namespace &apos;{1}&apos; in &apos;{0}&apos; conflicts with the imported type &apos;{3}&apos; in &apos;{2}&apos;. Using the namespace defined in &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SameFullNameThisNsAgg_Title">
            <summary>
              Looks up a localized string similar to Namespace conflicts with imported type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SequentialOnPartialClass">
            <summary>
              Looks up a localized string similar to There is no defined ordering between fields in multiple declarations of partial struct &apos;{0}&apos;. To specify an ordering, all instance fields must be in the same declaration..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_SequentialOnPartialClass_Title">
            <summary>
              Looks up a localized string similar to There is no defined ordering between fields in multiple declarations of partial struct.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TooManyLinesForDebugger">
            <summary>
              Looks up a localized string similar to Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TooManyLinesForDebugger_Title">
            <summary>
              Looks up a localized string similar to Source file has exceeded the limit of 16,707,565 lines representable in the PDB; debug information will be incorrect.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TypeParameterSameAsOuterTypeParameter">
            <summary>
              Looks up a localized string similar to Type parameter &apos;{0}&apos; has the same name as the type parameter from outer type &apos;{1}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_TypeParameterSameAsOuterTypeParameter_Title">
            <summary>
              Looks up a localized string similar to Type parameter has the same name as the type parameter from outer type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnableToLoadAnalyzer">
            <summary>
              Looks up a localized string similar to Unable to load Analyzer assembly {0} : {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnableToLoadAnalyzer_Title">
            <summary>
              Looks up a localized string similar to Unable to load Analyzer assembly.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedInternalField">
            <summary>
              Looks up a localized string similar to Field &apos;{0}&apos; is never assigned to, and will always have its default value {1}.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnassignedInternalField_Title">
            <summary>
              Looks up a localized string similar to Field is never assigned to, and will always have its default value.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceBldRev">
            <summary>
              Looks up a localized string similar to Assuming assembly reference &apos;{0}&apos; used by &apos;{1}&apos; matches identity &apos;{2}&apos; of &apos;{3}&apos;, you may need to supply runtime policy.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceBldRev_Description">
            <summary>
              Looks up a localized string similar to The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application&apos;s .config file, and you must provide the correct strong name of an assembly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceBldRev_Title">
            <summary>
              Looks up a localized string similar to Assuming assembly reference matches identity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceMajMin">
            <summary>
              Looks up a localized string similar to Assuming assembly reference &apos;{0}&apos; used by &apos;{1}&apos; matches identity &apos;{2}&apos; of &apos;{3}&apos;, you may need to supply runtime policy.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceMajMin_Description">
            <summary>
              Looks up a localized string similar to The two assemblies differ in release and/or version number. For unification to occur, you must specify directives in the application&apos;s .config file, and you must provide the correct strong name of an assembly..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnifyReferenceMajMin_Title">
            <summary>
              Looks up a localized string similar to Assuming assembly reference matches identity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnimplementedCommandLineSwitch">
            <summary>
              Looks up a localized string similar to The command line switch &apos;{0}&apos; is not yet implemented and was ignored..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnimplementedCommandLineSwitch_Title">
            <summary>
              Looks up a localized string similar to Command line switch is not yet implemented.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedParamRefTag">
            <summary>
              Looks up a localized string similar to XML comment on &apos;{1}&apos; has a paramref tag for &apos;{0}&apos;, but there is no parameter by that name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedParamRefTag_Title">
            <summary>
              Looks up a localized string similar to XML comment has a paramref tag, but there is no parameter by that name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedParamTag">
            <summary>
              Looks up a localized string similar to XML comment has a param tag for &apos;{0}&apos;, but there is no parameter by that name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedParamTag_Title">
            <summary>
              Looks up a localized string similar to XML comment has a param tag, but there is no parameter by that name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedTypeParamRefTag">
            <summary>
              Looks up a localized string similar to XML comment on &apos;{1}&apos; has a typeparamref tag for &apos;{0}&apos;, but there is no type parameter by that name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedTypeParamRefTag_Title">
            <summary>
              Looks up a localized string similar to XML comment has a typeparamref tag, but there is no type parameter by that name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedTypeParamTag">
            <summary>
              Looks up a localized string similar to XML comment has a typeparam tag for &apos;{0}&apos;, but there is no type parameter by that name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnmatchedTypeParamTag_Title">
            <summary>
              Looks up a localized string similar to XML comment has a typeparam tag, but there is no type parameter by that name.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnobservedAwaitableExpression">
            <summary>
              Looks up a localized string similar to Because this call is not awaited, execution of the current method continues before the call is completed. Consider applying the &apos;await&apos; operator to the result of the call..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnobservedAwaitableExpression_Description">
            <summary>
              Looks up a localized string similar to The current method calls an async method that returns a Task or a Task&lt;TResult&gt; and doesn’t apply the await operator to the result. The call to the async method starts an asynchronous task. However, because no await operator is applied, the program continues without waiting for the task to complete. In most cases, that behavior isn&apos;t what you expect. Usually other aspects of the calling method depend on the results of the call or, minimally, the called method is expected to complete before you return from t [rest of string was truncated]&quot;;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnobservedAwaitableExpression_Title">
            <summary>
              Looks up a localized string similar to Because this call is not awaited, execution of the current method continues before the call is completed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnprocessedXMLComment">
            <summary>
              Looks up a localized string similar to XML comment is not placed on a valid language element.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnprocessedXMLComment_Title">
            <summary>
              Looks up a localized string similar to XML comment is not placed on a valid language element.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnqualifiedNestedTypeInCref">
            <summary>
              Looks up a localized string similar to Within cref attributes, nested types of generic types should be qualified..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnqualifiedNestedTypeInCref_Title">
            <summary>
              Looks up a localized string similar to Within cref attributes, nested types of generic types should be qualified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreachableCode">
            <summary>
              Looks up a localized string similar to Unreachable code detected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreachableCode_Title">
            <summary>
              Looks up a localized string similar to Unreachable code detected.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreachableGeneralCatch">
            <summary>
              Looks up a localized string similar to A previous catch clause already catches all exceptions. All non-exceptions thrown will be wrapped in a System.Runtime.CompilerServices.RuntimeWrappedException..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreachableGeneralCatch_Description">
             <summary>
               Looks up a localized string similar to This warning is caused when a catch() block has no specified exception type after a catch (System.Exception e) block. The warning advises that the catch() block will not catch any exceptions.
            
            A catch() block after a catch (System.Exception e) block can catch non-CLS exceptions if the RuntimeCompatibilityAttribute is set to false in the AssemblyInfo.cs file: [assembly: RuntimeCompatibilityAttribute(WrapNonExceptionThrows = false)]. If this attribute is not set explicitly to false, all thrown non-CLS excep [rest of string was truncated]&quot;;.
             </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreachableGeneralCatch_Title">
            <summary>
              Looks up a localized string similar to A previous catch clause already catches all exceptions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedEvent">
            <summary>
              Looks up a localized string similar to The event &apos;{0}&apos; is never used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedEvent_Title">
            <summary>
              Looks up a localized string similar to Event is never used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedField">
            <summary>
              Looks up a localized string similar to The field &apos;{0}&apos; is never used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedField_Title">
            <summary>
              Looks up a localized string similar to Field is never used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedFieldAssg">
            <summary>
              Looks up a localized string similar to The field &apos;{0}&apos; is assigned but its value is never used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedFieldAssg_Title">
            <summary>
              Looks up a localized string similar to Field is assigned but its value is never used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedLabel">
            <summary>
              Looks up a localized string similar to This label has not been referenced.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedLabel_Title">
            <summary>
              Looks up a localized string similar to This label has not been referenced.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedVar">
            <summary>
              Looks up a localized string similar to The variable &apos;{0}&apos; is declared but never used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedVar_Title">
            <summary>
              Looks up a localized string similar to Variable is declared but never used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedVarAssg">
            <summary>
              Looks up a localized string similar to The variable &apos;{0}&apos; is assigned but its value is never used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_UnreferencedVarAssg_Title">
            <summary>
              Looks up a localized string similar to Variable is assigned but its value is never used.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_VacuousIntegralComp">
            <summary>
              Looks up a localized string similar to Comparison to integral constant is useless; the constant is outside the range of type &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_VacuousIntegralComp_Title">
            <summary>
              Looks up a localized string similar to Comparison to integral constant is useless; the constant is outside the range of the type.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_VolatileByRef">
            <summary>
              Looks up a localized string similar to &apos;{0}&apos;: a reference to a volatile field will not be treated as volatile.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_VolatileByRef_Description">
            <summary>
              Looks up a localized string similar to A volatile field should not normally be passed using a ref or out parameter, since it will not be treated as volatile within the scope of the function. There are exceptions to this, such as when calling an interlocked API..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_VolatileByRef_Title">
            <summary>
              Looks up a localized string similar to A reference to a volatile field will not be treated as volatile.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_WarningDirective">
            <summary>
              Looks up a localized string similar to #warning: &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_WarningDirective_Title">
            <summary>
              Looks up a localized string similar to #warning directive.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_XMLParseError">
            <summary>
              Looks up a localized string similar to XML comment has badly formed XML -- &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_XMLParseError_Title">
            <summary>
              Looks up a localized string similar to XML comment has badly formed XML.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_XMLParseIncludeError">
            <summary>
              Looks up a localized string similar to Badly formed XML in included comments file -- &apos;{0}&apos;.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WRN_XMLParseIncludeError_Title">
            <summary>
              Looks up a localized string similar to Badly formed XML in included comments file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WrongNumberOfTypeArguments">
            <summary>
              Looks up a localized string similar to Wrong number of type arguments.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.WrongSemanticModelType">
            <summary>
              Looks up a localized string similar to Expected a {0} SemanticModel..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_CDataEndTagNotAllowed">
            <summary>
              Looks up a localized string similar to The literal string &apos;]]&gt;&apos; is not allowed in element content..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_DuplicateAttribute">
            <summary>
              Looks up a localized string similar to Duplicate &apos;{0}&apos; attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_ElementTypeMatch">
            <summary>
              Looks up a localized string similar to End tag &apos;{0}&apos; does not match the start tag &apos;{1}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_EndTagExpected">
            <summary>
              Looks up a localized string similar to Expected an end tag for element &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_EndTagNotExpected">
            <summary>
              Looks up a localized string similar to End tag was not expected at this location..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_ExpectedEndOfTag">
            <summary>
              Looks up a localized string similar to Expected &apos;&gt;&apos; or &apos;/&gt;&apos; to close tag &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_ExpectedEndOfXml">
            <summary>
              Looks up a localized string similar to Unexpected character at this location..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_ExpectedIdentifier">
            <summary>
              Looks up a localized string similar to An identifier was expected..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_IncorrectComment">
            <summary>
              Looks up a localized string similar to Incorrect syntax was used in a comment..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_InvalidCharEntity">
            <summary>
              Looks up a localized string similar to An invalid character was found inside an entity reference..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_InvalidToken">
            <summary>
              Looks up a localized string similar to The character(s) &apos;{0}&apos; cannot be used at this location..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_InvalidUnicodeChar">
            <summary>
              Looks up a localized string similar to Invalid unicode character..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_InvalidWhitespace">
            <summary>
              Looks up a localized string similar to Whitespace is not allowed at this location..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_LessThanInAttributeValue">
            <summary>
              Looks up a localized string similar to The character &apos;&lt;&apos; cannot be used in an attribute value..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_MissingEqualsAttribute">
            <summary>
              Looks up a localized string similar to Missing equals sign between attribute and attribute value..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_RefUndefinedEntity_1">
            <summary>
              Looks up a localized string similar to Reference to undefined entity &apos;{0}&apos;..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_StringLiteralNoEndQuote">
            <summary>
              Looks up a localized string similar to Missing closing quotation mark for string literal..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_StringLiteralNonAsciiQuote">
            <summary>
              Looks up a localized string similar to Non-ASCII quotations marks may not be used around string literals..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_StringLiteralNoStartQuote">
            <summary>
              Looks up a localized string similar to A string literal was expected, but no opening quotation mark was found..
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpResources.XML_WhitespaceMissing">
            <summary>
              Looks up a localized string similar to Required white space was missing..
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Declaration">
            <summary>
            A Declaration summarizes the declaration structure of a source file. Each entity declaration
            in the program that is a container (specifically namespaces, classes, interfaces, structs,
            and delegate declarations) is represented by a node in this tree.  At the top level, the
            compilation unit is treated as a declaration of the unnamed namespace.
            
            Special treatment is required for namespace declarations, because a single namespace
            declaration can declare more than one namespace.  For example, in the declaration
            
                namespace A.B.C {}
                
            we see that namespaces A and B and C are declared.  This declaration is represented as three
            declarations. All three of these ContainerDeclaration objects contain a reference to the
            syntax tree for the declaration.
            
            A "single" declaration represents a specific namespace or type declaration at a point in
            source code. A "root" declaration is a special single declaration which summarizes the
            contents of an entire file's types and namespaces.  Each source file is represented as a tree
            of single declarations.
            
            A "merged" declaration merges together one or more declarations for the same symbol.  For
            example, the root namespace has multiple single declarations (one in each source file) but
            there is a single merged declaration for them all.  Similarly partial classes may have
            multiple declarations, grouped together under the umbrella of a merged declaration.  In the
            common trivial case, a merged declaration for a single declaration contains only that single
            declaration.  The whole program, consisting of the set of all declarations in all of the
            source files, is represented by a tree of merged declarations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DeclarationTable">
            <summary>
            A declaration table is a device which keeps track of type and namespace declarations from
            parse trees. It is optimized for the case where there is one set of declarations that stays
            constant, and a specific root namespace declaration corresponding to the currently edited
            file which is being added and removed repeatedly. It maintains a cache of information for
            "merging" the root declarations into one big summary declaration; this cache is efficiently
            re-used provided that the pattern of adds and removes is as we expect.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DeclarationTreeBuilder.CreateScriptRootDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax)">
            <summary>
            Creates a root declaration that contains a Script class declaration (possibly in a namespace) and namespace declarations.
            Top-level declarations in script code are nested in Script class.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DocumentationCommentIDVisitor.PartVisitor">
            <summary>
            A visitor that generates the part of the documentation comment after the initial type
            and colon.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.CSharpDefinitionMap">
            <summary>
            Matches symbols from an assembly in one compilation to
            the corresponding assembly in another. Assumes that only
            one assembly has changed between the two compilations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.CSharpDefinitionMap.CreateLocalSlotMap(Microsoft.CodeAnalysis.Emit.EditAndContinueMethodDebugInformation,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.LocalInfo{Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol}})">
            <summary>
            Match local declarations to names to generate a map from
            declaration to local slot. The names are indexed by slot and the
            assumption is that declarations are in the same order as slots.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.EmitHelpers.MapToCompilation(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Emit.PEDeltaAssemblyBuilder)">
            <summary>
            Return a version of the baseline with all definitions mapped to this compilation.
            Definitions from the initial generation, from metadata, are not mapped since
            the initial generation is always included as metadata. That is, the symbols from
            types, methods, ... in the TypesAdded, MethodsAdded, ... collections are replaced
            by the corresponding symbols from the current compilation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.GenericMethodInstanceReference">
            <summary>
            Represents a reference to a generic method instantiation, closed over type parameters,
            e.g. MyNamespace.Class.Method{T}()
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.GenericNamespaceTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation that is not nested.
            e.g. MyNamespace.A{int}
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.GenericNestedTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation that is nested in a non-generic type.
            e.g. A.B{int}
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.GenericTypeInstanceReference">
            <summary>
            Represents a reference to a generic type instantiation.
            Subclasses represent nested and namespace types.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Emit.PEAssemblyBuilderBase._metadataName">
            <summary>
            The behavior of the C# command-line compiler is as follows:
              1) If the /out switch is specified, then the explicit assembly name is used.
              2) Otherwise,
                 a) if the assembly is executable, then the assembly name is derived from
                    the name of the file containing the entrypoint;
                 b) otherwise, the assembly name is derived from the name of the first input
                    file.
            
            Since we don't know which method is the entrypoint until well after the
            SourceAssemblySymbol is created, in case 2a, its name will not reflect the
            name of the file containing the entrypoint.  We leave it to our caller to
            provide that name explicitly.
            </summary>
            <remarks>
            In cases 1 and 2b, we expect (metadataName == sourceAssembly.MetadataName).
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder._fixedImplementationTypes">
            <summary>
            The compiler-generated implementation type for each fixed-size buffer.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.IgnoreAccessibility">
            <summary>
            Ignore accessibility when resolving well-known type
            members, in particular for generic type arguments
            (e.g.: binding to internal types in the EE).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.DynamicOperationContextType">
            <summary>
            Override the dynamic operation context type for all dynamic calls in the module.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.IsEncDelta">
            <summary>
            True if this module is an ENC update.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.PEModuleBuilder.SetFixedImplementationType(Microsoft.CodeAnalysis.CSharp.Symbols.SourceMemberFieldSymbol)">
            <summary>
            Set the underlying implementation type for a given fixed-size buffer field.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.SpecializedFieldReference">
            <summary>
            Represents a reference to a field of a generic type instantiation.
            e.g.
            A{int}.Field
            A{int}.B{string}.C.Field
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.SpecializedGenericMethodInstanceReference">
            <summary>
            Represents a generic method of a generic type instantiation, closed over type parameters.
            e.g. 
            A{T}.M{S}()
            A.B{T}.C.M{S}()
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.SpecializedGenericNestedTypeInstanceReference">
            <summary>
            Represents a reference to an instantiation of a generic type nested in an instantiation of another generic type.
            e.g. 
            A{int}.B{string}
            A.B{int}.C.D{string}
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.SpecializedMethodReference">
            <summary>
            Represents a method of a generic type instantiation.
            e.g. 
            A{int}.M()
            A.B{int}.C.M()
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Emit.SpecializedNestedTypeReference">
            <summary>
            Represents a reference to a type nested in an instantiation of a generic type.
            e.g. 
            A{int}.B
            A.B{int}.C.D
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.TypeMemberReference.ToString">
            <remarks>
            Used only for testing.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedTypesManager.IsValidEmbeddableType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.Emit.NoPia.EmbeddedTypesManager)">
            <summary>
            Returns true if the type can be embedded. If the type is defined in a linked (/l-ed)
            assembly, but doesn't meet embeddable type requirements, this function returns false
            and reports appropriate diagnostics.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSDiagnostic">
            <summary>
            A diagnostic, along with the location where it occurred.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticBagExtensions.Add(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.ErrorCode,Microsoft.CodeAnalysis.Location)">
            <summary>
            Add a diagnostic to the bag.
            </summary>
            <param name="diagnostics"></param>
            <param name="code"></param>
            <param name="location"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticBagExtensions.Add(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.ErrorCode,Microsoft.CodeAnalysis.Location,System.Object[])">
            <summary>
            Add a diagnostic to the bag.
            </summary>
            <param name="diagnostics"></param>
            <param name="code"></param>
            <param name="location"></param>
            <param name="args"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticBagExtensions.Add(Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.DiagnosticInfo})">
            <summary>
            Adds diagnostics from useSiteDiagnostics into diagnostics and returns True if there were any errors.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ErrorFacts.GetMessage(Microsoft.CodeAnalysis.CSharp.MessageID,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ErrorFacts.GetMessage(Microsoft.CodeAnalysis.CSharp.ErrorCode,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ErrorFacts.GetMessage(Microsoft.CodeAnalysis.CSharp.XmlParseErrorCode,System.Globalization.CultureInfo)">
            <remarks>Don't call this during a parse--it loads resources</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ErrorFacts.PreventsSuccessfulDelegateConversion(Microsoft.CodeAnalysis.CSharp.ErrorCode)">
            <summary>
            When converting an anonymous function to a delegate type, there are some diagnostics
            that will occur regardless of the delegate type - particularly those that do not
            depend on the substituted types (e.g. name uniqueness).  Even though we need to
            produce a diagnostic in such cases, we do not need to abandon overload resolution -
            we can choose the overload that is best without regard to such diagnostics.
            </summary>
            <returns>True if seeing the ErrorCode should prevent a delegate conversion
            from completing successfully.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ErrorFacts.PreventsSuccessfulDelegateConversion(Microsoft.CodeAnalysis.DiagnosticBag)">
            <remarks>
            WARNING: will resolve lazy diagnostics - do not call this before the member lists are completed
            or you could trigger infinite recursion.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AbstractFlowPass`1">
            <summary>
            An abstract flow pass that takes some shortcuts in analyzing finally blocks, in order to enable
            the analysis to take place without tracking exceptions or repeating the analysis of a finally block
            for each exit from a try statement.  The shortcut results in a slightly less precise
            (but still conservative) analysis, but that less precise analysis is all that is required for
            the language specification.  The most significant shortcut is that we do not track the state
            where exceptions can arise.  That does not affect the soundness for most analyses, but for those
            analyses whose soundness would be affected (e.g. "data flows out"), we track "unassignments" to keep
            the analysis sound.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AbstractRegionDataFlowPass.Scan(System.Boolean@)">
            <summary>
            To scan the whole body, we start outside (before) the region.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AlwaysAssignedWalker">
            <summary>
            A region analysis walker that computes the set of variables that are always assigned a value
            in the region. A variable is "always assigned" in a region if an analysis of the region that
            starts with the variable unassigned ends with the variable assigned.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis">
            <summary>
            This class implements the region control flow analysis operations. Region control flow
            analysis provides information about statements which enter and leave a region. The analysis
            is done lazily. When created, it performs no analysis, but simply caches the arguments.
            Then, the first time one of the analysis results is used it computes that one result and
            caches it. Each result is computed using a custom algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis.EntryPoints">
            <summary>
            A collection of statements outside the region that jump into the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis.ExitPoints">
            <summary>
            A collection of statements inside the region that jump to locations outside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis.EndPointIsReachable">
            <summary>
            Returns true if and only if the endpoint of the last statement in the region is reachable or the region contains no
            statements.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis.ReturnStatements">
            <summary>
            A collection of return (or yield break) statements found within the region that return from the enclosing method or lambda.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpControlFlowAnalysis.Succeeded">
            <summary>
            Returns true iff analysis was successful.  Analysis can fail if the region does not properly span a single expression,
            a single statement, or a contiguous series of statements within the enclosing block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ControlFlowPass.LocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Analyze(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Perform control flow analysis, reporting all necessary diagnostics.  Returns true if the end of
            the body might be reachable..
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ControlFlowPass.Analyze(System.Boolean@,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Analyze the body, reporting all necessary diagnostics.  Returns true if the end of the
            body might be reachable.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis">
            <summary>
            This class implements the region data flow analysis operations.  Region data flow analysis
            provides information how data flows into and out of a region.  The analysis is done lazily.
            When created, it performs no analysis, but simply caches the arguments. Then, the first time
            one of the analysis results is used it computes that one result and caches it. Each result
            is computed using a custom algorithm.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.VariablesDeclared">
            <summary>
            A collection of the local variables that are declared within the region. Note that the region must be
            bounded by a method's body or a field's initializer, so method parameter symbols are never included
            in the result, but lambda parameters might appear in the result.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.DataFlowsIn">
            <summary>
            A collection of the local variables for which a value assigned outside the region may be used inside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.DataFlowsOut">
            <summary>
            A collection of the local variables for which a value assigned inside the region may be used outside the region.
            Note that every reachable assignment to a ref or out variable will be included in the results.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.AlwaysAssigned">
            <summary>
            A collection of the local variables for which a value is always assigned inside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.ReadInside">
            <summary>
            A collection of the local variables that are read inside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.WrittenInside">
            <summary>
            A collection of local variables that are written inside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.ReadOutside">
            <summary>
            A collection of the local variables that are read outside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.WrittenOutside">
            <summary>
            A collection of local variables that are written outside the region.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.Captured">
            <summary>
            A collection of the non-constant local variables and parameters that have been referenced in anonymous functions
            and therefore must be moved to a field of a frame class.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.UnsafeAddressTaken">
            <summary>
            A collection of the non-constant local variables and parameters that have had their address (or the address of one
            of their fields) taken using the '&amp;' operator.
            </summary>
            <remarks>
            If there are any of these in the region, then a method should not be extracted.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpDataFlowAnalysis.Succeeded">
            <summary>
            Returns true iff analysis was successful.  Analysis can fail if the region does not properly span a single expression,
            a single statement, or a contiguous series of statements within the enclosing block.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass.initiallyAssignedVariables">
            <summary>
            Some variables that should be considered initially assigned.  Used for region analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass._usedVariables">
            <summary>
            Variables that were used anywhere, in the sense required to suppress warnings about
            unused variables.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass._writtenVariables">
            <summary>
            Variables that were initialized or written anywhere.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass._unsafeAddressTakenVariables">
            <summary>
            Map from variables that had their addresses taken, to the location of the first corresponding
            address-of expression.
            </summary>
            <remarks>
            Doesn't include fixed statement address-of operands.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass._capturedVariables">
            <summary>
            Variables that were captured by anonymous functions.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass._sourceAssembly">
            <summary>
            The current source assembly.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass._variableSlot">
            <summary>
            A mapping from local variables to the index of their slot in a flow analysis local state.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass._unassignedVariableAddressOfSyntaxes">
            <summary>
            A set of address-of expressions for which the operand is not definitely assigned.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass.variableBySlot">
            <summary>
            A mapping from the local variable slot to the symbol for the local variable itself.  This
            is used in the implementation of region analysis (support for extract method) to compute
            the set of variables "always assigned" in a region of code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass.nextVariableSlot">
            <summary>
            Variable slots are allocated to local variables sequentially and never reused.  This is
            the index of the next slot number to use.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass._alreadyReported">
            <summary>
            Tracks variables for which we have already reported a definite assignment error.  This
            allows us to report at most one such error per variable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.DataFlowPass.currentMethodOrLambda">
            <summary>
            Reflects the enclosing method or lambda at the current location (in the bound tree).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass._emptyStructTypeCache">
            <summary>
            A cache for remember which structs are empty.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass._requireOutParamsAssigned">
            <summary>
            true if we should check to ensure that out parameters are assigned on every exit point.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.DataFlowPass.topLevelMethod">
            <summary>
            The topmost method of this analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.#ctor(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundNode,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbol},System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax},System.Boolean)">
            <summary>
            Constructor to be used for region analysis, for which a struct type should never be considered empty.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
            <summary>
            Perform data flow analysis, reporting all necessary diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.Analyze(System.Boolean@,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Analyze the body, reporting all necessary diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.CheckCaptured(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol)">
            <summary>
            Check if the variable is captured and, if so, add it to this._capturedVariables.
            </summary>
            <param name="variable">The variable to be checked</param>
            <param name="rangeVariableUnderlyingParameter">If variable.Kind is RangeVariable, its underlying lambda parameter. Else null.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.NoteCaptured(Microsoft.CodeAnalysis.CSharp.Symbol)">
            <summary>
            Add the variable to the captured set. For range variables we only add it if inside the region.
            </summary>
            <param name="variable"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.WriteConsideredUse(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            This reflects the Dev10 compiler's rules for when a variable initialization is considered a "use"
            for the purpose of suppressing the warning about unused variables.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.VariableSlot(Microsoft.CodeAnalysis.CSharp.Symbol,System.Int32)">
            <summary>
            Locals are given slots when their declarations are encountered.  We only need give slots
            to local variables, out parameters, and the "this" variable of a struct constructs.
            Other variables are not given slots, and are therefore not tracked by the analysis.  This
            returns -1 for a variable that is not tracked, for fields of structs that have the same
            assigned status as the container, and for structs that (recursively) contain no data members.
            We do not need to track references to
            variables that occur before the variable is declared, as those are reported in an
            earlier phase as "use before declaration". That allows us to avoid giving slots to local
            variables before processing their declarations.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.GetOrCreateSlot(Microsoft.CodeAnalysis.CSharp.Symbol,System.Int32)">
            <summary>
            Force a variable to have a slot.  Returns -1 if the variable has an empty struct type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.MakeSlot(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Return the slot for a variable, or -1 if it is not tracked (because, for example, it is an empty struct).
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.CheckAssigned(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Check that the given variable is definitely assigned.  If not, produce an error.
            </summary>
            <param name="symbol"></param>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.ReportUnassigned(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Report a given variable as not definitely assigned.  Once a variable has been so
            reported, we suppress further reports of that variable.
            </summary>
            <param name="symbol"></param>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.AssignImpl(Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.RefKind,System.Boolean,System.Boolean)">
            <summary>
            Mark a variable as assigned (or unassigned).
            </summary>
            <param name="node">Node being assigned to.</param>
            <param name="value">The value being assigned.</param>
            <param name="written">True if target location is considered written to.</param>
            <param name="refKind">Target kind (by-ref or not).</param>
            <param name="read">True if target location is considered read from.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.FieldsAllSet(System.Int32,Microsoft.CodeAnalysis.CSharp.DataFlowPass.LocalState)">
            <summary>
            Does the struct variable at the given slot have all of its instance fields assigned?
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.BoundUsingStatement)">
            <remarks>
            Variables declared in a using statement are always considered used, so this is just an assert.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DataFlowPass.LocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DataFlowsInWalker">
            <summary>
            A region analysis walker that computes the set of variables whose values flow into (are used
            in) the region. A variable assigned outside is used inside if an analysis that leaves the
            variable unassigned on entry to the region would cause the generation of "unassigned" errors
            within the region.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DataFlowsOutWalker">
            <summary>
            A region analysis walker that computes the set of variables for
            which their assigned values flow out of the region.
            A variable assigned inside is used outside if an analysis that
            treats assignments in the region as unassigning the variable would
            cause "unassigned" errors outside the region.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache">
            <summary>
            A small cache for remembering empty struct types for flow analysis.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache._dev12CompilerCompatibility">
            <summary>
            When set, we ignore private reference fields of structs loaded from metadata.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.#ctor(Microsoft.CodeAnalysis.Compilation,System.Boolean)">
            <summary>
            Create a cache for computing whether or not a struct type is "empty".
            </summary>
            <param name="dev12CompilerCompatibility">Enable compatibility with the native compiler, which
             ignores inaccessible fields of reference type for structs loaded from metadata.</param>
            <param name="compilation">if <see cref="F:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache._dev12CompilerCompatibility"/> is true, set to the compilation from
            which to check accessibility.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.IsEmptyStructType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Determine if the given type is an empty struct type.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.IsEmptyStructType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol})">
            <summary>
            Determine if the given type is an empty struct type,. "typesWithMembersOfThisType" contains
            a list of types that have members (directly or indirectly) of this type.
            to remove circularity.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.CheckStructInstanceFields(Roslyn.Utilities.ConsList{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol},Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Get all instance fields of a struct. They are not necessarily returned in order.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.GetStructInstanceFields(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
             <summary>
             Get all instance fields of a struct. They are not necessarily returned in order.
             </summary>
            
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.IsIgnorableType(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            When deciding what struct fields to drop on the floor, the native compiler looks
            through arrays, and does not ignore value types or type parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.EmptyStructTypeCache.IsAccessibleInAssembly(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.SourceAssemblySymbol)">
            <summary>
            Is it possible that the given symbol can be accessed somewhere in the given assembly?
            For the purposes of this test, we assume that code in the given assembly might derive from
            any type. So protected members are considered potentially accessible.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NeverEmptyStructTypeCache">
            <summary>
            Specialized EmptyStructTypeCache that reports all structs as not empty
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.EntryPointsWalker">
            <summary>
            A region analysis walker that records jumps into the region.  Works by overriding NoteBranch, which is
            invoked by a superclass when the two endpoints of a jump have been identified.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ExitPointsWalker">
            <summary>
            A region analysis walker that records jumps out of the region.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.FlowAnalysisPass.Rewrite(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.BoundBlock,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            The flow analysis pass.  This pass reports required diagnostics for unreachable
            statements and uninitialized variables (through the call to FlowAnalysisWalker.Analyze),
            and inserts a final return statement if the end of a void-returning method is reachable.
            </summary>
            <param name="method">the method to be analyzed</param>
            <param name="block">the method's body</param>
            <param name="diagnostics">the receiver of the reported diagnostics</param>
            <returns>the rewritten block for the method (with a return statement possibly inserted)</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.AbstractLocalState.Clone">
            <summary>
            Produce a duplicate of this flow analysis state.
            </summary>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.AbstractLocalState.Reachable">
            <summary>
            Is the code reachable?
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.compilation">
            <summary>
            The compilation in which the analysis is taking place.  This is needed to determine which
            conditional methods will be compiled and which will be omitted.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1._member">
            <summary>
            The method whose body is being analyzed, or the field whose initializer is being analyzed.
            It is used for
            references to method parameters. Thus, 'member' should not be used directly, but
            'MethodParameters', 'MethodThisParameter' and 'AnalyzeOutParameters(...)' should be used
            instead.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.methodMainNode">
            <summary>
            The bound node of the method or initializer being analyzed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1._labels">
            <summary>
            The flow analysis state at each label, computed by merging the state from branches to
            that label with the state when we fall into the label.  Entries are created when the
            label is encountered.  One case deserves special attention: when the destination of the
            branch is a label earlier in the code, it is possible (though rarely occurs in practice)
            that we are changing the state at a label that we've already analyzed. In that case we
            run another pass of the analysis to allow those changes to propagate. This repeats until
            no further changes to the state of these labels occurs.  This can result in quadratic
            performance in unlikely but possible code such as this: "int x; if (cond) goto l1; x =
            3; l5: print x; l4: goto l5; l3: goto l4; l2: goto l3; l1: goto l2;"
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.backwardBranchChanged">
            <summary>
            Set to true after an analysis scan if the analysis was incomplete due to a backward
            "goto" branch changing some analysis result.  In this case the caller scans again (until
            this is false). Since the analysis proceeds by monotonically changing the state computed
            at each label, this must terminate.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1._pendingBranches">
            <summary>
            See property PendingBranches
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1._labelsSeen">
            <summary>
            All of the labels seen so far in this forward scan of the body
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1._trackExceptions">
            <summary>
            If we are tracking exceptions, then by convention the first entry in the pending braches
            buffer contains a summary of the states that can arise from exceptions.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.PendingBranches">
            <summary>
            Pending escapes generated in the current scope (or more deeply nested scopes). When jump
            statements (goto, break, continue, return) are processed, they are placed in the
            pendingBranches buffer to be processed later by the code handling the destination
            statement. As a special case, the processing of try-finally statements might modify the
            contents of the pendingBranches buffer to take into account the behavior of
            "intervening" finally clauses.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.State">
            <summary>
            The definite assignment and/or reachability state at the point currently being analyzed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Diagnostics">
            <summary>
            Where all diagnostics are deposited.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1._loopHeadState">
            <summary>
            A cache of the state at the backward branch point of each loop.  This is not needed
            during normal flow analysis, but is needed for DataFlowsOut region analysis.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.EnterRegion">
            <summary>
            Subclasses may override EnterRegion to perform any actions at the entry to the region.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.LeaveRegion">
            <summary>
            Subclasses may override LeaveRegion to perform any action at the end of the region.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.PendingBranch">
            <summary>
            A pending branch.  There are created for a return, break, continue, goto statement,
            yield return, yield break, await expression, and if PreciseAbstractFlowPass.trackExceptions
            is true for other
            constructs that can cause an exception to be raised such as a throw statement or method
            invocation.
            The idea is that we don't know if the branch will eventually reach its destination
            because of an intervening finally block that cannot complete normally.  So we store them
            up and handle them as we complete processing each construct.  At the end of a block, if
            there are any pending branches to a label in that block we process the branch.  Otherwise
            we relay it up to the enclosing construct as a pending branch of the enclosing
            construct.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.Scan(System.Boolean@)">
            <summary>
            Perform a single pass of flow analysis.  Note that after this pass,
            this.backwardBranchChanged indicates if a further pass is required.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.MethodParameters">
            <summary>
            If a method is currently being analyzed returns its parameters, returns an empty array
            otherwise.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.MethodThisParameter">
            <summary>
            If a method is currently being analyzed returns its 'this' parameter, returns null
            otherwise.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.ShouldAnalyzeOutParameters(Microsoft.CodeAnalysis.Location@)">
            <summary>
            Specifies whether or not method's out parameters should be analyzed. If there's more
            than one location in the method being analyzed, then the method is partial and we prefer
            to report an out parameter in partial method error.
            </summary>
            <param name="location">location to be used</param>
            <returns>true if the out parameters of the method should be analyzed</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.LabelState(Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol)">
            <summary>
            Return the flow analysis state associated with a label.
            </summary>
            <param name="label"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.RemoveReturns">
            <summary>
            Return to the caller the set of pending return statements.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.SetUnreachable">
            <summary>
            Set the current state to one that indicates that it is unreachable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitCondition(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Visit a boolean condition expression.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitRvalue(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Visit a general expression, where we will only need to determine if variables are
            assigned (or not). That is, we will not be needing AssignedWhenTrue and
            AssignedWhenFalse.
            </summary>
            <param name="node"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitStatement(Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Visit a statement.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.LoopHead(Microsoft.CodeAnalysis.CSharp.BoundLoopStatement)">
            <summary>
            Called at the point in a loop where the backwards branch would go to.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.LoopTail(Microsoft.CodeAnalysis.CSharp.BoundLoopStatement)">
            <summary>
            Called at the point in a loop where the backward branch is placed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.ResolveBreaks(`0,Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol)">
            <summary>
            Used to resolve break statements in each statement form that has a break statement
            (loops, switch).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.ResolveContinues(Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol)">
            <summary>
            Used to resolve continue statements in each statement form that supports it.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.NoteBranch(Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass{`0}.PendingBranch,Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Subclasses override this if they want to take special actions on processing a goto
            statement, when both the jump and the label have been located.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.ResolveBranches(Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol,Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            To handle a label, we resolve all branches to that label.  Returns true if the state of
            the label changes as a result.
            </summary>
            <param name="label">Target label</param>
            <param name="target">Statement containing the target label</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.SavePending">
            <summary>
            Since branches cannot branch into constructs, only out, we save the pending branches
            when visiting more nested constructs.  When tracking exceptions, we store the current
            state as the exception state for the following code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.RestorePending(Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass{`0}.SavedPending)">
            <summary>
            We use this to restore the old set of pending branches after visiting a construct that contains nested statements.
            </summary>
            <param name="oldPending">The old pending branches, which are to be merged with the current ones</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.DefaultVisit(Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Since each language construct must be handled according to the rules of the language specification,
            the default visitor reports that the construct for the node is not implemented in the compiler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.TypeIsImmutable(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Certain (struct) types are known by the compiler to be immutable.  In these cases calling a method on
            the type is known (by flow analysis) not to write the receiver.
            </summary>
            <param name="t"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.PreciseAbstractFlowPass`1.VisitAddressOfOperator(Microsoft.CodeAnalysis.CSharp.BoundAddressOfOperator,System.Boolean)">
            <summary>
            If the operand is definitely assigned, we may want to perform a read (in addition to
            a write) so that the operand can show up as ReadInside/DataFlowsIn.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ReadWriteWalker">
            <summary>
            A region analysis walker that records reads and writes of all variables, both inside and outside the region.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ReadWriteWalker.NoteRead(Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol)">
            <summary>
            Note that a variable is read.
            </summary>
            <param name="variable">The variable</param>
            <param name="rangeVariableUnderlyingParameter">If variable.Kind is RangeVariable, its underlying lambda parameter. Else null.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ReadWriteWalker.NoteReceiverReadOrWritten(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess,System.Collections.Generic.HashSet{Microsoft.CodeAnalysis.CSharp.Symbol})">
            <summary>
            When we read a field from a struct, the receiver isn't seen as being read until we get to the
            end of the field access expression, because we only read the relevant piece of the struct.
            But we want the receiver to be considered to be read in the region in that case.
            For example, if an rvalue expression is x.y.z and the region is x.y, we want x to be included
            in the ReadInside set.  That is implemented here.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ReadWriteWalker.GetRangeVariableUnderlyingParameter(Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Compute the underlying lambda parameter symbol for a range variable, if any.
            </summary>
            <param name="underlying">The bound node for the expansion of the range variable</param>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext">
            <summary>
            Represents region analysis context attributes such as compilation, region, etc...
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.Compilation">
            <summary> Compilation to use </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.Member">
            <summary> Containing symbol if available, null otherwise </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.BoundNode">
            <summary> Bound node, not null </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.FirstInRegion">
            <summary> Region to be used </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.LastInRegion">
            <summary> Region to be used </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.Failed">
            <summary> True if the input was bad, such as no first and last nodes </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.RegionAnalysisContext.#ctor(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Construct context
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.RegionReachableWalker">
            <summary>
            A region analysis walker that computes whether or not the region completes normally.  It does this by determining
            if the point at which the region ends is reachable.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UnassignedAddressTakenVariablesWalker">
            <summary>
            An analysis that computes the set of variables that may be used
            before being assigned anywhere within a method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UnassignedVariablesWalker">
            <summary>
            An analysis that computes the set of variables that may be used
            before being assigned anywhere within a method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.VariablesDeclaredWalker">
            <summary>
            A region analysis walker that records declared variables.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LanguageVersion">
            <summary>
            Specifies the language version.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp1">
            <summary>
            C# language version 1.0.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp2">
            <summary>
            C# language version 2.0.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp3">
            <summary>
            C# language version 3.0.
            </summary>
            <remarks> 
            Features: LINQ.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp4">
            <summary>
            C# language version 4.0.
            </summary>
            <remarks> 
            Features: dynamic.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp5">
            <summary>
            C# language version 5.0.
            </summary>
            <remarks> 
            Features: async.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LanguageVersion.CSharp6">
            <summary> 
            C# language version 6.0.
            </summary>
            <remarks>
            <para>Features:</para>
            <list type="bullet">
            <item><description>Using of a static class</description></item> 
            <item><description>Auto-property initializers</description></item> 
            <item><description>Expression-bodied methods and properties</description></item> 
            <item><description>Null-propagating operator ?.</description></item> 
            <item><description>Exception filters</description></item> 
            </list> 
            </remarks> 
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter">
            <summary>
            The purpose of this rewriter is to replace await-containing catch and finally handlers
            with surrogate replacements that keep actual handler code in regular code blocks.
            That allows these constructs to be further lowered at the async lowering pass.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag)">
             <summary>
             Lower a block of code by performing local rewritings. 
             The goal is to not have exception handlers that contain awaits in them.
             
             1) Await containing finallies:
                 The general strategy is to rewrite await containing handlers into synthetic handlers.
                 Synthetic handlers are not handlers in IL sense so it is ok to have awaits in them.
                 Since synthetic handlers are just blocks, we have to deal with pending exception/branch/return manually
                 (this is the hard part of the rewrite).
            
                 try{
                    code;
                 }finally{
                    handler;
                 }
            
             Into ===>
            
                 Exception ex = null;
                 int pendingBranch = 0;
            
                 try{
                     code;  // any gotos/returns are rewritten to code that pends the necessary info and goes to finallyLabel
                     goto finallyLabel;
                 }catch (ex){  // essentially pend the currently active exception
                 };
            
                 finallyLabel:
                 {
                    handler;
                    if (ex != null) throw ex;     // unpend the exception
                    unpend branches/return
                 }
             
             2) Await containing catches:
                 try{
                     code;
                 }catch (Exeption ex){
                     handler;
                     throw;
                 }
             
             
             Into ===>
            
                 Object pendingException;
                 int pendingCatch = 0;
            
                 try{
                     code; 
                 }catch (Exception temp){  // essentially pend the currently active exception
                     pendingException = temp;
                     pendingCatch = 1;
                 };
            
                 switch(pendingCatch):
                 {
                    case 1:
                     {
                         Exception ex = (Exception)pendingException;
                         handler;
                         throw pendingException
                     }
                 }
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.RewriteFinalizedRegion(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            Rewrites Try/Catch part of the Try/Catch/Finally
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.AwaitInFinallyAnalysis">
            <summary>
            Analyses method body for Try blocks with awaits in finallies 
            Also collects labels that such blocks contain.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.AwaitInFinallyAnalysis.FinallyContainsAwaits(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            Returns true if a finally of the given try contains awaits
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.AwaitInFinallyAnalysis.CatchContainsAwait(Microsoft.CodeAnalysis.CSharp.BoundCatchBlock)">
            <summary>
            Returns true if a catch contains awaits
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.AwaitInFinallyAnalysis.ContainsAwaitInHandlers">
            <summary>
            Returns true if body contains await in a finally block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncExceptionHandlerRewriter.AwaitInFinallyAnalysis.Labels(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            Labels reachable from within this frame without invoking its finally. 
            null if there are no such labels.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection">
            <summary>
            Async methods have both a return type (void, Task, or Task&lt;T&gt;) and a 'result' type, which is the
            operand type of any return expressions in the async method. The result type is void in the case of
            Task-returning and void-returning async methods, and T in the case of Task&lt;T&gt;-returning async
            methods.
            
            System.Runtime.CompilerServices provides a collection of async method builders that are used in the
            generated code of async methods to create and manipulate the async method's task. There are three
            distinct async method builder types, one of each async return type: AsyncVoidMethodBuilder,
            AsyncTaskMethodBuilder, and AsyncTaskMethodBuilder&lt;T&gt;. 
            
            AsyncMethodBuilderMemberCollection provides a common mechanism for accessing the well-known members of
            each async method builder type. This avoids having to inspect the return style of the current async method
            to pick the right async method builder member during async rewriting.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.BuilderType">
            <summary>
            The builder's constructed type.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.ResultType">
            <summary>
            The result type of the constructed task: T for Task&lt;T&gt;, void otherwise.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.SetException">
            <summary>
            Binds an exception to the method builder.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.SetResult">
            <summary>
            Marks the method builder as successfully completed, and sets the result if method is Task&lt;T&gt;-returning.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.AwaitOnCompleted">
            <summary>
            Schedules the state machine to proceed to the next action when the specified awaiter completes.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.AwaitUnsafeOnCompleted">
            <summary>
            Schedules the state machine to proceed to the next action when the specified awaiter completes. This method can be called from partially trusted code.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.Start">
            <summary>
            Begins running the builder with the associated state machine.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.SetStateMachine">
            <summary>
            Associates the builder with the specified state machine.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodBuilderMemberCollection.Task">
            <summary>
            Get the constructed task for a Task-returning or Task&lt;T&gt;-returning async method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._method">
            <summary>
            The method being rewritten.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._asyncMethodBuilderField">
            <summary>
            The field of the generated async class used to store the async method builder: an instance of
            <see cref="T:System.Runtime.CompilerServices.AsyncVoidMethodBuilder"/>, <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder"/>, or <see cref="T:System.Runtime.CompilerServices.AsyncTaskMethodBuilder`1"/> depending on the
            return type of the async method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._asyncMethodBuilderMemberCollection">
            <summary>
            A collection of well-known members for the current async method builder.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._exprReturnLabel">
            <summary>
            The exprReturnLabel is used to label the return handling code at the end of the async state-machine
            method. Return expressions are rewritten as unconditional branches to exprReturnLabel.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._exitLabel">
            <summary>
            The label containing a return from the method when the async method has not completed.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter._exprRetValue">
            <summary>
            The field of the generated async class used in generic task returning async methods to store the value
            of rewritten return expressions. The return-handling code then uses <c>SetResult</c> on the async method builder
            to make the result available to the caller.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncMethodToStateMachineRewriter.GenerateMoveNext(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol)">
            <summary>
            Generate the body for <c>MoveNext()</c>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AsyncRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.AsyncStateMachine@)">
            <summary>
            Rewrite an async method into a state machine type.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.AsyncStateMachine">
            <summary>
            The class that represents a translated async method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.AwaitExpressionSpiller.PromoteAndAddLocals(Microsoft.CodeAnalysis.CSharp.AwaitExpressionSpiller.BoundSpillSequenceBuilder,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol})">
            <summary>
            If an expression node that declares synthesized short-lived locals (currently only sequence) contains an await, these locals become long-lived since their 
            values may be read by code that follows the await. We promote these variables to long-lived of kind <see cref="F:Microsoft.CodeAnalysis.SynthesizedLocalKind.AwaitSpill"/>. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass">
            <summary>
            This pass detects and reports diagnostics that do not affect lambda convertability.
            This part of the partial class focuses on features that cannot be used in expression trees.
            CAVEAT: Errors may be produced for ObsoleteAttribute, but such errors don't affect lambda convertability.
            </summary>
            <summary>
            This pass detects and reports diagnostics that do not affect lambda convertability.
            This part of the partial class focuses on expression and operator warnings.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass.CheckFieldAddress(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess,Microsoft.CodeAnalysis.CSharp.Symbol)">
            <remarks>
            This is for when we are taking the address of a field.
            Distinguish from <see cref="M:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass.CheckFieldAsReceiver(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass.CheckFieldAsReceiver(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess)">
            <remarks>
            This is for when we are dotting into a field.
            Distinguish from <see cref="M:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass.CheckFieldAddress(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess,Microsoft.CodeAnalysis.CSharp.Symbol)"/>.
            
            NOTE: dev11 also calls this on string initializers in fixed statements,
            but never accomplishes anything since string is a reference type.  This
            is probably a bug, but fixing it would be a breaking change.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.DiagnosticsPass.IsNonAgileFieldAccess(Microsoft.CodeAnalysis.CSharp.BoundFieldAccess,Microsoft.CodeAnalysis.CSharp.CSharpCompilation)">
            <remarks>
            Based on OutputContext::IsNonAgileField.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IteratorConstructor">
            <summary>
            The constructor of the class that is the translation of an iterator method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IteratorFinallyMethodSymbol">
            <summary>
            A synthesized Finally method containing finalization code for a resumable try statement.
            Finalization code for such try may run when:
            1) control flow goes out of try scope by dropping through
            2) control flow goes out of try scope by conditionally or unconditionally branching outside of one ore more try/finally frames.
            3) enumerator is disposed by the owner.
            4) enumerator is being disposed after an exception.
            
            It is easier to manage partial or complete finalization when every finally is factored out as a separate method. 
            
            NOTE: Finally is a private void nonvirtual instance method with no parameters. 
                  It is a valid JIT inlining target as long as JIT may consider inlining profitable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter._current">
            <summary>
            The field of the generated iterator class that underlies the Current property.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter._yieldsInTryAnalysis">
            <summary>
            Tells us if a particular try contains yield returns
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter._tryNestingLevel">
            <summary>
            When this is more that 0, returns are emitted as "methodValue = value; goto exitLabel;"
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter._currentFinallyFrame">
            <summary>
            The current iterator finally frame in the tree of finally frames.
            By default there is a root finally frame.
            Root frame does not have a handler, but may contain nested frames.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter._nextFinalizeState">
            <summary>
            Finally state of the next Finally frame if such created.
            Finally state is a negative decreasing number starting with -3. (-2 is used for something else).
            Root frame has finally state -1.
            
            The Finally state is the state that we are in when "between states".
            Regular states are positive and are the only states that can be resumed to.
            The purpose of distinct finally states is to have enough information about 
            which finally handlers must run when we need to finalize iterator after a fault. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.EmitFinallyFrame(Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.IteratorFinallyFrame,Microsoft.CodeAnalysis.CSharp.BoundLocal)">
            <summary>
            Produces a Try/Finally if frame has a handler (otherwise a regular block).
            Handler goes into the Finally.
            If there are nested frames, they are emitted into the try block.
            This way the handler for the current frame is guaranteed to run even if 
            nested handlers throw exceptions.
            
            {
                switch(state)
                {
                    case state1:
                    case state2:
                    case state3:
                    case state4:
                        try
                        {
                            switch(state)
                            {
                                case state3:
                                case state4:
                                    try
                                    {
                                        ... more nested state dispatches if any ....
                                    }
                                    finally
                                    {
                                        // handler for a try where state3 and state4 can be observed
                                        handler_3_4()
                                    }
                                    break;
                             }
                        }
                        finally
                        {
                            // handler for a try where state1 and state2 can be observed
                            handler_1_2()
                        }
                        break;
                        
                    case state5:
                        ... another dispatch of nested states to their finallies ...
                        break;
                }
            }
            
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.YieldsInTryAnalysis">
            <summary>
            Analyses method body for yields in try blocks and labels that they contain.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.YieldsInTryAnalysis.ContainsYields(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            Returns true if given try or any of its nested trys contain yields
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.YieldsInTryAnalysis.ContainsYieldsInTrys">
            <summary>
            Returns true if body contains yield returns within try blocks.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorMethodToStateMachineRewriter.YieldsInTryAnalysis.Labels(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            Labels reachable from within this frame without invoking its finally. 
            null if there are none such labels.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.IteratorRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag,Microsoft.CodeAnalysis.CSharp.IteratorStateMachine@)">
            <summary>
            Rewrite an iterator method into a state machine class.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IteratorStateMachine">
            <summary>
            The class that represents a translated iterator method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LabelCollector">
            <summary>
            Analyses method body for labels.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureKind.Static">
            <summary>
            The closure doesn't declare any variables. 
            Display class is a singleton and may be shared with other top-level methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureKind.ThisOnly">
            <summary>
            The closure only contains a reference to the containing class instance ("this").
            We don't emit a display class, lambdas are emitted directly to the containing class as its instance methods.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.ClosureKind.General">
            <summary>
            General closure.
            Display class may only contain lambdas defined in the same top-level method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ExpressionLambdaRewriter.VisitExactType(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Visit the expression, but do so in a way that ensures that its type is precise.  That means that any
            sometimes-unnecessary conversions (such as an implicit reference conversion) are retained.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LambdaCapturedVariable">
            <summary>
            A field of a frame class that represents a variable that has been captured in a lambda.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LambdaRewriter">
            <summary>
            The rewriter for removing lambda expressions from method bodies and introducing closure classes
            as containers for captured variables along the lines of the example in section 6.5.3 of the
            C# language specification.
            
            The entry point is the public method <see cref="M:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo},Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)"/>.  It operates as follows:
            
            First, an analysis of the whole method body is performed that determines which variables are
            captured, what their scopes are, and what the nesting relationship is between scopes that
            have captured variables.  The result of this analysis is left in <see cref="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter._analysis"/>.
            
            Then we make a frame, or compiler-generated class, represented by an instance of
            <see cref="T:Microsoft.CodeAnalysis.CSharp.LambdaFrame"/> for each scope with captured variables.  The generated frames are kept
            in <see cref="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter._frames"/>.  Each frame is given a single field for each captured
            variable in the corresponding scope.  These are are maintained in <see cref="F:Microsoft.CodeAnalysis.CSharp.Symbols.MethodToClassRewriter.proxies"/>.
            
            Finally, we walk and rewrite the input bound tree, keeping track of the following:
            (1) The current set of active frame pointers, in <see cref="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter._framePointers"/>
            (2) The current method being processed (this changes within a lambda's body), in <see cref="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter._currentMethod"/>
            (3) The "this" symbol for the current method in <see cref="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter._currentFrameThis"/>, and
            (4) The symbol that is used to access the innermost frame pointer (it could be a local variable or "this" parameter)
            
            There are a few key transformations done in the rewriting.
            (1) Lambda expressions are turned into delegate creation expressions, and the body of the lambda is
                moved into a new, compiler-generated method of a selected frame class.
            (2) On entry to a scope with captured variables, we create a frame object and store it in a local variable.
            (3) References to captured variables are transformed into references to fields of a frame class.
            
            In addition, the rewriting deposits into <see cref="P:Microsoft.CodeAnalysis.CSharp.TypeCompilationState.SynthesizedMethods"/> a (<see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/>, <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundStatement"/>)
            pair for each generated method.
            
            <see cref="M:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo},Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)"/> produces its output in two forms.  First, it returns a new bound statement
            for the caller to use for the body of the original method.  Second, it returns a collection of
            (<see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol"/>, <see cref="T:Microsoft.CodeAnalysis.CSharp.BoundStatement"/>) pairs for additional methods that the lambda rewriter produced.
            These additional methods contain the bodies of the lambdas moved into ordinary methods of their
            respective frame classes, and the caller is responsible for processing them just as it does with
            the returned bound node.  For example, the caller will typically perform iterator method and
            asynchronous method transformations, and emit IL instructions into an assembly.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis">
            <summary>
            Perform a first analysis pass in preparation for removing all lambdas from a method body.  The entry point is Analyze.
            The results of analysis are placed in the fields seenLambda, blockParent, variableBlock, captured, and captures.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis._inExpressionLambda">
            <summary>
            Set to true while we are analyzing the interior of an expression lambda.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.SeenLambda">
            <summary>
            Set to true of any lambda expressions were seen in the analyzed method body.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.scopeParent">
            <summary>
            For each scope that defines variables, identifies the nearest enclosing scope that defines variables.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.variableScope">
            <summary>
            For each captured variable, identifies the scope in which it will be moved to a frame class. This is
            normally the node where the variable is introduced, but method parameters are moved
            to a frame class within the body of the method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.capturedVariables">
            <summary>
            The syntax nodes associated with each captured variable.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.capturedVariablesByLambda">
            <summary>
            For each lambda in the code, the set of variables that it captures.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.needsParentFrame">
            <summary>
            Blocks that are positioned between a block declaring some lifted variables
            and a block that contains the lambda that lifts said variables.
            If such block itself requires a closure, then it must lift parent frame pointer into the closure
            in addition to whatever else needs to be lifted.
            
            NOTE: This information is computed in addition to the regular analysis of the tree and only needed for rewriting.
            If someone only needs diagnostics or information about captures, this information is not necessary.
            <see cref="M:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.ComputeLambdaScopesAndFrameCaptures"/> needs to be called to compute this.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.lambdaScopes">
            <summary>
            Optimized locations of lambdas. 
            
            Lambda does not need to be placed in a frame that corresponds to its lexical scope if lambda does not reference any local state in that scope.
            It is advantageous to place lambdas higher in the scope tree, ideally in the innermost scope of all scopes that contain variables captured by a given lambda.
            Doing so reduces indirections needed when captured locals are accessed. For example locals from the innermost scope can be accessed with no indirection at all.
            
            NOTE: This information is computed in addition to the regular analysis of the tree and only needed for rewriting.
            If someone only needs diagnostics or information about captures, this information is not necessary.
            <see cref="M:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.ComputeLambdaScopesAndFrameCaptures"/> needs to be called to compute this.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.ComputeLambdaScopesAndFrameCaptures">
            <summary>
            Create the optimized plan for the location of lambda methods and whether scopes need access to parent scopes
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Analysis.BlockDepth(Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Compute the nesting depth of a given block.
            Top-most block (where method locals and parameters are defined) are at the depth 0.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.LambdaDebugInfo},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo},Microsoft.CodeAnalysis.CodeGen.VariableSlotAllocator,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean)">
            <summary>
            Rewrite the given node to eliminate lambda expressions.  Also returned are the method symbols and their
            bound bodies for the extracted lambda bodies. These would typically be emitted by the caller such as
            MethodBodyCompiler.  See this class' documentation
            for a more thorough explanation of the algorithm and its use by clients.
            </summary>
            <param name="loweredBody">The bound node to be rewritten</param>
            <param name="thisType">The type of the top-most frame</param>
            <param name="thisParameter">The "this" parameter in the top-most frame, or null if static method</param>
            <param name="method">The containing method of the node to be rewritten</param>
            <param name="methodOrdinal">Index of the method symbol in its containing type member list.</param>
            <param name="lambdaDebugInfoBuilder">Information on lambdas defined in <paramref name="method"/> needed for debugging.</param>
            <param name="closureDebugInfoBuilder">Information on closures defined in <paramref name="method"/> needed for debugging.</param>
            <param name="slotAllocatorOpt">Slot allocator.</param>
            <param name="compilationState">The caller's buffer into which we produce additional methods to be emitted by the caller</param>
            <param name="diagnostics">Diagnostic bag for diagnostics</param>
            <param name="assignLocals">The rewritten tree should include assignments of the original locals to the lifted proxies</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.MakeFrames(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CodeGen.ClosureDebugInfo})">
            <summary>
            Create the frame types.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.FrameOfType(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Produce a bound expression representing a pointer to a frame of a particular frame type.
            </summary>
            <param name="syntax">The syntax to attach to the bound nodes produced</param>
            <param name="frameType">The type of frame to be returned</param>
            <returns>A bound node that computes the pointer to the required frame</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.FramePointer(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Produce a bound expression representing a pointer to a frame of a particular frame class.
            Note that for generic frames, the frameClass parameter is the generic definition, but
            the resulting expression will be constructed with the current type parameters.
            </summary>
            <param name="syntax">The syntax to attach to the bound nodes produced</param>
            <param name="frameClass">The class type of frame to be returned</param>
            <returns>A bound node that computes the pointer to the required frame</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaRewriter.IntroduceFrame``1(Microsoft.CodeAnalysis.CSharp.BoundNode,Microsoft.CodeAnalysis.CSharp.LambdaFrame,System.Func{Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},``0})">
            <summary>
            Introduce a frame around the translation of the given node.
            </summary>
            <param name="node">The node whose translation should be translated to contain a frame</param>
            <param name="frame">The frame for the translated node</param>
            <param name="F">A function that computes the translation of the node.  It receives lists of added statements and added symbols</param>
            <returns>The translated statement, as returned from F</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LambdaFrame">
            <summary>
            A class that represents the set of variables in a scope that have been
            captured by lambdas within that scope.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedLambdaMethod">
            <summary>
            A method that results from the translation of a single lambda expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.Rewrite(Microsoft.CodeAnalysis.CSharp.CSharpCompilation,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Int32,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundStatement,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields,System.Boolean,Microsoft.CodeAnalysis.DiagnosticBag,System.Boolean@,System.Boolean@)">
            <summary>
            Lower a block of code by performing local rewritings.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.ShouldOptimizeOutInitializer(Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <summary>
            Returns true if the initializer is a field initializer which should be optimized out
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeAssignmentOperator(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Generates a lowered form of the assignment operator for the given left and right sub-expressions.
            Left and right sub-expressions must be in lowered form.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeStaticAssignmentOperator(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean)">
            <summary>
            Generates a lowered form of the assignment operator for the given left and right sub-expressions.
            Left and right sub-expressions must be in lowered form.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteBuiltInShiftOperation(Microsoft.CodeAnalysis.CSharp.BoundBinaryOperator,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Int32)">
            <summary>
            Spec section 7.9: if the left operand is int or uint, mask the right operand with 0x1F;
            if the left operand is long or ulong, mask the right operand with 0x3F.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeSizeOfMultiplication(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol,System.Boolean)">
            <summary>
            This rather confusing method tries to reproduce the functionality of ExpressionBinder::bindPtrAddMul and
            ExpressionBinder::bindPtrMul.  The basic idea is that we have a numeric expression, x, and a pointer type, 
            T*, and we want to multiply x by sizeof(T).  Unfortunately, we need to stick in some conversions to make
            everything work.
            
              1) If x is an int, then convert it to an IntPtr (i.e. a native int).  Dev10 offers no explanation (ExpressionBinder::bindPtrMul).
              2) Do overload resolution based on the (possibly converted) type of X and int (the type of sizeof(T)).
              3) If the result type of the chosen multiplication operator is signed, convert the product to IntPtr;
                 otherwise, convert the product to UIntPtr.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeArguments(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.CSharp.Symbol,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean,System.Collections.Immutable.ImmutableArray{System.Int32},System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.RefKind}@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol}@,System.Boolean,Microsoft.CodeAnalysis.ThreeState)">
            <summary>
            Rewrites arguments of an invocation according to the receiving method or indexer.
            It is assumed that each argument has already been lowered, but we may need
            additional rewriting for the arguments, such as generating a params array, re-ordering
            arguments based on <paramref name="argsToParamsOpt"/> map, inserting arguments for optional parameters, etc.
            <paramref name="optionalParametersMethod"/> is the method used for values of any optional parameters.
            For indexers, this method must be an accessor, and for methods it must be the method
            itself. <paramref name="optionalParametersMethod"/> is needed for indexers since getter and setter
            may have distinct optional parameter values.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MergeArgumentsAndSideEffects(Microsoft.CodeAnalysis.CSharp.BoundExpression[],Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.RefKind},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundAssignmentOperator})">
            <summary>
            Process tempStores and add them as sideeffects to arguments where needed. The return
            value tells how many temps are actually needed. For unnecessary temps the corresponding
            temp store will be cleared.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.GetDefaultParameterValue(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,Microsoft.CodeAnalysis.ThreeState)">
            <summary>
            Gets the default value for the <paramref name="parameter"/>.
            </summary>
            <param name="syntax">
            A syntax node corresponding to the invocation.
            </param>
            <param name="parameter">
            A parameter to get the default value for.
            </param>
            <param name="enableCallerInfo">
            Indicates if caller info is to be enabled when processing this optional parameter.
            The value <see cref="F:Microsoft.CodeAnalysis.ThreeState.Unknown"/> means the decision is to be made based on the shape of the <paramref name="syntax"/> node.
            </param>
            <remarks>
            DELIBERATE SPEC VIOLATION: When processing an implicit invocation of an <c>Add</c> method generated
            for an element-initializer in a collection-initializer, the parameter <paramref name="enableCallerInfo"/> 
            is set to <see cref="F:Microsoft.CodeAnalysis.ThreeState.True"/>. It means that if the optional parameter is annotated with <see cref="T:System.Runtime.CompilerServices.CallerLineNumberAttribute"/>,
            <see cref="T:System.Runtime.CompilerServices.CallerFilePathAttribute"/> or <see cref="T:System.Runtime.CompilerServices.CallerMemberNameAttribute"/>, and there is no explicit argument corresponding to it,
            we will provide caller information as a value of this parameter.
            This is done to match the native compiler behavior and user requests (see http://roslyn.codeplex.com/workitem/171). This behavior
            does not match the C# spec that currently requires to provide caller information only in explicit invocations and query expressions.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TransformCompoundAssignmentLHS(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression},Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},System.Boolean)">
            <summary>
            In the expanded form of a compound assignment (or increment/decrement), the LHS appears multiple times.
            If we aren't careful, this can result in repeated side-effects.  This creates (ordered) temps for all of the
            subexpressions that could result in side-effects and returns a side-effect-free expression that can be used
            in place of the LHS in the expanded form.
            </summary>
            <param name="originalLHS">The LHS sub-expression of the compound assignment (or increment/decrement).</param>
            <param name="stores">Populated with a list of assignment expressions that initialize the temporary locals.</param>
            <param name="temps">Populated with a list of temporary local symbols.</param>
            <param name="isDynamicAssignment">True if the compound assignment is a dynamic operation.</param>
            <returns>
            A side-effect-free expression representing the LHS.
            The returned node needs to be lowered but its children are already lowered.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.CanChangeValueBetweenReads(Microsoft.CodeAnalysis.CSharp.BoundExpression,System.Boolean)">
            <summary>
            Variables local to current frame do not need temps when re-read multiple times
            as long as there is no code that may write to locals in between accesses and they
            are not captured.
            
            Example:
                   l += foo(ref l);
            
            even though l is a local, we must access it via a temp since "foo(ref l)" may change it
            on between accesses. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitConditionalOperator(Microsoft.CodeAnalysis.CSharp.BoundConditionalOperator)">
            <summary>
            If the condition has a constant value, then just use the selected branch.
            e.g. "true ? x : y" becomes "x".
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeConversion(Microsoft.CodeAnalysis.CSharp.BoundConversion,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.ConversionKind,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,System.Boolean,System.Boolean,System.Boolean,System.Boolean,Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Helper method to generate a lowered conversion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeConversion(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,System.Boolean)">
            <summary>
            Helper method to generate a lowered conversion from the given <paramref name="rewrittenOperand"/> to the given <paramref name="rewrittenType"/>.
            </summary>
            <remarks>
            If we're converting a default parameter value to the parameter type, then the conversion can actually fail
            (e.g. if the default value was specified by an attribute and was, therefore, not checked by the compiler).
            Set acceptFailingConversion if you want to see default(rewrittenType) in such cases.
            The error will be suppressed only for conversions from <see cref="T:System.Decimal"/> or <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeImplicitConversion(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Helper method to generate a lowered conversion from the given <paramref name="rewrittenOperand"/> to the given <paramref name="rewrittenType"/>.
            </summary>
            <remarks>
            If we're converting a default parameter value to the parameter type, then the conversion can actually fail
            (e.g. if the default value was specified by an attribute and was, therefore, not checked by the compiler).
            Set acceptFailingConversion if you want to see default(rewrittenType) in such cases.
            The error will be suppressed only for conversions from <see cref="T:System.Decimal"/> or <see cref="T:System.DateTime"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeConversion(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.ConversionKind,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,System.Boolean,Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            Helper method to generate a lowered conversion from the given rewrittenOperand to the given rewrittenType with the given conversion kind.
            </summary>
            <remarks>
            Conversion kind must not be a user defined conversion, use the other overload which takes a 'Conversion' parameter for generating synthesized user defined conversions.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteWindowsRuntimeEventAssignmentOperator(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,Microsoft.CodeAnalysis.CSharp.LocalRewriter.EventAssignmentKind,System.Boolean,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            If we have a WinRT type event, we need to encapsulate the adder call
            (which returns an EventRegistrationToken) with a call to 
            WindowsRuntimeMarshal.AddEventHandler or RemoveEventHandler, but these
            require us to create a new Func representing the adder and another
            Action representing the Remover.
            
            The rewritten call looks something like:
            
            WindowsRuntimeMarshal.AddEventHandler&lt;EventHandler&gt;
                (new Func&lt;EventHandler, EventRegistrationToken&gt;(@object.add), 
                 new Action&lt;EventRegistrationToken&gt;(@object.remove), handler);
            
            Where @object is a compiler-generated local temp if needed.
            </summary>
            <remarks>
            TODO: use or delete isDynamic.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.IsInTryBlock(Microsoft.CodeAnalysis.CSharp.BoundFixedStatement)">
            <summary>
            Basically, what we need to know is, if an exception occurred within the fixed statement, would
            additional code in the current method be executed before its stack frame was popped?
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.LocalRewriter._lazyUnmatchedLabelCache">
            <summary>
            If two (or more) fixed statements are nested, then we want to avoid having the outer
            fixed statement re-traverse the lowered bound tree of the inner one.  We accomplish
            this by having each fixed statement cache a set of unmatched gotos that can be
            reused by any containing fixed statements.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.HasGotoOut(Microsoft.CodeAnalysis.CSharp.BoundNode)">
            <summary>
            Look for gotos without corresponding labels in the lowered body of a fixed statement.
            </summary>
            <remarks>
            Assumes continue, break, etc have already been rewritten to gotos.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement)">
            <summary>
            This is the entry point for foreach-loop lowering.  It delegates to
              RewriteEnumeratorForEachStatement
              RewriteSingleDimensionalArrayForEachStatement
              RewriteMultiDimensionalArrayForEachStatement
              RewriteStringForEachStatement
            </summary>
            <remarks>
            We are diverging from the C# 4 spec (and Dev10) to follow the C# 5 spec.
            The iteration variable will be declared *inside* each loop iteration,
            rather than outside the loop.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteEnumeratorForEachStatement(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate a collection using an enumerator.
            
            E e = ((C)(x)).GetEnumerator()
            try {
                while (e.MoveNext()) {
                    V v = (V)(T)e.Current;
                    // body
                }
            }
            finally {
                // clean up e
            }
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.SynthesizeCall(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Conversion,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Synthesize a no-argument call to a given method, possibly applying a conversion to the receiver.
            
            If the receiver is of struct type and the method is an interface method, then skip the conversion
            and just call the interface method directly - the code generator will detect this and generate a 
            constrained virtual call.
            </summary>
            <param name="syntax">A syntax node to attach to the synthesized bound node.</param>
            <param name="receiver">Receiver of method call.</param>
            <param name="method">Method to invoke.</param>
            <param name="receiverConversion">Conversion to be applied to the receiver if not calling an interface method on a struct.</param>
            <param name="convertedReceiverType">Type of the receiver after applying the conversion.</param>
            <returns>A BoundExpression representing the call.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteStringForEachStatement(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate the characters of a string.
            
            string s = x;
            for (int p = 0; p &lt; s.Length; p = p + 1) {
                V v = (V)s.Chars[p];
                // body
            }
            </summary>
            <remarks>
            We will follow Dev10 in diverging from the C# 4 spec by ignoring string's 
            implementation of IEnumerable and just indexing into its characters.
            
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteSingleDimensionalArrayForEachStatement(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate a single-dimensional array.
            
            A[] a = x;
            for (int p = 0; p &lt; a.Length; p = p + 1) {
                V v = (V)a[p];
                // body
            }
            </summary>
            <remarks>
            We will follow Dev10 in diverging from the C# 4 spec by ignoring Array's 
            implementation of IEnumerable and just indexing into its elements.
            
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteMultiDimensionalArrayForEachStatement(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement)">
            <summary>
            Lower a foreach loop that will enumerate a multi-dimensional array.
            
            A[...] a = x;
            int q_0 = a.GetUpperBound(0), q_1 = a.GetUpperBound(1), ...;
            for (int p_0 = a.GetLowerBound(0); p_0 &lt;= q_0; p_0 = p_0 + 1)
                for (int p_1 = a.GetLowerBound(1); p_1 &lt;= q_1; p_1 = p_1 + 1)
                    ...
                        { V v = (V)a[p_0, p_1, ...]; /* body */ }
            </summary>
            <remarks>
            We will follow Dev10 in diverging from the C# 4 spec by ignoring Array's 
            implementation of IEnumerable and just indexing into its elements.
            
            NOTE: We're assuming that sequence points have already been generated.
            Otherwise, lowering to nested for-loops would generated spurious ones.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.GetUnconvertedCollectionExpression(Microsoft.CodeAnalysis.CSharp.BoundForEachStatement)">
            <summary>
            So that the binding info can return an appropriate SemanticInfo.Converted type for the collection
            expression of a foreach node, it is wrapped in a BoundConversion to the collection type in the
            initial bound tree.  However, we may be able to optimize away (or entirely disregard) the conversion
            so we pull out the bound node for the underlying expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.AddForEachExpressionSequencePoint(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,Microsoft.CodeAnalysis.CSharp.BoundStatement@)">
            <summary>
            Add sequence point |here|:
            
            foreach (Type var in |expr|) { }
            </summary>
            <remarks>
            Hit once, before looping begins.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.AddForEachIterationVariableSequencePoint(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,Microsoft.CodeAnalysis.CSharp.BoundStatement@)">
            <summary>
            Add sequence point |here|:
            
            foreach (|Type var| in expr) { }
            </summary>
            <remarks>
            Hit every iteration.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.AddForEachKeywordSequencePoint(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax,Microsoft.CodeAnalysis.CSharp.BoundStatement@)">
            <summary>
            Add sequence point |here|:
            
            |foreach| (Type var in expr) { }
            </summary>
            <remarks>
            Hit once, before looping begins.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitLockStatement(Microsoft.CodeAnalysis.CSharp.BoundLockStatement)">
            <summary>
            Lowers a lock statement to a try-finally block that calls Monitor.Enter and Monitor.Exit
            before and after the body, respectively.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteStringConcatenation(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
             <summary>
             The strategy of this rewrite is to do rewrite "locally".
             We analyze arguments of the concat in a shallow fasion assuming that 
             lowering and optimizations (including this one) is already done for the arguments.
             Based on the arguments we select the most appropriate pattern for the current node.
             
             NOTE: it is not guaranteed that the node that we chose will be the most optimal since we have only 
                   local information - i.e. we look at the arguments, but we do not know about siblings.
                   When we move to the parent, the node may be rewritten by this or some another optimization.
                   
             Example:
                 result = ( "abc" + "def" + null ?? expr1 + "moo" + "baz" ) + expr2
             
             Will rewrite into:
                 result = Concat("abcdef", expr2)
                 
             However there will be transient nodes like  Concat(expr1 + "moo")  that will not be present in the
             resulting tree.
            
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.FlattenConcatArg(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            digs into known concat operators and unwraps their arguments
            otherwise returns the expression as-is
            
            Generally we only need to recognize same node patterns that we create as a result of concatenation rewrite.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryFoldTwoConcatOperands(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            folds two concat operands into one expression if possible
            otherwise returns null
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.TryFoldTwoConcatConsts(Microsoft.CodeAnalysis.ConstantValue,Microsoft.CodeAnalysis.ConstantValue)">
            <summary>
            folds two concat constants into one if possible
            otherwise returns null.
            It is generally always possible to concat constants, unless resulting string would be too large.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteStringConcatenationOneExpr(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Strangely enough there is such a thing as unary concatenation and it must be rewritten.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteStringConcatInExpressionLambda(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BinaryOperatorKind,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Most of the above optimizations are not applicable in expression trees as the operator
            must stay a binary operator. We cannot do much beyond constant folding which is done in binder.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.ConvertConcatExprToStringIfPossible(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Checks whether the expression represents a boxing conversion of a special value type.
            If it does, it tries to return a string-based representation instead in order
            to avoid allocations.  If it can't, the original expression is returned.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.ConcatExprCanBeOptimizedWithToString(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Gets whether the type of an argument used in string concatenation can
            be optimized by first calling ToString on it before passing the argument
            to the String.Concat function.
            </summary>
            <param name="symbol">The type symbol of the argument.</param>
            <returns>
            true if ToString may be used; false if using ToString could lead to observable differences in behavior.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitUnaryOperator(Microsoft.CodeAnalysis.CSharp.BoundUnaryOperator)">
            <summary>
            This rewriter lowers pre-/post- increment/decrement operations (initially represented as
            unary operators). We use BoundSequenceExpressions because we need to capture the RHS of the
            assignment in a temp variable.
            </summary>
            <remarks>
            This rewriter assumes that it will be run before decimal rewriting (so that it does not have
            to lower decimal constants and operations) and call rewriting (so that it does not have to
            lower property accesses).
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitIncrementOperator(Microsoft.CodeAnalysis.CSharp.BoundIncrementOperator)">
            <summary>
            The rewrites are as follows: suppose the operand x is a variable of type X. The
            chosen increment/decrement operator is modelled as a static method on a type T,
            which takes a value of type T and returns the result of incrementing or decrementing
            that value.
            
            x++
                X temp = x
                x = (X)(T.Increment((T)temp))
                return temp
            x--
                X temp = x
                x = (X)(T.Decrement((T)temp))
                return temp
            ++x
                X temp = (X)(T.Increment((T)x))
                x = temp
                return temp
            --x
                X temp = (X)(T.Decrement((T)x))
                x = temp
                return temp
            
            Note: 
            Dev11 implements dynamic prefix operators incorrectly.
            
              result = ++x.P  is emitted as  result = SetMember{"P"}(t, UnaryOperation{Inc}(GetMember{"P"}(x)))
            
            The difference is that Dev11 relies on SetMember returning the same value as it was given as an argument.
            Failing to do so changes the semantics of ++/-- operator which is undesirable. We emit the same pattern for
            both dynamic and static operators.
               
            For example, we might have a class X with user-defined implicit conversions
            to and from short, but no user-defined increment or decrement operators. We
            would bind x++ as "X temp = x; x = (X)(short)((int)(short)temp + 1); return temp;"
            </summary>
            <param name="node">The unary operator expression representing the increment/decrement.</param>
            <returns>A bound sequence that uses a temp to acheive the correct side effects and return value.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.MakeRValue(Microsoft.CodeAnalysis.CSharp.BoundExpression)">
            <summary>
            Transform an expression from a form suitable as an lvalue to a form suitable as an rvalue.
            </summary>
            <param name="transformedExpression">The children of this node must already be lowered.</param>
            <returns>Fully lowered node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.BoundUsingStatement)">
            <summary>
            Rewrite a using statement into a try finally statement.  Two forms are possible:
              1) using (expr) stmt
              2) using (C c = expr) stmt
              
            The former is handled by RewriteExpressionUsingStatement and the latter is handled by
            RewriteDeclarationUsingStatement (called in a loop, once for each local declared).
            </summary>
            <remarks>
            It would be more in line with our usual pattern to rewrite using to try-finally
            in the ControlFlowRewriter, but if we don't do it here the BoundMultipleLocalDeclarations
            will be rewritten into a form that makes them harder to separate.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteExpressionUsingStatement(Microsoft.CodeAnalysis.CSharp.BoundUsingStatement,Microsoft.CodeAnalysis.CSharp.BoundBlock)">
            <summary>
            Lower "using (expression) statement" to a try-finally block.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LocalRewriter.RewriteDeclarationUsingStatement(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.BoundLocalDeclaration,Microsoft.CodeAnalysis.CSharp.BoundBlock,Microsoft.CodeAnalysis.CSharp.Conversion)">
            <summary>
            Lower "using (ResourceType resource = expression) statement" to a try-finally block.
            </summary>
            <remarks>
            Assumes that the local symbol will be declared (i.e. in the LocalsOpt array) of an enclosing block.
            Assumes that using statements with multiple locals have already been split up into multiple using statements.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LoweredDynamicOperation">
            <summary>
            The dynamic operation factories below return this struct so that the caller
            have the option of separating the call-site initialization from its invocation.
            
            Most callers just call <see cref="M:Microsoft.CodeAnalysis.CSharp.LoweredDynamicOperation.ToExpression"/> to get the combo but some (object and array initializers) 
            hoist all call-site initialization code and emit multiple invocations of the same site.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LoweredDynamicOperationFactory.CSharpBinderFlags">
            <summary>
            Corresponds to <see cref="T:Microsoft.CSharp.RuntimeBinder.CSharpBinderFlags"/>.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.LoweredDynamicOperationFactory.CSharpArgumentInfoFlags">
            <summary>
            Corresponds to <see cref="T:Microsoft.CSharp.RuntimeBinder.CSharpArgumentInfoFlags"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CapturedSymbolReplacement.Replacement(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.BoundExpression})">
            <summary>
            Rewrite the replacement expression for the hoisted local so all synthesized field are accessed as members
            of the appropriate frame.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.IteratorAndAsyncCaptureWalker">
            <summary>
            A walker that computes the set of local variables of an iterator/async
            method that must be hoisted to the state machine.
            </summary>
            <remarks>
            Data flow analysis is used to calculate the locals. At yield/await we mark all variables as "unassigned".
            When a read from an unassigned variables is reported we add the variable to the captured set.
            "this" parameter is captured if a reference to "this", "base" or an instance field is encountered.
            Variables used in finally also need to be captured if there is a yield in the corresponding try block.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._useFinalizerBookkeeping">
            <summary>
            True if we need to generate the code to do the bookkeeping so we can "finalize" the state machine
            by executing code from its current state through the enclosing finally blocks.  This is true for
            iterators and false for async.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.GenerateReturn(System.Boolean)">
            <summary>
            Generate return statements from the state machine method body.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.stateField">
            <summary>
            The "state" of the state machine that is the translation of the iterator method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.cachedState">
            <summary>
            Cached "state" of the state machine within the MoveNext method.  We work with a copy of
            the state to avoid shared mutable state between threads.  (Two threads can be executing
            in a Task's MoveNext method because an awaited task may complete after the awaiter has
            tested whether the subtask is complete but before the awaiter has returned)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._dispatches">
            <summary>
            For each distinct label, the set of states that need to be dispatched to that label.
            Note that there is a dispatch occurring at every try-finally statement, so this
            variable takes on a new set of values inside each try block.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.finalizerStateMap">
            <summary>
            A mapping from each state of the state machine to the new state that will be used to execute
            finally blocks in case the state machine is disposed.  The Dispose method computes the new state
            and then runs MoveNext.  Not used if !this.useFinalizerBookkeeping.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._hasFinalizerState">
            <summary>
            A try block might have no state (transitions) within it, in which case it does not need
            to have a state to represent finalization.  This flag tells us whether the current try
            block that we are within has a finalizer state.  Initially true as we have the (trivial)
            finalizer state of -1 at the top level.  Not used if !this.useFinalizerBookkeeping.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._currentFinalizerState">
            <summary>
            If hasFinalizerState is true, this is the state for finalization from anywhere in this
            try block.  Initially set to -1, representing the no-op finalization required at the top
            level.  Not used if !this.useFinalizerBookkeeping.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._lazyAvailableReusableHoistedFields">
            <summary>
            A pool of fields used to hoist locals. They appear in this set when not in scope,
            so that members of this set may be allocated to locals when the locals come into scope.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._nextHoistedFieldId">
            <summary>
            Fields allocated for temporary variables are given unique names distinguished by a number at the end.
            This counter ensures they are unique within a given translated method.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._emptyStructTypeCache">
            <summary>
            Used to enumerate the instance fields of a struct.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter._hoistedVariables">
            <summary>
            The set of local variables and parameters that were hoisted and need a proxy.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.PossibleIteratorScope(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol},System.Func{Microsoft.CodeAnalysis.CSharp.BoundStatement})">
            <summary>
            Translate a statement that declares a given set of locals.  Also allocates and frees hoisted temps as
            required for the translation.
            </summary>
            <param name="locals">The set of locals declared in the original version of this statement</param>
            <param name="wrapped">A delegate to return the translation of the body of this statement</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.MakeStateMachineScope(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.StateMachineFieldSymbol},Microsoft.CodeAnalysis.CSharp.BoundStatement)">
            <remarks>
            Must remain in sync with <see cref="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.TryUnwrapBoundStateMachineScope(Microsoft.CodeAnalysis.CSharp.BoundStatement@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.StateMachineFieldSymbol}@)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.TryUnwrapBoundStateMachineScope(Microsoft.CodeAnalysis.CSharp.BoundStatement@,System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.StateMachineFieldSymbol}@)">
            <remarks>
            Must remain in sync with <see cref="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.MakeStateMachineScope(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.StateMachineFieldSymbol},Microsoft.CodeAnalysis.CSharp.BoundStatement)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.MightContainReferences(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Might the given type be, or contain, managed references?  This is used to determine which
            fields allocated to temporaries should be cleared when the underlying variable goes out of scope, so
            that they do not cause unnecessary object retention.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.MethodToStateMachineRewriter.VisitTryStatement(Microsoft.CodeAnalysis.CSharp.BoundTryStatement)">
            <summary>
            The try statement is the most complex part of the state machine transformation.
            Since the CLR will not allow a 'goto' into the scope of a try statement, we must
            generate the dispatch to the state's label stepwise.  That is done by translating
            the try statements from the inside to the outside.  Within a try statement, we
            start with an empty dispatch table (representing the mapping from state numbers
            to labels).  During translation of the try statement's body, the dispatch table
            will be filled in with the data necessary to dispatch once we're inside the try
            block.  We generate that at the head of the translated try statement.  Then, we
            copy all of the states from that table into the table for the enclosing construct,
            but associate them with a label just before the translated try block.  That way
            the enclosing construct will generate the code necessary to get control into the
            try block for all of those states.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.StateMachineFieldSymbol">
            <summary>
            Represents a synthesized state machine field.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.PreserveInitialParameterValues">
            <summary>
            True if the initial values of locals in the rewritten method need to be preserved. (e.g. enumerable iterator methods)
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.GenerateControlFields">
            <summary>
            Add fields to the state machine class that control the state machine.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.InitializeStateMachine(Microsoft.CodeAnalysis.ArrayBuilder{Microsoft.CodeAnalysis.CSharp.BoundStatement},Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol)">
            <summary>
            Initialize the state machine class.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.GenerateStateMachineCreation(Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol)">
            <summary>
            Generate implementation-specific state machine initialization for the kickoff method body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.StateMachineRewriter.GenerateMethodImplementations">
            <summary>
            Generate implementation-specific state machine member method implementations.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedStateMachineMethod">
            <summary>
            State machine interface method implementation.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedStateMachineMoveNextMethod">
            <summary>
            Represents a state machine MoveNext method.
            Handles special behavior around inheriting some attributes from the original async/iterator method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedStateMachineDebuggerHiddenMethod">
            <summary>
            Represents a state machine method other than a MoveNext method.
            All such methods are considered debugger hidden. 
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SynthesizedSubmissionFields">
            <summary>
            Tracks synthesized fields that are needed in a submission being compiled.
            </summary>
            <remarks>
            For every other submission referenced by this submission we add a field, so that we can access members of the target submission.
            A field is also needed for the host object, if provided.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory">
            <summary>
            A helper class for synthesizing quantities of code.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.MissingPredefinedMember">
            <summary>
            Thrown by the bound node factory when there is a failure to synthesize code.
            An appropriate diagnostic is included that should be reported.  Currently
            the only diagnostic handled through this mechanism is a missing special/well-known
            member.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory._binder">
            <summary>
            A binder suitable for performing overload resolution to synthesize a call to a helper method.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.SyntheticBinderImpl">
            <summary>
            A binder used only for performing overload resolution of runtime helper methods.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag)">
            <summary>
            Create a bound node factory. Note that the use of the factory to get special or well-known members
            that do not exist will result in an exception of type <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.MissingPredefinedMember"/> being thrown.
            </summary>
            <param name="topLevelMethod">The top-level method that will contain the code</param>
            <param name="node">The syntax node to which generated code should be attributed</param>
            <param name="compilationState">The state of compilation of the enclosing type</param>
            <param name="diagnostics">A bag where any diagnostics should be output</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.#ctor(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.TypeCompilationState,Microsoft.CodeAnalysis.DiagnosticBag)">
            <param name="topLevelMethodOpt">The top-level method that will contain the code</param>
            <param name="currentClassOpt">The enclosing class</param>
            <param name="node">The syntax node to which generated code should be attributed</param>
            <param name="compilationState">The state of compilation of the enclosing type</param>
            <param name="diagnostics">A bag where any diagnostics should be output</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.WellKnownMember(Microsoft.CodeAnalysis.WellKnownMember,System.Boolean)">
            <summary>
            Get the symbol for a well-known member. The use of this method to get a well-known member
            that does not exist will result in an exception of type MissingPredefinedMember being thrown
            containing an appropriate diagnostic for the caller to report.
            </summary>
            <param name="wm">The desired well-known member</param>
            <param name="isOptional">If true, the method may return null for a missing member without an exception</param>
            <returns>A symbol for the well-known member, or null if it is missing and isOptions == true</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.SpecialMember(Microsoft.CodeAnalysis.SpecialMember)">
            <summary>
            Get the symbol for a special member. The use of this method to get a special member
            that does not exist will result in an exception of type MissingPredefinedMember being thrown
            containing an appropriate diagnostic for the caller to report.
            </summary>
            <param name="sm">The desired special member</param>
            <returns>A symbol for the special member.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.CheckSwitchSections(System.Collections.Immutable.ImmutableArray{Microsoft.CodeAnalysis.CSharp.BoundSwitchSection})">
            <summary>
            Check for (and assert that there are no) duplicate case labels in the switch.
            </summary>
            <param name="sections"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntheticBoundNodeFactory.StoreToTemp(Microsoft.CodeAnalysis.CSharp.BoundExpression,Microsoft.CodeAnalysis.CSharp.BoundAssignmentOperator@,Microsoft.CodeAnalysis.RefKind,Microsoft.CodeAnalysis.SynthesizedLocalKind,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Takes an expression and returns the bound local expression "temp" 
            and the bound assignment expression "temp = expr".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.UnmatchedGotoFinder">
            <summary>
            Compiles a list of all labels that are targeted by gotos within a
            node, but are not declared within the node.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender._newPosition">
            <summary>
            newPosition represents the position we are in the final SourceText.  As we consume and reuse
            nodes from the old tree we will update our position in the new text accordingly.
            Likewise, when we must lex tokens out of the new tree we will update as well.
            
            NOTE(cyrusn): We do not need an oldPosition because it is redundant given the
            oldTreeCursor.  The oldPosition is implicitly defined by the position of the cursor.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.ExtendToAffectedRange(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.Text.TextChangeRange)">
            <summary>
            Affected range of a change is the range within which nodes can be affected by a change
            and cannot be reused. Because of lookahead effective range of a change is larger than
            the change itself.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Blender.Cursor">
            <summary>
            THe cursor represents a location in the tree that we can move around to indicate where
            we are in the original tree as we're incrementally parsing.  When it is at a node or
            token, it can either move forward to that entity's next sibling.  It can also move down
            to a node's first child or first token.
            
            Once the cursor hits the end of file, it's done.  Note: the cursor will skip any other
            zero length nodes in the tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DirectiveParser.ParseErrorOrWarningDirective(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,System.Boolean)">
            <summary>
            An error/warning directive tells the compiler to indicate a syntactic error/warning
            at the current location.
            
            Format: #error Error message string
            Resulting message: from the first non-whitespace character after the directive
            keyword until the end of the directive (aka EOD) at the line break or EOF.
            Resulting span: [first non-whitespace char, EOD)
            
            Examples (pipes indicate span):
            #error |foo|
            #error  |foo|
            #error |foo |
            #error |foo baz|
            #error |//foo|
            #error |/*foo*/|
            #error |/*foo|
            </summary>
            <param name="hash">The '#' token.</param>
            <param name="keyword">The 'error' or 'warning' token.</param>
            <param name="isActive">True if the error/warning should be recorded.</param>
            <returns>An ErrorDirective or WarningDirective node.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.IsNonAsciiQuotationMark(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken)">
            <summary>
            These aren't acceptable in place of ASCII quotation marks in XML, 
            but we want to consume them (and produce an appropriate error) if
            they occur in a place where a quotation mark is legal.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefAttributeValue">
             <summary>
             ACASEY: This grammar is derived from the behavior and sources of the native compiler.
             Tokens start with underscores (I've cheated for _PredefinedTypeToken, which is not actually a
             SyntaxKind), "*" indicates "0 or more", "?" indicates "0 or 1", and parentheses are for grouping.
             
             Cref	 			= CrefType _DotToken CrefMember
             					| CrefType
             					| CrefMember
                                 | CrefFirstType _OpenParenToken CrefParameterList? _CloseParenToken
             CrefName			= _IdentifierToken (_LessThanToken _IdentifierToken (_CommaToken _IdentifierToken)* _GreaterThanToken)?
             CrefFirstType 		= ((_IdentifierToken _ColonColonToken)? CrefName) 
                                 | _PredefinedTypeToken
             CrefType 			= CrefFirstType (_DotToken CrefName)*
             CrefMember 			= CrefName (_OpenParenToken CrefParameterList? _CloseParenToken)?
             					| _ThisKeyword (_OpenBracketToken CrefParameterList _CloseBracketToken)?
             					| _OperatorKeyword _OperatorToken (_OpenParenToken CrefParameterList? _CloseParenToken)?
             					| (_ImplicitKeyword | _ExplicitKeyword) _OperatorKeyword CrefParameterType (_OpenParenToken CrefParameterList? _CloseParenToken)?
             CrefParameterList	= CrefParameter (_CommaToken CrefParameter)*
             CrefParameter		= (_RefKeyword | _OutKeyword)? CrefParameterType
             CrefParameterType	= CrefParameterType2 _QuestionToken? _AsteriskToken* (_OpenBracketToken _CommaToken* _CloseBracketToken)*
             CrefParameterType2 	= (((_IdentifierToken _ColonColonToken)? CrefParameterType3) | _PredefinedTypeToken) (_DotToken CrefParameterType3)*
             CrefParameterType3 	= _IdentifierToken (_LessThanToken CrefParameterType (_CommaToken CrefParameterType)* _GreaterThanToken)?
            
             NOTE: type parameters, not type arguments
             NOTE: the first production of Cref is preferred to the other two
             NOTE: pointer, array, and nullable types only work in parameters
             NOTE: CrefParameterType2 and CrefParameterType3 correspond to CrefType and CrefName, respectively.
             Since the only difference is that they accept non-identifier type arguments, this is accomplished
             using parameters on the parsing methods (rather than whole new methods).
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseMemberCref">
            <summary>
            Parse the custom cref syntax for a named member (method, property, etc),
            an indexer, an overloadable operator, or a user-defined conversion.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseNameMemberCref">
            <summary>
            Parse a named member (method, property, etc), with optional type
            parameters and regular parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseIndexerMemberCref">
            <summary>
            Parse an indexer member, with optional parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseOperatorMemberCref">
            <summary>
            Parse an overloadable operator, with optional parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseConversionOperatorMemberCref">
            <summary>
            Parse a user-defined conversion, with optional parameters.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefParameterList">
            <summary>
            Parse a parenthesized parameter list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseBracketedCrefParameterList">
            <summary>
            Parse a bracketed parameter list.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseBaseCrefParameterList(System.Boolean)">
            <summary>
            Parse the parameter list (if any) of a cref member (name, indexer, operator, or conversion).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.IsPossibleCrefParameter">
            <summary>
            True if the current token could be the beginning of a cref parameter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefParameter">
            <summary>
            Parse an element of a cref parameter list.
            </summary>
            <remarks>
            "ref" and "out" work, but "params", "this", and "__arglist" don't.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefName(System.Boolean)">
            <summary>
            Parse an identifier, optionally followed by an angle-bracketed list of type parameters.
            </summary>
            <param name="typeArgumentsMustBeIdentifiers">True to give an error when a non-identifier
            type argument is seen, false to accept.  No change in the shape of the tree.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefType(System.Boolean,System.Boolean)">
            <summary>
            Parse a type.  May include an alias, a predefined type, and/or a qualified name.
            </summary>
            <remarks>
            Pointer, nullable, or array types are only allowed if <paramref name="typeArgumentsMustBeIdentifiers"/> is false.
            Leaves a dot and a name unconsumed if the name is not followed by another dot
            and checkForMember is true.
            </remarks>
            <param name="typeArgumentsMustBeIdentifiers">True to give an error when a non-identifier
            type argument is seen, false to accept.  No change in the shape of the tree.</param>
            <param name="checkForMember">True means that the last name should not be consumed
            if it is followed by a parameter list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefTypeHelper(System.Boolean,System.Boolean)">
            <summary>
            Parse a type.  May include an alias, a predefined type, and/or a qualified name.
            </summary>
            <remarks>
            No pointer, nullable, or array types.
            Leaves a dot and a name unconsumed if the name is not followed by another dot
            and checkForMember is true.
            </remarks>
            <param name="typeArgumentsMustBeIdentifiers">True to give an error when a non-identifier
            type argument is seen, false to accept.  No change in the shape of the tree.</param>
            <param name="checkForMember">True means that the last name should not be consumed
            if it is followed by a parameter list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.ParseCrefTypeSuffix(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax)">
            <summary>
            Once the name part of a type (including type parameter/argument lists) is parsed,
            we need to consume ?, *, and rank specifiers.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.IsEndOfCrefAttribute">
            <summary>
            Ends at appropriate quotation mark, EOF, or EndOfDocumentationComment.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.InCref">
            <summary>
            Convenience method for checking the mode.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentParser.IsEndOfNameAttribute">
            <summary>
            Ends at appropriate quotation mark, EOF, or EndOfDocumentationComment.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentXmlTokens">
            <summary>
            Set of well-known SyntaxTokens commonly found within XML doc comments.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DocumentationCommentXmlTokens.LookupToken(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder)">
            <summary>
            Look up a well known SyntaxToken for a given XML element tag or attribute.
            This is a performance optimization to avoid creating duplicate tokens for the same content.
            </summary>
            <param name="text">The text of the tag or attribute.</param>
            <param name="leading">The leading trivia of the token.</param>
            <returns>The SyntaxToken representing the well-known tag or attribute or null if it's not well-known.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanExternAliasDirective">
            <summary>
            Returns true if the lookahead tokens compose extern alias directive.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseBlockAndExpressionBodiesWithSemicolon(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BlockSyntax@,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax@,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken@)">
            <summary>
            Parses any block or expression bodies that are present. Also parses
            the trailing semicolon if one is present.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.SkipBadListTokensWithExpectedKindHelper(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder,System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser,System.Boolean},System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser,System.Boolean},Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode@)">
            <remarks>
            WARNING: it is possible that "list" is really the underlying builder of a SeparateSyntaxListBuilder,
            so it is important that we not add anything to the list.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsTrueIdentifier">
            <summary>
            True if current identifier token is not really some contextual keyword
            </summary>
            <returns></returns>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.NotType">
            <summary>
            Definitely not a type name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.MustBeType">
            <summary>
            Definitely a type name: either a predefined type (int, string, etc.) or an array type name (ending with a bracket).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.GenericTypeOrMethod">
            <summary>
            Might be a generic (qualified) type name or a method name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.GenericTypeOrExpression">
            <summary>
            Might be a generic (qualified) type name or an expression or a method name.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.NonGenericTypeOrExpression">
            <summary>
            Might be a non-generic (qualified) type name or an expression.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.AliasQualifiedName">
            <summary>
            A type name with alias prefix (Alias::Name)
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.NullableType">
            <summary>
            Nullable type (ending with ?).
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ScanTypeFlags.PointerOrMultiplication">
            <summary>
            Might be a pointer type or a multiplication.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.ParseStatementNoDeclaration(System.Boolean)">
            <summary>
            Parses any statement but a declaration statement. Returns null if the lookahead looks like a declaration.
            </summary>
            <remarks>
            Variable declarations in global code are parsed as field declarations so we need to fallback if we encounter a declaration statement.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.IsPossibleTypedIdentifierStart(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,System.Boolean)">
            <returns>
            true if the current token can be the first token of a typed identifier (a type name followed by an identifier),
            false if it definitely can't be,
            null if we need to scan further to find out.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.Substring(System.String,System.Int32,System.Int32)">
            <summary>
            "Safe" substring using start and end positions rather than start and length.
            If things are out of bounds just returns the empty string. That should only
            be used by clients to assist in error recovery.
            <param name="s">original string</param>
            <param name="first">index of first character to be included</param>
            <param name="last">index of last character to be included</param>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LanguageParser.MakeStringToken(System.String,System.String,System.Boolean,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Take the given text and treat it as the contents of a string literal, returning a token for that.
            </summary>
            <param name="text">The text for the full string literal, including the quotes and contents</param>
            <param name="bodyText">The text for the string literal's contents, excluding surrounding quotes</param>
            <param name="isVerbatim">True if the string contents should be scanned using the rules for verbatim strings</param>
            <param name="kind">The token kind to be assigned to the resulting token</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanIdentifier_CrefSlowPath(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.TokenInfo@)">
            <summary>
            This method is essentially the same as ScanIdentifier_SlowPath,
            except that it can handle XML entities.  Since ScanIdentifier
            is hot code and since this method does extra work, it seem
            worthwhile to separate it from the common case.
            </summary>
            <param name="info"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanEndOfLine">
            <summary>
            Scans a new-line sequence (either a single new-line character or a CR-LF combo).
            </summary>
            <returns>A trivia node with the new-line text</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanWhitespace">
            <summary>
            Scans all of the whitespace (not new-lines) into a trivia node until it runs out.
            </summary>
            <returns>A trivia node with the whitespace text</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlToken">
            <summary>
            Lexer entry point for LexMode.XmlDocComment
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlElementTagToken">
            <summary>
            Lexer entry point for LexMode.XmlElementTag
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.IsXmlNameStartChar(System.Char)">
            <summary>
            Determines whether this Unicode character can start a XMLName.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.IsXmlNameChar(System.Char)">
            <summary>
            Determines if this Unicode character can be part of an XML Name.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlAttributeTextToken">
            <summary>
            Lexer entry point for LexMode.XmlAttributeText
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlCharacter">
            <summary>
            Lexer entry point for LexerMode.XmlCharacter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanXmlCharacter(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.TokenInfo@)">
            <summary>
            Scan a single XML character (or entity).  Assumes that leading trivia has already
            been consumed.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlCrefOrNameToken">
            <summary>
            Lexer entry point for LexerMode.XmlCrefQuote, LexerMode.XmlCrefDoubleQuote, 
            LexerMode.XmlNameQuote, and LexerMode.XmlNameDoubleQuote.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.ScanXmlCrefToken(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.TokenInfo@)">
            <summary>
            Scan a single cref attribute token.  Assumes that leading trivia has already
            been consumed.
            </summary>
            <remarks>
            Within this method, characters that are not XML meta-characters can be seamlessly
            replaced with the corresponding XML entities.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.AdvanceIfMatches(System.Char)">
            <summary>
            Given a character, advance the input if either the character or the
            corresponding XML entity appears next in the text window.
            </summary>
            <param name="ch"></param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InXmlCrefOrNameAttributeValue">
            <summary>
            Convenience property for determining whether we are currently lexing the
            value of a cref or name attribute.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InXmlNameAttributeValue">
            <summary>
            Convenience property for determining whether we are currently lexing the
            value of a name attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.AddCrefError(Microsoft.CodeAnalysis.CSharp.ErrorCode,System.Object[])">
            <summary>
            Diagnostics that occur within cref attributes need to be
            wrapped with ErrorCode.WRN_ErrorOverride.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.AddCrefError(Microsoft.CodeAnalysis.DiagnosticInfo)">
            <summary>
            Diagnostics that occur within cref attributes need to be
            wrapped with ErrorCode.WRN_ErrorOverride.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlCDataSectionTextToken">
            <summary>
            Lexer entry point for LexMode.XmlCDataSectionText
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlCommentTextToken">
            <summary>
            Lexer entry point for LexMode.XmlCommentText
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlProcessingInstructionTextToken">
            <summary>
            Lexer entry point for LexMode.XmlProcessingInstructionText
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlDocCommentLeadingTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder@)">
            <summary>
            Collects XML doc comment exterior trivia, and therefore is a no op unless we are in the Start or Exterior of an XML doc comment.
            </summary>
            <param name="trivia">List in which to collect the trivia</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.LexXmlWhitespaceAndNewLineTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxListBuilder@)">
            <summary>
            Collects whitespace and new line trivia for XML doc comments. Does not see XML doc comment exterior trivia, and is a no op unless we are in the interior.
            </summary>
            <param name="trivia">List in which to collect the trivia</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.RescanInterpolatedString(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax)">
            <summary>
            Turn a (parsed) interpolated string nonterminal into an interpolated string token.
            </summary>
            <param name="interpolatedString"></param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.Lexer.InterpolatedStringScanner.ScanInterpolatedStringLiteralHoleBalancedText(System.Char,System.Boolean,System.Int32@)">
            <summary>
            Scan past the hole inside an interpolated string literal, leaving the current character on the '}' (if any)
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow">
            <summary>
            Keeps a sliding buffer over the SourceText of a file for the lexer. Also
            provides the lexer with the ability to keep track of a current "lexeme"
            by leaving a marker and advancing ahead the offset. The lexer can then
            decide to "keep" the lexeme by erasing the marker, or abandon the current
            lexeme by moving the offset back to the marker.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.InvalidCharacter">
            <summary>
            In many cases, e.g. PeekChar, we need the ability to indicate that there are
            no characters left and we have reached the end of the stream, or some other
            invalid or not present character was asked for. Due to perf concerns, things
            like nullable or out variables are not viable. Instead we need to choose a
            char value which can never be legal.
            
            In .NET, all characters are represented in 16 bits using the UTF-16 encoding.
            Fortunately for us, there are a variety of different bit patterns which
            are *not* legal UTF-16 characters. 0xffff (char.MaxValue) is one of these
            characters -- a legal Unicode code point, but not a legal UTF-16 bit pattern.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.Position">
            <summary>
            The current absolute position in the text file.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.Offset">
            <summary>
            The current offset inside the window (relative to the window start).
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.CharacterWindow">
            <summary>
            The buffer backing the current window.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.LexemeRelativeStart">
            <summary>
            Returns the start of the current lexeme relative to the window start.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.CharacterWindowCount">
            <summary>
            Number of characters in the character window.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.LexemeStartPosition">
            <summary>
            The absolute position of the start of the current lexeme in the given
            SourceText.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.Width">
            <summary>
            The number of characters in the current lexeme.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.Start">
            <summary>
            Start parsing a new lexeme.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.IsReallyAtEnd">
            <summary>
            After reading <see cref="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.InvalidCharacter"/>, a consumer can determine
            if the InvalidCharacter was in the user's source or a sentinel.
            
            Comments and string literals are allowed to contain any Unicode character.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.AdvanceChar">
            <summary>
            Advance the current position by one. No guarantee that this
            position is valid.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.AdvanceChar(System.Int32)">
            <summary>
            Advance the current position by n. No guarantee that this position
            is valid.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.NextChar">
            <summary>
            Grab the next character and advance the position.
            </summary>
            <returns>
            The next character, <see cref="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.InvalidCharacter" /> if there were no characters 
            remaining.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.PeekChar">
            <summary>
            Gets the next character if there are any characters in the 
            SourceText. May advance the window if we are at the end.
            </summary>
            <returns>
            The next character if any are available. InvalidCharacterSentinal otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.PeekChar(System.Int32)">
            <summary>
            Gets the character at the given offset to the current position if
            the position is valid within the SourceText.
            </summary>
            <returns>
            The next character if any are available. InvalidCharacterSentinal otherwise.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.TryScanXmlEntity(System.Char@,System.Char@)">
            <summary>
            Given that the next character is an ampersand ('&amp;'), attempt to interpret the
            following characters as an XML entity.  On success, populate the out parameters
            with the low and high UTF-16 surrogates for the character represented by the
            entity.
            </summary>
            <param name="ch">e.g. '&lt;' for &amp;lt;.</param>
            <param name="surrogate">e.g. '\uDC00' for &amp;#x10000; (ch == '\uD800').</param>
            <returns>True if a valid XML entity was consumed.</returns>
            <remarks>
            NOTE: Always advances, even on failure.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SlidingTextWindow.AdvanceIfMatches(System.String)">
            <summary>
            If the next characters in the window match the given string,
            then advance past those characters.  Otherwise, do nothing.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactoryContext">
            <summary>
            Because syntax nodes need to be constructed with context information - to allow us to 
            determine whether or not they can be reused during incremental parsing - the syntax
            factory needs a view of some internal parser state.
            </summary>
            <remarks>
            Read-only outside SyntaxParser (not enforced for perf reasons).
            Reference type so that the factory stays up-to-date.
            </remarks>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactoryContext.IsInAsync">
            <summary>
            If a method goes from async to non-async, or vice versa, then every occurrence of "await"
            within the method (but not within a lambda) needs to be reinterpreted, to determine whether
            it is a keyword or an identifier.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactoryContext.IsInQuery">
            <summary>
            If the end of a query expression statement is commented out, then the following statement may
            appear to be part of the query.  When this occurs, identifiers within the following statement
            may need to be reinterpreted as query keywords.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.IsInteractive">
            <summary>
            Interactive code - global statements, member declarations and expressions allowed.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.IsScript">
            <summary>
            Script - global statements and member declarations allowed, but not expressions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.AddSkippedSyntax(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode,System.Boolean)">
            <summary>
            Converts skippedSyntax node into tokens and adds these as trivia on the target token.
            Also adds the first error (in depth-first preorder) found in the skipped syntax tree to the target token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.FindOffset(Microsoft.CodeAnalysis.GreenNode,Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode,System.Int32@)">
            <summary>
            This function searches for the given location node within the subtree rooted at root node. 
            If it finds it, the function computes the offset span of that child node within the root and returns true, 
            otherwise it returns false.
            </summary>
            <param name="root">Root node</param>
            <param name="location">Node to search in the subtree rooted at root node</param>
            <param name="offset">Offset of the location node within the subtree rooted at child</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxParser.CheckFeatureAvailability``1(``0,Microsoft.CodeAnalysis.CSharp.MessageID,System.Boolean)">
            <remarks>
            NOTE: we are specifically diverging from dev11 to improve the user experience.
            Since treating the "async" keyword as an identifier in older language
            versions can never result in a correct program, we instead accept it as a
            keyword regardless of the language version and produce an error if the version
            is insufficient.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax">
            <summary>Class which represents the syntax node for identifier name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IdentifierNameSyntax.Identifier">
            <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SeparatedSyntaxList`1.GetSeparator(System.Int32)">
            <summary>
            Gets the separator at the given index in this list.
            </summary>
            <param name="index">The index.</param>
            <returns></returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SeparatedSyntaxListBuilder`1.UnderlyingBuilder">
            <summary>
            WARN WARN WARN: This should be used with extreme caution - the underlying builder does
            not give any indication that it is from a separated syntax list but the constraints
            (node, token, node, token, ...) should still be maintained.
            </summary>
            <remarks>
            In order to avoid creating a separate pool of SeparatedSyntaxListBuilders, we expose
            our underlying SyntaxListBuilder to SyntaxListPool.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxList.WithLotsOfChildren.FindSlotIndexContainingOffset(System.Int32)">
            <summary>
            Find the slot that contains the given offset.
            </summary>
            <param name="offset">The target offset. Must be between 0 and <see cref="P:Microsoft.CodeAnalysis.GreenNode.FullWidth"/>.</param>
            <returns>The slot index of the slot containing the given offset.</returns>
            <remarks>
            This implementation uses a binary search to find the first slot that contains
            the given offset.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode.EnumerateNodes">
            <summary>
            Enumerates all nodes of the tree rooted by this node (including this node).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode.SetFactoryContext(Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxFactoryContext)">
            <summary>
            Should only be called during construction.
            </summary>
            <remarks>
            This should probably be an extra constructor parameter, but we don't need more constructor overloads.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CSharpSyntaxNode.GetStructure(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Gets the syntax node represented the structure of this trivia, if any. The HasStructure property can be used to 
            determine if this trivia has structure.
            </summary>
            <returns>
            A CSharpSyntaxNode derived from StructuredTriviaSyntax, with the structured view of this trivia node. 
            If this trivia node does not have structure, returns null.
            </returns>
            <remarks>
            Some types of trivia have structure that can be accessed as additional syntax nodes.
            These forms of trivia include: 
              directives, where the structure describes the structure of the directive.
              documentation comments, where the structure describes the XML structure of the comment.
              skipped tokens, where the structure describes the tokens that were skipped by the parser.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GreenStats">
            <summary>
            Provides caching functionality for green nonterminals with up to 3 children.
            Example:
                When constructing a node with given kind, flags, child1 and child2, we can look up 
                in the cache whether we already have a node that contains same kind, flags, 
                child1 and child2 and use that.
                
                For the purpose of children comparison, reference equality is used as a much cheaper 
                alternative to the structural/recursive equality. This implies that in order to de-duplicate
                a node to a cache node, the children of two nodes must be already de-duplicated.     
                When adding a node to the cache we verify that cache does contain node's children,
                since otherwise there is no reason for the node to be used.
                Tokens/nulls are for this purpose considered deduplicated. Indeed most of the tokens
                are deduplicated via quick-scanner caching, so we just assume they all are.
                
                As a result of above, "fat" nodes with 4 or more children or their recursive parents
                will never be in the cache. This naturally limits the typical single cache item to be 
                a relatively simple expression. We do not want the cache to be completely unbounded 
                on the item size. 
                While it still may be possible to store a gigantic nested binary expression, 
                it should be a rare occurrence.
                
                We only consider "normal" nodes to be cacheable. 
                Nodes with diagnostics/annotations/directives/skipped, etc... have more complicated identity 
                and are not likely to be repetitive.
                
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SyntaxToken.ToString">
            <summary>
            Returns the string representation of this token, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this token, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameSyntax">
            <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax">
            <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleNameSyntax.Identifier">
            <summary>SyntaxToken representing the identifier of the simple name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedNameSyntax">
            <summary>Class which represents the syntax node for qualified name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedNameSyntax.Left">
            <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedNameSyntax.DotToken">
            <summary>SyntaxToken representing the dot.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedNameSyntax.Right">
            <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GenericNameSyntax">
            <summary>Class which represents the syntax node for generic name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GenericNameSyntax.Identifier">
            <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GenericNameSyntax.TypeArgumentList">
            <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax">
            <summary>Class which represents the syntax node for type argument list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax.LessThanToken">
            <summary>SyntaxToken representing less than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeArgumentListSyntax.GreaterThanToken">
            <summary>SyntaxToken representing greater than.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AliasQualifiedNameSyntax">
            <summary>Class which represents the syntax node for alias qualified name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AliasQualifiedNameSyntax.Alias">
            <summary>IdentifierNameSyntax node representing the name of the alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AliasQualifiedNameSyntax.ColonColonToken">
            <summary>SyntaxToken representing colon colon.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AliasQualifiedNameSyntax.Name">
            <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeSyntax">
            <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PredefinedTypeSyntax">
            <summary>Class which represents the syntax node for predefined types.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PredefinedTypeSyntax.Keyword">
            <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayTypeSyntax">
            <summary>Class which represents the syntax node for the array type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element of the array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayTypeSyntax.RankSpecifiers">
            <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PointerTypeSyntax">
            <summary>Class which represents the syntax node for pointer type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PointerTypeSyntax.ElementType">
            <summary>TypeSyntax node that represents the element type of the pointer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PointerTypeSyntax.AsteriskToken">
            <summary>SyntaxToken representing the asterisk.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NullableTypeSyntax">
            <summary>Class which represents the syntax node for a nullable type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NullableTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NullableTypeSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedTypeArgumentSyntax">
            <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedTypeArgumentSyntax.OmittedTypeArgumentToken">
            <summary>SyntaxToken representing the omitted type argument.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExpressionSyntax">
            <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PrefixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for prefix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PrefixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PrefixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AwaitExpressionSyntax">
            <summary>Class which represents the syntax node for an "await" expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AwaitExpressionSyntax.AwaitKeyword">
            <summary>SyntaxToken representing the kind "await" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AwaitExpressionSyntax.Expression">
            <summary>ExpressionSyntax representing the operand of the "await" operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PostfixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for postfix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PostfixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PostfixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberAccessExpressionSyntax">
            <summary>Class which represents the syntax node for member access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberAccessExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax">
            <summary>Class which represents the syntax node for conditional access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalAccessExpressionSyntax.WhenNotNull">
            <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberBindingExpressionSyntax">
            <summary>Class which represents the syntax node for member binding expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberBindingExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing dot.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberBindingExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being bound to.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementBindingExpressionSyntax">
            <summary>Class which represents the syntax node for element binding expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementBindingExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitElementAccessSyntax">
            <summary>Class which represents the syntax node for implicit element access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitElementAccessSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BinaryExpressionSyntax">
            <summary>Class which represents an expression that has a binary operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BinaryExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BinaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the binary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BinaryExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AssignmentExpressionSyntax">
            <summary>Class which represents an expression that has an assignment operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AssignmentExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AssignmentExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the assignment expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AssignmentExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax">
            <summary>Class which represents the syntax node for conditional expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax.Condition">
            <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax.WhenTrue">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConditionalExpressionSyntax.WhenFalse">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InstanceExpressionSyntax">
            <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ThisExpressionSyntax">
            <summary>Class which represents the syntax node for a this expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ThisExpressionSyntax.Token">
            <summary>SyntaxToken representing the this keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseExpressionSyntax">
            <summary>Class which represents the syntax node for a base expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseExpressionSyntax.Token">
            <summary>SyntaxToken representing the base keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LiteralExpressionSyntax">
            <summary>Class which represents the syntax node for a literal expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LiteralExpressionSyntax.Token">
            <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax">
            <summary>Class which represents the syntax node for MakeRef expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the MakeRefKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MakeRefExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax">
            <summary>Class which represents the syntax node for RefType expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefTypeKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefTypeExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax">
            <summary>Class which represents the syntax node for RefValue expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefValueKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.Expression">
            <summary>Typed reference expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.Comma">
            <summary>Comma separating the arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.Type">
            <summary>The type of the value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.RefValueExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax">
            <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CheckedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax">
            <summary>Class which represents the syntax node for Default expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the DefaultKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax">
            <summary>Class which represents the syntax node for TypeOf expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the TypeOfKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax.Type">
            <summary>The expression to return type of.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax">
            <summary>Class which represents the syntax node for SizeOf expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the SizeOfKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SizeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InvocationExpressionSyntax">
            <summary>Class which represents the syntax node for invocation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InvocationExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InvocationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementAccessExpressionSyntax">
            <summary>Class which represents the syntax node for element access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElementAccessExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseArgumentListSyntax">
            <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax">
            <summary>Class which represents the syntax node for the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentListSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax">
            <summary>Class which represents the syntax node for bracketed argument list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax.OpenBracketToken">
            <summary>SyntaxToken representing open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedArgumentListSyntax.CloseBracketToken">
            <summary>SyntaxToken representing close bracket.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax">
            <summary>Class which represents the syntax node for argument.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax.NameColon">
            <summary>NameColonSyntax node representing the optional name arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax.RefOrOutKeyword">
            <summary>SyntaxToken representing the optional ref or out keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArgumentSyntax.Expression">
            <summary>ExpressionSyntax node representing the argument.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax">
            <summary>Class which represents the syntax node for name colon syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax.Name">
            <summary>IdentifierNameSyntax representing the identifer name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameColonSyntax.ColonToken">
            <summary>SyntaxToken representing colon.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax">
            <summary>Class which represents the syntax node for cast expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type the expression is being casted to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CastExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousFunctionExpressionSyntax">
            <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousFunctionExpressionSyntax.AsyncKeyword">
            <summary>Gets the "async" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousFunctionExpressionSyntax.Body">
            <summary>ExpressionSyntax or BlockSyntax representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous method expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax.AsyncKeyword">
            <summary>Gets the "async" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax.DelegateKeyword">
            <summary>SyntaxToken representing the delegate keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax.ParameterList">
            <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousMethodExpressionSyntax.Body">
            <summary>BlockSyntax node representing the body of the anonymous method.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LambdaExpressionSyntax">
            <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for a simple lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax.AsyncKeyword">
            <summary>Gets the "async" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax.Parameter">
            <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SimpleLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax.AsyncKeyword">
            <summary>Gets the "async" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax.ParameterList">
            <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParenthesizedLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax">
            <summary>Class which represents the syntax node for initializer expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax.Expressions">
            <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InitializerExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax.Type">
            <summary>TypeSyntax representing the type of the object being created.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectMemberDeclaratorSyntax.NameEquals">
            <summary>NameEqualsSyntax representing the optional name of the member being initialized.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectMemberDeclaratorSyntax.Expression">
            <summary>ExpressionSyntax representing the value the member is initialized with.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax.Initializers">
            <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AnonymousObjectCreationExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayCreationExpressionSyntax.Type">
            <summary>ArrayTypeSyntax node representing the type of the array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax.OpenBracketToken">
            <summary>SyntaxToken representing the open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax.Commas">
            <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax.CloseBracketToken">
            <summary>SyntaxToken representing the close bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ImplicitArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StackAllocArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StackAllocArrayCreationExpressionSyntax.StackAllocKeyword">
            <summary>SyntaxToken representing the stackalloc keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StackAllocArrayCreationExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FromClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LetClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.JoinIntoClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QueryContinuationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedArraySizeExpressionSyntax">
            <summary>Class which represents a placeholder in an array size list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OmittedArraySizeExpressionSyntax.OmittedArraySizeExpressionToken">
            <summary>SyntaxToken representing the omitted array size expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax.StringStartToken">
            <summary>The first part of an interpolated string, $" or $@"</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax.Contents">
            <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringExpressionSyntax.StringEndToken">
            <summary>The closing quote of the interpolated string.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolatedStringTextSyntax.TextToken">
            <summary>The text contents of a part of the interpolated string.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterpolationFormatClauseSyntax.FormatStringToken">
            <summary>The text contents of the format specifier for an interpolation.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StatementSyntax">
            <summary>Represents the base class for all statements syntax classes.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LocalDeclarationStatementSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.VariableDeclaratorSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LabeledStatementSyntax">
            <summary>Represents a labeled statement syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LabeledStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.LabeledStatementSyntax.ColonToken">
            <summary>Gets a SyntaxToken that represents the colon succeeding the statement's label.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax">
            <summary>
            Represents a goto statement syntax
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax.GotoKeyword">
            <summary>
            Gets a SyntaxToken that represents the goto keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax.CaseOrDefaultKeyword">
            <summary>
            Gets a SyntaxToken that represents the case or default keywords if any exists.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax.Expression">
            <summary>
            Gets a constant expression for a goto case statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.GotoStatementSyntax.SemicolonToken">
            <summary>
            Gets a SyntaxToken that represents the semi-colon at the end of the statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ForEachStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax">
            <summary>
            Represents an if statement syntax.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.IfKeyword">
            <summary>
            Gets a SyntaxToken that represents the if keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.Condition">
            <summary>
            Gets an ExpressionSyntax that represents the condition of the if statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.Statement">
            <summary>
            Gets a StatementSyntax the represents the statement to be executed when the condition is true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IfStatementSyntax.Else">
            <summary>
            Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseClauseSyntax">
            <summary>Represents an else statement syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ElseClauseSyntax.ElseKeyword">
            <summary>
            Gets a syntax token
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax">
            <summary>Represents a switch statement syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.SwitchKeyword">
            <summary>
            Gets a SyntaxToken that represents the switch keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.Expression">
            <summary>
            Gets an ExpressionSyntax representing the expression of the switch statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis succeeding the switch expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.OpenBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces preceding the switch sections.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.Sections">
            <summary>
            Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchStatementSyntax.CloseBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces succeeding the switch sections.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchSectionSyntax">
            <summary>Represents a switch section syntax of a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchSectionSyntax.Labels">
            <summary>
            Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchSectionSyntax.Statements">
            <summary>
            Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchLabelSyntax">
            <summary>Represents a switch label within a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchLabelSyntax.Keyword">
            <summary>
            Gets a SyntaxToken that represents a case or default keywords that belongs to a switch label.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.SwitchLabelSyntax.ColonToken">
            <summary>
            Gets a SyntaxToken that represents the colon that terminates the switch label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CaseSwitchLabelSyntax">
            <summary>Represents a case label within a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CaseSwitchLabelSyntax.Keyword">
            <summary>Gets the case keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CaseSwitchLabelSyntax.Value">
            <summary>
            Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultSwitchLabelSyntax">
            <summary>Represents a default label within a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DefaultSwitchLabelSyntax.Keyword">
            <summary>Gets the default keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CompilationUnitSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax">
            <summary>
            Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax.ExternKeyword">
            <summary>SyntaxToken representing the extern keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax.AliasKeyword">
            <summary>SyntaxToken representing the alias keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ExternAliasDirectiveSyntax.SemicolonToken">
            <summary>SyntaxToken representing the semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberDeclarationSyntax">
            <summary>Member declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NamespaceDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax">
            <summary>Class representing one or more attributes applied to a language construct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax">
            <summary>Class representing what language construct an attribute targets.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeTargetSpecifierSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeSyntax">
            <summary>Attribute syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeSyntax.Name">
            <summary>Gets the name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax">
            <summary>Attribute argument list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax.Arguments">
            <summary>Gets the arguments syntax list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentSyntax">
            <summary>Attribute argument syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AttributeArgumentSyntax.Expression">
            <summary>Gets the expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax">
            <summary>Class representing an identifier name followed by an equals token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameEqualsSyntax.Name">
            <summary>Gets the identifier name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax">
            <summary>Type parameter list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax.LessThanToken">
            <summary>Gets the &lt; token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterListSyntax.GreaterThanToken">
            <summary>Gets the &gt; token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterSyntax">
            <summary>Type parameter syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax">
            <summary>Base class for type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.BaseList">
            <summary>Gets the base type list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.OpenBraceToken">
            <summary>Gets the open brace token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.CloseBraceToken">
            <summary>Gets the close brace token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeDeclarationSyntax">
            <summary>Base class for type declaration syntax (class, struct, interface).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeDeclarationSyntax.Keyword">
            <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeDeclarationSyntax.ConstraintClauses">
            <summary>Gets the type constraint list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeDeclarationSyntax.Members">
            <summary>Gets the member declarations.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassDeclarationSyntax">
            <summary>Class type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassDeclarationSyntax.Keyword">
            <summary>Gets the class keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StructDeclarationSyntax">
            <summary>Struct type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.StructDeclarationSyntax.Keyword">
            <summary>Gets the struct keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterfaceDeclarationSyntax">
            <summary>Interface type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.InterfaceDeclarationSyntax.Keyword">
            <summary>Gets the interface keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax">
            <summary>Enum type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax.EnumKeyword">
            <summary>Gets the enum keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax.Members">
            <summary>Gets the members declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax">
            <summary>Delegate declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.DelegateKeyword">
            <summary>Gets the "delegate" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DelegateDeclarationSyntax.SemicolonToken">
            <summary>Gets the semicolon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumMemberDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EnumMemberDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax">
            <summary>Base list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseListSyntax.Types">
            <summary>Gets the base type references.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseTypeSyntax">
            <summary>Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax">
            <summary>Type parameter constraint clause.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax.Name">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintClauseSyntax.Constraints">
            <summary>Gets the constraints list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeParameterConstraintSyntax">
            <summary>Base type for type parameter constraint syntax.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax">
            <summary>Constructor constraint syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax.NewKeyword">
            <summary>Gets the "new" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax.OpenParenToken">
            <summary>Gets the open paren keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorConstraintSyntax.CloseParenToken">
            <summary>Gets the close paren keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassOrStructConstraintSyntax">
            <summary>Base type for class or struct constraint syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ClassOrStructConstraintSyntax.ClassOrStructKeyword">
            <summary>Gets the constraint keyword ("class" or "struct").</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeConstraintSyntax">
            <summary>Type constraint syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeConstraintSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseFieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseFieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.FieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EventFieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EventFieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseMethodDeclarationSyntax">
            <summary>Base type for method declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseMethodDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseMethodDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseMethodDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseMethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax">
            <summary>Method declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax.ReturnType">
            <summary>Gets the return type syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax">
            <summary>Operator declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorDeclarationSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax">
            <summary>Conversion operator declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax.ImplicitOrExplicitKeyword">
            <summary>Gets the "implicit" or "explicit" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax.Type">
            <summary>Gets the type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorDeclarationSyntax">
            <summary>Constructor declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorInitializerSyntax">
            <summary>Constructor initializer syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorInitializerSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConstructorInitializerSyntax.ThisOrBaseKeyword">
            <summary>Gets the "this" or "base" keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax">
            <summary>Destructor declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax.TildeToken">
            <summary>Gets the tilde token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.DestructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BasePropertyDeclarationSyntax">
            <summary>Base type for property declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BasePropertyDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BasePropertyDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BasePropertyDeclarationSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BasePropertyDeclarationSyntax.ExplicitInterfaceSpecifier">
            <summary>Gets the optional explicit interface specifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.PropertyDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ArrowExpressionClauseSyntax">
            <summary>The syntax for the expression body of an expression-bodied member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.EventDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IndexerDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax.Keyword">
            <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax.Body">
            <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.AccessorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseParameterListSyntax">
            <summary>Base type for parameter list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax">
            <summary>Parameter list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedParameterListSyntax">
            <summary>Parameter list syntax with surrounding brackets.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax">
            <summary>Parameter syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IncompleteMemberSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IncompleteMemberSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefSyntax">
            <summary>
            A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
            For example, the M in &lt;see cref="M" /&gt;.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.TypeCrefSyntax">
            <summary>
            A symbol reference that definitely refers to a type.
            For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.QualifiedCrefSyntax">
            <summary>
            A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
            For example, cref="System.String.ToString()".
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.MemberCrefSyntax">
            <summary>
            The unqualified part of a CrefSyntax.
            For example, "ToString()" in "object.ToString()".
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.NameMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,
            with an optional type parameter list) and an optional parameter list.
            For example, "M", "M&lt;T&gt;" or "M(int)".
            Also, "A::B()" or "string()".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.IndexerMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by a this keyword and an optional parameter list.
            For example, "this" or "this[int]".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
            For example, "operator +" or "operator -[int]".
            NOTE: the operator must be overloadable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.OperatorMemberCrefSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.ConversionOperatorMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.
            For example, "implicit operator int" or "explicit operator MyType(int)".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseCrefParameterListSyntax">
            <summary>
            A list of cref parameters with surrounding punctuation.
            Unlike regular parameters, cref parameters do not have names.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.BaseCrefParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax">
            <summary>
            A parenthesized list of cref parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefBracketedParameterListSyntax">
            <summary>
            A bracketed list of cref parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefBracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefBracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InternalSyntax.CrefParameterSyntax">
            <summary>
            An element of a BaseCrefParameterListSyntax.
            Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
            there is no name and there are no attributes or other modifiers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax">
            <summary>Class which represents the syntax node for alias qualified name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax.Alias">
            <summary>IdentifierNameSyntax node representing the name of the alias</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax.ColonColonToken">
            <summary>SyntaxToken representing colon colon.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax.Name">
            <summary>SimpleNameSyntax node representing the name that is being alias qualified.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax">
            <summary>Attribute syntax.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.GetErrorDisplayName">
            <summary>
            Return the name used in syntax for the attribute. This is typically the class
            name without the "Attribute" suffix. (For certain diagnostics, the native
            compiler uses the attribute name from syntax rather than the class name.)
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax.Name">
            <summary>Gets the name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax">
            <summary>Class representing what language construct an attribute targets.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.GetReferenceDirectives">
            <summary>
            Returns #r directives specified in the compilation.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CSharpLineDirectiveMap">
            <summary>
            Adds C# specific parts to the line directive map.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax">
            <summary>Delegate declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.DelegateKeyword">
            <summary>Gets the "delegate" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax.SemicolonToken">
            <summary>Gets the semicolon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax.AllowsAnyExpression">
            <summary>
            Returns true if the <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax.Expression"/> property is allowed by the rules of the
            language to be an arbitrary expression, not just a statement expression.
            </summary>
            <remarks>
            True if, for example, this expression statement represents the last expression statement
            of the interactive top-level code.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax">
            <summary>Class which represents the syntax node for generic name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax.Identifier">
            <summary>SyntaxToken representing the name of the identifier of the generic name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax.TypeArgumentList">
            <summary>TypeArgumentListSyntax node representing the list of type arguments of the generic name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous method expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax.AsyncKeyword">
            <summary>Gets the "async" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax.DelegateKeyword">
            <summary>SyntaxToken representing the delegate keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax.ParameterList">
            <summary>List of parameters of the anonymous method expression, or null if there no parameters are specified.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax.Body">
            <summary>BlockSyntax node representing the body of the anonymous method.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition">
            <summary>
            This class contains a variety of helper methods for determining whether a
            position is within the scope (and not just the span) of a node.  In general,
            general, the scope extends from the first token up to, but not including,
            the last token. For example, the open brace of a block is within the scope
            of the block, but the close brace is not.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInBlock(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>
            A position is considered to be inside a block if it is on or after
            the open brace and strictly before the close brace.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInBody(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)">
            <summary>
            A position is inside a property body only if it is inside an expression body.
            All block bodies for properties are part of the accessor declaration (a type
            of BaseMethodDeclaration), not the property declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInBody(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax)">
            <summary>
            A position is inside a property body only if it is inside an expression body.
            All block bodies for properties are part of the accessor declaration (a type
            of BaseMethodDeclaration), not the property declaration.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInBody(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax)">
             <summary>
             A position is inside a body if it is inside the block or expression
             body. 
            
             A position is considered to be inside a block if it is on or after
             the open brace and strictly before the close brace. A position is
             considered to be inside an expression body if it is on or after
             the '=>' and strictly before the semicolon.
             </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsBeforeToken(System.Int32,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Returns true if position is within the given node and before the first excluded token.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInStatementScope(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <remarks>
            Used to determine whether it would be appropriate to use the binder for the statement (if any).
            Not used to determine whether the position is syntactically within the statement.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInCatchBlockScope(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax)">
            <remarks>
            Used to determine whether it would be appropriate to use the binder for the statement (if any).
            Not used to determine whether the position is syntactically within the statement.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.LookupPosition.IsInCatchFilterScope(System.Int32,Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax)">
            <remarks>
            Used to determine whether it would be appropriate to use the binder for the statement (if any).
            Not used to determine whether the position is syntactically within the statement.
            </remarks>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax">
            <summary>Method declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.ReturnType">
            <summary>Gets the return type syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.ConstraintClauses">
            <summary>Gets the constraint clause list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax">
            <summary>Provides the base class from which the classes that represent name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax.GetUnqualifiedName">
            <summary>
            Returns the unqualified (right-most) part of a qualified or alias-qualified name, or the name itself if already unqualified. 
            </summary>
            <returns>The unqualified (right-most) part of a qualified or alias-qualified name, or the name itself if already unqualified.
            If called on an instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax"/> returns the value of the <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax.Name"/> property.
            If called on an instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax"/> returns the value of the <see cref="P:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Right"/> property.
            If called on an instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax"/> returns the instance itself.
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax.GetAliasQualifierOpt">
            <remarks>
            This inspection is entirely syntactic.  We are not trying to find the alias corresponding to the assembly symbol
            containing the explicitly implemented interface symbol - there may be more than one.  We just want to know
            how the name was qualified in source so that we can make a similar qualification (for uniqueness purposes).
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax">
            <summary>Parameter list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax">
            <summary>Parameter syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax">
            <summary>Class which represents the syntax node for qualified name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Left">
            <summary>NameSyntax node representing the name on the left side of the dot token of the qualified name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.DotToken">
            <summary>SyntaxToken representing the dot.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax.Right">
            <summary>SimpleNameSyntax node representing the name on the right side of the dot token of the qualified name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax">
            <summary>Provides the base class from which the classes that represent simple name syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax.Identifier">
            <summary>SyntaxToken representing the identifier of the simple name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax">
            <summary>
            It's a non terminal Trivia CSharpSyntaxNode that has a tree underneath it.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax.ParentTrivia">
            <summary>
            Get parent trivia.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax">
            <summary>Base class for type declaration syntax (class, struct, interface).</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax.Keyword">
            <summary>Gets the type keyword token ("class", "struct", "interface").</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax.ConstraintClauses">
            <summary>Gets the type constraint list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeDeclarationSyntax.Members">
            <summary>Gets the member declarations.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax">
            <summary>Provides the base class from which the classes that represent type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax">
            <summary>Class which represents the syntax node for identifier name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax.Identifier">
            <summary>SyntaxToken representing the keyword for the kind of the identifier name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax">
            <summary>Class which represents the syntax node for type argument list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax.LessThanToken">
            <summary>SyntaxToken representing less than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of TypeSyntax node representing the type arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax.GreaterThanToken">
            <summary>SyntaxToken representing greater than.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax">
            <summary>Class which represents the syntax node for predefined types.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax.Keyword">
            <summary>SyntaxToken which represents the keyword corresponding to the predefined type.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax">
            <summary>Class which represents the syntax node for the array type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element of the array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax.RankSpecifiers">
            <summary>SyntaxList of ArrayRankSpecifierSyntax nodes representing the list of rank specifiers for the array.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax">
            <summary>Class which represents the syntax node for pointer type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax.ElementType">
            <summary>TypeSyntax node that represents the element type of the pointer.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax.AsteriskToken">
            <summary>SyntaxToken representing the asterisk.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax">
            <summary>Class which represents the syntax node for a nullable type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax.ElementType">
            <summary>TypeSyntax node representing the type of the element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax">
            <summary>Class which represents a placeholder in the type argument list of an unbound generic type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax.OmittedTypeArgumentToken">
            <summary>SyntaxToken representing the omitted type argument.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax">
            <summary>Provides the base class from which the classes that represent expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression enclosed within the parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for prefix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the prefix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the prefix unary expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax">
            <summary>Class which represents the syntax node for an "await" expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax.AwaitKeyword">
            <summary>SyntaxToken representing the kind "await" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax.Expression">
            <summary>ExpressionSyntax representing the operand of the "await" operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax">
            <summary>Class which represents the syntax node for postfix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax.Operand">
            <summary>ExpressionSyntax representing the operand of the postfix unary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator of the postfix unary expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax">
            <summary>Class which represents the syntax node for member access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object that the member belongs to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the kind of the operator in the member access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being accessed.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax">
            <summary>Class which represents the syntax node for conditional access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the object conditionally accessed.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax.WhenNotNull">
            <summary>ExpressionSyntax node representing the access expression to be executed when the object is not null.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax">
            <summary>Class which represents the syntax node for member binding expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing dot.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax.Name">
            <summary>SimpleNameSyntax node representing the member being bound to.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax">
            <summary>Class which represents the syntax node for element binding expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element binding expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax">
            <summary>Class which represents the syntax node for implicit element access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the implicit element access expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax">
            <summary>Class which represents an expression that has a binary operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the binary operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the binary expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the binary operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax">
            <summary>Class which represents an expression that has an assignment operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax.Left">
            <summary>ExpressionSyntax node representing the expression on the left of the assignment operator.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax.OperatorToken">
            <summary>SyntaxToken representing the operator of the assignment expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax.Right">
            <summary>ExpressionSyntax node representing the expression on the right of the assignment operator.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax">
            <summary>Class which represents the syntax node for conditional expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax.Condition">
            <summary>ExpressionSyntax node representing the condition of the conditional expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax.QuestionToken">
            <summary>SyntaxToken representing the question mark.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax.WhenTrue">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is true.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax.WhenFalse">
            <summary>ExpressionSyntax node representing the expression to be executed when the condition is false.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InstanceExpressionSyntax">
            <summary>Provides the base class from which the classes that represent instance expression syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax">
            <summary>Class which represents the syntax node for a this expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax.Token">
            <summary>SyntaxToken representing the this keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax">
            <summary>Class which represents the syntax node for a base expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax.Token">
            <summary>SyntaxToken representing the base keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax">
            <summary>Class which represents the syntax node for a literal expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax.Token">
            <summary>SyntaxToken representing the keyword corresponding to the kind of the literal expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax">
            <summary>Class which represents the syntax node for MakeRef expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the MakeRefKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax">
            <summary>Class which represents the syntax node for RefType expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefTypeKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax">
            <summary>Class which represents the syntax node for RefValue expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the RefValueKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.Expression">
            <summary>Typed reference expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.Comma">
            <summary>Comma separating the arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.Type">
            <summary>The type of the value.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax">
            <summary>Class which represents the syntax node for Checked or Unchecked expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the checked or unchecked keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax.Expression">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax">
            <summary>Class which represents the syntax node for Default expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the DefaultKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax">
            <summary>Class which represents the syntax node for TypeOf expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the TypeOfKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax.Type">
            <summary>The expression to return type of.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax">
            <summary>Class which represents the syntax node for SizeOf expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax.Keyword">
            <summary>SyntaxToken representing the SizeOfKeyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax.Type">
            <summary>Argument of the primary function.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax">
            <summary>Class which represents the syntax node for invocation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression part of the invocation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax node representing the list of arguments of the invocation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax">
            <summary>Class which represents the syntax node for element access expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression which is accessing the element.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax.ArgumentList">
            <summary>BracketedArgumentListSyntax node representing the list of arguments of the element access expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax">
            <summary>Provides the base class from which the classes that represent argument list syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax nodes representing the list of arguments.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax">
            <summary>Class which represents the syntax node for the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax.OpenParenToken">
            <summary>SyntaxToken representing open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax.CloseParenToken">
            <summary>SyntaxToken representing close parenthesis.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax">
            <summary>Class which represents the syntax node for bracketed argument list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax.OpenBracketToken">
            <summary>SyntaxToken representing open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax.Arguments">
            <summary>SeparatedSyntaxList of ArgumentSyntax representing the list of arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax.CloseBracketToken">
            <summary>SyntaxToken representing close bracket.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax">
            <summary>Class which represents the syntax node for argument.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.NameColon">
            <summary>NameColonSyntax node representing the optional name arguments.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.RefOrOutKeyword">
            <summary>SyntaxToken representing the optional ref or out keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax.Expression">
            <summary>ExpressionSyntax node representing the argument.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax">
            <summary>Class which represents the syntax node for name colon syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax.Name">
            <summary>IdentifierNameSyntax representing the identifer name.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax.ColonToken">
            <summary>SyntaxToken representing colon.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax">
            <summary>Class which represents the syntax node for cast expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax.OpenParenToken">
            <summary>SyntaxToken representing the open parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type the expression is being casted to.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax.CloseParenToken">
            <summary>SyntaxToken representing the close parenthesis.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax.Expression">
            <summary>ExpressionSyntax node representing the expression that is being casted.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax">
            <summary>Provides the base class from which the classes that represent anonymous function expressions are derived.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax.AsyncKeyword">
            <summary>Gets the "async" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousFunctionExpressionSyntax.Body">
            <summary>ExpressionSyntax or BlockSyntax representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax">
            <summary>Provides the base class from which the classes that represent lambda expressions are derived.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for a simple lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax.AsyncKeyword">
            <summary>Gets the "async" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax.Parameter">
            <summary>ParameterSyntax node representing the parameter of the lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax">
            <summary>Class which represents the syntax node for parenthesized lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax.AsyncKeyword">
            <summary>Gets the "async" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax.ParameterList">
            <summary>ParameterListSyntax node representing the list of parameters for the lambda expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax.ArrowToken">
            <summary>SyntaxToken representing equals greater than.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax.Body">
            <summary>SyntaxNode representing the body of the lambda expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax">
            <summary>Class which represents the syntax node for initializer expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax.Expressions">
            <summary>SeparatedSyntaxList of ExpressionSyntax representing the list of expressions in the initializer expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.Type">
            <summary>TypeSyntax representing the type of the object being created.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.ArgumentList">
            <summary>ArgumentListSyntax representing the list of arguments passed as part of the object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression for the object being created.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax.NameEquals">
            <summary>NameEqualsSyntax representing the optional name of the member being initialized.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax.Expression">
            <summary>ExpressionSyntax representing the value the member is initialized with.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax">
            <summary>Class which represents the syntax node for anonymous object creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax.OpenBraceToken">
            <summary>SyntaxToken representing the open brace.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax.Initializers">
            <summary>SeparatedSyntaxList of AnonymousObjectMemberDeclaratorSyntax representing the list of object member initializers.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax.CloseBraceToken">
            <summary>SyntaxToken representing the close brace.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax.Type">
            <summary>ArrayTypeSyntax node representing the type of the array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax node representing the initializer of the array creation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for implicit array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax.NewKeyword">
            <summary>SyntaxToken representing the new keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax.OpenBracketToken">
            <summary>SyntaxToken representing the open bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax.Commas">
            <summary>SyntaxList of SyntaxToken representing the commas in the implicit array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax.CloseBracketToken">
            <summary>SyntaxToken representing the close bracket.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax.Initializer">
            <summary>InitializerExpressionSyntax representing the initializer expression of the implicit array creation expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax">
            <summary>Class which represents the syntax node for stackalloc array creation expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax.StackAllocKeyword">
            <summary>SyntaxToken representing the stackalloc keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax.Type">
            <summary>TypeSyntax node representing the type of the stackalloc array.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax">
            <summary>Class which represents a placeholder in an array size list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax.OmittedArraySizeExpressionToken">
            <summary>SyntaxToken representing the omitted array size expression.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax.StringStartToken">
            <summary>The first part of an interpolated string, $" or $@"</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax.Contents">
            <summary>List of parts of the interpolated string, each one is either a literal part or an interpolation.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax.StringEndToken">
            <summary>The closing quote of the interpolated string.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax.TextToken">
            <summary>The text contents of a part of the interpolated string.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax.FormatStringToken">
            <summary>The text contents of the format specifier for an interpolation.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax">
            <summary>Represents the base class for all statements syntax classes.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax">
            <summary>Represents a labeled statement syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax.ColonToken">
            <summary>Gets a SyntaxToken that represents the colon succeeding the statement's label.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax">
            <summary>
            Represents a goto statement syntax
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax.GotoKeyword">
            <summary>
            Gets a SyntaxToken that represents the goto keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax.CaseOrDefaultKeyword">
            <summary>
            Gets a SyntaxToken that represents the case or default keywords if any exists.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax.Expression">
            <summary>
            Gets a constant expression for a goto case statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax.SemicolonToken">
            <summary>
            Gets a SyntaxToken that represents the semi-colon at the end of the statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax">
            <summary>
            Represents an if statement syntax.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.IfKeyword">
            <summary>
            Gets a SyntaxToken that represents the if keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis before the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.Condition">
            <summary>
            Gets an ExpressionSyntax that represents the condition of the if statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis after the if statement's condition expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.Statement">
            <summary>
            Gets a StatementSyntax the represents the statement to be executed when the condition is true.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax.Else">
            <summary>
            Gets an ElseClauseSyntax that represents the statement to be executed when the condition is false if such statement exists.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax">
            <summary>Represents an else statement syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax.ElseKeyword">
            <summary>
            Gets a syntax token
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax">
            <summary>Represents a switch statement syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.SwitchKeyword">
            <summary>
            Gets a SyntaxToken that represents the switch keyword.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.OpenParenToken">
            <summary>
            Gets a SyntaxToken that represents the open parenthesis preceding the switch expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.Expression">
            <summary>
            Gets an ExpressionSyntax representing the expression of the switch statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.CloseParenToken">
            <summary>
            Gets a SyntaxToken that represents the close parenthesis succeeding the switch expression.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.OpenBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces preceding the switch sections.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.Sections">
            <summary>
            Gets a SyntaxList of SwitchSectionSyntax's that represents the switch sections of the switch statement.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax.CloseBraceToken">
            <summary>
            Gets a SyntaxToken that represents the open braces succeeding the switch sections.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax">
            <summary>Represents a switch section syntax of a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax.Labels">
            <summary>
            Gets a SyntaxList of SwitchLabelSyntax's the represents the possible labels that control can transfer to within the section.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax.Statements">
            <summary>
            Gets a SyntaxList of StatementSyntax's the represents the statements to be executed when control transfer to a label the belongs to the section.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax">
            <summary>Represents a switch label within a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax.Keyword">
            <summary>
            Gets a SyntaxToken that represents a case or default keywords that belongs to a switch label.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax.ColonToken">
            <summary>
            Gets a SyntaxToken that represents the colon that terminates the switch label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax">
            <summary>Represents a case label within a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax.Keyword">
            <summary>Gets the case keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax.Value">
            <summary>
            Gets an ExpressionSyntax that represents the constant expression that gets matched for the case label.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax">
            <summary>Represents a default label within a switch statement.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax.Keyword">
            <summary>Gets the default keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax">
            <summary>
            Represents an ExternAlias directive syntax, e.g. "extern alias MyAlias;" with specifying "/r:MyAlias=SomeAssembly.dll " on the compiler command line.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax.ExternKeyword">
            <summary>SyntaxToken representing the extern keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax.AliasKeyword">
            <summary>SyntaxToken representing the alias keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax.SemicolonToken">
            <summary>SyntaxToken representing the semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax">
            <summary>Member declaration syntax.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax">
            <summary>Class representing one or more attributes applied to a language construct.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax.Attributes">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax">
            <summary>Attribute argument list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax.Arguments">
            <summary>Gets the arguments syntax list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax">
            <summary>Attribute argument syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax.Expression">
            <summary>Gets the expression.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax">
            <summary>Class representing an identifier name followed by an equals token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax.Name">
            <summary>Gets the identifier name.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax">
            <summary>Type parameter list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax.LessThanToken">
            <summary>Gets the &lt; token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax.GreaterThanToken">
            <summary>Gets the &gt; token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax">
            <summary>Type parameter syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax">
            <summary>Base class for type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.BaseList">
            <summary>Gets the base type list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.OpenBraceToken">
            <summary>Gets the open brace token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.CloseBraceToken">
            <summary>Gets the close brace token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax">
            <summary>Class type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax.Keyword">
            <summary>Gets the class keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax">
            <summary>Struct type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax.Keyword">
            <summary>Gets the struct keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax">
            <summary>Interface type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax.Keyword">
            <summary>Gets the interface keyword token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax">
            <summary>Enum type declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax.EnumKeyword">
            <summary>Gets the enum keyword token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax.Members">
            <summary>Gets the members declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax">
            <summary>Base list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax.Types">
            <summary>Gets the base type references.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax">
            <summary>Provides the base class from which the classes that represent base type syntax nodes are derived. This is an abstract class.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax">
            <summary>Type parameter constraint clause.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax.Name">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax.Constraints">
            <summary>Gets the constraints list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax">
            <summary>Base type for type parameter constraint syntax.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax">
            <summary>Constructor constraint syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax.NewKeyword">
            <summary>Gets the "new" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax.OpenParenToken">
            <summary>Gets the open paren keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax.CloseParenToken">
            <summary>Gets the close paren keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax">
            <summary>Base type for class or struct constraint syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax.ClassOrStructKeyword">
            <summary>Gets the constraint keyword ("class" or "struct").</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax">
            <summary>Type constraint syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseFieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax">
            <summary>Base type for method declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax.ParameterList">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseMethodDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax">
            <summary>Operator declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax.ReturnType">
            <summary>Gets the return type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" keyword.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax">
            <summary>Conversion operator declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax.ImplicitOrExplicitKeyword">
            <summary>Gets the "implicit" or "explicit" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax.OperatorKeyword">
            <summary>Gets the "operator" token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax.Type">
            <summary>Gets the type.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax">
            <summary>Constructor declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax">
            <summary>Constructor initializer syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax.ColonToken">
            <summary>Gets the colon token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax.ThisOrBaseKeyword">
            <summary>Gets the "this" or "base" keyword.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax">
            <summary>Destructor declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax.TildeToken">
            <summary>Gets the tilde token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax">
            <summary>Base type for property declaration syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax.Type">
            <summary>Gets the type syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BasePropertyDeclarationSyntax.ExplicitInterfaceSpecifier">
            <summary>Gets the optional explicit interface specifier.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax">
            <summary>The syntax for the expression body of an expression-bodied member.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax.Identifier">
            <summary>Gets the identifier.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.Keyword">
            <summary>Gets the keyword token, or identifier if an erroneous accessor declaration.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.Body">
            <summary>Gets the optional body block which may be empty, but it is null if there are no braces.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax.SemicolonToken">
            <summary>Gets the optional semicolon token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax">
            <summary>Base type for parameter list syntax.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax">
            <summary>Parameter list syntax with surrounding brackets.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax.AttributeLists">
            <summary>Gets the attribute declaration list.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax.Modifiers">
            <summary>Gets the modifier list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax">
            <summary>
            A symbol referenced by a cref attribute (e.g. in a &lt;see&gt; or &lt;seealso&gt; documentation comment tag).
            For example, the M in &lt;see cref="M" /&gt;.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax">
            <summary>
            A symbol reference that definitely refers to a type.
            For example, "int", "A::B", "A.B", "A&lt;T&gt;", but not "M()" (has parameter list) or "this" (indexer).
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax">
            <summary>
            A symbol reference to a type or non-type member that is qualified by an enclosing type or namespace.
            For example, cref="System.String.ToString()".
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax">
            <summary>
            The unqualified part of a CrefSyntax.
            For example, "ToString()" in "object.ToString()".
            NOTE: TypeCrefSyntax, QualifiedCrefSyntax, and MemberCrefSyntax overlap.  The syntax in a TypeCrefSyntax
            will always be bound as type, so it's safer to use QualifiedCrefSyntax or MemberCrefSyntax if the symbol
            might be a non-type member.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by a name (an identifier, predefined type keyword, or an alias-qualified name,
            with an optional type parameter list) and an optional parameter list.
            For example, "M", "M&lt;T&gt;" or "M(int)".
            Also, "A::B()" or "string()".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by a this keyword and an optional parameter list.
            For example, "this" or "this[int]".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by an operator keyword, an operator symbol and an optional parameter list.
            For example, "operator +" or "operator -[int]".
            NOTE: the operator must be overloadable.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax.OperatorToken">
            <summary>Gets the operator token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax">
            <summary>
            A MemberCrefSyntax specified by an implicit or explicit keyword, an operator keyword, a destination type, and an optional parameter list.
            For example, "implicit operator int" or "explicit operator MyType(int)".
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax">
            <summary>
            A list of cref parameters with surrounding punctuation.
            Unlike regular parameters, cref parameters do not have names.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.BaseCrefParameterListSyntax.Parameters">
            <summary>Gets the parameter list.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax">
            <summary>
            A parenthesized list of cref parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax.OpenParenToken">
            <summary>Gets the open paren token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax.CloseParenToken">
            <summary>Gets the close paren token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax">
            <summary>
            A bracketed list of cref parameters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax.OpenBracketToken">
            <summary>Gets the open bracket token.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax.CloseBracketToken">
            <summary>Gets the close bracket token.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax">
            <summary>
            An element of a BaseCrefParameterListSyntax.
            Unlike a regular parameter, a cref parameter has only an optional ref or out keyword and a type -
            there is no name and there are no attributes or other modifiers.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntaxFacts">
            <summary>
            Defines a set of methods to determine how Unicode characters are treated by the C# compiler.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsHexDigit(System.Char)">
            <summary>
            Returns true if the Unicode character is a hexadecimal digit.
            </summary>
            <param name="c">The Unicode character.</param>
            <returns>true if the character is a hexadecimal digit 0-9, A-F, a-f.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsDecDigit(System.Char)">
            <summary>
            Returns true if the Unicode character is a decimal digit.
            </summary>
            <param name="c">The Unicode character.</param>
            <returns>true if the Unicode character is a decimal digit.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.HexValue(System.Char)">
            <summary>
            Returns the value of a hexadecimal Unicode character.
            </summary>
            <param name="c">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.DecValue(System.Char)">
            <summary>
            Returns the value of a decimal Unicode character.
            </summary>
            <param name="c">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsWhitespace(System.Char)">
            <summary>
            Returns true if the Unicode character represents a whitespace.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsNewLine(System.Char)">
            <summary>
            Returns true if the Unicode character is a newline character.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsIdentifierStartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be the starting character of a C# identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsIdentifierPartCharacter(System.Char)">
            <summary>
            Returns true if the Unicode character can be a part of a C# identifier.
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsValidIdentifier(System.String)">
            <summary>
            Check that the name is a valid identifier.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.ContainsDroppedIdentifierCharacters(System.String)">
            <summary>
            Spec section 2.4.2 says that identifiers are compared without regard
            to leading "@" characters or unicode formatting characters.  As in dev10,
            this is actually accomplished by dropping such characters during parsing.
            Unfortunately, metadata names can still contain these characters and will
            not be referenceable from source if they do (lookup will fail since the
            characters will have been dropped from the search string).
            See DevDiv #14432 for more.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsFormattingChar(System.Char)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="ch">The Unicode character.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsFormattingChar(System.Globalization.UnicodeCategory)">
            <summary>
            Returns true if the Unicode character is a formatting character (Unicode class Cf).
            </summary>
            <param name="cat">The Unicode character.</param>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.EqualityComparer">
            <summary>
            A custom equality comparer for <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/>
            </summary>
            <remarks>
            PERF: The framework specializes EqualityComparer for enums, but only if the underlying type is System.Int32
            Since SyntaxKind's underlying type is System.UInt16, ObjectEqualityComparer will be chosen instead.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsPreprocessorContextualKeyword(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Some preprocessor keywords are only keywords when they appear after a
            hash sign (#).  For these keywords, the lexer will produce tokens with
            Kind = SyntaxKind.IdentifierToken and ContextualKind set to the keyword
            SyntaxKind.
            </summary>
            <remarks>
            This wrinkle is specifically not publicly exposed.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsGlobalMemberDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Member declarations that can appear in global code (other than type declarations).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsAliasQualifier(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the node is the alias of an AliasQualifiedNameSyntax
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsInvoked(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Returns true if the node is the object of an invocation expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsIndexed(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Returns true if the node is the object of an element access expression.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsInTypeOnlyContext(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Returns true if the node is in a tree location that is expected to be a type
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsInNamespaceOrTypeContext(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Returns true if a node is in a tree location that is expected to be either a namespace or type
            </summary>
            <param name="node"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsNamedArgumentName(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Is the node the name of a named argument of an invocation, object creation expression, 
            constructor initializer, or element access, but not an attribute.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFacts.IsFixedStatementExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Is the expression the initializer in a fixed statement?
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.ObjectDisplay">
            <summary>
            Displays a value in the C# style.
            </summary>
            <remarks>
            Separate from <see cref="T:Microsoft.CodeAnalysis.CSharp.SymbolDisplay"/> because we want to link this functionality into
            the Formatter project and we don't want it to be public there.
            </remarks>
            <seealso cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.ObjectDisplay"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ObjectDisplay.FormatPrimitive(System.Object,Microsoft.CodeAnalysis.ObjectDisplayOptions)">
            <summary>
            Returns a string representation of an object of primitive type.
            </summary>
            <param name="obj">A value to display as a string.</param>
            <param name="options">Options used to customize formatting of an object value.</param>
            <returns>A string representation of an object of primitive type (or null if the type is not supported).</returns>
            <remarks>
            Handles <see cref="T:System.Boolean"/>, <see cref="T:System.String"/>, <see cref="T:System.Char"/>, <see cref="T:System.SByte"/>
            <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>,
            <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Double"/>, <see cref="T:System.Single"/>, <see cref="T:System.Decimal"/>,
            and <c>null</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ObjectDisplay.ReplaceChar(System.Char,System.Char,System.String@)">
            <summary>
            Returns true if the character should be replaced and sets
            <paramref name="replaceWith"/> to the replacement text if the
            character is replaced with text other than the Unicode escape sequence.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ObjectDisplay.FormatLiteral(System.String,Microsoft.CodeAnalysis.ObjectDisplayOptions)">
            <summary>
            Returns a C# string literal with the given value.
            </summary>
            <param name="value">The value that the resulting string literal should have.</param>
            <param name="options">Options used to customize formatting of an object value.</param>
            <returns>A string literal with the given value.</returns>
            <remarks>
            Escapes non-printable characters.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.ObjectDisplay.FormatLiteral(System.Char,Microsoft.CodeAnalysis.ObjectDisplayOptions)">
            <summary>
            Returns a C# character literal with the given value.
            </summary>
            <param name="c">The value that the resulting character literal should have.</param>
            <param name="options">Options used to customize formatting of an object value.</param>
            <returns>A character literal with the given value.</returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SymbolDisplay">
            <summary>
            Displays a symbol in the C# style.
            </summary>
            <seealso cref="T:Microsoft.CodeAnalysis.VisualBasic.Symbols.SymbolDisplay"/>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.ToDisplayString(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Displays a symbol in the C# style, based on a <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayFormat"/>.
            </summary>
            <param name="symbol">The symbol to be displayed.</param>
            <param name="format">The formatting options to apply.  If null is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat"/> will be used.</param>
            <returns>A formatted string that can be displayed to the user.</returns>
            <remarks>
            The return value is not expected to be syntactically valid C#.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.ToMinimalDisplayString(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Displays a symbol in the C# style, based on a <see cref="T:Microsoft.CodeAnalysis.SymbolDisplayFormat"/>.
            Based on the context, qualify type and member names as little as possible without
            introducing ambiguities.
            </summary>
            <param name="symbol">The symbol to be displayed.</param>
            <param name="semanticModel">Semantic information about the context in which the symbol is being displayed.</param>
            <param name="position">A position within the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <paramref name="semanticModel"/>.</param>
            <param name="format">The formatting options to apply.  If null is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat"/> will be used.</param>
            <returns>A formatted string that can be displayed to the user.</returns>
            <remarks>
            The return value is not expected to be syntactically valid C#.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.ToDisplayParts(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. Useful for
            colorizing the display string.
            </summary>
            <param name="symbol">The symbol to be displayed.</param>
            <param name="format">The formatting options to apply.  If null is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat"/> will be used.</param>
            <returns>A list of display parts.</returns>
            <remarks>
            Parts are not localized until they are converted to strings.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.ToMinimalDisplayParts(Microsoft.CodeAnalysis.ISymbol,Microsoft.CodeAnalysis.SemanticModel,System.Int32,Microsoft.CodeAnalysis.SymbolDisplayFormat)">
            <summary>
            Convert a symbol to an array of string parts, each of which has a kind. Useful for
            colorizing the display string.
            </summary>
            <param name="symbol">The symbol to be displayed.</param>
            <param name="semanticModel">Semantic information about the context in which the symbol is being displayed.</param>
            <param name="position">A position within the <see cref="T:Microsoft.CodeAnalysis.SyntaxTree"/> or <paramref name="semanticModel"/>.</param>
            <param name="format">The formatting options to apply.  If null is passed, <see cref="P:Microsoft.CodeAnalysis.SymbolDisplayFormat.CSharpErrorMessageFormat"/> will be used.</param>
            <returns>A list of display parts.</returns>
            <remarks>
            Parts are not localized until they are converted to strings.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatPrimitive(System.Object,System.Boolean,System.Boolean)">
            <summary>
            Returns a string representation of an object of primitive type.
            </summary>
            <param name="obj">A value to display as a string.</param>
            <param name="quoteStrings">Whether or not to quote string literals.</param>
            <param name="useHexadecimalNumbers">Whether or not to display integral literals in hexadecimal.</param>
            <returns>A string representation of an object of primitive type (or null if the type is not supported).</returns>
            <remarks>
            Handles <see cref="T:System.Boolean"/>, <see cref="T:System.String"/>, <see cref="T:System.Char"/>, <see cref="T:System.SByte"/>
            <see cref="T:System.Byte"/>, <see cref="T:System.Int16"/>, <see cref="T:System.UInt16"/>, <see cref="T:System.Int32"/>, <see cref="T:System.UInt32"/>,
            <see cref="T:System.Int64"/>, <see cref="T:System.UInt64"/>, <see cref="T:System.Double"/>, <see cref="T:System.Single"/>, <see cref="T:System.Decimal"/>,
            and <c>null</c>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatLiteral(System.String,System.Boolean)">
            <summary>
            Returns a C# string literal with the given value.
            </summary>
            <param name="value">The value that the resulting string literal should have.</param>
            <param name="quote">True to put (double) quotes around the string literal.</param>
            <returns>A string literal with the given value.</returns>
            <remarks>
            Escapes non-printable characters.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SymbolDisplay.FormatLiteral(System.Char,System.Boolean)">
            <summary>
            Returns a C# character literal with the given value.
            </summary>
            <param name="c">The value that the resulting character literal should have.</param>
            <param name="quote">True to put (single) quotes around the character literal.</param>
            <returns>A character literal with the given value.</returns>
            <remarks>
            Escapes non-printable characters.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SymbolDistinguisher">
            <summary>
            Some error messages are particularly confusing if multiple placeholders are substituted
            with the same string.  For example, "cannot convert from 'Foo' to 'Foo'".  Usually, this
            occurs because there are two types in different contexts with the same qualified name.
            The solution is to provide additional qualification on each symbol - either a source
            location, an assembly path, or an assembly identity.
            </summary>
            <remarks>
            Performs the same function as ErrArgFlags::Unique in the native compiler.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2">
            <summary>
            Virtual dispatch based on a symbol's particular class. 
            </summary>
            <typeparam name="TArgument">Additional argument type</typeparam>
            <typeparam name="TResult">Result type</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.Visit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)">
            <summary>
            Call the correct VisitXXX method in this class based on the particular type of symbol that is passed in.
            Return default(TResult) if symbol is null
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)">
            <summary>
            The default Visit method called when visiting any <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbol" /> and 
            if visiting specific symbol method VisitXXX is not overridden
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitAssembly(Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AssemblySymbol" />; Override this method with
            specific implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not
            overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitModule(Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ModuleSymbol" />; Override this method with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitNamespace(Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceSymbol" />; Should override this method if
            want to visit members of the namespace; Calling <see
            cref="M:Microsoft.CodeAnalysis.CSharp.Symbols.NamespaceOrTypeSymbol.GetMembers" />
            and loop over each member; calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.Visit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> on it Or override this with
            specific implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not
            overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitNamedType(Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.NamedTypeSymbol" />; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitArrayType(Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ArrayTypeSymbol" />; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitPointerType(Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.PointerTypeSymbol" />; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitErrorType(Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ErrorTypeSymbol" /> 
            Error symbol is created when there is compiler error; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol" />; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitDynamicType(Microsoft.CodeAnalysis.CSharp.Symbols.DynamicTypeSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.DynamicTypeSymbol" />; Override this with specific
            implementation; Calling <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitMethod(Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.MethodSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitField(Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.FieldSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitProperty(Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.PropertySymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitEvent(Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.EventSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitParameter(Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.ParameterSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitLocal(Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.LocalSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitLabel(Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.LabelSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitAlias(Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol,`0)">
            <summary>
            Called when visiting an <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.AliasSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.VisitRangeVariable(Microsoft.CodeAnalysis.CSharp.Symbols.RangeVariableSymbol,`0)">
            <summary>
            Called when visiting a <see cref="T:Microsoft.CodeAnalysis.CSharp.Symbols.RangeVariableSymbol" />; Override this with specific
            implementation; Calling default <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSymbolVisitor`2.DefaultVisit(Microsoft.CodeAnalysis.CSharp.Symbol,`0)" /> if it's not overridden 
            </summary>
            <param name="symbol">The visited symbol</param>
            <param name="argument">Additional argument</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypedConstantExtensions.ToCSharpString(Microsoft.CodeAnalysis.TypedConstant)">
            <summary>
            Returns the System.String that represents the current TypedConstant.
            </summary>
            <returns>A System.String that represents the current TypedConstant.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeUnification.CanUnify(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol)">
            <summary>
            Determine whether there is any substitution of type parameters that will
            make two types identical.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeUnification.CanUnifyHelper(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.MutableTypeMap@)">
            <summary>
            Determine whether there is any substitution of type parameters that will
            make two types identical.
            </summary>
            <param name="t1">LHS</param>
            <param name="t2">RHS</param>
            <param name="substitution">
            Substitutions performed so far (or null for none).
            Keys are type parameters, values are types (possibly type parameters).
            Will be updated with new subsitutions by the callee.
            Should be ignored when false is returned.
            </param>
            <returns>True if there exists a type map such that Map(LHS) == Map(RHS).</returns>
            <remarks>
            Derived from Dev10's BSYMMGR::UnifyTypes.
            Two types will not unify if they have different custom modifiers.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.TypeUnification.Contains(Microsoft.CodeAnalysis.CSharp.Symbols.TypeSymbol,Microsoft.CodeAnalysis.CSharp.Symbols.TypeParameterSymbol)">
            <summary>
            Return true if the given type contains the specified type parameter.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode">
            <summary>
            Represents a non-terminal node in the syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.#ctor(Microsoft.CodeAnalysis.GreenNode,System.Int32,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Used by structured trivia which has "parent == null", and therefore must know its
            SyntaxTree explicitly when created.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.CloneNodeAsRoot``1(``0,Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Creates a clone of a red node that can be used as a root of given syntaxTree.
            New node has no parents, position == 0, and syntaxTree as specified.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree">
            <summary>
            Returns a non-null <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree"/> that owns this node.
            If this node was created with an explicit non-null <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree"/>, returns that tree.
            Otherwise, if this node has a non-null parent, then returns the parent's <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree"/>.
            Otherwise, returns a newly created <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree"/> rooted at this node, preserving this node's reference identity.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.Parent">
            <summary>
            The node that contains this node in its Children collection.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.Kind">
            <summary>
            Returns the <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> of the node.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.Language">
            <summary>
            The language name that this node is syntax of.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetLeadingTrivia">
            <summary>
            The list of trivia that appears before this node in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetTrailingTrivia">
            <summary>
            The list of trivia that appears after this node in the source code.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.ToString">
            <summary>
            Returns the string representation of this node, not including its leading and trailing trivia.
            </summary>
            <returns>The string representation of this node, not including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as Span.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.ToFullString">
            <summary>
            Returns full string representation of this node including its leading and trailing trivia.
            </summary>
            <returns>The full string representation of this node including its leading and trailing trivia.</returns>
            <remarks>The length of the returned string is always the same as FullSpan.Length</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.WriteTo(System.IO.TextWriter)">
            <summary>
            Writes the full text of this node to the specified TextWriter.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SerializeTo(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Serialize the syntax node into a byte stream.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.DeserializeFrom(System.IO.Stream,System.Threading.CancellationToken)">
            <summary>
            Deserialize a syntax node from the byte stream.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.IsEquivalentTo(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Determines whether this node is structurally equivalent to another.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetLocation">
            <summary>
            Gets a <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.Location"/> for this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetReference">
            <summary>
            Gets a SyntaxReference for this syntax node. SyntaxReferences can be used to
            regain access to a syntax node without keeping the entire tree and source text in
            memory.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetDiagnostics">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has this node as its root.
            This method does not filter diagnostics based on #pragmas and compiler options
            like nowarn, warnaserror etc.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetFirstDirective(System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})">
            <summary>
            Gets the first directive of the tree rooted by this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetLastDirective(System.Func{Microsoft.CodeAnalysis.CSharp.Syntax.DirectiveTriviaSyntax,System.Boolean})">
            <summary>
            Gets the last directive of the tree rooted by this node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.ChildThatContainsPosition(System.Int32)">
            <summary>
            Returns child node or token that contains given position.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetFirstToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the first token of the tree rooted by this node.
            </summary>
            <param name="includeZeroWidth">True if zero width tokens should be included, false by
            default.</param>
            <param name="includeSkipped">True if skipped tokens should be included, false by default.</param>
            <param name="includeDirectives">True if directives should be included, false by default.</param>
            <param name="includeDocumentationComments">True if documentation comments should be
            included, false by default.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetFirstToken(System.Func{Microsoft.CodeAnalysis.SyntaxToken,System.Boolean},System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Gets the first token of the tree rooted by this node.
            </summary>
            <param name="predicate">Only tokens for which this predicate returns true are included.  Pass null to include
            all tokens.</param>
            <param name="stepInto">Steps into trivia if this is not null.  Only trivia for which this delegate returns
            true are included.</param> 
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.GetLastToken(System.Boolean,System.Boolean,System.Boolean,System.Boolean)">
            <summary>
            Gets the last non-zero-width token of the tree rooted by this node.
            </summary>
            <param name="includeZeroWidth">True if zero width tokens should be included, false by
            default.</param>
            <param name="includeSkipped">True if skipped tokens should be included, false by default.</param>
            <param name="includeDirectives">True if directives should be included, false by default.</param>
            <param name="includeDocumentationComments">True if documentation comments should be
            included, false by default.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.FindToken(System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Finds a token according to the following rules:
            1) If position matches the End of the node/s FullSpan and the node is CompilationUnit,
              then EoF is returned. 
            
            2) If node.FullSpan.Contains(position) the token that contains given position is
               returned. If stepInto is not Nothing, then structured trivia that satisfies the
               condition will also be visited during the search.
            
            3) Otherwise an IndexOutOfRange is thrown
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.FindToken(System.Int32,System.Boolean)">
            <summary>
            Finds a token according to the following rules:
            1) If position matches the End of the node/s FullSpan and the node is CompilationUnit,
               then EoF is returned. 
            
             2) If node.FullSpan.Contains(position) then the token that contains given position is
                returned.
            
             3) Otherwise an ArgumentOutOfRangeException is thrown
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.FindTokenIncludingCrefAndNameAttributes(System.Int32)">
            <summary>
            Finds a token according to the following rules:
            1) If position matches the End of the node/s FullSpan and the node is CompilationUnit,
               then EoF is returned. 
            
             2) If node.FullSpan.Contains(position) then the token that contains given position is
                returned.
            
             3) Otherwise an ArgumentOutOfRangeException is thrown
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.FindTrivia(System.Int32,System.Func{Microsoft.CodeAnalysis.SyntaxTrivia,System.Boolean})">
            <summary>
            Finds a descendant trivia of this node at the specified position, where the position is
            within the span of the node.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of
            the file.</param>
            <param name="stepInto">Specifies a function that determines per trivia node, whether to
            descend into structured trivia of that node.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.FindTrivia(System.Int32,System.Boolean)">
            <summary>
            Finds a descendant trivia of this node whose span includes the supplied position.
            </summary>
            <param name="position">The character position of the trivia relative to the beginning of
            the file.</param>
            <param name="findInsideTrivia">Whether to search inside structured trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.EquivalentToCore(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Determine if this node is structurally equivalent to another.
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxRewriter">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1"/> which descends an entire <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> graph and
            may replace or remove visited SyntaxNodes in depth-first order.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree">
            <summary>
            The parsed representation of a C# source document.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.Options">
            <summary>
            The options used by the parser to produce the syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.CloneNodeAsRoot``1(``0)">
            <summary>
            Produces a clone of a <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> which will have current syntax tree as its parent.
            
            Caller must guarantee that if the same instance of <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> makes multiple calls
            to this function, only one result is observable.
            </summary>
            <typeparam name="T">Type of the syntax node.</typeparam>
            <param name="node">The original syntax node.</param>
            <returns>A clone of the original syntax node that has current <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree"/> as its parent.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetRoot(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.TryGetRoot(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode@)">
            <summary>
            Gets the root node of the syntax tree if it is already available.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetRootAsync(System.Threading.CancellationToken)">
            <summary>
            Gets the root node of the syntax tree asynchronously.
            </summary>
            <remarks>
            By default, the work associated with this method will be executed immediately on the current thread.
            Implementations that wish to schedule this work differently should override <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetRootAsync(System.Threading.CancellationToken)"/>.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetCompilationUnitRoot(System.Threading.CancellationToken)">
            <summary>
            Gets the root of the syntax tree statically typed as <see cref="T:Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax"/>.
            </summary>
            <remarks>
            Ensure that <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot"/> is true for this tree prior to invoking this method.
            </remarks>
            <exception cref="T:System.InvalidCastException">Throws this exception if <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.HasCompilationUnitRoot"/> is false.</exception>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.IsEquivalentTo(Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="tree">The tree to compare against.</param>
            <param name="topLevel">
            If true then the trees are equivalent if the contained nodes and tokens declaring metadata visible symbolic information are equivalent,
            ignoring any differences of nodes inside method bodies or initializer expressions, otherwise all nodes and tokens must be equivalent.
            </param>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree._preprocessorStateChangePositions">
            <summary>
            Stores positions where preprocessor state changes. Sorted by position.
            The updated state can be found in <see cref="F:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree._preprocessorStates"/> array at the same index.
            </summary>
        </member>
        <member name="F:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree._preprocessorStates">
            <summary>
            Preprocessor states corresponding to positions in <see cref="F:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree._preprocessorStateChangePositions"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.Create(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Text.Encoding)">
            <summary>
            Creates a new syntax tree from a syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.Create(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new syntax tree from a syntax node with text that should correspond to the syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.CreateWithoutClone(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            <para>
            Internal helper for <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> class to create a new syntax tree rooted at the given root node.
            This method does not create a clone of the given root, but instead preserves it's reference identity.
            </para>
            <para>NOTE: This method is only intended to be used from <see cref="P:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode.SyntaxTree"/> property.</para>
            <para>NOTE: Do not use this method elsewhere, instead use <see cref="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.Create(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Text.Encoding)"/> method for creating a syntax tree.</para>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(System.String,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.ParseText(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.String,System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.WithChangedText(Microsoft.CodeAnalysis.Text.SourceText)">
            <summary>
            Creates a new syntax based off this tree using a new source text.
            </summary>
            <remarks>
            If the new source text is a minor change from the current source text an incremental parse will occur
            reusing most of the current syntax tree internal data.  Otherwise, a full parse will occur using the new
            source text.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetChangedSpans(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Produces a pessimistic list of spans that denote the regions of text in this tree that
            are changed from the text of the old tree.
            </summary>
            <param name="oldTree">The old tree. Cannot be <c>null</c>.</param>
            <remarks>The list is pessimistic because it may claim more or larger regions than actually changed.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetChanges(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Gets a list of text changes that when applied to the old tree produce this tree.
            </summary>
            <param name="oldTree">The old tree. Cannot be <c>null</c>.</param>
            <remarks>The list of changes may be different than the original changes that produced this tree.</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Gets the location in terms of path, line and column for a given span.
            </summary>
            <param name="span">Span within the tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>
            <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.
            </returns>
            <remarks>The values are not affected by line mapping directives (<c>#line</c>).</remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetMappedLineSpan(Microsoft.CodeAnalysis.Text.TextSpan,System.Threading.CancellationToken)">
            <summary>
            Gets the location in terms of path, line and column after applying source line mapping directives (<c>#line</c>). 
            </summary>
            <param name="span">Span within the tree.</param>
            <param name="cancellationToken">Cancellation token.</param>
            <returns>
            <para>A valid <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> that contains path, line and column information.</para>
            <para>
            If the location path is mapped the resulting path is the path specified in the corresponding <c>#line</c>,
            otherwise it's <see cref="P:Microsoft.CodeAnalysis.SyntaxTree.FilePath"/>.
            </para>
            <para>
            A location path is considered mapped if the first <c>#line</c> directive that preceeds it and that
            either specifies an explicit file path or is <c>#line default</c> exists and specifies an explicit path.
            </para>
            </returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetMappedLineSpanAndVisibility(Microsoft.CodeAnalysis.Text.TextSpan,System.Boolean@)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/> for a <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan"/>. FileLinePositionSpans are used
            primarily for diagnostics and source locations.
            </summary>
            <param name="span">The source <see cref="T:Microsoft.CodeAnalysis.Text.TextSpan" /> to convert.</param>
            <param name="isHiddenPosition">When the method returns, contains a boolean value indicating whether this span is considered hidden or not.</param>
            <returns>A resulting <see cref="T:Microsoft.CodeAnalysis.FileLinePositionSpan"/>.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.HasHiddenRegions">
            <summary>
            Gets a boolean value indicating whether there are any hidden regions in the tree.
            </summary>
            <returns>True if there is at least one hidden region.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetPragmaDirectiveWarningState(System.String,System.Int32)">
            <summary>
            Given the error code and the source location, get the warning state based on <c>#pragma warning</c> directives.
            </summary>
            <param name="id">Error code.</param>
            <param name="position">Source location.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetLocation(Microsoft.CodeAnalysis.Text.TextSpan)">
            <summary>
            Gets a <see cref="T:Microsoft.CodeAnalysis.Location"/> for the specified text <paramref name="span"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Gets a list of all the diagnostics in the sub tree that has the specified node as its root.
            </summary>
            <remarks>
            This method does not filter diagnostics based on <c>#pragma</c>s and compiler options
            like /nowarn, /warnaserror etc.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Gets a list of all the diagnostics associated with the token and any related trivia.
            </summary>
            <remarks>
            This method does not filter diagnostics based on <c>#pragma</c>s and compiler options
            like /nowarn, /warnaserror etc.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Gets a list of all the diagnostics associated with the trivia.
            </summary>
            <remarks>
            This method does not filter diagnostics based on <c>#pragma</c>s and compiler options
            like /nowarn, /warnaserror etc.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetDiagnostics(Microsoft.CodeAnalysis.SyntaxNodeOrToken)">
            <summary>
            Gets a list of all the diagnostics in either the sub tree that has the specified node as its root or
            associated with the token and its related trivia. 
            </summary>
            <remarks>
            This method does not filter diagnostics based on <c>#pragma</c>s and compiler options
            like /nowarn, /warnaserror etc.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxTree.GetDiagnostics(System.Threading.CancellationToken)">
            <summary>
            Gets a list of all the diagnostics in the syntax tree.
            </summary>
            <remarks>
            This method does not filter diagnostics based on <c>#pragma</c>s and compiler options
            like /nowarn, /warnaserror etc.
            </remarks>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> visitor that visits only the single CSharpSyntaxNode
            passed into its Visit method and produces 
            a value of the type specified by the <typeparamref name="TResult"/> parameter.
            </summary>
            <typeparam name="TResult">
            The type of the return value this visitor's Visit method.
            </typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)">
            <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax)">
            <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitGenericName(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax)">
            <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax)">
            <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax)">
            <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPredefinedType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax)">
            <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax)">
            <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArrayRankSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax)">
            <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax)">
            <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitNullableType(Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax)">
            <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOmittedTypeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax)">
            <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)">
            <summary>Called when the visitor visits a AwaitExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitMemberAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax)">
            <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitMemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax)">
            <summary>Called when the visitor visits a MemberBindingExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax)">
            <summary>Called when the visitor visits a ElementBindingExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax)">
            <summary>Called when the visitor visits a ImplicitElementAccessSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBinaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax)">
            <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax)">
            <summary>Called when the visitor visits a AssignmentExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitThisExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax)">
            <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBaseExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax)">
            <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLiteralExpression(Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax)">
            <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitMakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax)">
            <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax)">
            <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax)">
            <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCheckedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax)">
            <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax)">
            <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax)">
            <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax)">
            <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax)">
            <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax)">
            <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBracketedArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax)">
            <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax)">
            <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax)">
            <summary>Called when the visitor visits a NameColonSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax)">
            <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInitializerExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAnonymousObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax)">
            <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitQueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax)">
            <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLetClause(Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax)">
            <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitJoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax)">
            <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitJoinIntoClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax)">
            <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitWhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax)">
            <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOrderByClause(Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax)">
            <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOrdering(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax)">
            <summary>Called when the visitor visits a OrderingSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax)">
            <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitGroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax)">
            <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitQueryContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax)">
            <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOmittedArraySizeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax)">
            <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterpolatedStringExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax)">
            <summary>Called when the visitor visits a InterpolatedStringExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterpolatedStringText(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax)">
            <summary>Called when the visitor visits a InterpolatedStringTextSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterpolation(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax)">
            <summary>Called when the visitor visits a InterpolationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterpolationAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax)">
            <summary>Called when the visitor visits a InterpolationAlignmentClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterpolationFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax)">
            <summary>Called when the visitor visits a InterpolationFormatClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitGlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax)">
            <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Called when the visitor visits a BlockSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)">
            <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitVariableDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax)">
            <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax)">
            <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEmptyStatement(Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax)">
            <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLabeledStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax)">
            <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitGotoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax)">
            <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBreakStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax)">
            <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitContinueStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax)">
            <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax)">
            <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax)">
            <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitYieldStatement(Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax)">
            <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitWhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax)">
            <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax)">
            <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax)">
            <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)">
            <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax)">
            <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax)">
            <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCheckedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax)">
            <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitUnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax)">
            <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax)">
            <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax)">
            <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax)">
            <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax)">
            <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSwitchSection(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax)">
            <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax)">
            <summary>Called when the visitor visits a CaseSwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDefaultSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax)">
            <summary>Called when the visitor visits a DefaultSwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax)">
            <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax)">
            <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax)">
            <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax)">
            <summary>Called when the visitor visits a CatchFilterClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax)">
            <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCompilationUnit(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax)">
            <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitExternAliasDirective(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax)">
            <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)">
            <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax)">
            <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax)">
            <summary>Called when the visitor visits a AttributeListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax)">
            <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>Called when the visitor visits a AttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAttributeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax)">
            <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax)">
            <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax)">
            <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax)">
            <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax)">
            <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitInterfaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax)">
            <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEnumDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax)">
            <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEnumMemberDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax)">
            <summary>Called when the visitor visits a BaseListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax)">
            <summary>Called when the visitor visits a SimpleBaseTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax)">
            <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConstructorConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax)">
            <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax)">
            <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax)">
            <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax)">
            <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax)">
            <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax)">
            <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitMethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax)">
            <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConversionOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConstructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)">
            <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDestructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax)">
            <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)">
            <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Called when the visitor visits a ArrowExpressionClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax)">
            <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax)">
            <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)">
            <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax)">
            <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax)">
            <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax)">
            <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax)">
            <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax)">
            <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitSkippedTokensTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax)">
            <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax)">
            <summary>Called when the visitor visits a DocumentationCommentTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitTypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax)">
            <summary>Called when the visitor visits a TypeCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitQualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax)">
            <summary>Called when the visitor visits a QualifiedCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitNameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax)">
            <summary>Called when the visitor visits a NameMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax)">
            <summary>Called when the visitor visits a IndexerMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax)">
            <summary>Called when the visitor visits a OperatorMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCrefParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Called when the visitor visits a CrefParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCrefBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax)">
            <summary>Called when the visitor visits a CrefBracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax)">
            <summary>Called when the visitor visits a CrefParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax)">
            <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax)">
            <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax)">
            <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax)">
            <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax)">
            <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax)">
            <summary>Called when the visitor visits a XmlTextAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax)">
            <summary>Called when the visitor visits a XmlCrefAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax)">
            <summary>Called when the visitor visits a XmlNameAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlText(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax)">
            <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlCDataSection(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax)">
            <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax)">
            <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitXmlComment(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax)">
            <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a IfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElifDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitElseDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElseDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEndIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndIfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a RegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitEndRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndRegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitErrorDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ErrorDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a WarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitBadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a BadDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitDefineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a DefineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitUndefDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a UndefDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitLineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a LineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaWarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitPragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaChecksumDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor`1.VisitReferenceDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ReferenceDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> visitor that visits only the single CSharpSyntaxNode
            passed into its Visit method.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIdentifierName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)">
            <summary>Called when the visitor visits a IdentifierNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedNameSyntax)">
            <summary>Called when the visitor visits a QualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitGenericName(Microsoft.CodeAnalysis.CSharp.Syntax.GenericNameSyntax)">
            <summary>Called when the visitor visits a GenericNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax)">
            <summary>Called when the visitor visits a TypeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.AliasQualifiedNameSyntax)">
            <summary>Called when the visitor visits a AliasQualifiedNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPredefinedType(Microsoft.CodeAnalysis.CSharp.Syntax.PredefinedTypeSyntax)">
            <summary>Called when the visitor visits a PredefinedTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax)">
            <summary>Called when the visitor visits a ArrayTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArrayRankSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax)">
            <summary>Called when the visitor visits a ArrayRankSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPointerType(Microsoft.CodeAnalysis.CSharp.Syntax.PointerTypeSyntax)">
            <summary>Called when the visitor visits a PointerTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitNullableType(Microsoft.CodeAnalysis.CSharp.Syntax.NullableTypeSyntax)">
            <summary>Called when the visitor visits a NullableTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOmittedTypeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedTypeArgumentSyntax)">
            <summary>Called when the visitor visits a OmittedTypeArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PrefixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PrefixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AwaitExpressionSyntax)">
            <summary>Called when the visitor visits a AwaitExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.PostfixUnaryExpressionSyntax)">
            <summary>Called when the visitor visits a PostfixUnaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitMemberAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberAccessExpressionSyntax)">
            <summary>Called when the visitor visits a MemberAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitMemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MemberBindingExpressionSyntax)">
            <summary>Called when the visitor visits a MemberBindingExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementBindingExpressionSyntax)">
            <summary>Called when the visitor visits a ElementBindingExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitElementAccessSyntax)">
            <summary>Called when the visitor visits a ImplicitElementAccessSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBinaryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BinaryExpressionSyntax)">
            <summary>Called when the visitor visits a BinaryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAssignmentExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AssignmentExpressionSyntax)">
            <summary>Called when the visitor visits a AssignmentExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ConditionalExpressionSyntax)">
            <summary>Called when the visitor visits a ConditionalExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitThisExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ThisExpressionSyntax)">
            <summary>Called when the visitor visits a ThisExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBaseExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BaseExpressionSyntax)">
            <summary>Called when the visitor visits a BaseExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLiteralExpression(Microsoft.CodeAnalysis.CSharp.Syntax.LiteralExpressionSyntax)">
            <summary>Called when the visitor visits a LiteralExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitMakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.MakeRefExpressionSyntax)">
            <summary>Called when the visitor visits a MakeRefExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefTypeExpressionSyntax)">
            <summary>Called when the visitor visits a RefTypeExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.RefValueExpressionSyntax)">
            <summary>Called when the visitor visits a RefValueExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCheckedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedExpressionSyntax)">
            <summary>Called when the visitor visits a CheckedExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultExpressionSyntax)">
            <summary>Called when the visitor visits a DefaultExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeOfExpressionSyntax)">
            <summary>Called when the visitor visits a TypeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SizeOfExpressionSyntax)">
            <summary>Called when the visitor visits a SizeOfExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InvocationExpressionSyntax)">
            <summary>Called when the visitor visits a InvocationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ElementAccessExpressionSyntax)">
            <summary>Called when the visitor visits a ElementAccessExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax)">
            <summary>Called when the visitor visits a ArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBracketedArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax)">
            <summary>Called when the visitor visits a BracketedArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax)">
            <summary>Called when the visitor visits a ArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitNameColon(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax)">
            <summary>Called when the visitor visits a NameColonSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.CastExpressionSyntax)">
            <summary>Called when the visitor visits a CastExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousMethodExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousMethodExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a SimpleLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParenthesizedLambdaExpressionSyntax)">
            <summary>Called when the visitor visits a ParenthesizedLambdaExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInitializerExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Called when the visitor visits a InitializerExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectMemberDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAnonymousObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectCreationExpressionSyntax)">
            <summary>Called when the visitor visits a AnonymousObjectCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ImplicitArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a ImplicitArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitStackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.StackAllocArrayCreationExpressionSyntax)">
            <summary>Called when the visitor visits a StackAllocArrayCreationExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitQueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.QueryExpressionSyntax)">
            <summary>Called when the visitor visits a QueryExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitQueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Called when the visitor visits a QueryBodySyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFromClause(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax)">
            <summary>Called when the visitor visits a FromClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLetClause(Microsoft.CodeAnalysis.CSharp.Syntax.LetClauseSyntax)">
            <summary>Called when the visitor visits a LetClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitJoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinClauseSyntax)">
            <summary>Called when the visitor visits a JoinClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitJoinIntoClause(Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax)">
            <summary>Called when the visitor visits a JoinIntoClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitWhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.WhereClauseSyntax)">
            <summary>Called when the visitor visits a WhereClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOrderByClause(Microsoft.CodeAnalysis.CSharp.Syntax.OrderByClauseSyntax)">
            <summary>Called when the visitor visits a OrderByClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOrdering(Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax)">
            <summary>Called when the visitor visits a OrderingSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectClauseSyntax)">
            <summary>Called when the visitor visits a SelectClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitGroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.GroupClauseSyntax)">
            <summary>Called when the visitor visits a GroupClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitQueryContinuation(Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax)">
            <summary>Called when the visitor visits a QueryContinuationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOmittedArraySizeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.OmittedArraySizeExpressionSyntax)">
            <summary>Called when the visitor visits a OmittedArraySizeExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterpolatedStringExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringExpressionSyntax)">
            <summary>Called when the visitor visits a InterpolatedStringExpressionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterpolatedStringText(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringTextSyntax)">
            <summary>Called when the visitor visits a InterpolatedStringTextSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterpolation(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationSyntax)">
            <summary>Called when the visitor visits a InterpolationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterpolationAlignmentClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax)">
            <summary>Called when the visitor visits a InterpolationAlignmentClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterpolationFormatClause(Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax)">
            <summary>Called when the visitor visits a InterpolationFormatClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitGlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GlobalStatementSyntax)">
            <summary>Called when the visitor visits a GlobalStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBlock(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Called when the visitor visits a BlockSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LocalDeclarationStatementSyntax)">
            <summary>Called when the visitor visits a LocalDeclarationStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitVariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Called when the visitor visits a VariableDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitVariableDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax)">
            <summary>Called when the visitor visits a VariableDeclaratorSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Called when the visitor visits a EqualsValueClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionStatementSyntax)">
            <summary>Called when the visitor visits a ExpressionStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEmptyStatement(Microsoft.CodeAnalysis.CSharp.Syntax.EmptyStatementSyntax)">
            <summary>Called when the visitor visits a EmptyStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLabeledStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LabeledStatementSyntax)">
            <summary>Called when the visitor visits a LabeledStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitGotoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.GotoStatementSyntax)">
            <summary>Called when the visitor visits a GotoStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBreakStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BreakStatementSyntax)">
            <summary>Called when the visitor visits a BreakStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitContinueStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ContinueStatementSyntax)">
            <summary>Called when the visitor visits a ContinueStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ReturnStatementSyntax)">
            <summary>Called when the visitor visits a ReturnStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ThrowStatementSyntax)">
            <summary>Called when the visitor visits a ThrowStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitYieldStatement(Microsoft.CodeAnalysis.CSharp.Syntax.YieldStatementSyntax)">
            <summary>Called when the visitor visits a YieldStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitWhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.WhileStatementSyntax)">
            <summary>Called when the visitor visits a WhileStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.DoStatementSyntax)">
            <summary>Called when the visitor visits a DoStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForStatementSyntax)">
            <summary>Called when the visitor visits a ForStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ForEachStatementSyntax)">
            <summary>Called when the visitor visits a ForEachStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UsingStatementSyntax)">
            <summary>Called when the visitor visits a UsingStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.FixedStatementSyntax)">
            <summary>Called when the visitor visits a FixedStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCheckedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.CheckedStatementSyntax)">
            <summary>Called when the visitor visits a CheckedStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.UnsafeStatementSyntax)">
            <summary>Called when the visitor visits a UnsafeStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.LockStatementSyntax)">
            <summary>Called when the visitor visits a LockStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.IfStatementSyntax)">
            <summary>Called when the visitor visits a IfStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax)">
            <summary>Called when the visitor visits a ElseClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchStatementSyntax)">
            <summary>Called when the visitor visits a SwitchStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSwitchSection(Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax)">
            <summary>Called when the visitor visits a SwitchSectionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.CaseSwitchLabelSyntax)">
            <summary>Called when the visitor visits a CaseSwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDefaultSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.DefaultSwitchLabelSyntax)">
            <summary>Called when the visitor visits a DefaultSwitchLabelSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TryStatementSyntax)">
            <summary>Called when the visitor visits a TryStatementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax)">
            <summary>Called when the visitor visits a CatchClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax)">
            <summary>Called when the visitor visits a CatchDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax)">
            <summary>Called when the visitor visits a CatchFilterClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax)">
            <summary>Called when the visitor visits a FinallyClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCompilationUnit(Microsoft.CodeAnalysis.CSharp.Syntax.CompilationUnitSyntax)">
            <summary>Called when the visitor visits a CompilationUnitSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitExternAliasDirective(Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax)">
            <summary>Called when the visitor visits a ExternAliasDirectiveSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax)">
            <summary>Called when the visitor visits a UsingDirectiveSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitNamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NamespaceDeclarationSyntax)">
            <summary>Called when the visitor visits a NamespaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax)">
            <summary>Called when the visitor visits a AttributeListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAttributeTargetSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax)">
            <summary>Called when the visitor visits a AttributeTargetSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax)">
            <summary>Called when the visitor visits a AttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAttributeArgumentList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax)">
            <summary>Called when the visitor visits a AttributeArgumentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitNameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax)">
            <summary>Called when the visitor visits a NameEqualsSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax)">
            <summary>Called when the visitor visits a TypeParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax)">
            <summary>Called when the visitor visits a TypeParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitClassDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ClassDeclarationSyntax)">
            <summary>Called when the visitor visits a ClassDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitStructDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.StructDeclarationSyntax)">
            <summary>Called when the visitor visits a StructDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitInterfaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.InterfaceDeclarationSyntax)">
            <summary>Called when the visitor visits a InterfaceDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEnumDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DelegateDeclarationSyntax)">
            <summary>Called when the visitor visits a DelegateDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEnumMemberDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax)">
            <summary>Called when the visitor visits a EnumMemberDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBaseList(Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax)">
            <summary>Called when the visitor visits a BaseListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleBaseTypeSyntax)">
            <summary>Called when the visitor visits a SimpleBaseTypeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax)">
            <summary>Called when the visitor visits a TypeParameterConstraintClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConstructorConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorConstraintSyntax)">
            <summary>Called when the visitor visits a ConstructorConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.ClassOrStructConstraintSyntax)">
            <summary>Called when the visitor visits a ClassOrStructConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeConstraintSyntax)">
            <summary>Called when the visitor visits a TypeConstraintSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.FieldDeclarationSyntax)">
            <summary>Called when the visitor visits a FieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventFieldDeclarationSyntax)">
            <summary>Called when the visitor visits a EventFieldDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax)">
            <summary>Called when the visitor visits a ExplicitInterfaceSpecifierSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitMethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.MethodDeclarationSyntax)">
            <summary>Called when the visitor visits a MethodDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a OperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConversionOperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConstructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorDeclarationSyntax)">
            <summary>Called when the visitor visits a ConstructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConstructorInitializer(Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax)">
            <summary>Called when the visitor visits a ConstructorInitializerSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDestructorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.DestructorDeclarationSyntax)">
            <summary>Called when the visitor visits a DestructorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.PropertyDeclarationSyntax)">
            <summary>Called when the visitor visits a PropertyDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Called when the visitor visits a ArrowExpressionClauseSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.EventDeclarationSyntax)">
            <summary>Called when the visitor visits a EventDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerDeclarationSyntax)">
            <summary>Called when the visitor visits a IndexerDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAccessorList(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)">
            <summary>Called when the visitor visits a AccessorListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitAccessorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax)">
            <summary>Called when the visitor visits a AccessorDeclarationSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax)">
            <summary>Called when the visitor visits a ParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax)">
            <summary>Called when the visitor visits a BracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitParameter(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax)">
            <summary>Called when the visitor visits a ParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.IncompleteMemberSyntax)">
            <summary>Called when the visitor visits a IncompleteMemberSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitSkippedTokensTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.SkippedTokensTriviaSyntax)">
            <summary>Called when the visitor visits a SkippedTokensTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DocumentationCommentTriviaSyntax)">
            <summary>Called when the visitor visits a DocumentationCommentTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitTypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeCrefSyntax)">
            <summary>Called when the visitor visits a TypeCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitQualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.QualifiedCrefSyntax)">
            <summary>Called when the visitor visits a QualifiedCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitNameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.NameMemberCrefSyntax)">
            <summary>Called when the visitor visits a NameMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.IndexerMemberCrefSyntax)">
            <summary>Called when the visitor visits a IndexerMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.OperatorMemberCrefSyntax)">
            <summary>Called when the visitor visits a OperatorMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitConversionOperatorMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.ConversionOperatorMemberCrefSyntax)">
            <summary>Called when the visitor visits a ConversionOperatorMemberCrefSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCrefParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Called when the visitor visits a CrefParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCrefBracketedParameterList(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax)">
            <summary>Called when the visitor visits a CrefBracketedParameterListSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitCrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax)">
            <summary>Called when the visitor visits a CrefParameterSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementSyntax)">
            <summary>Called when the visitor visits a XmlElementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax)">
            <summary>Called when the visitor visits a XmlElementStartTagSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax)">
            <summary>Called when the visitor visits a XmlElementEndTagSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlEmptyElementSyntax)">
            <summary>Called when the visitor visits a XmlEmptyElementSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Called when the visitor visits a XmlNameSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlPrefix(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax)">
            <summary>Called when the visitor visits a XmlPrefixSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextAttributeSyntax)">
            <summary>Called when the visitor visits a XmlTextAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCrefAttributeSyntax)">
            <summary>Called when the visitor visits a XmlCrefAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameAttributeSyntax)">
            <summary>Called when the visitor visits a XmlNameAttributeSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlText(Microsoft.CodeAnalysis.CSharp.Syntax.XmlTextSyntax)">
            <summary>Called when the visitor visits a XmlTextSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlCDataSection(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCDataSectionSyntax)">
            <summary>Called when the visitor visits a XmlCDataSectionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlProcessingInstructionSyntax)">
            <summary>Called when the visitor visits a XmlProcessingInstructionSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitXmlComment(Microsoft.CodeAnalysis.CSharp.Syntax.XmlCommentSyntax)">
            <summary>Called when the visitor visits a XmlCommentSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.IfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a IfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElifDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElifDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitElseDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ElseDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ElseDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEndIfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndIfDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndIfDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.RegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a RegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitEndRegionDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.EndRegionDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a EndRegionDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitErrorDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ErrorDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ErrorDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.WarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a WarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitBadDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.BadDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a BadDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitDefineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.DefineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a DefineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitUndefDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.UndefDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a UndefDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitLineDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.LineDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a LineDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaWarningDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaWarningDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitPragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.PragmaChecksumDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a PragmaChecksumDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor.VisitReferenceDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ReferenceDirectiveTriviaSyntax)">
            <summary>Called when the visitor visits a ReferenceDirectiveTriviaSyntax node.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxWalker">
            <summary>
            Represents a <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxVisitor"/> that descends an entire <see cref="T:Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode"/> graph
            visiting each CSharpSyntaxNode and its child SyntaxNodes and <see cref="T:Microsoft.CodeAnalysis.SyntaxToken"/>s in depth-first order.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntaxFactory">
            <summary>
            A class containing factory methods for constructing syntax nodes, tokens and trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousMethodExpression">
            <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CarriageReturnLineFeed">
            <summary>
            A trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineFeed">
            <summary>
            A trivia with kind EndOfLineTrivia containing a single line feed character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CarriageReturn">
            <summary>
            A trivia with kind EndOfLineTrivia containing a single carriage return character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Space">
            <summary>
             A trivia with kind WhitespaceTrivia containing a single space character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Tab">
            <summary>
            A trivia with kind WhitespaceTrivia containing a single tab character.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticCarriageReturnLineFeed">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing both the carriage return and line feed characters.
            Elastic trivia are used to denote trivia that was not produced by parsing source text, and are usually not
            preserved during formatting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticLineFeed">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing a single line feed character. Elastic trivia are used
            to denote trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticCarriageReturn">
            <summary>
            An elastic trivia with kind EndOfLineTrivia containing a single carriage return character. Elastic trivia
            are used to denote trivia that was not produced by parsing source text, and are usually not preserved during
            formatting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticSpace">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing a single space character. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticTab">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing a single tab character. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticMarker">
            <summary>
            An elastic trivia with kind WhitespaceTrivia containing no characters. Elastic marker trivia are included
            automatically by factory methods when trivia is not specified. Syntax formatting will replace elastic
            markers with appropriate trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EndOfLine(System.String)">
            <summary>
            Creates a trivia with kind EndOfLineTrivia containing the specified text. 
            </summary>
            <param name="text">The text of the end of line. Any text can be specified here, however only carriage return and
            line feed characters are recognized by the parser as end of line.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticEndOfLine(System.String)">
            <summary>
            Creates a trivia with kind EndOfLineTrivia containing the specified text. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
            <param name="text">The text of the end of line. Any text can be specified here, however only carriage return and
            line feed characters are recognized by the parser as end of line.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Whitespace(System.String)">
            <summary>
            Creates a trivia with kind WhitespaceTrivia containing the specified text.
            </summary>
            <param name="text">The text of the whitespace. Any text can be specified here, however only specific
            whitespace characters are recognized by the parser.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElasticWhitespace(System.String)">
            <summary>
            Creates a trivia with kind WhitespaceTrivia containing the specified text. Elastic trivia are used to
            denote trivia that was not produced by parsing source text, and are usually not preserved during formatting.
            </summary>
            <param name="text">The text of the whitespace. Any text can be specified here, however only specific
            whitespace characters are recognized by the parser.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Comment(System.String)">
            <summary>
            Creates a trivia with kind either SingleLineCommentTrivia or MultiLineCommentTrivia containing the specified
            text.
            </summary>
            <param name="text">The entire text of the comment including the leading '//' token for single line comments
            or stop or start tokens for multiline comments.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DisabledText(System.String)">
            <summary>
            Creates a trivia with kind DisabledTextTrivia. Disabled text corresponds to any text between directives that
            is not considered active.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PreprocessingMessage(System.String)">
            <summary>
            Creates a trivia with kind PreprocessingMessageTrivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SyntaxTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.String)">
            <summary>
            Trivia nodes represents parts of the program text that are not parts of the
            syntactic grammar, such as spaces, newlines, comments, preprocessors
            directives, and disabled code.
            </summary>
            <param name="kind">
            A <cref c="SyntaxKind"/> representing the specific kind of SyntaxTrivia. One of
            WhitespaceTrivia, EndOfLineTrivia, CommentTrivia,
            DocumentationCommentExteriorTrivia, DisabledTextTrivia.
            </param>
            <param name="text">
            The actual text of this token.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Token(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Creates a token corresponding to a syntax kind. This method can be used for token syntax kinds whose text
            can be inferred by the kind alone.
            </summary>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Token(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token corresponding to syntax kind. This method can be used for token syntax kinds whose text can
            be inferred by the kind alone.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Token(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token corresponding to syntax kind. This method gives control over token Text and ValueText.
            
            For example, consider the text '&lt;see cref="operator &amp;#43;"/&gt;'.  To create a token for the value of
            the operator symbol (&amp;#43;), one would call 
            Token(default(SyntaxTriviaList), SyntaxKind.PlusToken, "&amp;#43;", "+", default(SyntaxTriviaList)).
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="text">The text from which this this token was created (e.g. lexed).</param>
            <param name="valueText">How C# should interpret the text of this token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MissingToken(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an
            expected token is not found. A missing token has no text and normally has associated diagnostics.
            </summary>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MissingToken(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a missing token corresponding to syntax kind. A missing token is produced by the parser when an
            expected token is not found. A missing token has no text and normally has associated diagnostics.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="kind">A syntax kind value for a token. These have the suffix Token or Keyword.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier(System.String)">
            <summary>
            Creates a token with kind IdentifierToken containing the specified text.
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind IdentifierToken containing the specified text.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VerbatimIdentifier(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a verbatim token with kind IdentifierToken containing the specified text.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character as it is in source.</param>
            <param name="valueText">The canonical value of the token's text.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Identifier(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind IdentifierToken containing the specified text.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="contextualKind">An alternative SyntaxKind that can be inferred for this token in special
            contexts. These are usually keywords.</param>
            <param name="text">The raw text of the identifier name, including any escapes or leading '@'
            character.</param>
            <param name="valueText">The text of the identifier name without escapes or leading '@' character.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Int32)">
            <summary>
            Creates a token with kind NumericLiteralToken from a 4-byte signed integer value.
            </summary>
            <param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Int32)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Int32,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte signed integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte signed integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.UInt32)">
            <summary>
            Creates a token with kind NumericLiteralToken from a 4-byte unsigned integer value.
            </summary>
            <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.UInt32)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte unsigned integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.UInt32,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteraToken from the text and corresponding 4-byte unsigned integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte unsigned integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Int64)">
            <summary>
            Creates a token with kind NumericLiteralToken from an 8-byte signed integer value.
            </summary>
            <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Int64)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Int64,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte signed integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte signed integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.UInt64)">
            <summary>
            Creates a token with kind NumericLiteralToken from an 8-byte unsigned integer value.
            </summary>
            <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.UInt64)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.UInt64,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte unsigned integer value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte unsigned integer value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Single)">
            <summary>
            Creates a token with kind NumericLiteralToken from a 4-byte floating point value.
            </summary>
            <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Single)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Single,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 4-byte floating point value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 4-byte floating point value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Double)">
            <summary>
            Creates a token with kind NumericLiteralToken from an 8-byte floating point value.
            </summary>
            <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Double)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Double,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding 8-byte floating point value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The 8-byte floating point value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Decimal)">
            <summary>
            Creates a token with kind NumericLiteralToken from a decimal value.
            </summary>
            <param name="value">The decimal value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Decimal)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.
            </summary>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The decimal value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Decimal,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind NumericLiteralToken from the text and corresponding decimal value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The decimal value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String)">
            <summary>
            Creates a token with kind StringLiteralToken from a string value.
            </summary>
            <param name="value">The string value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.String)">
            <summary>
            Creates a token with kind StringLiteralToken from the text and corresponding string value.
            </summary>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The string value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind StringLiteralToken from the text and corresponding string value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The string value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.Char)">
            <summary>
            Creates a token with kind CharacterLiteralToken from a character value.
            </summary>
            <param name="value">The character value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(System.String,System.Char)">
            <summary>
            Creates a token with kind CharacterLiteralToken from the text and corresponding character value.
            </summary>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The character value to be represented by the returned token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Literal(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Char,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind CharacterLiteralToken from the text and corresponding character value.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal, including quotes and escape sequences.</param>
            <param name="value">The character value to be represented by the returned token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BadToken(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind BadToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the bad token.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextLiteral(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlTextLiteralToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml text value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextNewLine(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlTextLiteralNewLineToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml text new line value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlEntity(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.String,Microsoft.CodeAnalysis.SyntaxTriviaList)">
            <summary>
            Creates a token with kind XmlEntityLiteralToken.
            </summary>
            <param name="leading">A list of trivia immediately preceding the token.</param>
            <param name="text">The raw text of the literal.</param>
            <param name="value">The xml entity value.</param>
            <param name="trailing">A list of trivia immediately following the token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DocumentationCommentExterior(System.String)">
            <summary>
            Creates a trivia with kind DocumentationCommentExteriorTrivia.
            </summary>
            <param name="text">The raw text of the literal.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.List``1">
            <summary>
            Creates an empty list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SingletonList``1(``0)">
            <summary>
            Creates a singleton list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="node">The single element node.</param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.List``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a list of syntax nodes.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of element nodes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TokenList">
            <summary>
            Creates an empty list of tokens.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TokenList(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Creates a singleton list of tokens.
            </summary>
            <param name="token">The single token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TokenList(Microsoft.CodeAnalysis.SyntaxToken[])">
            <summary>
            Creates a list of tokens.
            </summary>
            <param name="tokens">An array of tokens.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TokenList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a list of tokens.
            </summary>
            <param name="tokens"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Trivia(Microsoft.CodeAnalysis.CSharp.Syntax.StructuredTriviaSyntax)">
            <summary>
            Creates a trivia from a StructuredTriviaSyntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TriviaList">
            <summary>
            Creates an empty list of trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TriviaList(Microsoft.CodeAnalysis.SyntaxTrivia)">
            <summary>
            Creates a singleton list of trivia.
            </summary>
            <param name="trivia">A single trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TriviaList(Microsoft.CodeAnalysis.SyntaxTrivia[])">
            <summary>
            Creates a list of trivia.
            </summary>
            <param name="trivias">An array of trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TriviaList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxTrivia})">
            <summary>
            Creates a list of trivia.
            </summary>
            <param name="trivias">A sequence of trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SeparatedList``1">
            <summary>
            Creates an empty separated list.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SingletonSeparatedList``1(``0)">
            <summary>
            Creates a singleton separated list.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="node">A single node.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SeparatedList``1(System.Collections.Generic.IEnumerable{``0})">
            <summary>
            Creates a separated list of nodes from a sequence of nodes, synthesizing comma separators in between.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of syntax nodes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SeparatedList``1(System.Collections.Generic.IEnumerable{``0},System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxToken})">
            <summary>
            Creates a separated list of nodes from a sequence of nodes and a sequence of separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodes">A sequence of syntax nodes.</param>
            <param name="separators">A sequence of token to be interleaved between the nodes. The number of tokens must
            be one less than the number of nodes.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SeparatedList``1(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Creates a separated list from a sequence of nodes and tokens, starting with a node and alternating between additional nodes and separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodesAndTokens">A sequence of nodes or tokens, alternating between nodes and separator tokens.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SeparatedList``1(Microsoft.CodeAnalysis.SyntaxNodeOrTokenList)">
            <summary>
            Creates a separated list from a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/>, where the list elements start with a node and then alternate between
            additional nodes and separator tokens.
            </summary>
            <typeparam name="TNode">The specific type of the element nodes.</typeparam>
            <param name="nodesAndTokens">The list of nodes and tokens.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NodeOrTokenList">
            <summary>
            Creates an empty <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/>.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NodeOrTokenList(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.SyntaxNodeOrToken})">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> from a sequence of <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodesAndTokens">The sequence of nodes and tokens</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NodeOrTokenList(Microsoft.CodeAnalysis.SyntaxNodeOrToken[])">
            <summary>
            Create a <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrTokenList"/> from one or more <see cref="T:Microsoft.CodeAnalysis.SyntaxNodeOrToken"/>.
            </summary>
            <param name="nodesAndTokens">The nodes and tokens</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(System.String)">
            <summary>
            Creates an IdentifierNameSyntax node.
            </summary>
            <param name="name">The identifier name.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SyntaxTree(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.ParseOptions,System.String,System.Text.Encoding)">
            <summary>
            Create a new syntax tree from a syntax node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(System.String,Microsoft.CodeAnalysis.ParseOptions,System.String,System.Text.Encoding,System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseSyntaxTree(Microsoft.CodeAnalysis.Text.SourceText,Microsoft.CodeAnalysis.ParseOptions,System.String,System.Threading.CancellationToken)">
            <summary>
            Produces a syntax tree by parsing the source text.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseLeadingTrivia(System.String,System.Int32)">
            <summary>
            Parse a list of trivia rules for leading trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseLeadingTrivia(System.String,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions,System.Int32)">
            <summary>
            Parse a list of trivia rules for leading trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseTrailingTrivia(System.String,System.Int32)">
            <summary>
            Parse a list of trivia using the parsing rules for trailing trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseToken(System.String,System.Int32)">
            <summary>
            Parse a C# language token.
            </summary>
            <param name="text">The text of the token including leading and trailing trivia.</param>
            <param name="offset">Optional offset into text.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseTokens(System.String,System.Int32,System.Int32,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions)">
            <summary>
            Parse a sequence of C# language tokens.
            </summary>
            <param name="text">The text of all the tokens.</param>
            <param name="initialTokenPosition">An integer to use as the starting position of the first token.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">Parse options.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseName(System.String,System.Int32,System.Boolean)">
            <summary>
            Parse a NameSyntax node using the grammar rule for names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseTypeName(System.String,System.Int32,System.Boolean)">
            <summary>
            Parse a TypeNameSyntax node using the grammar rule for type names.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseExpression(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse an ExpressionSyntax node using the lowest precedence grammar rule for expressions.
            </summary>
            <param name="text">The text of the expression.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseStatement(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse a StatementSyntaxNode using grammar rule for statements.
            </summary>
            <param name="text">The text of the statement.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseCompilationUnit(System.String,System.Int32,Microsoft.CodeAnalysis.CSharp.CSharpParseOptions)">
            <summary>
            Parse a CompilationUnitSyntax using the grammar rule for an entire compilation unit (file). To produce a
            SyntaxTree instance, use CSharpSyntaxTree.ParseText instead.
            </summary>
            <param name="text">The text of the compilation unit.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseParameterList(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse a ParameterListSyntax node.
            </summary>
            <param name="text">The text of the parenthesized parameter list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseBracketedParameterList(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse a BracketedParameterListSyntax node.
            </summary>
            <param name="text">The text of the bracketed parameter list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseArgumentList(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse an ArgumentListSyntax node.
            </summary>
            <param name="text">The text of the parenthesized argument list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseBracketedArgumentList(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse a BracketedArgumentListSyntax node.
            </summary>
            <param name="text">The text of the bracketed argument list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParseAttributeArgumentList(System.String,System.Int32,Microsoft.CodeAnalysis.ParseOptions,System.Boolean)">
            <summary>
            Parse an AttributeArgumentListSyntax node.
            </summary>
            <param name="text">The text of the attribute argument list.</param>
            <param name="offset">Optional offset into text.</param>
            <param name="options">The optional parse options to use. If no options are specified default options are
            used.</param>
            <param name="consumeFullText">True if extra tokens in the input should be treated as an error</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MakeSourceText(System.String,System.Int32)">
            <summary>
            Helper method for wrapping a string in an SourceText.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxTree,Microsoft.CodeAnalysis.SyntaxTree,System.Boolean)">
            <summary>
            Determines if two trees are the same, disregarding trivia differences.
            </summary>
            <param name="oldTree">The original tree.</param>
            <param name="newTree">The new tree.</param>
            <param name="topLevel"> 
            If true then the trees are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Determines if two syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldNode">The old node.</param>
            <param name="newNode">The new node.</param>
            <param name="topLevel"> 
            If true then the nodes are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode,System.Func{Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Boolean})">
            <summary>
            Determines if two syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldNode">The old node.</param>
            <param name="newNode">The new node.</param>
            <param name="ignoreChildNode">
            If specified called for every child syntax node (not token) that is visited during the comparison. 
            It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Determines if two syntax tokens are the same, disregarding trivia differences.
            </summary>
            <param name="oldToken">The old token.</param>
            <param name="newToken">The new token.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>
            Determines if two lists of tokens are the same, disregarding trivia differences.
            </summary>
            <param name="oldList">The old token list.</param>
            <param name="newList">The new token list.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.SyntaxList{``0},System.Boolean)">
            <summary>
            Determines if two lists of syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldList">The old list.</param>
            <param name="newList">The new list.</param>
            <param name="topLevel"> 
            If true then the nodes are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.SyntaxList{``0},System.Func{Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Boolean})">
            <summary>
            Determines if two lists of syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldList">The old list.</param>
            <param name="newList">The new list.</param>
            <param name="ignoreChildNode">
            If specified called for every child syntax node (not token) that is visited during the comparison. 
            It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},System.Boolean)">
            <summary>
            Determines if two lists of syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldList">The old list.</param>
            <param name="newList">The new list.</param>
            <param name="topLevel"> 
            If true then the nodes are equivalent if the contained nodes and tokens declaring
            metadata visible symbolic information are equivalent, ignoring any differences of nodes inside method bodies
            or initializer expressions, otherwise all nodes and tokens must be equivalent. 
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AreEquivalent``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},System.Func{Microsoft.CodeAnalysis.CSharp.SyntaxKind,System.Boolean})">
            <summary>
            Determines if two lists of syntax nodes are the same, disregarding trivia differences.
            </summary>
            <param name="oldList">The old list.</param>
            <param name="newList">The new list.</param>
            <param name="ignoreChildNode">
            If specified called for every child syntax node (not token) that is visited during the comparison. 
            It it returns true the child is recursively visited, otherwise the child and its subtree is disregarded.
            </param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GetStandaloneExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Gets the containing expression that is actually a language expression and not just typed
            as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side
            of qualified names and member access expressions are not language expressions, yet the
            containing qualified names or member access expressions are indeed expressions.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GetStandaloneNode(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Gets the containing expression that is actually a language expression and not just typed
            as an ExpressionSyntax for convenience. For example, NameSyntax nodes on the right side
            of qualified names and member access expressions are not language expressions, yet the
            containing qualified names or member access expressions are indeed expressions.
            Similarly, if the input node is a cref part that is not independently meaningful, then
            the result will be the full cref.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FindConditionalAccessNodeForBinding(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Given a conditional binding expression, find corresponding conditional access node.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GetNonGenericExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Converts a generic name expression into one without the generic arguments.
            </summary>
            <param name="expression"></param>
            <returns></returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IsCompleteSubmission(Microsoft.CodeAnalysis.SyntaxTree)">
            <summary>
            Determines whether the given text is considered a syntactically complete submission.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new CaseSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultSwitchLabel">
            <summary>Creates a new DefaultSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Block(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax[])">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Block(System.Collections.Generic.IEnumerable{Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax})">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IdentifierName(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new IdentifierNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new QualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new QualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GenericName(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeArgumentListSyntax)">
            <summary>Creates a new GenericNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GenericName(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new GenericNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GenericName(System.String)">
            <summary>Creates a new GenericNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeArgumentList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TypeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax})">
            <summary>Creates a new TypeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AliasQualifiedName(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AliasQualifiedName(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new AliasQualifiedNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PredefinedType(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PredefinedTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArrayRankSpecifierSyntax})">
            <summary>Creates a new ArrayTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new ArrayTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayRankSpecifier(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayRankSpecifier(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax})">
            <summary>Creates a new ArrayRankSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PointerType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PointerTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PointerType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new PointerTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NullableType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new NullableTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NullableType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new NullableTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OmittedTypeArgument(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OmittedTypeArgument">
            <summary>Creates a new OmittedTypeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ParenthesizedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PrefixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new PrefixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AwaitExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AwaitExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AwaitExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AwaitExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PostfixUnaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new PostfixUnaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MemberAccessExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MemberAccessExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new MemberAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ConditionalAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConditionalAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ConditionalAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MemberBindingExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new MemberBindingExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MemberBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax)">
            <summary>Creates a new MemberBindingExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElementBindingExpression(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax)">
            <summary>Creates a new ElementBindingExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElementBindingExpression">
            <summary>Creates a new ElementBindingExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitElementAccess(Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax)">
            <summary>Creates a new ImplicitElementAccessSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitElementAccess">
            <summary>Creates a new ImplicitElementAccessSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new BinaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BinaryExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new BinaryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AssignmentExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AssignmentExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AssignmentExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConditionalExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ConditionalExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ThisExpression(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ThisExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ThisExpression">
            <summary>Creates a new ThisExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BaseExpression(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new BaseExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BaseExpression">
            <summary>Creates a new BaseExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new LiteralExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LiteralExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>Creates a new LiteralExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MakeRefExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MakeRefExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new MakeRefExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefTypeExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefTypeExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new RefTypeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefValueExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new RefValueExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RefValueExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new RefValueExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CheckedExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CheckedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CheckedExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new CheckedExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DefaultExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new DefaultExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeOfExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new TypeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SizeOfExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SizeOfExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new SizeOfExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax)">
            <summary>Creates a new InvocationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InvocationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new InvocationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax)">
            <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElementAccessExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ElementAccessExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArgumentList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax})">
            <summary>Creates a new ArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BracketedArgumentList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BracketedArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentSyntax})">
            <summary>Creates a new BracketedArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Argument(Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Argument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameColon(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new NameColonSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameColon(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)">
            <summary>Creates a new NameColonSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameColon(System.String)">
            <summary>Creates a new NameColonSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CastExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new CastExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CastExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new CastExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousMethodExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousMethodExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>Creates a new AnonymousMethodExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SimpleLambdaExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SimpleLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>Creates a new SimpleLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParenthesizedLambdaExpression(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>Creates a new ParenthesizedLambdaExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InitializerExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InitializerExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InitializerExpression(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax})">
            <summary>Creates a new InitializerExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ObjectCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new ObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousObjectMemberDeclarator(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AnonymousObjectMemberDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AnonymousObjectCreationExpression(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AnonymousObjectMemberDeclaratorSyntax})">
            <summary>Creates a new AnonymousObjectCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.ArrayTypeSyntax)">
            <summary>Creates a new ArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ImplicitArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.InitializerExpressionSyntax)">
            <summary>Creates a new ImplicitArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StackAllocArrayCreationExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StackAllocArrayCreationExpression(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new StackAllocArrayCreationExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryExpression(Microsoft.CodeAnalysis.CSharp.Syntax.FromClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Creates a new QueryExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryBody(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.QueryClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.QueryContinuationSyntax)">
            <summary>Creates a new QueryBodySyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryBody(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax)">
            <summary>Creates a new QueryBodySyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FromClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FromClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FromClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FromClause(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new FromClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LetClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new LetClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LetClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new LetClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LetClause(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new LetClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinClause(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.JoinIntoClauseSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinClause(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new JoinClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinIntoClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinIntoClause(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.JoinIntoClause(System.String)">
            <summary>Creates a new JoinIntoClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WhereClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new WhereClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WhereClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new WhereClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OrderByClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax})">
            <summary>Creates a new OrderByClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OrderByClause(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.OrderingSyntax})">
            <summary>Creates a new OrderByClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Ordering(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OrderingSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Ordering(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new OrderingSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SelectClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SelectClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SelectClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SelectClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GroupClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new GroupClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GroupClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new GroupClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryContinuation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Creates a new QueryContinuationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryContinuation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Creates a new QueryContinuationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QueryContinuation(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.QueryBodySyntax)">
            <summary>Creates a new QueryContinuationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OmittedArraySizeExpression(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OmittedArraySizeExpression">
            <summary>Creates a new OmittedArraySizeExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.InterpolatedStringContentSyntax})">
            <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolatedStringExpression(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolatedStringExpressionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolatedStringText(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolatedStringTextSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolatedStringText">
            <summary>Creates a new InterpolatedStringTextSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Interpolation(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Interpolation(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationAlignmentClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.InterpolationFormatClauseSyntax)">
            <summary>Creates a new InterpolationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Interpolation(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new InterpolationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolationAlignmentClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new InterpolationAlignmentClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolationFormatClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolationFormatClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterpolationFormatClause(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterpolationFormatClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GlobalStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new GlobalStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Block(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Block(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax})">
            <summary>Creates a new BlockSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LocalDeclarationStatement(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LocalDeclarationStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new LocalDeclarationStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclaratorSyntax})">
            <summary>Creates a new VariableDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VariableDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new VariableDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VariableDeclarator(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedArgumentListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VariableDeclarator(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.VariableDeclarator(System.String)">
            <summary>Creates a new VariableDeclaratorSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EqualsValueClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EqualsValueClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new EqualsValueClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ExpressionStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExpressionStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ExpressionStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EmptyStatement(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EmptyStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EmptyStatement">
            <summary>Creates a new EmptyStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LabeledStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LabeledStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LabeledStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LabeledStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LabeledStatement(System.String,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LabeledStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new GotoStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new GotoStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.GotoStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new GotoStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BreakStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new BreakStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BreakStatement">
            <summary>Creates a new BreakStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ContinueStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ContinueStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ContinueStatement">
            <summary>Creates a new ContinueStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ReturnStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ReturnStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ReturnStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ReturnStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ThrowStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ThrowStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ThrowStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ThrowStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.YieldStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new YieldStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.YieldStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new YieldStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WhileStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new WhileStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WhileStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new WhileStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DoStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DoStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DoStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new DoStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForEachStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForEachStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForEachStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ForEachStatement(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.String,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ForEachStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new UsingStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new UsingStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingStatement(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new UsingStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FixedStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new FixedStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FixedStatement(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new FixedStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CheckedStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new CheckedStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CheckedStatement(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new CheckedStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UnsafeStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new UnsafeStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UnsafeStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new UnsafeStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LockStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LockStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LockStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new LockStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IfStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax)">
            <summary>Creates a new IfStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ElseClauseSyntax)">
            <summary>Creates a new IfStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IfStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new IfStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElseClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ElseClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElseClause(Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax)">
            <summary>Creates a new ElseClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new SwitchStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SwitchSectionSyntax})">
            <summary>Creates a new SwitchStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchStatement(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new SwitchStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchSection(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.SwitchLabelSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.StatementSyntax})">
            <summary>Creates a new SwitchSectionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SwitchSection">
            <summary>Creates a new SwitchSectionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CaseSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CaseSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CaseSwitchLabel(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CaseSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DefaultSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefaultSwitchLabel(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DefaultSwitchLabelSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TryStatement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax)">
            <summary>Creates a new TryStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TryStatement(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.FinallyClauseSyntax)">
            <summary>Creates a new TryStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TryStatement(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CatchClauseSyntax})">
            <summary>Creates a new TryStatementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new CatchClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchClause(Microsoft.CodeAnalysis.CSharp.Syntax.CatchDeclarationSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.CatchFilterClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new CatchClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchClause">
            <summary>Creates a new CatchClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchDeclaration(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CatchDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CatchDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new CatchDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchFilterClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CatchFilterClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CatchFilterClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new CatchFilterClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FinallyClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new FinallyClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FinallyClause(Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new FinallyClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CompilationUnit(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CompilationUnitSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CompilationUnit(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new CompilationUnitSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CompilationUnit">
            <summary>Creates a new CompilationUnitSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExternAliasDirective(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExternAliasDirective(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExternAliasDirective(System.String)">
            <summary>Creates a new ExternAliasDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingDirective(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingDirective(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UsingDirective(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new UsingDirectiveSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NamespaceDeclaration(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExternAliasDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.UsingDirectiveSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NamespaceDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new NamespaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AttributeListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeList(Microsoft.CodeAnalysis.CSharp.Syntax.AttributeTargetSpecifierSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax})">
            <summary>Creates a new AttributeListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeSyntax})">
            <summary>Creates a new AttributeListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeTargetSpecifier(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeTargetSpecifier(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AttributeTargetSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Attribute(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentListSyntax)">
            <summary>Creates a new AttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Attribute(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new AttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeArgumentList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeArgumentList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeArgumentSyntax})">
            <summary>Creates a new AttributeArgumentListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.NameEqualsSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.NameColonSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AttributeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AttributeArgument(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new AttributeArgumentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new NameEqualsSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameEquals(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)">
            <summary>Creates a new NameEqualsSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameEquals(System.String)">
            <summary>Creates a new NameEqualsSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TypeParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterSyntax})">
            <summary>Creates a new TypeParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameter(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TypeParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameter(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new TypeParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameter(System.String)">
            <summary>Creates a new TypeParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassDeclaration(System.String)">
            <summary>Creates a new ClassDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StructDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StructDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StructDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.StructDeclaration(System.String)">
            <summary>Creates a new StructDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.MemberDeclarationSyntax})">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterfaceDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.InterfaceDeclaration(System.String)">
            <summary>Creates a new InterfaceDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BaseListSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.EnumMemberDeclarationSyntax})">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumDeclaration(System.String)">
            <summary>Creates a new EnumDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DelegateDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DelegateDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax})">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DelegateDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.String)">
            <summary>Creates a new DelegateDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumMemberDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumMemberDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EnumMemberDeclaration(System.String)">
            <summary>Creates a new EnumMemberDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BaseList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax})">
            <summary>Creates a new BaseListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BaseList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.BaseTypeSyntax})">
            <summary>Creates a new BaseListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SimpleBaseType(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new SimpleBaseTypeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterConstraintClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax})">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintSyntax})">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterConstraintClause(Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax)">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeParameterConstraintClause(System.String)">
            <summary>Creates a new TypeParameterConstraintClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorConstraint(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorConstraint">
            <summary>Creates a new ConstructorConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ClassOrStructConstraint(Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>Creates a new ClassOrStructConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeConstraint(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new TypeConstraintSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FieldDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new FieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FieldDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new FieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.FieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new FieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventFieldDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventFieldDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventFieldDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.VariableDeclarationSyntax)">
            <summary>Creates a new EventFieldDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ExplicitInterfaceSpecifier(Microsoft.CodeAnalysis.CSharp.Syntax.NameSyntax)">
            <summary>Creates a new ExplicitInterfaceSpecifierSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MethodDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MethodDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.TypeParameterConstraintClauseSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.MethodDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.String)">
            <summary>Creates a new MethodDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorDeclaration(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new ConversionOperatorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ConstructorInitializerSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorDeclaration(System.String)">
            <summary>Creates a new ConstructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorInitializer(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax)">
            <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConstructorInitializer(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.ArgumentListSyntax)">
            <summary>Creates a new ConstructorInitializerSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DestructorDeclaration(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DestructorDeclaration(System.String)">
            <summary>Creates a new DestructorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PropertyDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PropertyDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PropertyDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.String)">
            <summary>Creates a new PropertyDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrowExpressionClause(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ArrowExpressionClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ArrowExpressionClause(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>Creates a new ArrowExpressionClauseSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EventDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,System.String)">
            <summary>Creates a new EventDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IndexerDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IndexerDeclaration(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExplicitInterfaceSpecifierSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.BracketedParameterListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.AccessorListSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ArrowExpressionClauseSyntax)">
            <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IndexerDeclaration(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new IndexerDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AccessorList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AccessorListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AccessorList(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AccessorDeclarationSyntax})">
            <summary>Creates a new AccessorListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.AccessorDeclaration(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.CSharp.Syntax.BlockSyntax)">
            <summary>Creates a new AccessorDeclarationSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax})">
            <summary>Creates a new ParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BracketedParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new BracketedParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BracketedParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ParameterSyntax})">
            <summary>Creates a new BracketedParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Parameter(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.EqualsValueClauseSyntax)">
            <summary>Creates a new ParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.Parameter(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new ParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IncompleteMember(Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.AttributeListSyntax},Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new IncompleteMemberSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IncompleteMember(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new IncompleteMemberSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SkippedTokensTrivia(Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.SkippedTokensTrivia">
            <summary>Creates a new SkippedTokensTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new DocumentationCommentTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DocumentationCommentTrivia(Microsoft.CodeAnalysis.CSharp.SyntaxKind,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax})">
            <summary>Creates a new DocumentationCommentTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.TypeCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new TypeCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax)">
            <summary>Creates a new QualifiedCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.QualifiedCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.MemberCrefSyntax)">
            <summary>Creates a new QualifiedCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new NameMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.NameMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new NameMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IndexerMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax)">
            <summary>Creates a new IndexerMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IndexerMemberCref(Microsoft.CodeAnalysis.CSharp.Syntax.CrefBracketedParameterListSyntax)">
            <summary>Creates a new IndexerMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.OperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new OperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterListSyntax)">
            <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ConversionOperatorMemberCref(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new ConversionOperatorMemberCrefSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CrefParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax})">
            <summary>Creates a new CrefParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefBracketedParameterList(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new CrefBracketedParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefBracketedParameterList(Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.CrefParameterSyntax})">
            <summary>Creates a new CrefBracketedParameterListSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefParameter(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new CrefParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.CrefParameter(Microsoft.CodeAnalysis.CSharp.Syntax.TypeSyntax)">
            <summary>Creates a new CrefParameterSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlNodeSyntax},Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax)">
            <summary>Creates a new XmlElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementStartTagSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.XmlElementEndTagSyntax)">
            <summary>Creates a new XmlElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElementStartTag(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax})">
            <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElementStartTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Creates a new XmlElementStartTagSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElementEndTag(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlElementEndTag(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Creates a new XmlElementEndTagSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlEmptyElement(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax},Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.XmlAttributeSyntax})">
            <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlEmptyElement(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Creates a new XmlEmptyElementSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlName(Microsoft.CodeAnalysis.CSharp.Syntax.XmlPrefixSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlName(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlName(System.String)">
            <summary>Creates a new XmlNameSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlPrefix(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlPrefixSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlPrefix(Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlPrefixSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlPrefix(System.String)">
            <summary>Creates a new XmlPrefixSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlTextAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlTextAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlCrefAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlCrefAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.CrefSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlCrefAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.IdentifierNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlNameAttribute(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxToken,System.String,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlNameAttributeSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlText(Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>Creates a new XmlTextSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlText">
            <summary>Creates a new XmlTextSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlCDataSection(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlCDataSection(Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>Creates a new XmlCDataSectionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlProcessingInstruction(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax,Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlProcessingInstruction(Microsoft.CodeAnalysis.CSharp.Syntax.XmlNameSyntax)">
            <summary>Creates a new XmlProcessingInstructionSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlComment(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>Creates a new XmlCommentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.XmlComment(Microsoft.CodeAnalysis.SyntaxTokenList)">
            <summary>Creates a new XmlCommentSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new IfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.IfDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new IfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElifDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new ElifDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElifDirectiveTrivia(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax,System.Boolean,System.Boolean,System.Boolean)">
            <summary>Creates a new ElifDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElseDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean,System.Boolean)">
            <summary>Creates a new ElseDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ElseDirectiveTrivia(System.Boolean,System.Boolean)">
            <summary>Creates a new ElseDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EndIfDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new EndIfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EndIfDirectiveTrivia(System.Boolean)">
            <summary>Creates a new EndIfDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RegionDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new RegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.RegionDirectiveTrivia(System.Boolean)">
            <summary>Creates a new RegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EndRegionDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new EndRegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.EndRegionDirectiveTrivia(System.Boolean)">
            <summary>Creates a new EndRegionDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ErrorDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new ErrorDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ErrorDirectiveTrivia(System.Boolean)">
            <summary>Creates a new ErrorDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new WarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.WarningDirectiveTrivia(System.Boolean)">
            <summary>Creates a new WarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new BadDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.BadDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new BadDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.DefineDirectiveTrivia(System.String,System.Boolean)">
            <summary>Creates a new DefineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UndefDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UndefDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.UndefDirectiveTrivia(System.String,System.Boolean)">
            <summary>Creates a new UndefDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.LineDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new LineDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SeparatedSyntaxList{Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax},System.Boolean)">
            <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PragmaWarningDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaWarningDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaChecksumDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.PragmaChecksumDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new PragmaChecksumDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ReferenceDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new ReferenceDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxFactory.ReferenceDirectiveTrivia(Microsoft.CodeAnalysis.SyntaxToken,System.Boolean)">
            <summary>Creates a new ReferenceDirectiveTriviaSyntax instance.</summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.NamespaceDeclarationSyntaxReference">
            <summary>
            A SyntaxReference implementation that lazily translates the result (CSharpSyntaxNode) of the
            original syntax reference to a syntax reference for its NamespaceDeclarationSyntax.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SimpleSyntaxReference">
            <summary>
            this is a basic do-nothing implementation of a syntax reference
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.GetExpressionBodySyntax(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Gets the expression-body syntax from an expression-bodied member. The
            given syntax must be for a member which could contain an expression-body.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxToken,System.String,System.Boolean)">
            <summary>
            Creates a new syntax token with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <param name="token">The token to normalize.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.NormalizeWhitespace(Microsoft.CodeAnalysis.SyntaxTriviaList,System.String,System.Boolean)">
            <summary>
            Creates a new syntax trivia list with all whitespace and end of line trivia replaced with
            regularly formatted trivia.
            </summary>
            <param name="list">The trivia list to normalize.</param>
            <param name="indentation">An optional sequence of whitespace characters that defines a
            single level of indentation.</param>
            <param name="elasticTrivia">If true the replaced trivia is elastic trivia.</param>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxExtensions.WithIdentifier(Microsoft.CodeAnalysis.CSharp.Syntax.SimpleNameSyntax,Microsoft.CodeAnalysis.SyntaxToken)">
            <summary>
            Updates the given SimpleNameSyntax node with the given identifier token.
            This function is a wrapper that calls WithIdentifier on derived syntax nodes.
            </summary>
            <param name="simpleName"></param>
            <param name="identifier"></param>
            <returns>The given simple name updated with the given identifier.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the specified node represents a lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.GetLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Given a node that represents a lambda body returns a node that represents the lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.TryGetCorrespondingLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            See SyntaxNode.GetCorrespondingLambdaBody.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambdaBody(Microsoft.CodeAnalysis.SyntaxNode,System.Boolean)">
            <summary>
            Returns true if the specified <paramref name="node"/> represents a body of a lambda.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsReducedSelectOrGroupByClause(Microsoft.CodeAnalysis.CSharp.Syntax.SelectOrGroupClauseSyntax,Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            When queries are translated into expressions select and group-by expressions such that
            1) select/group-by expression is the same identifier as the "source" identifier and
            2) at least one Where or OrderBy clause but no other clause is present in the contained query body or
               the expression in question is a group-by expression and the body has no clause
            
            do not translate into lambdas.
            By "source" identifier we mean the identifier specified in the from clause that initiates the query or the query continuation that includes the body.
            
            The above condition can be dervied from the language specification (chapter 7.16.2) as follows:
            - In order for 7.16.2.5 "Select clauses" to be applicable the following conditions must hold:
              - There has to be at least one clause in the body, otherwise the query is reduced into a final form by 7.16.2.3 "Degenerate query expressions".
              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 "From, let, where, join and orderby clauses"
                produces pattern that doesn't match the requirements of 7.16.2.5.
              
            - In order for 7.16.2.6 "Groupby clauses" to be applicable the following conditions must hold:
              - Only where and order-by clauses may be present in the query body, otherwise a transformation in 7.16.2.4 "From, let, where, join and orderby clauses"
                produces pattern that doesn't match the requirements of 7.16.2.5.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsLambdaBodyStatementOrExpression(Microsoft.CodeAnalysis.SyntaxNode)">
            <remarks>
            In C# lambda bodies are expressions or block statements. In both cases it's a single node.
            In VB a lambda body might be a sequence of nodes (statements). 
            We define this function to minimize differences between C# and VB implementation.
            </remarks>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.TryGetLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode@,Microsoft.CodeAnalysis.SyntaxNode@)">
            <summary>
            If the specified node represents a lambda returns a node (or nodes) that represent its body (bodies).
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.AreEquivalentIgnoringLambdaBodies(Microsoft.CodeAnalysis.SyntaxNode,Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Compares content of two nodes ignoring lambda bodies and trivia.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsQueryPairLambda(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            "Pair lambda" is a synthesized lambda that creates an instance of an anonymous type representing a pair of values. 
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.LambdaUtilities.IsClosureScope(Microsoft.CodeAnalysis.SyntaxNode)">
            <summary>
            Returns true if the specified node can represent a closure scope -- that is a scope of a captured variable.
            Doesn't validate whether or not the node actually declares any captured variable.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxNodeExtensions.CanHaveAssociatedLocalBinder(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            This method is used to keep the code that generates binders in sync
            with the code that searches for binders.  We don't want the searcher
            to skip over any nodes that could have associated binders, especially
            if changes are made later.
            
            "Local binder" is a vague term that refers to binders that represent
            scopes for names (e.g. BlockBinders) rather than binders that tweak
            default behaviors (e.g. FieldInitializerBinders).  Local binders are
            created by LocalBinderFactory.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxNodeExtensions.ExtractAnonymousTypeMemberName(Microsoft.CodeAnalysis.CSharp.Syntax.ExpressionSyntax)">
            <summary>
            Given an initializer expression infer the name of anonymous property.
            Returns default(SyntaxToken) if unsuccessful
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.CSharp.SyntaxTreeDiagnosticEnumerator">
            <summary>
            An enumerator for diagnostic lists.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.SyntaxTreeDiagnosticEnumerator.MoveNext">
            <summary>
            Moves the enumerator to the next diagnostic instance in the diagnostic list.
            </summary>
            <returns>Returns true if enumerator moved to the next diagnostic, false if the
            enumerator was at the end of the diagnostic list.</returns>
        </member>
        <member name="P:Microsoft.CodeAnalysis.CSharp.SyntaxTreeDiagnosticEnumerator.Current">
            <summary>
            The current diagnostic that the enumerator is pointing at.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharp.CSharpDeclarationComputer.GetExpressionBodySyntax(Microsoft.CodeAnalysis.CSharp.CSharpSyntaxNode)">
            <summary>
            Gets the expression-body syntax from an expression-bodied member. The
            given syntax must be for a member which could contain an expression-body.
            </summary>
        </member>
        <member name="T:Microsoft.CodeAnalysis.Diagnostics.CSharp.CSharpCompilerDiagnosticAnalyzer">
            <summary>
            DiagnosticAnalyzer for C# compiler's syntax/semantic/compilation diagnostics.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns the index of the first node of a specified kind in the node list.
            </summary>
            <param name="list">Node list.</param>
            <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> to find.</param>
            <returns>Returns non-negative index if the list contains a node which matches <paramref name="kind"/>, -1 otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            True if the list has at least one node of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns the index of the first node of a specified kind in the node list.
            </summary>
            <param name="list">Node list.</param>
            <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> to find.</param>
            <returns>Returns non-negative index if the list contains a node which matches <paramref name="kind"/>, -1 otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.Any``1(Microsoft.CodeAnalysis.SeparatedSyntaxList{``0},Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            True if the list has at least one node of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns the index of the first trivia of a specified kind in the trivia list.
            </summary>
            <param name="list">Trivia list.</param>
            <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> to find.</param>
            <returns>Returns non-negative index if the list contains a trivia which matches <paramref name="kind"/>, -1 otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTriviaList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            True if the list has at least one trivia of the specified kind.
            </summary>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.IndexOf(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Returns the index of the first token of a specified kind in the token list.
            </summary>
            <param name="list">Token list.</param>
            <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> to find.</param>
            <returns>Returns non-negative index if the list contains a token which matches <paramref name="kind"/>, -1 otherwise.</returns>
        </member>
        <member name="M:Microsoft.CodeAnalysis.CSharpExtensions.Any(Microsoft.CodeAnalysis.SyntaxTokenList,Microsoft.CodeAnalysis.CSharp.SyntaxKind)">
            <summary>
            Tests whether a list contains a token of a particular kind.
            </summary>
            <param name="list"></param>
            <param name="kind">The <see cref="T:Microsoft.CodeAnalysis.CSharp.SyntaxKind"/> to test for.</param>
            <returns>Returns true if the list contains a token which matches <paramref name="kind"/></returns>
        </member>
    </members>
</doc>
