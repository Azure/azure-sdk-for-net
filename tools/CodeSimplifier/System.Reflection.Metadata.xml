<?xml version="1.0"?>
<doc>
    <assembly>
        <name>System.Reflection.Metadata</name>
    </assembly>
    <members>
        <member name="T:System.Reflection.Metadata.MetadataResources">
            <summary>
              A strongly-typed resource class, for looking up localized strings, etc.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.ResourceManager">
            <summary>
              Returns the cached ResourceManager instance used by this class.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.Culture">
            <summary>
              Overrides the current thread's CurrentUICulture property for all
              resource lookups using this strongly typed resource class.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.AssemblyTableInvalidNumberOfRows">
            <summary>
              Looks up a localized string similar to Invalid number of rows of Assembly table: {0}..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.CantGetOffsetForVirtualHeapHandle">
            <summary>
              Looks up a localized string similar to Can&apos;t get a heap offset for a virtual heap handle.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.EnCMapNotSorted">
            <summary>
              Looks up a localized string similar to EnCMap table not sorted or has missing records..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.HandleBelongsToFutureGeneration">
            <summary>
              Looks up a localized string similar to Handle belongs to a future generation.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.IllegalTablesInCompressedMetadataStream">
            <summary>
              Looks up a localized string similar to Illegal tables in compressed metadata stream..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.ImageTooSmall">
            <summary>
              Looks up a localized string similar to Image is too small..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.ImageTooSmallOrContainsInvalidOffsetOrCount">
            <summary>
              Looks up a localized string similar to Image is either too small or contains an invalid byte offset or count..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidCodedIndex">
            <summary>
              Looks up a localized string similar to Invalid coded index..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidCompressedInteger">
            <summary>
              Looks up a localized string similar to Invalid compressed integer..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidCorHeaderSize">
            <summary>
              Looks up a localized string similar to Invalid COR header size..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidHandle">
            <summary>
              Looks up a localized string similar to Invalid handle..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidLocalSignatureToken">
            <summary>
              Looks up a localized string similar to Invalid local signature token: 0x{0:X8}.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidMetadataSectionSpan">
            <summary>
              Looks up a localized string similar to Invalid metadata section span..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidMetadataStreamFormat">
            <summary>
              Looks up a localized string similar to Invalid Metadata stream format..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidMethodHeader1">
            <summary>
              Looks up a localized string similar to Invalid method header: 0x{0:X2}.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidMethodHeader2">
            <summary>
              Looks up a localized string similar to Invalid method header: 0x{0:X2} 0x{1:X2}.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidMethodRva">
            <summary>
              Looks up a localized string similar to Invalid relative virtual address (RVA): 0x{0:X8}.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidNumberOfSections">
            <summary>
              Looks up a localized string similar to Invalid number of sections in declared in PE header..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidPESignature">
            <summary>
              Looks up a localized string similar to Invalid PE signature..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidRowCount">
            <summary>
              Looks up a localized string similar to Invalid row count: {0}.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidSectionName">
            <summary>
              Looks up a localized string similar to Invalid section name.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidSehHeader">
            <summary>
              Looks up a localized string similar to Invalid SEH header: 0x{0:X2}.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidSerializedString">
            <summary>
              Looks up a localized string similar to Invalid serialized string..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidSignature">
            <summary>
              Looks up a localized string similar to Invalid signature..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidToken">
            <summary>
              Looks up a localized string similar to Invalid token..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.InvalidTypeSize">
            <summary>
              Looks up a localized string similar to Invalid type size..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.LitteEndianArchitectureRequired">
            <summary>
              Looks up a localized string similar to Little-endian architecture required..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.MetadataHeaderTooSmall">
            <summary>
              Looks up a localized string similar to Metadata header too small..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.MetadataImageDoesNotRepresentAnAssembly">
            <summary>
              Looks up a localized string similar to Metadata image doesn&apos;t represent an assembly..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.MetadataSignature">
            <summary>
              Looks up a localized string similar to Invalid COR20 header signature..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.MetadataStringDecoderEncodingMustBeUtf8">
            <summary>
              Looks up a localized string similar to The MetadataStringDecoder instance used to instantiate the Metadata reader must have a UTF8 encoding..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.MetadataTableHeaderTooSmall">
            <summary>
              Looks up a localized string similar to Metadata table header too small..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.MetadataTableNotSorted">
            <summary>
              Looks up a localized string similar to Metadata table 0x{0:x2} not sorted..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.MetadataTablesTooSmall">
            <summary>
              Looks up a localized string similar to Metadata tables too small..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.MissingDataDirectory">
            <summary>
              Looks up a localized string similar to Missing data directory..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.ModuleTableInvalidNumberOfRows">
            <summary>
              Looks up a localized string similar to Invalid number of rows of Module table: {0}..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.NegativeByteCountOrOffset">
            <summary>
              Looks up a localized string similar to Negative byte count or offset..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.NotEnoughSpaceForBlobStream">
            <summary>
              Looks up a localized string similar to Not enough space for Blob stream..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.NotEnoughSpaceForGUIDStream">
            <summary>
              Looks up a localized string similar to Not enough space for GUID stream..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.NotEnoughSpaceForMetadataStream">
            <summary>
              Looks up a localized string similar to Not enough space for Metadata stream..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.NotEnoughSpaceForStreamHeaderName">
            <summary>
              Looks up a localized string similar to Not enough space for stream header name..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.NotEnoughSpaceForStringStream">
            <summary>
              Looks up a localized string similar to Not enough space for String stream..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.NotEnoughSpaceForVersionString">
            <summary>
              Looks up a localized string similar to Not enough space for version string..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.NotMetadataHeapHandle">
            <summary>
              Looks up a localized string similar to Specified handle is not a valid metadata heap handle..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.NotMetadataTableHandle">
            <summary>
              Looks up a localized string similar to Specified handle is not a valid metadata table handle..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.NotMetadataTableOrUserStringHandle">
            <summary>
              Looks up a localized string similar to Specified handle is not a valid metadata table or UserString heap handle..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.OutOfBoundsRead">
            <summary>
              Looks up a localized string similar to Read out of bounds..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.PEImageDoesNotHaveMetadata">
            <summary>
              Looks up a localized string similar to PE image does not have metadata..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.PEImageNotAvailable">
            <summary>
              Looks up a localized string similar to PE image not available..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.RowIdOrHeapOffsetTooLarge">
            <summary>
              Looks up a localized string similar to Row ID or heap offset is too large..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.SectionTooSmall">
            <summary>
              Looks up a localized string similar to Section too small..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.StreamHeaderTooSmall">
            <summary>
              Looks up a localized string similar to Stream header too small..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.StreamMustSupportReadAndSeek">
            <summary>
              Looks up a localized string similar to Stream must support read and seek operations..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.StreamTooLarge">
            <summary>
              Looks up a localized string similar to Stream length minus starting position is too large to hold a PEImage..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.TableRowCountSpaceTooSmall">
            <summary>
              Looks up a localized string similar to Table row count space to small..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.UnableToReadMetadataFile">
            <summary>
              Looks up a localized string similar to Unable to read metadata file..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.UnexpectedStreamEnd">
            <summary>
              Looks up a localized string similar to Unexpected stream end..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.UnknownFileFormat">
            <summary>
              Looks up a localized string similar to Unknown file format..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.UnknownPEMagicValue">
            <summary>
              Looks up a localized string similar to Unknown PE Magic value..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.UnknownTables">
            <summary>
              Looks up a localized string similar to Unknown tables: 0x{0:x16}..
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataResources.WinMDMissingMscorlibRef">
            <summary>
              Looks up a localized string similar to Missing mscorlib reference in AssemblyRef table..
            </summary>
        </member>
        <member name="T:System.Reflection.Internal.AbstractMemoryBlock">
            <summary>
            Represents a disposable blob of memory accessed via unsafe pointer.
            </summary>
        </member>
        <member name="M:System.Reflection.Internal.AbstractMemoryBlock.GetContent(System.Int32)">
            <summary>
            Returns the content of the memory block. 
            </summary>
            <remarks>
            Only creates a copy of the data if they are not represented by a managed byte array, or the offset is non-zero.
            </remarks>
        </member>
        <member name="M:System.Reflection.Internal.AbstractMemoryBlock.Dispose">
            <summary>
            Disposes the block. 
            </summary>
            <remarks>
            The operation is idempotent, but must not be called concurrently with any other operations on the block
            or with another call to Dispose.
            
            Using the block after dispose is an error in our code and therefore no effort is made to throw a tidy 
            ObjectDisposedException and null ref or AV is possible.
            </remarks>
        </member>
        <member name="P:System.Reflection.Internal.AbstractMemoryBlock.Pointer">
            <summary>
            Pointer to the underlying data (not valid after disposal).
            </summary>
        </member>
        <member name="T:System.Reflection.Internal.ByteArrayMemoryBlock">
            <summary>
            Represents a memory block backed by an array of bytes.
            </summary>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlockProvider.GetMemoryBlock">
            <summary>
            Creates and hydrates a memory block representing all data.
            </summary>
            <exception cref="T:System.IO.IOException">Error while reading from the memory source.</exception>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlockProvider.GetMemoryBlock(System.Int32,System.Int32)">
            <summary>
            Creates and hydrates a memory block representing data in the specified range.
            </summary>
            <param name="start">Starting offset relative to the beginning of the data represented by this provider.</param>
            <param name="size">Size of the resulting block.</param>
            <exception cref="T:System.IO.IOException">Error while reading from the memory source.</exception>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlockProvider.GetStream(System.Reflection.Internal.StreamConstraints@)">
            <summary>
            Gets a seekable and readable <see cref="T:System.IO.Stream"/> that can be used to read all data.
            The operations on the stream has to be done under a lock of <see cref="F:System.Reflection.Internal.StreamConstraints.GuardOpt"/> if non-null.
            The image starts at <see cref="F:System.Reflection.Internal.StreamConstraints.ImageStart"/> and has size <see cref="F:System.Reflection.Internal.StreamConstraints.ImageSize"/>.
            It is the caller's responsibility not to read outside those bounds.
            </summary>
        </member>
        <member name="P:System.Reflection.Internal.MemoryBlockProvider.Size">
            <summary>
            The size of the data.
            </summary>
        </member>
        <member name="T:System.Reflection.Internal.ExternalMemoryBlock">
            <summary>
            Class representing raw memory but not owning the memory.
            </summary>
        </member>
        <member name="T:System.Reflection.Internal.ExternalMemoryBlockProvider">
            <summary>
            Represents raw memory owned by an external object. 
            </summary>
        </member>
        <member name="T:System.Reflection.Internal.NativeHeapMemoryBlock">
            <summary>
            Represents memory block allocated on native heap.
            </summary>
            <remarks>
            Owns the native memory resource.
            </remarks>
        </member>
        <member name="T:System.Reflection.Internal.StreamMemoryBlockProvider">
            <summary>
            Represents data read from a stream.
            </summary>
            <remarks>
            Uses memory map to load data from streams backed by files that are bigger than <see cref="F:System.Reflection.Internal.StreamMemoryBlockProvider.MemoryMapThreshold"/>.
            </remarks>
        </member>
        <member name="M:System.Reflection.Internal.StreamMemoryBlockProvider.GetMemoryBlockImpl(System.Int32,System.Int32)">
            <exception cref="T:System.IO.IOException">Error while reading from the stream.</exception>
        </member>
        <member name="T:System.Reflection.Internal.EncodingHelper">
             <summary>
             Provides helpers to decode strings from unmanaged memory to System.String while avoiding
             intermediate allocation.
             
             This has three components:
             
               (1) Light-up Encoding.GetString(byte*, int) via reflection and resurface it as extension 
                   method. 
            
                   This is a new API that will provide API convergence across all platforms for 
                   this scenario. It is already on .NET 4.6+ and ASP.NET vNext, but not yet available 
                   on every platform we support. See below for how we fall back.
            
               (2) Deal with WinRT prefixes. 
            
                  When reading managed winmds with projections enabled, the metadata   reader needs to prepend 
                  a WinRT prefix in some case . Doing this without allocation poses a problem
                  as we don't have the prefix and input in contiguous data that we can pass to the
                  Encoding.GetString. We handle this case using pooled managed scratch buffers where we copy
                  the prefix and input and decode using Encoding.GetString(byte[], int, int).
            
               (3) Deal with platforms that don't yet have Encoding.GetString(byte*, int). 
               
                  If we're running on a full framework earlier than 4.6, we will bind to the internal
                  String.CreateStringFromEncoding which is equivalent and Encoding.GetString is just a trivial 
                  wrapper around it in .NET 4.6. This means that we always have the fast path on every
                  full framework version we support.
            
                  If we can't bind to it via reflection, then we emulate it using what is effectively (2) and 
                  with an empty prefix. 
            
             For both (2) and (3), the pooled buffers have a fixed size deemed large enough for the
             vast majority of metadata strings. In the rare worst case (byteCount > threshold and
             (lightUpAttemptFailed || prefix != null), we give up and allocate a temporary array,
             copy to it, decode, and throw it away.
             </summary>
        </member>
        <member name="T:System.Reflection.Internal.ImmutableByteArrayInterop">
             <summary>
             Provides tools for using <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> in interop scenarios.
             </summary>
             <remarks>
             *** WARNING *** 
             
             If you decide to copy this code elsewhere, please retain the documentation here
             and the Dangerous prefixes in the API names. This will help track down and audit
             other places where this technique (with dangerous consequences when misused) may
             be applied.
            
             A generic version of this API was once public in a pre-release of immutable 
             collections, but  it was deemed to be too subject to abuse when available publicly.
             
             This implementation is scoped to byte arrays as that is all that the metadata reader needs.
             
             Also, since we don't have access to immutable collection internals, we use a trick involving
             overlapping a <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> with a <see cref="T:Byte[]"/> refer. While
             unverifiable, it is valid. See Ecma 335, section II.10.7 Controlling instance layout:
             
             "It is possible to overlap fields in this way, though offsets occupied by an object reference 
             shall not overlap with offsets occupied by a built-in value type or a part of
             another object reference. While one object reference can completely overlap another, this is
             unverifiable."
             
             Furthermore, the fact that <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> backed by a single <see cref="T:Byte[]"/> 
             field is something inherent to the design of ImmutableArray in order to get its performance
             characteristics and therefore something we (Microsoft) are comfortable defining as a contract that 
             can be depended upon as below.
             </remarks>
        </member>
        <member name="M:System.Reflection.Internal.ImmutableByteArrayInterop.DangerousCreateFromUnderlyingArray(System.Byte[]@)">
            <summary>
            Creates a new instance of <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> using a given mutable array as the backing
            field, without creating a defensive copy. It is the responsibility of the caller to ensure no other mutable 
            references exist to the array.  Do not mutate the array after calling this method.
            </summary>
            <param name="array">The mutable array to use as the backing field. The incoming reference is set to null 
            since it should not be retained by the caller.</param>
            <remarks>
            Users of this method should take extra care to ensure that the mutable array given as a parameter
            is never modified. The returned <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> will use the given array as its backing
            field without creating a defensive copy, so changes made to the given mutable array will be observable
            on the returned <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.  Instance and static methods of <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>
            and <see cref="T:System.Collections.Immutable.ImmutableArray"/> may malfunction if they operate on an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> instance
            whose underlying backing field is modified. 
            </remarks>
            <returns>An immutable array.</returns>
        </member>
        <member name="M:System.Reflection.Internal.ImmutableByteArrayInterop.DangerousGetUnderlyingArray(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Access the backing mutable array instance for the given <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>, without
            creating a defensive copy.  It is the responsibility of the caller to ensure the array is not modified
            through the returned mutable reference.  Do not mutate the returned array.
            </summary>
            <param name="array">The <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> from which to retrieve the backing field.</param>
            <remarks>
            Users of this method should take extra care to ensure that the returned mutable array is never modified.
            The returned mutable array continues to be used as the backing field of the given <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>
            without creating a defensive copy, so changes made to the returned mutable array will be observable
            on the given <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>.  Instance and static methods of <see cref="T:System.Collections.Immutable.ImmutableArray`1"/>
            and <see cref="T:System.Collections.Immutable.ImmutableArray"/> may malfunction if they operate on an <see cref="T:System.Collections.Immutable.ImmutableArray`1"/> instance
            whose underlying backing field is modified. 
            </remarks>
            <returns>The underlying array, or null if <see cref="P:System.Collections.Immutable.ImmutableArray`1.IsDefault"/> is true.</returns>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.PeekCompressedInteger(System.Int32,System.Int32@)">
            <summary>
            Decodes a compressed integer value starting at offset. 
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
            <param name="offset">Offset to the start of the compressed data.</param>
            <param name="numberOfBytesRead">Bytes actually read.</param>
            <returns>
            Value between 0 and 0x1fffffff, or <see cref="F:System.Reflection.Metadata.BlobReader.InvalidCompressedInteger"/> if the value encoding is invalid.
            </returns>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.PeekUtf8NullTerminated(System.Int32,System.Byte[],System.Reflection.Metadata.MetadataStringDecoder,System.Int32@,System.Char)">
            <summary>
            Read UTF8 at the given offset up to the given terminator, null terminator, or end-of-block.
            </summary>
            <param name="offset">Offset in to the block where the UTF8 bytes start.</param>
            <param name="prefix">UTF8 encoded prefix to prepend to the bytes at the offset before decoding.</param>
            <param name="utf8Decoder">The UTF8 decoder to use that allows user to adjust fallback and/or reuse existing strings without allocating a new one.</param>
            <param name="numberOfBytesRead">The number of bytes read, which includes the terminator if we did not hit the end of the block.</param>
            <param name="terminator">A character in the ASCII range that marks the end of the string. 
            If a value other than '\0' is passed we still stop at the null terminator if encountered first.</param>
            <returns>The decoded string.</returns>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.GetUtf8NullTerminatedLength(System.Int32,System.Int32@,System.Char)">
            <summary>
            Get number of bytes from offset to given terminator, null terminator, or end-of-block (whichever comes first).
            Returned length does not include the terminator, but numberOfBytesRead out parameter does.
            </summary>
            <param name="offset">Offset in to the block where the UTF8 bytes start.</param>
            <param name="terminator">A character in the ASCII range that marks the end of the string. 
            If a value other than '\0' is passed we still stop at the null terminator if encountered first.</param>
            <param name="numberOfBytesRead">The number of bytes read, which includes the terminator if we did not hit the end of the block.</param>
            <returns>Length (byte count) not including terminator.</returns>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.BinarySearchReferenceRange(System.Int32,System.Int32,System.Int32,System.UInt32,System.Boolean,System.Int32@,System.Int32@)">
            <summary>
            Calculates a range of rows that have specified value in the specified column in a table that is sorted by that column.
            </summary>
        </member>
        <member name="M:System.Reflection.Internal.MemoryBlock.BinarySearchReferenceRange(System.Int32[],System.Int32,System.Int32,System.UInt32,System.Boolean,System.Int32@,System.Int32@)">
            <summary>
            Calculates a range of rows that have specified value in the specified column in a table that is sorted by that column.
            </summary>
        </member>
        <member name="T:System.Reflection.Internal.ObjectPool`1">
            <summary>
            Generic implementation of object pooling pattern with predefined pool size limit. The main
            purpose is that limited number of frequently used objects can be kept in the pool for
            further recycling.
            
            Notes: 
            1) it is not the goal to keep all returned objects. Pool is not meant for storage. If there
               is no space in the pool, extra returned objects will be dropped.
            
            2) it is implied that if object was obtained from a pool, the caller will return it back in
               a relatively short time. Keeping checked out objects for long durations is ok, but 
               reduces usefulness of pooling. Just new up your own.
            
            Not returning objects to the pool in not detrimental to the pool's work, but is a bad practice. 
            Rationale: 
               If there is no intent for reusing the object, do not use pool - just use "new". 
            </summary>
        </member>
        <member name="M:System.Reflection.Internal.ObjectPool`1.Allocate">
            <summary>
            Produces an instance.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search.
            </remarks>
        </member>
        <member name="M:System.Reflection.Internal.ObjectPool`1.Free(`0)">
            <summary>
            Returns objects to the pool.
            </summary>
            <remarks>
            Search strategy is a simple linear probing which is chosen for it cache-friendliness.
            Note that Free will try to store recycled objects close to the start thus statistically 
            reducing how far we will typically search in Allocate.
            </remarks>
        </member>
        <member name="M:System.Reflection.Internal.StreamExtensions.CopyTo(System.IO.Stream,System.Byte*,System.Int32)">
            <summary>
            Copies specified amount of data from given stream to a target memory pointer.
            </summary>
            <exception cref="T:System.IO.IOException">unexpected stream end.</exception>
        </member>
        <member name="P:System.Reflection.Metadata.AssemblyFile.ContainsMetadata">
            <summary>
            True if the file contains metadata.
            </summary>
            <remarks>
            Corresponds to Flags field of File table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.AssemblyFile.Name">
            <summary>
            File name with extension.
            </summary>
            <remarks>
            Corresponds to Name field of File table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.AssemblyFile.HashValue">
            <summary>
            Hash value of the file content calculated using <see cref="P:System.Reflection.Metadata.AssemblyDefinition.HashAlgorithm"/>.
            </summary>
            <remarks>
            Corresponds to HashValue field of File table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="F:System.Reflection.Metadata.BlobReader._nullCharArray">
            <summary>An array containing the '\0' character.</summary>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF8(System.Int32)">
            <summary>
            Reads UTF8 encoded string starting at the current position. 
            </summary>
            <param name="byteCount">The number of bytes to read.</param>
            <returns>The string.</returns>
            <exception cref="T:System.BadImageFormatException"><paramref name="byteCount"/> bytes not available.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadUTF16(System.Int32)">
            <summary>
            Reads UTF16 (little-endian) encoded string starting at the current position. 
            </summary>
            <param name="byteCount">The number of bytes to read.</param>
            <returns>The string.</returns>
            <exception cref="T:System.BadImageFormatException"><paramref name="byteCount"/> bytes not available.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadBytes(System.Int32)">
            <summary>
            Reads bytes starting at the current position. 
            </summary>
            <param name="byteCount">The number of bytes to read.</param>
            <returns>The byte array.</returns>
            <exception cref="T:System.BadImageFormatException"><paramref name="byteCount"/> bytes not available.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedInteger(System.Int32@)">
            <summary>
            Reads an unsigned compressed integer value. 
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
            <param name="value">The value of the compressed integer that was read.</param>
            <returns>true if the value was read successfully. false if the data at the current position was not a valid compressed integer.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedInteger">
            <summary>
            Reads an unsigned compressed integer value. 
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
            <returns>The value of the compressed integer that was read.</returns>
            <exception cref="T:System.BadImageFormatException">The data at the current position was not a valid compressed integer.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.TryReadCompressedSignedInteger(System.Int32@)">
            <summary>
            Reads a signed compressed integer value. 
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
            <param name="value">The value of the compressed integer that was read.</param>
            <returns>true if the value was read successfully. false if the data at the current position was not a valid compressed integer.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadCompressedSignedInteger">
            <summary>
            Reads a signed compressed integer value. 
            See Metadata Specification section II.23.2: Blobs and signatures.
            </summary>
            <returns>The value of the compressed integer that was read.</returns>
            <exception cref="T:System.BadImageFormatException">The data at the current position was not a valid compressed integer.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializationTypeCode">
            <summary>
            Reads type code encoded in a serialized custom attribute value. 
            </summary>
            <returns><see cref="F:System.Reflection.Metadata.SerializationTypeCode.Invalid"/> if the encoding is invalid.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadSignatureTypeCode">
            <summary>
            Reads type code encoded in a signature. 
            </summary>
            <returns><see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid"/> if the encoding is invalid.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadSerializedString">
            <summary>
            Reads a string encoded as a compressed integer containing its length followed by
            its contents in UTF8. Null strings are encoded as a single 0xFF byte.
            </summary>
            <remarks>Defined as a 'SerString' in the Ecma CLI specification.</remarks>
            <returns>String value or null.</returns>
            <exception cref="T:System.BadImageFormatException">If the encoding is invalid.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.BlobReader.ReadTypeHandle">
            <summary>
            Reads a type handle encoded in a signature as TypeDefOrRefOrSpecEncoded (see ECMA-335 II.23.2.8).
            </summary>
            <returns>The handle or nil if the encoding is invalid.</returns>
        </member>
        <member name="P:System.Reflection.Metadata.Constant.TypeCode">
            <summary>
            The type of the constant value.
            </summary>
            <remarks>
            Corresponds to Type field of Constant table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.Constant.Value">
            <summary>
            The constant value.
            </summary>
            <remarks>
            Corresponds to Value field of Constant table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.Constant.Parent">
            <summary>
            The parent handle (<see cref="T:System.Reflection.Metadata.ParameterHandle"/>, <see cref="T:System.Reflection.Metadata.FieldDefinitionHandle"/>, or <see cref="T:System.Reflection.Metadata.PropertyDefinitionHandle"/>).
            </summary>
            <remarks>
            Corresponds to Parent field of Constant table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.CustomAttribute.Constructor">
            <summary>
            The constructor (<see cref="T:System.Reflection.Metadata.MethodDefinitionHandle"/> or <see cref="T:System.Reflection.Metadata.MemberReferenceHandle"/>) of the custom attribute type.
            </summary>
            <remarks>
            Corresponds to Type field of CustomAttribute table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.CustomAttribute.Parent">
            <summary>
            The handle of the metadata entity the attribute is applied to.
            </summary>
            <remarks>
            Corresponds to Parent field of CustomAttribute table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.CustomAttribute.Value">
            <summary>
            The value of the attribute.
            </summary>
            <remarks>
            Corresponds to Value field of CustomAttribute table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions">
            <summary>
            Provides an extension method to access the TypeDefinitionId column of the ExportedType table.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.ExportedTypeExtensions.GetTypeDefinitionId(System.Reflection.Metadata.ExportedType)">
            <summary>
            Gets a hint at the likely row number of the target type in the TypeDef table of its module. 
            If the namespaces and names do not match, resolution falls back to a full search of the 
            target TypeDef table. Ignored and should be zero if <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder"/> is
            true.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions">
            <summary>
            Provides extension methods for working with certain raw elements of the Ecma 335 metadata tables and heaps.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowCount(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
            <summary>
            Returns the number of rows in the specified table.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="tableIndex"/> is not a valid table index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableRowSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
            <summary>
            Returns the size of a row in the specified table.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="tableIndex"/> is not a valid table index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTableMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.TableIndex)">
            <summary>
            Returns the offset from the start of metadata to the specified table.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="tableIndex"/> is not a valid table index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapSize(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
            <summary>
            Returns the size of the specified heap.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="heapIndex"/> is not a valid heap index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetHeapMetadataOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
            <summary>
            Returns the offset from the start of metadata to the specified heap.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="heapIndex"/> is not a valid heap index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetMetadataBlock(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Ecma335.HeapIndex)">
            <summary>
            Returns the size of the specified heap.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="heapIndex"/> is not a valid heap index.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.UserStringHandle)">
            <summary>
            Returns the a handle to the UserString that follows the given one in the UserString heap or a nil handle if it is the last one.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.BlobHandle)">
            <summary>
            Returns the a handle to the Blob that follows the given one in the Blob heap or a nil handle if it is the last one.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetNextHandle(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.StringHandle)">
            <summary>
            Returns the a handle to the String that follows the given one in the String heap or a nil handle if it is the last one.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueLogEntries(System.Reflection.Metadata.MetadataReader)">
            <summary>
            Enumerates entries of EnC log.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception> 
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetEditAndContinueMapEntries(System.Reflection.Metadata.MetadataReader)">
            <summary>
            Enumerates entries of EnC map.
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="reader"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithProperties(System.Reflection.Metadata.MetadataReader)">
            <summary>
            Enumerate types that define one or more properties. 
            </summary>
            <returns>
            The resulting sequence corresponds exactly to entries in PropertyMap table, 
            i.e. n-th returned <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/> is stored in n-th row of PropertyMap.
            </returns>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataReaderExtensions.GetTypesWithEvents(System.Reflection.Metadata.MetadataReader)">
            <summary>
            Enumerate types that define one or more events. 
            </summary>
            <returns>
            The resulting sequence corresponds exactly to entries in EventMap table, 
            i.e. n-th returned <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/> is stored in n-th row of EventMap.
            </returns>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.TableCount">
            <summary>
            Maximum number of tables that can be present in Ecma335 metadata.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.MetadataTokens.HeapCount">
            <summary>
            Maximum number of tables that can be present in Ecma335 metadata.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)">
            <summary>
            Returns the row number of a metadata table entry that corresponds 
            to the specified <paramref name="handle"/> in the context of <paramref name="reader"/>.
            </summary>
            <returns>One based row number.</returns>
            <exception cref="T:System.ArgumentException">The <paramref name="handle"/> is not a valid metadata table handle.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
            <summary>
            Returns the offset of metadata heap data that corresponds 
            to the specified <paramref name="handle"/> in the context of <paramref name="reader"/>.
            </summary>
            <returns>Zero based offset, or -1 if <paramref name="handle"/> isn't a metadata heap handle.</returns>
            <exception cref="T:System.NotSupportedException">The operation is not supported for the specified <paramref name="handle"/>.</exception>
            <exception cref="T:System.ArgumentException">The <paramref name="handle"/> is invalid.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)">
            <summary>
            Returns the metadata token of the specified <paramref name="handle"/> in the context of <paramref name="reader"/>.
            </summary>
            <returns>Metadata token.</returns>
            <exception cref="T:System.ArgumentException">
            Handle represents a metadata entity that doesn't have a token.
            A token can only be retrieved for a metadata table handle or a heap handle of type <see cref="F:System.Reflection.Metadata.HandleKind.UserString"/>.
            </exception>
            <exception cref="T:System.NotSupportedException">The operation is not supported for the specified <paramref name="handle"/>.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.EntityHandle)">
            <summary>
            Returns the row number of a metadata table entry that corresponds 
            to the specified <paramref name="handle"/>.
            </summary>
            <returns>
            One based row number, or -1 if <paramref name="handle"/> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetRowNumber(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.EntityHandle)"/>.
            </returns>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.Handle)">
            <summary>
            Returns the offset of metadata heap data that corresponds 
            to the specified <paramref name="handle"/>.
            </summary>
            <returns>
            Zero based offset, or -1 if <paramref name="handle"/> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetHeapOffset(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)"/>.
            </returns>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.Handle)">
            <summary>
            Returns the metadata token of the specified <paramref name="handle"/>.
            </summary>
            <returns>
            Metadata token, or 0 if <paramref name="handle"/> can only be interpreted in a context of a specific <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            See <see cref="M:System.Reflection.Metadata.Ecma335.MetadataTokens.GetToken(System.Reflection.Metadata.MetadataReader,System.Reflection.Metadata.Handle)"/>.
            </returns>
            <exception cref="T:System.ArgumentException">
            Handle represents a metadata entity that doesn't have a token.
            A token can only be retrieved for a metadata table handle or a heap handle of type <see cref="F:System.Reflection.Metadata.HandleKind.UserString"/>.
            </exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetTableIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.TableIndex@)">
            <summary>
            Gets the <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex"/> of the table corresponding to the specified <see cref="T:System.Reflection.Metadata.HandleKind"/>.
            </summary>
            <param name="type">Handle type.</param>
            <param name="index">Table index.</param>
            <returns>True if the handle type corresponds to an Ecma335 table, false otherwise.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.TryGetHeapIndex(System.Reflection.Metadata.HandleKind,System.Reflection.Metadata.Ecma335.HeapIndex@)">
            <summary>
            Gets the <see cref="T:System.Reflection.Metadata.Ecma335.HeapIndex"/> of the heap corresponding to the specified <see cref="T:System.Reflection.Metadata.HandleKind"/>.
            </summary>
            <param name="type">Handle type.</param>
            <param name="index">Heap index.</param>
            <returns>True if the handle type corresponds to an Ecma335 heap, false otherwise.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Int32)">
            <summary>
            Creates a handle from a token value.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="token"/> is not a valid metadata token.
            It must encode a metadata table entity or an offset in <see cref="F:System.Reflection.Metadata.HandleKind.UserString"/> heap.
            </exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.EntityHandle(System.Int32)">
            <summary>
            Creates an entity handle from a token value.
            </summary>
            <exception cref="T:System.ArgumentException"><paramref name="token"/> is not a valid metadata entity token.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.MetadataTokens.Handle(System.Reflection.Metadata.Ecma335.TableIndex,System.Int32)">
            <summary>
            Creates a handle from a token value.
            </summary>
            <exception cref="T:System.ArgumentException">
            <paramref name="tableIndex"/> is not a valid table index.</exception>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.TryOffset">
            <summary>
            Start IL offset of the try block.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.TryLength">
            <summary>
            Length in bytes of try block.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerOffset">
            <summary>
            Start IL offset of the exception handler.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.HandlerLength">
            <summary>
            Length in bytes of the exception handler.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.FilterOffset">
            <summary>
            IL offset of the start of the filter block, or -1 if the region is not a filter.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExceptionRegion.CatchType">
            <summary>
            Returns a TypeRef, TypeDef, or TypeSpec handle if the region represents a catch, nil token otherwise. 
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExportedType.Name">
            <summary>
            Name of the target type, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExportedType.Namespace">
            <summary>
            Full name of the namespace where the target type, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExportedType.NamespaceDefinition">
            <summary>
            The definition handle of the namespace where the target type is defined, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ExportedType.Implementation">
            <summary>
            Handle to resolve the implementation of the target type.
            </summary>
            <returns>
            <list type="bullet">
            <item><description><see cref="T:System.Reflection.Metadata.AssemblyFileHandle"/> representing another module in the assembly.</description></item>
            <item><description><see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle"/> representing another assembly if <see cref="P:System.Reflection.Metadata.ExportedType.IsForwarder"/> is true.</description></item>
            <item><description><see cref="T:System.Reflection.Metadata.ExportedTypeHandle"/> representing the declaring exported type in which this was is nested.</description></item>
            </list>
            </returns>
        </member>
        <member name="M:System.Reflection.Metadata.FieldDefinition.GetOffset">
            <summary>
            Returns field layout offset, or -1 if not available.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameter.Parent">
            <summary>
            <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/> or <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle"/>.
            </summary>
            <remarks>
            Corresponds to Owner field of GenericParam table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameter.Attributes">
            <summary>
            Attributes specifying variance and constraints.
            </summary>
            <remarks>
            Corresponds to Flags field of GenericParam table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameter.Index">
            <summary>
            Zero-based index of the parameter within the declaring generic type or method declaration.
            </summary>
            <remarks>
            Corresponds to Number field of GenericParam table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameter.Name">
            <summary>
            The name of the generic parameter.
            </summary>
            <remarks>
            Corresponds to Name field of GenericParam table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Parameter">
            <summary>
            The constrained <see cref="T:System.Reflection.Metadata.GenericParameterHandle"/>.
            </summary>
            <remarks>
            Corresponds to Owner field of GenericParamConstraint table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.GenericParameterConstraint.Type">
            <summary>
            Handle (<see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/>, or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle"/>) 
            specifying from which type this generic parameter is constrained to derive,
            or which interface this generic parameter is constrained to implement.
            </summary>
            <remarks>
            Corresponds to Constraint field of GenericParamConstraint table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.GenericParameterHandleCollection">
            <summary>
            Represents generic type parameters of a method or type.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.GenericParameterConstraintHandleCollection">
            <summary>
            Represents constraints of a generic type parameter.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.ParameterHandleCollection">
            <summary>
            Collection of parameters of a specified method.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.TypeDefinitionHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.TypeReferenceHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/>.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.ExportedTypeHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/>.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.MemberReferenceHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.MemberReferenceHandle"/>.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.AssemblyReferenceHandleCollection">
            <summary>
            Collection of assembly references.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.ManifestResourceHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.ManifestResourceHandle"/>.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.AssemblyFileHandleCollection">
            <summary>
            Represents a collection of <see cref="T:System.Reflection.Metadata.AssemblyFileHandle"/>.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)">
            <summary>
            Compares two handles.
            </summary>
            <remarks>
            The order of handles that differ in kind is undefined.
            Returns 0 if and only if <see cref="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.Handle,System.Reflection.Metadata.Handle)"/> returns true.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.HandleComparer.Compare(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)">
            <summary>
            Compares two entity handles.
            </summary>
            <remarks>
            The order of handles that differ in kind is undefined.
            Returns 0 if and only if <see cref="M:System.Reflection.Metadata.HandleComparer.Equals(System.Reflection.Metadata.EntityHandle,System.Reflection.Metadata.EntityHandle)"/> returns true.
            </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.Handle">
            <summary>
            Represents any metadata entity (type reference/definition/specification, method definition, custom attribute, etc.) or value (string, blob, guid, user string).
            </summary>
            <remarks>
            Use <see cref="T:System.Reflection.Metadata.Handle"/> to store multiple kinds of handles.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.Handle.FromVToken(System.UInt32)">
            <summary>
            Creates <see cref="T:System.Reflection.Metadata.Handle"/> from a token or a token combined with a virtual flag.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Handle.EntityHandleType">
            <summary>
            Token type (0x##000000), does not include virtual flag.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Handle.Type">
            <summary>
            Small token type (0x##), does not include virtual flag.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Handle.EntityHandleValue">
            <summary>
            Value stored in an <see cref="T:System.Reflection.Metadata.EntityHandle"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Handle.SpecificEntityHandleValue">
            <summary>
            Value stored in a concrete entity handle (see <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle"/>, etc.).
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.EntityHandle">
            <summary>
            Represents a metadata entity (type reference/definition/specification, method definition, custom attribute, etc.). 
            </summary>
            <remarks>
            Use <see cref="T:System.Reflection.Metadata.EntityHandle"/> to store multiple kinds of entity handles.
            It has smaller memory footprint than <see cref="T:System.Reflection.Metadata.Handle"/>.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.EntityHandle.SpecificHandleValue">
            <summary>
            Value stored in a specific entity handle (see <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>, <see cref="T:System.Reflection.Metadata.MethodDefinitionHandle"/>, etc.).
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.NamespaceDefinitionHandle">
            <summary>
            A handle that represents a namespace definition. 
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.InterfaceImplementation.Interface">
            <summary>
            The interface that is implemented
            <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/>, or <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle"/>
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.StringStreamReader.EqualsRaw(System.Reflection.Metadata.StringHandle,System.String)">
            <summary>
            Returns true if the given raw (non-virtual) handle represents the same string as given ASCII string.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.StringStreamReader.IndexOfRaw(System.Int32,System.Char)">
            <summary>
            Returns the heap index of the given ASCII character or -1 if not found prior null terminator or end of heap.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.StringStreamReader.StartsWithRaw(System.Reflection.Metadata.StringHandle,System.String)">
            <summary>
            Returns true if the given raw (non-virtual) handle represents a string that starts with given ASCII prefix.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.StringStreamReader.BinarySearchRaw(System.String[],System.Reflection.Metadata.StringHandle)">
            <summary>
            Equivalent to Array.BinarySearch, searches for given raw (non-virtual) handle in given array of ASCII strings.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.HandleType.VirtualBit">
            <summary>
            Use the highest bit to mark tokens that are virtual (synthesized).
            We create virtual tokens to represent projected WinMD entities. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.TokenTypeIds.VirtualBit">
            <summary>
            Use the highest bit to mark tokens that are virtual (synthesized).
            We create virtual tokens to represent projected WinMD entities. 
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.TokenTypeIds.IsEntityOrUserStringToken(System.UInt32)">
            <summary>
            Returns true if the token value can escape the metadata reader.
            We don't allow virtual tokens and heap tokens other than UserString to escape 
            since the token type ids are internal to the reader and not specified by ECMA spec.
            
            Spec (Partition III, 1.9 Metadata tokens):
            Many CIL instructions are followed by a "metadata token". This is a 4-byte value, that specifies a row in a
            metadata table, or a starting byte offset in the User String heap. 
            
            For example, a value of 0x02 specifies the TypeDef table; a value of 0x70 specifies the User
            String heap.The value corresponds to the number assigned to that metadata table (see Partition II for the full
            list of tables) or to 0x70 for the User String heap.The least-significant 3 bytes specify the target row within that
            metadata table, or starting byte offset within the User String heap.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.GetSimpleName(System.Reflection.Metadata.NamespaceDefinitionHandle,System.Int32)">
             <summary>
             This will return a StringHandle for the simple name of a namespace name at the given segment index.
             If no segment index is passed explicitly or the "segment" index is greater than or equal to the number
             of segments, then the last segment is used. "Segment" in this context refers to part of a namespace
             name between dots.
            
             Example: Given a NamespaceDefinitionHandle to "System.Collections.Generic.Test" called 'handle':
            
               reader.GetString(GetSimpleName(handle)) == "Test"
               reader.GetString(GetSimpleName(handle, 0)) == "System"
               reader.GetString(GetSimpleName(handle, 1)) == "Collections"
               reader.GetString(GetSimpleName(handle, 2)) == "Generic"
               reader.GetString(GetSimpleName(handle, 3)) == "Test"
               reader.GetString(GetSimpleName(handle, 1000)) == "Test"
             </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.PopulateNamespaceTable">
            <summary>
            Two distinct namespace handles represent the same namespace if their full names are the same. This
            method merges builders corresponding to such namespace handles.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.MergeDuplicateNamespaces(System.Collections.Generic.Dictionary{System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder},System.Collections.Generic.Dictionary{System.String,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder}@)">
            <summary>
            This will take 'table' and merge all of the NamespaceData instances that point to the same
            namespace. It has to create 'stringTable' as an intermediate dictionary, so it will hand it
            back to the caller should the caller want to use it.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.SynthesizeNamespaceData(System.String,System.Reflection.Metadata.NamespaceDefinitionHandle)">
            <summary>
            Creates a NamespaceDataBuilder instance that contains a synthesized NamespaceDefinitionHandle, 
            as well as the name provided.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.LinkChildDataToParentData(System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder)">
            <summary>
            Quick convenience method that handles linking together child + parent
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.LinkChildToParentNamespace(System.Collections.Generic.Dictionary{System.String,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder},System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder,System.Collections.Generic.List{System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder}@)">
            <summary>
            Links a child to its parent namespace. If the parent namespace doesn't exist, this will create a
            synthetic one. This will automatically link any synthetic namespaces it creates up to its parents.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.ResolveParentChildRelationships(System.Collections.Generic.Dictionary{System.String,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder},System.Collections.Generic.List{System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder}@)">
            <summary>
            This will link all parents/children in the given namespaces dictionary up to each other.
            
            In some cases, we need to synthesize namespaces that do not have any type definitions or forwarders
            of their own, but do have child namespaces. These are returned via the syntheticNamespaces out
            parameter.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.PopulateTableWithTypeDefinitions(System.Collections.Generic.Dictionary{System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder})">
            <summary>
            Loops through all type definitions in metadata, adding them to the given table
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.PopulateTableWithExportedTypes(System.Collections.Generic.Dictionary{System.Reflection.Metadata.NamespaceDefinitionHandle,System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder})">
            <summary>
            Loops through all type forwarders in metadata, adding them to the given table
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.PopulateNamespaceList">
            <summary>
            Populates namespaceList with distinct namespaces. No ordering is guaranteed.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.EnsureNamespaceTableIsPopulated">
            <summary>
            If the namespace table doesn't exist, populates it!
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.EnsureNamespaceListIsPopulated">
            <summary>
            If the namespace list doesn't exist, populates it!
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.Ecma335.NamespaceCache.CacheIsRealized">
            <summary>
            Returns whether the namespaceTable has been created. If it hasn't, calling a GetXXX method
            on this will probably have a very high amount of overhead.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder">
            <summary>
            An intermediate class used to build NamespaceData instances. This was created because we wanted to
            use ImmutableArrays in NamespaceData, but having ArrayBuilders and ImmutableArrays that served the
            same purpose in NamespaceData got ugly. With the current design of how we create our Namespace
            dictionary, this needs to be a class because we have a many-to-one mapping between NamespaceHandles
            and NamespaceData. So, the pointer semantics must be preserved.
            
            This class assumes that the builders will not be modified in any way after the first call to
            Freeze().
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.NamespaceCache.NamespaceDataBuilder.Freeze">
            <summary>
            Returns a NamespaceData that represents this NamespaceDataBuilder instance. After calling
            this method, it is an error to use any methods or fields except Freeze() on the target 
            NamespaceDataBuilder.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.Ecma335.FieldLayoutTableReader.FindFieldLayoutRowId(System.Reflection.Metadata.FieldDefinitionHandle)">
            <summary>
            Returns field offset for given field RowId, or -1 if not available. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.Ecma335.AssemblyRefTableReader.NumberOfNonVirtualRows">
            <summary>
            In CLI metadata equal to the actual number of entries in AssemblyRef table.
            In WinMD metadata it includes synthesized AssemblyRefs in addition.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.ManifestResource.Offset">
            <summary>
            Specifies the byte offset within the referenced file at which this resource record begins.
            </summary>
            <remarks>
            Corresponds to Offset field of ManifestResource table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.ManifestResource.Attributes">
            <summary>
            Resource attributes.
            </summary>
            <remarks>
            Corresponds to Flags field of ManifestResource table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.ManifestResource.Name">
            <summary>
            Name of the resource.
            </summary>
            <remarks>
            Corresponds to Name field of ManifestResource table in ECMA-335 Standard.
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.ManifestResource.Implementation">
            <summary>
            <see cref="T:System.Reflection.Metadata.AssemblyFileHandle"/>, <see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle"/>, or nil handle.
            </summary>
            <remarks>
            Corresponds to Implementation field of ManifestResource table in ECMA-335 Standard.
            
            If nil then <see cref="P:System.Reflection.Metadata.ManifestResource.Offset"/> is an offset in the PE image that contains the metadata, 
            starting from the Resource entry in the CLI header.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.MemberReference.GetKind">
            <summary>
            Determines if the member reference is to a method or field.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MemberReference.Parent">
            <summary>
            MethodDef, ModuleRef,TypeDef, TypeRef, or TypeSpec handle.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.MemberReferenceKind">
            <summary>
            Indicates whether a MemberReference references a method or field.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MemberReferenceKind.Method">
            <summary>
            The MemberReference references a method.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MemberReferenceKind.Field">
            <summary>
            The MemberReference references a field.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataKind.Ecma335">
            <summary>
            CLI metadata.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataKind.WindowsMetadata">
            <summary>
            Windows Metadata.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataKind.ManagedWindowsMetadata">
            <summary>
            Windows Metadata generated by managed compilers.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.MetadataReader">
            <summary>
            Reads metadata as defined byte the ECMA 335 CLI specification.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32)">
            <summary>
            Creates a metadata reader from the metadata stored at the given memory location.
            </summary>
            <remarks>
            The memory is owned by the caller and it must be kept memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions)">
            <summary>
            Creates a metadata reader from the metadata stored at the given memory location.
            </summary>
            <remarks>
            The memory is owned by the caller and it must be kept memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            Use <see cref="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)"/> to obtain 
            metadata from a PE image.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.#ctor(System.Byte*,System.Int32,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
            <summary>
            Creates a metadata reader from the metadata stored at the given memory location.
            </summary>
            <remarks>
            The memory is owned by the caller and it must be kept memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.Metadata.MetadataReader"/>.
            Use <see cref="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)"/> to obtain 
            metadata from a PE image.
            </remarks>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataReader.IsMinimalDelta">
            <summary>
            True if the metadata stream has minimal delta format. Used for EnC.
            </summary>
            <remarks>
            The metadata stream has minimal delta format if "#JTD" stream is present.
            Minimal delta format uses large size (4B) when encoding table/heap references.
            The heaps in minimal delta only contain data of the delta, 
            there is no padding at the beginning of the heaps that would align them 
            with the original full metadata heaps.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.ReadMetadataHeader(System.Reflection.Metadata.BlobReader@)">
            <summary>
            Looks like this function reads beginning of the header described in
            Ecma-335 24.2.1 Metadata root
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.ReadStreamHeaders(System.Reflection.Metadata.BlobReader@)">
            <summary>
            Reads stream headers described in Ecma-335 24.2.2 Stream header
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataReader.TableRowCounts">
            <summary>
            A row count for each possible table. May be indexed by <see cref="T:System.Reflection.Metadata.Ecma335.TableIndex"/>.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.GetNestedTypes(System.Reflection.Metadata.TypeDefinitionHandle)">
            <summary>
            Returns an array of types nested in the specified type.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.CalculateFieldDefTreatmentAndRowId(System.Reflection.Metadata.FieldDefinitionHandle)">
            <summary>
            The backing field of a WinRT enumeration type is not public although the backing fields
            of managed enumerations are. To allow managed languages to directly access this field,
            it is made public by the metadata adapter.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.ImplementsRedirectedInterface(System.Reflection.Metadata.MemberReferenceHandle,System.Boolean@)">
            <summary>
            We want to know if a given method implements a redirected interface.
            For example, if we are given the method RemoveAt on a class "A" 
            which implements the IVector interface (which is redirected
            to IList in .NET) then this method would return true. The most 
            likely reason why we would want to know this is that we wish to hide
            (mark private) all methods which implement methods on a redirected 
            interface.
            </summary>
            <param name="memberRef">The declaration token for the method</param>
            <param name="isIDisposable">
            Returns true if the redirected interface is <see cref="T:System.IDisposable"/>.
            </param>
            <returns>True if the method implements a method on a redirected interface.
            False otherwise.</returns>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataReader.GetAttributeTypeRaw(System.Reflection.Metadata.CustomAttributeHandle)">
            <summary>
            Returns the type definition or reference handle of the attribute type.
            </summary>
            <returns><see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/> or <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/> or nil token if the metadata is invalid and the type can't be determined.</returns>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataReaderOptions.None">
            <summary>
            All options are disabled.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataReaderOptions.Default">
            <summary>
            The options that are used when a <see cref="T:System.Reflection.Metadata.MetadataReader"/> is obtained
            via an overload that does not take a <see cref="T:System.Reflection.Metadata.MetadataReaderOptions"/>
            argument.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.MetadataReaderOptions.ApplyWindowsRuntimeProjections">
            <summary>
            Windows Runtime projections are enabled (on by default).
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.MetadataStringComparer">
             <summary>
             Provides string comparison helpers to query strings in metadata while
             avoiding allocation where possible.
             </summary>
            
             <remarks>
             No allocation is performed unless both the handle argument and the
             value argument contain non-ascii text.
            
             Obtain instances using <see cref="P:System.Reflection.Metadata.MetadataReader.StringComparer"/>.
            
             A default-initialized instance is useless and behaves as a null reference.
            
             The code is optimized such that there is no additional overhead in
             re-obtaining a a comparer over hoisting it in to a local.
             
             That is to say that a construct like:
            
             <code>
             if (reader.StringComparer.Equals(typeDef.Namespace, "System") &amp;&amp; 
                 reader.StringComparer.Equals(typeDef.Name, "Object")
             {
                 // found System.Object
             }
             </code>
             
             is no less efficient than:
             
             <code>
             var comparer = reader.StringComparer;
             if (comparer.Equals(typeDef.Namespace, "System") &amp;&amp;
                 comparer.Equals(typeDef.Name, "Object")
             {
                 // found System.Object
             }
             </code>
            
             The choice between them is therefore one of style and not performance.
             </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.MetadataStringDecoder">
             <summary>
             Provides the <see cref="T:System.Reflection.Metadata.MetadataReader"/> with a custom mechanism for decoding
             byte sequences in metadata that represent text.
             </summary>
             <remarks>
             This can be used for the following purposes:
             
             1) To customize the treatment of invalid input. When no decoder is provided,
                the <see cref="T:System.Reflection.Metadata.MetadataReader"/> uses the default fallback replacement 
                with \uFFFD)
            
             2) To reuse existing strings instead of allocating a new one for each decoding
                operation.
             </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataStringDecoder.#ctor(System.Text.Encoding)">
            <summary>
            Creates a <see cref="T:System.Reflection.Metadata.MetadataStringDecoder"/> for the given encoding.
            </summary>
            <param name="encoding">The encoding to use.</param>
            <remarks>
            To cache and reuse existing strings. Create a derived class and override <see cref="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)"/> 
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.MetadataStringDecoder.GetString(System.Byte*,System.Int32)">
            <summary>
            The mechanism through which the <see cref="T:System.Reflection.Metadata.MetadataReader"/> obtains strings
            for byte sequences in metadata. Override this to cache strings if required.
            Otherwise, it is implemented by forwarding straight to <see cref="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding"/>
            and every call will allocate a new string.
            </summary>
            <param name="bytes">Pointer to bytes to decode.</param>
            <param name="byteCount">Number of bytes to decode.</param>
            <returns>The decoded string.</returns>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataStringDecoder.DefaultUTF8">
            <summary>
            The default decoder used by <see cref="T:System.Reflection.Metadata.MetadataReader"/> to decode UTF-8 when
            no decoder is provided to the constructor.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MetadataStringDecoder.Encoding">
            <summary>
            Gets the encoding used by this instance. 
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MethodBodyBlock.Size">
            <summary>
            Size of the method body - includes the header, IL and exception regions.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MethodSpecification.Method">
            <summary>
            MethodDef or MemberRef handle specifying to which generic method this <see cref="T:System.Reflection.Metadata.MethodSpecification"/> refers,
            that is which generic method is it an instantiation of.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.MethodSpecification.Signature">
            <summary>
            Blob handle holding the signature of this instantiation.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.NamespaceDefinition.Name">
            <summary>
            Gets the unqualified name of the NamespaceDefinition.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.NamespaceDefinition.Parent">
            <summary>
            Gets the parent namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.NamespaceDefinition.NamespaceDefinitions">
            <summary>
            Gets the namespace definitions that are direct children of the current
            namespace definition. 
            
            System.Collections and System.Linq are direct children of System. 
            System.Collections.Generic is a direct child of System.Collections.
            System.Collections.Generic is *not* a direct child of System.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.NamespaceDefinition.TypeDefinitions">
            <summary>
            Gets all type definitions that reside directly in a namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.NamespaceDefinition.ExportedTypes">
            <summary>
            Gets all exported types that reside directly in a namespace.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMethodBody(System.Reflection.PortableExecutable.PEReader,System.Int32)">
            <summary>
            Returns a body block of a method with specified Relative Virtual Address (RVA);
            </summary>
            <exception cref="T:System.ArgumentNullException"><paramref name="peReader"/> is null.</exception>
            <exception cref="T:System.BadImageFormatException">The body is not found in the metadata or is invalid.</exception>
            <exception cref="T:System.InvalidOperationException">Section where the method is stored is not available.</exception>
        </member>
        <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader)">
            <summary>
            Gets a <see cref="T:System.Reflection.Metadata.MetadataReader"/> from a <see cref="T:System.Reflection.PortableExecutable.PEReader"/>.
            </summary>
            <remarks>
            The caller must keep the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> alive and undisposed throughout the lifetime of the metadata reader.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions)">
            <summary>
            Gets a <see cref="T:System.Reflection.Metadata.MetadataReader"/> from a <see cref="T:System.Reflection.PortableExecutable.PEReader"/>.
            </summary>
            <remarks>
            The caller must keep the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> alive and undisposed throughout the lifetime of the metadata reader.
            </remarks>
        </member>
        <member name="M:System.Reflection.Metadata.PEReaderExtensions.GetMetadataReader(System.Reflection.PortableExecutable.PEReader,System.Reflection.Metadata.MetadataReaderOptions,System.Reflection.Metadata.MetadataStringDecoder)">
            <summary>
            Gets a <see cref="T:System.Reflection.Metadata.MetadataReader"/> from a <see cref="T:System.Reflection.PortableExecutable.PEReader"/>.
            </summary>
            <remarks>
            The caller must keep the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> alive and undisposed throughout the lifetime of the metadata reader.
            </remarks>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Invalid">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Invalid"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Boolean">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Boolean"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Char">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Char"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.SByte">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SByte"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Byte">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Byte"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int16">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int16"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt16">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt16"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int32">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int32"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt32">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt32"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Int64">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Int64"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.UInt64">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.UInt64"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Single">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Single"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Double">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.Double"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.String">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.String"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.SZArray">
            <summary>
            Equivalent to <see cref="F:System.Reflection.Metadata.SignatureTypeCode.SZArray"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Type">
            <summary>
            The attribute argument is a System.Type instance.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.TaggedObject">
            <summary>
            The attribute argument is "boxed" (passed to a parameter, field, or property of type object) and carries type information in the attribute blob.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SerializationTypeCode.Enum">
            <summary>
            The attribute argument is an Enum instance.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.SignatureAttributes">
            <summary>
            Specified additional flags that can be applied to method signatures.
            Underlying values correspond to the representation in the leading signature 
            byte represented by <see cref="T:System.Reflection.Metadata.SignatureHeader"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureAttributes.None">
            <summary>
            No flags.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureAttributes.Generic">
            <summary>
            Generic method.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureAttributes.Instance">
            <summary>
            Instance method.
            </summary>
            <remarks>Ecma 335 CLI Specification refers to this flag as HAS_THIS.</remarks>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureAttributes.ExplicitThis">
            <summary>
            The first explicitly declared parameter represents the instance pointer.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.SignatureCallingConvention">
            <summary>
            Specifies how arguments in a given signature are passed from the caller to the callee.
            Underlying values correspond to the representation in the leading signature byte 
            represented by <see cref="T:System.Reflection.Metadata.SignatureHeader"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.Default">
            <summary>
            Managed calling convention with fixed-length argument list.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.CDecl">
            <summary>
            Unmanaged C/C++-style calling convention where the call stack is cleaned by the caller.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.StdCall">
            <summary>
            Unmanaged calling convention where call stack is cleaned up by the callee.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.ThisCall">
            <summary>
            Unmanaged C++-style calling convention for calling instance member functions with a fixed argument list.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.FastCall">
            <summary>
            Unmanaged calling convention where arguments are passed in registers when possible.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureCallingConvention.VarArgs">
            <summary>
            Managed calling convention for passing extra arguments.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.SignatureHeader">
            <summary>
            Represents the signature characteristics specified by the leading byte of signature blobs.
            </summary>
            <remarks>
            This header byte is present in all method definition, method reference, standalone method, field, 
            property, and local variable signatures, but not in type specification signatures.
            </remarks>
        </member>
        <member name="T:System.Reflection.Metadata.SignatureKind">
            <summary>
            Specifies the signature kind. Underlying values correspond to the representation 
            in the leading signature byte represented by <see cref="T:System.Reflection.Metadata.SignatureHeader"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureKind.Method">
            <summary>
            Method reference, method definition, or standalone method signature.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureKind.Field">
            <summary>
            Field signature.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureKind.LocalVariables">
            <summary>
            Local variables signature.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureKind.Property">
            <summary>
            Property signature.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureKind.MethodSpecification">
            <summary>
            Method specification signature.
            </summary>
        </member>
        <member name="T:System.Reflection.Metadata.SignatureTypeCode">
            <summary>
            Represents the type codes that are used in signature encoding.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Invalid">
            <summary>
            Represents an invalid or uninitialized type code. It will not appear in valid signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Void">
            <summary>
            Represents <see cref="T:System.Void"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Boolean">
            <summary>
            Represents <see cref="T:System.Boolean"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Char">
            <summary>
            Represents <see cref="T:System.Char"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.SByte">
            <summary>
            Represents <see cref="T:System.SByte"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Byte">
            <summary>
            Represents <see cref="T:System.Byte"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int16">
            <summary>
            Represents <see cref="T:System.Int16"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt16">
            <summary>
            Represents <see cref="T:System.UInt16"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int32">
            <summary>
            Represents <see cref="T:System.Int32"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt32">
            <summary>
            Represents <see cref="T:System.UInt32"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Int64">
            <summary>
            Represents <see cref="T:System.Int64"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.UInt64">
            <summary>
            Represents <see cref="T:System.UInt64"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Single">
            <summary>
            Represents <see cref="T:System.Single"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Double">
            <summary>
            Represents <see cref="T:System.Double"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.String">
            <summary>
            Represents <see cref="T:System.String"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pointer">
            <summary>
            Represents a unmanaged pointers in signatures.
            It is followed in the blob by the signature encoding of the underlying type.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.ByReference">
            <summary>
            Represents managed pointers (byref return values and parameters) in signatures.
            It is followed in the blob by the signature encoding of the underlying type.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeParameter">
            <summary>
            Represents a generic type parameter used within a signature. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Array">
            <summary>
            Represents a generalized <see cref="T:System.Array"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericTypeInstance">
            <summary>
            Represents the instantiation of a generic type in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypedReference">
            <summary>
            Represents a System.TypedReference in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.IntPtr">
            <summary>
            Represents a <see cref="T:System.IntPtr"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.UIntPtr">
            <summary>
            Represents a <see cref="T:System.UIntPtr"/> in signatures.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.FunctionPointer">
            <summary>
            Represents function pointer types in signatures. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Object">
            <summary>
            Represents <see cref="T:System.Object"/>
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.SZArray">
            <summary>
            Represents a single dimensional <see cref="T:System.Array"/> with 0 lower bound.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.GenericMethodParameter">
            <summary>
            Represents a generic method parameter used within a signature. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.RequiredModifier">
            <summary>
            Represents a custom modifier applied to a type within a signature that the caller must understand. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.OptionalModifier">
            <summary>
            Represents a custom modifier applied to a type within a signature that the caller can ignore.
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.TypeHandle">
            <summary>
            Precedes a type <see cref="T:System.Reflection.Metadata.EntityHandle"/> in signatures.
            </summary>
            <remarks>
            In raw metadata, this will be encoded as either ELEMENT_TYPE_CLASS (0x12) for reference
            types and ELEMENT_TYPE_VALUETYPE (0x11) for value types. This is collapsed to a single
            code because Windows Runtime projections can project from class to value type or vice-versa
            and the raw code is misleading in those cases.
            </remarks>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Sentinel">
            <summary>
            Represents a marker to indicate the end of fixed arguments and the beginning of variable arguments. 
            </summary>
        </member>
        <member name="F:System.Reflection.Metadata.SignatureTypeCode.Pinned">
            <summary>
            Represents a local variable that is pinned by garbage collector
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.TypeDefinition.GetDeclaringType">
            <summary>
            Returns the enclosing type of a specified nested type or nil handle if the type is not nested.
            </summary>
        </member>
        <member name="M:System.Reflection.Metadata.TypeDefinition.GetNestedTypes">
            <summary>
            Returns an array of types nested in the specified type.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeDefinition.Name">
            <summary>
            Name of the type.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeDefinition.Namespace">
            <summary>
            Full name of the namespace where the type is defined, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeDefinition.NamespaceDefinition">
            <summary>
            The definition handle of the namespace where the type is defined, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeDefinition.BaseType">
            <summary>
            The base type of the type definition: either
            <see cref="T:System.Reflection.Metadata.TypeSpecificationHandle"/>, <see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/> or <see cref="T:System.Reflection.Metadata.TypeDefinitionHandle"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeReference.ResolutionScope">
            <summary>
            Resolution scope in which the target type is defined and is uniquely identified by the specified <see cref="P:System.Reflection.Metadata.TypeReference.Namespace"/> and <see cref="P:System.Reflection.Metadata.TypeReference.Name"/>.
            </summary>
            <remarks>
            Resolution scope can be one of the following handles:
            <list type="bullet">
            <item><description><see cref="T:System.Reflection.Metadata.TypeReferenceHandle"/> of the enclosing type, if the target type is a nested type.</description></item>
            <item><description><see cref="T:System.Reflection.Metadata.ModuleReferenceHandle"/>, if the target type is defined in another module within the same assembly as this one.</description></item>
            <item><description><see cref="F:System.Reflection.Metadata.EntityHandle.ModuleDefinition"/>, if the target type is defined in the current module. This should not occur in a CLI compressed metadata module.</description></item>
            <item><description><see cref="T:System.Reflection.Metadata.AssemblyReferenceHandle"/>, if the target type is defined in a different assembly from the current module.</description></item>
            <item><description>Nil handle if the target type must be resolved by searching the <see cref="P:System.Reflection.Metadata.MetadataReader.ExportedTypes"/> for a matching <see cref="P:System.Reflection.Metadata.TypeReference.Namespace"/> and <see cref="P:System.Reflection.Metadata.TypeReference.Name"/>.</description></item>
            </list>
            </remarks>
        </member>
        <member name="P:System.Reflection.Metadata.TypeReference.Name">
            <summary>
            Name of the target type.
            </summary>
        </member>
        <member name="P:System.Reflection.Metadata.TypeReference.Namespace">
            <summary>
            Full name of the namespace where the target type is defined, or nil if the type is nested or defined in a root namespace.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.Machine">
            <summary>
            The type of target machine.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSections">
            <summary>
            The number of sections. This indicates the size of the section table, which immediately follows the headers.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.TimeDateStamp">
            <summary>
            The low 32 bits of the number of seconds since 00:00 January 1, 1970, that indicates when the file was created.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.PointerToSymbolTable">
            <summary>
            The file pointer to the COFF symbol table, or zero if no COFF symbol table is present. 
            This value should be zero for a PE image.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.NumberOfSymbols">
            <summary>
            The number of entries in the symbol table. This data can be used to locate the string table, 
            which immediately follows the symbol table. This value should be zero for a PE image.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.SizeOfOptionalHeader">
            <summary>
            The size of the optional header, which is required for executable files but not for object files. 
            This value should be zero for an object file. 
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.CoffHeader.Characteristics">
            <summary>
            The flags that indicate the attributes of the file. 
            </summary>
        </member>
        <member name="T:System.Reflection.PortableExecutable.CorFlags">
            <summary>
            COR20Flags
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Unknown">
            <summary>
            The target CPU is unknown or not specified.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.I386">
            <summary>
            Intel 386.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.WceMipsV2">
            <summary>
            MIPS little-endian WCE v2
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Alpha">
            <summary>
            Alpha
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.SH3">
            <summary>
            Hitachi SH3 little endian
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.SH3Dsp">
            <summary>
            Hitachi SH3 DSP.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.SH3E">
            <summary>
            Hitachi SH3 little endian.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.SH4">
            <summary>
            Hitachi SH4 little endian.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.SH5">
            <summary>
            Hitachi SH5.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Arm">
            <summary>
            ARM little endian
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Thumb">
            <summary>
            Thumb.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.ArmThumb2">
            <summary>
            ARM Thumb-2 little endian.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.AM33">
            <summary>
            Matsushita AM33.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.PowerPC">
            <summary>
            IBM PowerPC little endian.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.PowerPCFP">
            <summary>
            PowerPCFP
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.IA64">
            <summary>
            Intel 64
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.MIPS16">
            <summary>
            MIPS
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Alpha64">
            <summary>
            ALPHA64
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu">
            <summary>
            MIPS with FPU.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.MipsFpu16">
            <summary>
            MIPS16 with FPU.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Tricore">
            <summary>
            Infineon
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Ebc">
            <summary>
            EFI Byte Code
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.Amd64">
            <summary>
            AMD64 (K8)
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.Machine.M32R">
            <summary>
            M32R little-endian
            </summary>
        </member>
        <member name="T:System.Reflection.PortableExecutable.PEBinaryReader">
             <summary>
             Simple BinaryReader wrapper to:
            
              1) throw BadImageFormat instead of EndOfStream or ArgumentOutOfRange.
              2) limit reads to a subset of the base stream.
            
             Only methods that are needed to read PE headers are implemented.
             </summary>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEBinaryReader.GetAndValidateSize(System.IO.Stream,System.Nullable{System.Int32})">
            <summary>
            Resolve image size as either the given user-specified size or distance from current position to end-of-stream.
            Also performs the relevant argument validation and publicly visible caller has same argument names.
            </summary>
            <exception cref="T:System.ArgumentException">size is null and distance from current position to end-of-stream can't fit in Int32.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end-of-stream from current position.</exception>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.Magic">
            <summary>
            Identifies the format of the image file.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorLinkerVersion">
            <summary>
            The linker major version number.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorLinkerVersion">
            <summary>
            The linker minor version number.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfCode">
            <summary>
            The size of the code (text) section, or the sum of all code sections if there are multiple sections.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfInitializedData">
            <summary>
            The size of the initialized data section, or the sum of all such sections if there are multiple data sections.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfUninitializedData">
            <summary>
            The size of the uninitialized data section (BSS), or the sum of all such sections if there are multiple BSS sections.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.AddressOfEntryPoint">
            <summary>
            The address of the entry point relative to the image base when the PE file is loaded into memory. 
            For program images, this is the starting address. For device drivers, this is the address of the initialization function.
            An entry point is optional for DLLs. When no entry point is present, this field must be zero.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfCode">
            <summary>
            The address that is relative to the image base of the beginning-of-code section when it is loaded into memory.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.BaseOfData">
            <summary>
            The address that is relative to the image base of the beginning-of-data section when it is loaded into memory.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.ImageBase">
            <summary>
            The preferred address of the first byte of image when loaded into memory; 
            must be a multiple of 64K.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment">
            <summary>
            The alignment (in bytes) of sections when they are loaded into memory. It must be greater than or equal to <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment"/>. 
            The default is the page size for the architecture.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment">
            <summary>
            The alignment factor (in bytes) that is used to align the raw data of sections in the image file. 
            The value should be a power of 2 between 512 and 64K, inclusive. The default is 512. 
            If the <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment"/> is less than the architecture's page size, 
            then <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment"/> must match <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorOperatingSystemVersion">
            <summary>
            The major version number of the required operating system.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorOperatingSystemVersion">
            <summary>
            The minor version number of the required operating system.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorImageVersion">
            <summary>
            The major version number of the image.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorImageVersion">
            <summary>
            The minor version number of the image.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MajorSubsystemVersion">
            <summary>
            The major version number of the subsystem.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.MinorSubsystemVersion">
            <summary>
            The minor version number of the subsystem.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfImage">
            <summary>
            The size (in bytes) of the image, including all headers, as the image is loaded in memory. 
            It must be a multiple of <see cref="P:System.Reflection.PortableExecutable.PEHeader.SectionAlignment"/>.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeaders">
            <summary>
            The combined size of an MS DOS stub, PE header, and section headers rounded up to a multiple of FileAlignment.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.CheckSum">
            <summary>
            The image file checksum. 
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.Subsystem">
            <summary>
            The subsystem that is required to run this image. 
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackReserve">
            <summary>
            The size of the stack to reserve. Only <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit"/> is committed; 
            the rest is made available one page at a time until the reserve size is reached.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfStackCommit">
            <summary>
            The size of the stack to commit.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapReserve">
            <summary>
            The size of the local heap space to reserve. Only <see cref="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit"/> is committed; 
            the rest is made available one page at a time until the reserve size is reached.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.SizeOfHeapCommit">
            <summary>
            The size of the local heap space to commit.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.NumberOfRvaAndSizes">
            <summary>
            The number of data-directory entries in the remainder of the <see cref="T:System.Reflection.PortableExecutable.PEHeader"/>. Each describes a location and size.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeader.CertificateTableDirectory">
            <summary>
            The Certificate Table entry points to a table of attribute certificates. 
            These certificates are not loaded into memory as part of the image.
             As such, the first field of this entry, which is normally an RVA, is a file pointer instead.
            </summary>
        </member>
        <member name="T:System.Reflection.PortableExecutable.PEHeaders">
            <summary>
            An object used to read PE (Portable Executable) and COFF (Common Object File Format) headers from a stream.
            </summary>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream)">
            <summary>
            Reads PE headers from the current location in the stream.
            </summary>
            <param name="peStream">Stream containing PE image starting at the stream's current position and ending at the end of the stream.</param>
            <exception cref="T:System.BadImageFormatException">The data read from stream have invalid format.</exception>
            <exception cref="T:System.IO.IOException">Error reading from the stream.</exception>
            <exception cref="T:System.ArgumentException">The stream doesn't support seek operations.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEHeaders.#ctor(System.IO.Stream,System.Int32)">
            <summary>
            Reads PE headers from the current location in the stream.
            </summary>
            <param name="peStream">Stream containing PE image of the given size starting at its current position.</param>
            <param name="size">Size of the PE image.</param>
            <exception cref="T:System.BadImageFormatException">The data read from stream have invalid format.</exception>
            <exception cref="T:System.IO.IOException">Error reading from the stream.</exception>
            <exception cref="T:System.ArgumentException">The stream doesn't support seek operations.</exception>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end of the stream.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEHeaders.TryGetDirectoryOffset(System.Reflection.PortableExecutable.DirectoryEntry,System.Int32@)">
            <summary>
            Gets the offset (in bytes) from the start of the image to the given directory entry.
            </summary>
            <param name="directory"></param>
            <param name="offset"></param>
            <returns>The section containing the directory could not be found.</returns>
            <exception cref="T:System.BadImageFormatException">The section containing the</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEHeaders.GetContainingSectionIndex(System.Int32)">
            <summary>
            Searches sections of the PE image for the one that contains specified Relative Virtual Address.
            </summary>
            <param name="relativeVirtualAddress">Address.</param>
            <returns>
            Index of the section that contains <paramref name="relativeVirtualAddress"/>,
            or -1 if there is none.
            </returns>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataStartOffset">
            <summary>
            Gets the offset (in bytes) from the start of the PE image to the start of the CLI metadata.
            or -1 if the image does not contain metadata.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.MetadataSize">
            <summary>
            Gets the size of the CLI metadata 0 if the image does not contain metadata.)
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeader">
            <summary>
            Gets the COFF header of the image.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.CoffHeaderStartOffset">
            <summary>
            Gets the byte offset from the start of the PE image to the start of the COFF header.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsCoffOnly">
            <summary>
            Determines if the image is Coff only.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeader">
            <summary>
            Gets the PE header of the image or null if the image is COFF only.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.PEHeaderStartOffset">
            <summary>
            Gets the byte offset from the start of the image to 
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.SectionHeaders">
            <summary>
            Gets the PE section headers.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeader">
            <summary>
            Gets the CLI header or null if the image does not have one.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.CorHeaderStartOffset">
            <summary>
            Gets the byte offset from the start of the image to the COR header or -1 if the image does not have one.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsConsoleApplication">
            <summary>
            Determines if the image represents a Windows console application.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsDll">
            <summary>
            Determines if the image represents a dynamically linked library.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEHeaders.IsExe">
            <summary>
            Determines if the image represents an executable.
            </summary>
        </member>
        <member name="T:System.Reflection.PortableExecutable.PEReader">
            <summary>
            Portable Executable format reader.
            </summary>
            <remarks>
            The implementation is thread-safe, that is multiple threads can read data from the reader in parallel.
            Disposal of the reader is not thread-safe (see <see cref="M:System.Reflection.PortableExecutable.PEReader.Dispose"/>).
            </remarks>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Byte*,System.Int32)">
            <summary>
            Creates a Portable Executable reader over a PE image stored in memory.
            </summary>
            <param name="peImage">Pointer to the start of the PE image.</param>
            <param name="size">The size of the PE image.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is <see cref="F:System.IntPtr.Zero"/>.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="size"/> is negative.</exception>
            <remarks>
            The memory is owned by the caller and not released on disposal of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>.
            The caller is responsible for keeping the memory alive and unmodified throughout the lifetime of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>.
            The content of the image is not read during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>
            </remarks>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream)">
            <summary>
            Creates a Portable Executable reader over a PE image stored in a stream.
            </summary>
            <param name="peStream">PE image stream.</param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
            <exception cref="T:System.BadImageFormatException">
            <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> is specified and the PE headers of the image are invalid.
            </exception>
            <remarks>
            Ownership of the stream is transferred to the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> upon successful validation of constructor arguments. It will be 
            disposed by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> and the caller must not manipulate it.
            </remarks>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions)">
            <summary>
            Creates a Portable Executable reader over a PE image stored in a stream beginning at its current position and ending at the end of the stream.
            </summary>
            <param name="peStream">PE image stream.</param>
            <param name="options">
            Options specifying how sections of the PE image are read from the stream.
            
            Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is specified, ownership of the stream is transferred to the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> 
            upon successful argument validation. It will be disposed by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> and the caller must not manipulate it.
            
            Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage"/> is specified no data 
            is read from the stream during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>. Furthermore, the stream must not be manipulated
            by caller while the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is alive and undisposed.
            
            If <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage"/>, the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> 
            will have read all of the data requested during construction. As such, if <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is also
            specified, the caller retains full ownership of the stream and is assured that it will not be manipulated by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>
            after construction.
            </param>
            <exception cref="T:System.ArgumentNullException"><paramref name="peStream"/> is null.</exception>
            <exception cref="T:System.ArgumentOutOfRangeException"><paramref name="options"/> has an invalid value.</exception>
            <exception cref="T:System.BadImageFormatException">
            <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> is specified and the PE headers of the image are invalid.
            </exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.IO.Stream,System.Reflection.PortableExecutable.PEStreamOptions,System.Int32)">
            <summary>
            Creates a Portable Executable reader over a PE image of the given size beginning at the stream's current position.
            </summary>
            <param name="peStream">PE image stream.</param>
            <param name="size">PE image size.</param>
            <param name="options">
            Options specifying how sections of the PE image are read from the stream.
            
            Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is specified, ownership of the stream is transferred to the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> 
            upon successful argument validation. It will be disposed by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> and the caller must not manipulate it.
            
            Unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage"/> is specified no data 
            is read from the stream during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>. Furthermore, the stream must not be manipulated
            by caller while the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is alive and undisposed.
            
            If <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata"/> or <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage"/>, the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> 
            will have read all of the data requested during construction. As such, if <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is also
            specified, the caller retains full ownership of the stream and is assured that it will not be manipulated by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>
            after construction.
            </param>
            <exception cref="T:System.ArgumentOutOfRangeException">Size is negative or extends past the end of the stream.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.#ctor(System.Collections.Immutable.ImmutableArray{System.Byte})">
            <summary>
            Creates a Portable Executable reader over a PE image stored in a byte array.
            </summary>
            <param name="peImage">PE image.</param>
            <remarks>
            The content of the image is not read during the construction of the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>
            </remarks>
            <exception cref="T:System.ArgumentNullException"><paramref name="peImage"/> is null.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.Dispose">
            <summary>
            Disposes all memory allocated by the reader.
            </summary>
            <remarks>
            <see cref="M:System.Reflection.PortableExecutable.PEReader.Dispose"/>  can be called multiple times (but not in parallel).
            It is not safe to call <see cref="M:System.Reflection.PortableExecutable.PEReader.Dispose"/> in parallel with any other operation on the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>
            or reading from <see cref="T:System.Reflection.PortableExecutable.PEMemoryBlock"/>s retrieved from the reader.
            </remarks>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImageBlock">
            <summary>
            Returns a view of the entire image as a pointer and length.
            </summary>
            <exception cref="T:System.InvalidOperationException">PE image not available.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.GetEntireImage">
            <summary>
            Gets a pointer to and size of the PE image if available (<see cref="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable"/>).
            </summary>
            <exception cref="T:System.InvalidOperationException">The entire PE image is not available.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.GetMetadata">
            <summary>
            Loads PE section that contains CLI metadata.
            </summary>
            <exception cref="T:System.InvalidOperationException">The PE image doesn't contain metadata (<see cref="P:System.Reflection.PortableExecutable.PEReader.HasMetadata"/> returns false).</exception>
            <exception cref="T:System.BadImageFormatException">The PE headers contain invalid data.</exception>
        </member>
        <member name="M:System.Reflection.PortableExecutable.PEReader.GetSectionData(System.Int32)">
            <summary>
            Loads PE section that contains the specified <paramref name="relativeVirtualAddress"/> into memory
            and returns a memory block that starts at <paramref name="relativeVirtualAddress"/> and ends at the end of the containing section.
            </summary>
            <param name="relativeVirtualAddress">Relative Virtual Address of the data to read.</param>
            <returns>
            An empty block if <paramref name="relativeVirtualAddress"/> doesn't represent a location in any of the PE sections of this PE image.
            </returns>
            <exception cref="T:System.BadImageFormatException">The PE headers contain invalid data.</exception>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEReader.PEHeaders">
            <summary>
            Gets the PE headers.
            </summary>
            <exception cref="T:System.BadImageFormatException">The headers contain invalid data.</exception>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEReader.IsEntireImageAvailable">
            <summary>
            Return true if the reader can access the entire PE image.
            </summary>
            <remarks>
            Returns false if the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is constructed from a stream and only part of it is prefetched into memory.
            </remarks>
        </member>
        <member name="P:System.Reflection.PortableExecutable.PEReader.HasMetadata">
            <summary>
            Returns true if the PE image contains CLI metadata.
            </summary>
            <exception cref="T:System.BadImageFormatException">The PE headers contain invalid data.</exception>
        </member>
        <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.Default">
            <summary>
            By default the stream is disposed when <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is disposed and sections of the PE image are read lazily.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen">
            <summary>
            Keep the stream open when the <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is disposed.
            </summary>
        </member>
        <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchMetadata">
            <summary>
            Reads metadata section into memory right away. 
            </summary>
            <remarks>
            Reading from other sections of the file is not allowed (<see cref="T:System.InvalidOperationException"/> is thrown by the <see cref="T:System.Reflection.PortableExecutable.PEReader"/>).
            The underlying file may be closed and even deleted after <see cref="T:System.Reflection.PortableExecutable.PEReader"/> is constructed.
            
            <see cref="T:System.Reflection.PortableExecutable.PEReader"/> closes the stream automatically by the time the constructor returns unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is specified.
            </remarks>
        </member>
        <member name="F:System.Reflection.PortableExecutable.PEStreamOptions.PrefetchEntireImage">
            <summary>
            Reads the entire image into memory right away. 
            </summary>
            <remarks>
            <see cref="T:System.Reflection.PortableExecutable.PEReader"/> closes the stream automatically by the time the constructor returns unless <see cref="F:System.Reflection.PortableExecutable.PEStreamOptions.LeaveOpen"/> is specified.
            </remarks>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.Name">
            <summary>
            An 8-byte, null-padded UTF-8 encoded string. If the string is exactly 8 characters long, there is no terminating null. 
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize">
            <summary>
            The total size of the section when loaded into memory. 
            If this value is greater than <see cref="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData"/>, the section is zero-padded. 
            This field is valid only for PE images and should be set to zero for object files.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.VirtualAddress">
            <summary>
            For PE images, the address of the first byte of the section relative to the image base when the 
            section is loaded into memory. For object files, this field is the address of the first byte before
            relocation is applied; for simplicity, compilers should set this to zero. Otherwise, 
            it is an arbitrary value that is subtracted from offsets during relocation.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData">
            <summary>
            The size of the section (for object files) or the size of the initialized data on disk (for image files).
            For PE images, this must be a multiple of <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment"/>.
            If this is less than <see cref="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize"/>, the remainder of the section is zero-filled. 
            Because the <see cref="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData"/> field is rounded but the <see cref="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize"/> field is not, 
            it is possible for <see cref="P:System.Reflection.PortableExecutable.SectionHeader.SizeOfRawData"/> to be greater than <see cref="P:System.Reflection.PortableExecutable.SectionHeader.VirtualSize"/> as well.
             When a section contains only uninitialized data, this field should be zero.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRawData">
            <summary>
            The file pointer to the first page of the section within the COFF file. 
            For PE images, this must be a multiple of <see cref="P:System.Reflection.PortableExecutable.PEHeader.FileAlignment"/>. 
            For object files, the value should be aligned on a 4 byte boundary for best performance. 
            When a section contains only uninitialized data, this field should be zero.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToRelocations">
            <summary>
            The file pointer to the beginning of relocation entries for the section.
            This is set to zero for PE images or if there are no relocations.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.PointerToLineNumbers">
            <summary>
            The file pointer to the beginning of line-number entries for the section. 
            This is set to zero if there are no COFF line numbers. 
            This value should be zero for an image because COFF debugging information is deprecated.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfRelocations">
            <summary>
            The number of relocation entries for the section. This is set to zero for PE images.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.NumberOfLineNumbers">
            <summary>
            The number of line-number entries for the section.
             This value should be zero for an image because COFF debugging information is deprecated.
            </summary>
        </member>
        <member name="P:System.Reflection.PortableExecutable.SectionHeader.SectionCharacteristics">
            <summary>
            The flags that describe the characteristics of the section. 
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Setter">
            <summary>
            Used to modify the value of the property.
            CLS-compliant setters are named with set_ prefix.
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Getter">
            <summary>
            Used to read the value of the property.
            CLS-compliant getters are named with get_ prefix.
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Other">
            <summary>
            Other method for property (not getter or setter) or event (not adder, remover, or raiser).
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Adder">
            <summary>
            Used to add a handler for an event.
            Corresponds to the AddOn flag in the Ecma 335 CLI specification.
            CLS-compliant adders are named with add_ prefix.
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Remover">
            <summary>
            Used to remove a handler for an event.
            Corresponds to the RemoveOn flag in the Ecma 335 CLI specification.
            CLS-compliant removers are named with remove_ prefix.
            </summary>
        </member>
        <member name="F:System.Reflection.MethodSemanticsAttributes.Raiser">
            <summary>
            Used to indicate that an event has occurred.
            Corresponds to the Fire flag in the Ecma 335 CLI specification.
            CLS-compliant raisers are named with raise_ prefix.
            </summary>
        </member>
        <member name="T:System.Reflection.DeclarativeSecurityAction">
            <summary>
            Specifies the security actions that can be performed using declarative security.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.None">
            <summary>
            No declarative security action.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.Demand">
            <summary>
            Check that all callers in the call chain have been granted specified permission,
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.Assert">
            <summary>
            The calling code can access the resource identified by the current permission object, even if callers higher in the stack have not been granted permission to access the resource.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.Deny">
            <summary>
            Without further checks refuse Demand for the specified permission.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.PermitOnly">
            <summary>
            Without further checks, refuse Demand for all permissions other than those specified.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.LinkDemand">
            <summary>
            Check that the immediate caller has been granted the specified permission;
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.InheritanceDemand">
            <summary>
            The derived class inheriting the class or overriding a method is required to have been granted the specified permission.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.RequestMinimum">
            <summary>
            The request for the minimum permissions required for code to run. This action can only be used within the scope of the assembly.
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.RequestOptional">
            <summary>
            The request for additional permissions that are optional (not required to run). This request implicitly refuses all other permissions not specifically requested. This action can only be used within the scope of the assembly. 
            </summary>
        </member>
        <member name="F:System.Reflection.DeclarativeSecurityAction.RequestRefuse">
            <summary>
            The request that permissions that might be misused will not be granted to the calling code. This action can only be used within the scope of the assembly.
            </summary>
        </member>
        <member name="F:System.Reflection.ManifestResourceAttributes.Public">
            <summary>
            The Resource is exported from the Assembly
            </summary>
        </member>
        <member name="F:System.Reflection.ManifestResourceAttributes.Private">
            <summary>
            The Resource is not exported from the Assembly
            </summary>
        </member>
        <member name="F:System.Reflection.ManifestResourceAttributes.VisibilityMask">
            <summary>
            Masks just the visibility-related attributes.
            </summary>
        </member>
        <member name="T:System.Reflection.AssemblyHashAlgorithm">
            <summary>
            Specifies all the hash algorithms used for hashing assembly files and for generating the strong name.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.None">
            <summary>
            A mask indicating that there is no hash algorithm. If you specify None for a multi-module assembly, the common language runtime defaults to the SHA1 algorithm, since multi-module assemblies need to generate a hash.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.MD5">
            <summary>
            Retrieves the MD5 message-digest algorithm. MD5 was developed by Rivest in 1991. It is basically MD4 with safety-belts and while it is slightly slower than MD4, it helps provide more security. The algorithm consists of four distinct rounds, which has a slightly different design from that of MD4. Message-digest size, as well as padding requirements, remain the same.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha1">
            <summary>
            Retrieves a revision of the Secure Hash Algorithm that corrects an unpublished flaw in SHA.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha256">
            <summary>
            Retrieves a version of the Secure Hash Algorithm with a hash size of 256 bits.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha384">
            <summary>
            Retrieves a version of the Secure Hash Algorithm with a hash size of 384 bits.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyHashAlgorithm.Sha512">
            <summary>
            Retrieves a version of the Secure Hash Algorithm with a hash size of 512 bits.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.PublicKey">
            <summary>
            The assembly reference holds the full (unhashed) public key.
            Not applicable on assembly definition.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.Retargetable">
            <summary>
            The implementation of the referenced assembly used at runtime is not expected to match the version seen at compile time.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.WindowsRuntime">
            <summary>
            The assembly contains Windows Runtime code.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.ContentTypeMask">
            <summary>
            Content type mask. Masked bits correspond to values of <see cref="T:System.Reflection.AssemblyContentType"/>.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.DisableJitCompileOptimizer">
            <summary>
            Specifies that just-in-time (JIT) compiler optimization is disabled for the assembly.
            </summary>
        </member>
        <member name="F:System.Reflection.AssemblyFlags.EnableJitCompileTracking">
            <summary>
            Specifies that just-in-time (JIT) compiler tracking is enabled for the assembly.
            </summary>
        </member>
    </members>
</doc>
